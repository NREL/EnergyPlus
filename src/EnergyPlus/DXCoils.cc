// EnergyPlus, Copyright (c) 1996-2024, The Board of Trustees of the University of Illinois,
// The Regents of the University of California, through Lawrence Berkeley National Laboratory
// (subject to receipt of any required approvals from the U.S. Dept. of Energy), Oak Ridge
// National Laboratory, managed by UT-Battelle, Alliance for Sustainable Energy, LLC, and other
// contributors. All rights reserved.
//
// NOTICE: This Software was developed under funding from the U.S. Department of Energy and the
// U.S. Government consequently retains certain rights. As such, the U.S. Government has been
// granted for itself and others acting on its behalf a paid-up, nonexclusive, irrevocable,
// worldwide license in the Software to reproduce, distribute copies to the public, prepare
// derivative works, and perform publicly and display publicly, and to permit others to do so.
//
// Redistribution and use in source and binary forms, with or without modification, are permitted
// provided that the following conditions are met:
//
// (1) Redistributions of source code must retain the above copyright notice, this list of
//     conditions and the following disclaimer.
//
// (2) Redistributions in binary form must reproduce the above copyright notice, this list of
//     conditions and the following disclaimer in the documentation and/or other materials
//     provided with the distribution.
//
// (3) Neither the name of the University of California, Lawrence Berkeley National Laboratory,
//     the University of Illinois, U.S. Dept. of Energy nor the names of its contributors may be
//     used to endorse or promote products derived from this software without specific prior
//     written permission.
//
// (4) Use of EnergyPlus(TM) Name. If Licensee (i) distributes the software in stand-alone form
//     without changes from the version obtained under this License, or (ii) Licensee makes a
//     reference solely to the software portion of its product, Licensee must refer to the
//     software as "EnergyPlus version X" software, where "X" is the version number Licensee
//     obtained under this License and may not use a different name for the software. Except as
//     specifically required in this Section (4), Licensee shall not use in a company name, a
//     product name, in advertising, publicity, or other promotional activities any name, trade
//     name, trademark, logo, or other designation of "EnergyPlus", "E+", "e+" or confusingly
//     similar designation, without the U.S. Department of Energy's prior written consent.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// C++ Headers
#include <cmath>
#include <string>

// ObjexxFCL Headers
#include <ObjexxFCL/Fmath.hh>

// EnergyPlus Headers
#include <EnergyPlus/Autosizing/All_Simple_Sizing.hh>
#include <EnergyPlus/Autosizing/CoolingAirFlowSizing.hh>
#include <EnergyPlus/Autosizing/CoolingCapacitySizing.hh>
#include <EnergyPlus/Autosizing/CoolingSHRSizing.hh>
#include <EnergyPlus/Autosizing/HeatingAirFlowSizing.hh>
#include <EnergyPlus/Autosizing/HeatingCapacitySizing.hh>
#include <EnergyPlus/BranchNodeConnections.hh>
#include <EnergyPlus/CurveManager.hh>
#include <EnergyPlus/DXCoils.hh>
#include <EnergyPlus/Data/EnergyPlusData.hh>
#include <EnergyPlus/DataAirSystems.hh>
#include <EnergyPlus/DataBranchNodeConnections.hh>
#include <EnergyPlus/DataContaminantBalance.hh>
#include <EnergyPlus/DataEnvironment.hh>
#include <EnergyPlus/DataGlobalConstants.hh>
#include <EnergyPlus/DataHeatBalance.hh>
#include <EnergyPlus/DataLoopNode.hh>
#include <EnergyPlus/DataPrecisionGlobals.hh>
#include <EnergyPlus/DataSizing.hh>
#include <EnergyPlus/DataWater.hh>
#include <EnergyPlus/EMSManager.hh>
#include <EnergyPlus/Fans.hh>
#include <EnergyPlus/General.hh>
#include <EnergyPlus/GeneralRoutines.hh>
#include <EnergyPlus/GlobalNames.hh>
#include <EnergyPlus/HVACVariableRefrigerantFlow.hh>
#include <EnergyPlus/HeatBalanceInternalHeatGains.hh>
#include <EnergyPlus/InputProcessing/InputProcessor.hh>
#include <EnergyPlus/NodeInputManager.hh>
#include <EnergyPlus/OutAirNodeManager.hh>
#include <EnergyPlus/OutputProcessor.hh>
#include <EnergyPlus/OutputReportPredefined.hh>
#include <EnergyPlus/Psychrometrics.hh>
#include <EnergyPlus/ScheduleManager.hh>
#include <EnergyPlus/SimAirServingZones.hh>
#include <EnergyPlus/StandardRatings.hh>
#include <EnergyPlus/UtilityRoutines.hh>
#include <EnergyPlus/WaterManager.hh>
#include <EnergyPlus/ZoneTempPredictorCorrector.hh>

namespace EnergyPlus::DXCoils {

// Module containing the DX coil simulation routines

// MODULE INFORMATION:
//       AUTHOR         Fred Buhl
//       DATE WRITTEN   May 2000
//       MODIFIED       Aug 2000, Don Shirey, Sept 2000, Feb/Oct 2001, Sept 2003, Jan 2004
//                      Feb 2005, M. J. Witte, GARD Analytics, Inc., Add new coil type COIL:DX:MultiMode:CoolingEmpirical: Work supported by
//                      ASHRAE research project 1254-RP Aug 2006, B Griffith, NREL, Added water system interactions for new water manager, Feb
//                      2010, B Nigusse, FSEC, Added Standard Rating for Coil:Cooling:DX:SingleSpeed Apr 2010, Chandan Sharma, FSEC, Added basin
//                      heater routines for Coil:Cooling:DX:SingleSpeed, Coil:Cooling:DX:TwoSpeed,
//                                Coil:Cooling:DX:MultiSpeed, and Coil:Cooling:DX:TwoStageWithHumidityControlMode
//                      Feb 2013, Bereket Nigusse, FSEC, Added DX Coil Model For 100% OA systems
//                      Jul 2015, RP Zhang, XF Pang, LBNL, Added new coil type for VRF-FluidTemperatureControl Model

// PURPOSE OF THIS MODULE:
// To encapsulate the data and algorithms required to simulate DX cooling coils in
// EnergyPlus. Module currently models air-cooled or evap-cooled direct expansion systems
// (split or packaged). Air-side performance is modeled to determine coil discharge
// air conditions. The module also determines the DX unit's electrical energy usage.
// Neither the air-side performance nor the electrical energy usage includes the effect
// of supply air fan heat/energy usage. The supply air fan is modeled by other modules.

// USE STATEMENTS:
// Use statements for data only modules
// Using/Aliasing
using namespace DataLoopNode;
using namespace Psychrometrics;

// Use statements for access to subroutines in other modules
using namespace ScheduleManager;

// Functions

void SimDXCoil(EnergyPlusData &state,
               std::string_view CompName,             // name of the fan coil unit
               HVAC::CompressorOp const compressorOp, // compressor operation; 1=on, 0=off
               bool const FirstHVACIteration,         // True when first HVAC iteration
               int &CompIndex,
               HVAC::FanOp const fanOp,                                      // allows parent object to control fan mode
               ObjexxFCL::Optional<Real64 const> PartLoadRatio,              // part load ratio (for single speed cycling unit)
               ObjexxFCL::Optional<Real64 const> OnOffAFR,                   // ratio of compressor on airflow to compressor off airflow
               ObjexxFCL::Optional<Real64 const> CoilCoolingHeatingPLRRatio, // used for cycling fan RH control
               ObjexxFCL::Optional<Real64 const> MaxCap,                     // maximum cooling capacity of VRF terminal units
               ObjexxFCL::Optional<Real64 const> CompCyclingRatio            // cycling ratio of VRF condenser connected to this TU
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Fred Buhl
    //       DATE WRITTEN   May 2000
    //       MODIFIED       Don Shirey, Sept 2000, October 2001, June 2005

    // PURPOSE OF THIS SUBROUTINE:
    // Manages the simulation of a single speed on/off DX coil.

    // Using/Aliasing

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int DXCoilNum;       // index of fan coil unit being simulated
    Real64 AirFlowRatio; // ratio of compressor on airflow to compressor off airflow
    Real64 CompCycRatio; // compressor cycling ratio of VRF condenser

    // First time SimDXCoil is called, get the input for all the DX coils (condensing units)
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false; // Set GetInputFlag false so you don't get coil inputs again
    }

    if (CompIndex == 0) {
        DXCoilNum = Util::FindItemInList(CompName, state.dataDXCoils->DXCoil);
        if (DXCoilNum == 0) {
            ShowFatalError(state, format("DX Coil not found={}", CompName));
        }
        CompIndex = DXCoilNum;
    } else {
        DXCoilNum = CompIndex;
        if (DXCoilNum > state.dataDXCoils->NumDXCoils || DXCoilNum < 1) {
            ShowFatalError(state,
                           format("SimDXCoil: Invalid CompIndex passed={}, Number of DX Coils={}, Coil name={}",
                                  DXCoilNum,
                                  state.dataDXCoils->NumDXCoils,
                                  CompName));
        }
        if (state.dataDXCoils->CheckEquipName(DXCoilNum)) {
            if (!CompName.empty() && CompName != state.dataDXCoils->DXCoil(DXCoilNum).Name) {
                ShowFatalError(state,
                               format("SimDXCoil: Invalid CompIndex passed={}, Coil name={}, stored Coil Name for that index={}",
                                      DXCoilNum,
                                      CompName,
                                      state.dataDXCoils->DXCoil(DXCoilNum).Name));
            }
            state.dataDXCoils->CheckEquipName(DXCoilNum) = false;
        }
    }

    if (present(OnOffAFR)) {
        AirFlowRatio = OnOffAFR;
    } else {
        AirFlowRatio = 1.0;
    }

    if (present(CompCyclingRatio)) {
        CompCycRatio = CompCyclingRatio;
    } else {
        CompCycRatio = 1.0;
    }

    // Initialize the DX coil unit
    InitDXCoil(state, DXCoilNum);

    // Select the correct unit type
    switch (state.dataDXCoils->DXCoil(DXCoilNum).DXCoilType_Num) { // Autodesk:OPTIONAL PartLoadRatio, MaxCap used in this block without PRESENT check
    case HVAC::CoilDX_CoolingSingleSpeed: {
        if (present(CoilCoolingHeatingPLRRatio)) {
            CalcDoe2DXCoil(state, DXCoilNum, compressorOp, FirstHVACIteration, PartLoadRatio, fanOp, _, AirFlowRatio, CoilCoolingHeatingPLRRatio);
        } else {
            CalcDoe2DXCoil(state, DXCoilNum, compressorOp, FirstHVACIteration, PartLoadRatio, fanOp, _, AirFlowRatio);
        }
    } break;
    case HVAC::CoilDX_HeatingEmpirical: {
        CalcDXHeatingCoil(state, DXCoilNum, PartLoadRatio, fanOp, AirFlowRatio);
    } break;
    case HVAC::CoilDX_HeatPumpWaterHeaterPumped:
    case HVAC::CoilDX_HeatPumpWaterHeaterWrapped: {
        //   call the HPWHDXCoil routine to calculate water side performance set up the DX coil info for air-side calcs
        CalcHPWHDXCoil(state, DXCoilNum, PartLoadRatio);
        //    CALL CalcDoe2DXCoil(state, DXCoilNum, compressorOp, FirstHVACIteration,PartLoadRatio), perform air-side calculations
        CalcDoe2DXCoil(state, DXCoilNum, HVAC::CompressorOp::On, FirstHVACIteration, PartLoadRatio, fanOp);
    } break;
    case HVAC::CoilVRF_Cooling: {
        CalcVRFCoolingCoil(state, DXCoilNum, HVAC::CompressorOp::On, FirstHVACIteration, PartLoadRatio, fanOp, CompCycRatio, _, AirFlowRatio, MaxCap);
    } break;
    case HVAC::CoilVRF_Heating: {
        CalcDXHeatingCoil(state, DXCoilNum, PartLoadRatio, fanOp, AirFlowRatio, MaxCap);
    } break;
    case HVAC::CoilVRF_FluidTCtrl_Cooling: {
        CalcVRFCoolingCoil_FluidTCtrl(state, DXCoilNum, HVAC::CompressorOp::On, FirstHVACIteration, PartLoadRatio, fanOp, CompCycRatio, _, _, MaxCap);
    } break;
    case HVAC::CoilVRF_FluidTCtrl_Heating: {
        CalcVRFHeatingCoil_FluidTCtrl(state, compressorOp, DXCoilNum, PartLoadRatio, fanOp, _, MaxCap);
    } break;
    default: {
        ShowSevereError(state, format("Error detected in DX Coil={}", CompName));
        ShowContinueError(state, format("Invalid DX Coil Type={}", state.dataDXCoils->DXCoil(DXCoilNum).DXCoilType));
        ShowFatalError(state, "Preceding condition causes termination.");
    } break;
    }

    // Update the unit outlet nodes
    UpdateDXCoil(state, DXCoilNum);

    // Report the result of the simulation
    ReportDXCoil(state, DXCoilNum);
}

void SimDXCoilMultiSpeed(EnergyPlusData &state,
                         std::string_view CompName, // name of the fan coil unit
                         Real64 const SpeedRatio,   // = (CompressorSpeed - CompressorSpeedMin) /
                         Real64 const CycRatio,     // cycling part load ratio for variable speed
                         int &CompIndex,
                         ObjexxFCL::Optional_int_const SpeedNum,       // Speed number for multispeed cooling coil only
                         ObjexxFCL::Optional<HVAC::FanOp const> fanOp, // Fan operation mode
                         HVAC::CompressorOp compressorOp,              // Compressor on/off; 1=on, 0=off
                         ObjexxFCL::Optional_int_const SingleMode      // Single mode operation Yes/No; 1=Yes, 0=No
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Fred Buhl
    //       DATE WRITTEN   September 2002
    //       MODIFIED       Lixing Gu, Sep. 2007

    // PURPOSE OF THIS SUBROUTINE:
    // Manages the simulation of a multi speed DX coil.

    // Using/Aliasing

    // Locals
    // SUBROUTINE ARGUMENT DEFINITIONS:
    //   (CompressorSpeedMax - CompressorSpeedMin)
    // for variable speed or 2 speed compressors
    // or 2 speed compressors

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int DXCoilNum;      // index of fan coil unit being simulated
    int SingleModeOper; // SingleMode Operation

    // First time SimDXCoil is called, get the input for all the DX coils (condensing units)
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false; // Set GetInputFlag false so you don't get coil inputs again
    }

    //  find correct DX Coil

    if (CompIndex == 0) {
        DXCoilNum = Util::FindItemInList(CompName, state.dataDXCoils->DXCoil);
        if (DXCoilNum == 0) {
            ShowFatalError(state, format("DX Coil not found={}", CompName));
        }
        CompIndex = DXCoilNum;
    } else {
        DXCoilNum = CompIndex;
        if (DXCoilNum > state.dataDXCoils->NumDXCoils || DXCoilNum < 1) {
            ShowFatalError(state,
                           format("SimDXCoilMultiSpeed: Invalid CompIndex passed={}, Number of DX Coils={}, Coil name={}",
                                  DXCoilNum,
                                  state.dataDXCoils->NumDXCoils,
                                  CompName));
        }
        if (state.dataDXCoils->CheckEquipName(DXCoilNum)) {
            if (!CompName.empty() && CompName != state.dataDXCoils->DXCoil(DXCoilNum).Name) {
                ShowFatalError(state,
                               format("SimDXCoilMultiSpeed: Invalid CompIndex passed={}, Coil name={}, stored Coil Name for that index={}",
                                      DXCoilNum,
                                      CompName,
                                      state.dataDXCoils->DXCoil(DXCoilNum).Name));
            }
            state.dataDXCoils->CheckEquipName(DXCoilNum) = false;
        }
    }

    if (present(SingleMode)) {
        SingleModeOper = SingleMode;
    } else {
        SingleModeOper = 0;
    }

    // Initialize the DX coil unit
    InitDXCoil(state, DXCoilNum);

    // Select the correct unit type
    switch (state.dataDXCoils->DXCoil(DXCoilNum).DXCoilType_Num) {
    case HVAC::CoilDX_CoolingTwoSpeed: {
        CalcMultiSpeedDXCoil(state, DXCoilNum, SpeedRatio, CycRatio);
    } break;
    case HVAC::CoilDX_MultiSpeedCooling: {
        if (present(SpeedNum))
            CalcMultiSpeedDXCoilCooling(state,
                                        DXCoilNum,
                                        SpeedRatio,
                                        CycRatio,
                                        SpeedNum,
                                        fanOp,
                                        compressorOp,
                                        SingleModeOper); // Autodesk:OPTIONAL fanOp, CompressorOp used without PRESENT check

    } break;
    case HVAC::CoilDX_MultiSpeedHeating: {
        if (present(SpeedNum))
            CalcMultiSpeedDXCoilHeating(state,
                                        DXCoilNum,
                                        SpeedRatio,
                                        CycRatio,
                                        SpeedNum,
                                        fanOp,
                                        SingleModeOper); // Autodesk:OPTIONAL fanOp used without PRESENT check

    } break;
    default: {
        ShowSevereError(state, format("Error detected in DX Coil={}", CompName));
        ShowContinueError(state, format("Invalid DX Coil Type={}", state.dataDXCoils->DXCoil(DXCoilNum).DXCoilType));
        ShowFatalError(state, "Preceding condition causes termination.");
    } break;
    }

    // Update the unit outlet nodes
    UpdateDXCoil(state, DXCoilNum);

    // Report the result of the simulation
    ReportDXCoil(state, DXCoilNum);
}

void SimDXCoilMultiMode(EnergyPlusData &state,
                        std::string_view CompName,                              // name of the fan coil unit
                        [[maybe_unused]] HVAC::CompressorOp const compressorOp, // compressor operation; 1=on, 0=off !unused1208
                        bool const FirstHVACIteration,                          // true if first hvac iteration
                        Real64 const PartLoadRatio,                             // part load ratio
                        HVAC::CoilMode const DehumidMode,                       // dehumidification mode (0=normal, 1=enhanced)
                        int &CompIndex,
                        HVAC::FanOp const fanOp // allows parent object to control fan mode
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         M. J. Witte (based on SimDXCoilMultiSpeed by Fred Buhl)
    //       DATE WRITTEN   February 2005
    //       MODIFIED       April 2010, Chandan sharma, added basin heater

    // PURPOSE OF THIS SUBROUTINE:
    // Manages the simulation of a DX coil with multiple performance modes, such as
    // multiple stages, or sub-cool reheat for humidity control.

    // Using/Aliasing

    // SUBROUTINE PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineName("SimDXCoilMultiMode");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int DXCoilNum; // index of coil being simulated
    int PerfMode;  // Performance mode for MultiMode DX coil; Always 1 for other coil types
    // 1-2=normal mode: 1=stage 1 only, 2=stage 1&2
    // 3-4=enhanced dehumidification mode: 3=stage 1 only, 4=stage 1&2
    Real64 AirMassFlow; // Dry air mass flow rate through coil [kg/s]

    Real64 S1OutletAirTemp;     // Stage 1   Outlet air dry bulb temp [C]
    Real64 S1OutletAirHumRat;   // Stage 1   Outlet air humidity ratio [kgWater/kgDryAir]
    Real64 S1OutletAirEnthalpy; // Stage 1   Outlet air enthalpy
    Real64 S1PLR;               // Stage 1   Ratio of actual sensible cooling load to
    //           steady-state sensible cooling capacity
    Real64 S1TotalCoolingEnergyRate; // Stage 1   Total cooling rate [W]
    Real64 S1SensCoolingEnergyRate;  // Stage 1   Sensible cooling rate [W]
    Real64 S1LatCoolingEnergyRate;   // Stage 1   Latent cooling rate [W]
    Real64 S1ElecCoolingPower;       // Stage 1   Electric power input [W]
    Real64 S1RuntimeFraction(0.0);   // Stage 1   Run time fraction (overlaps with stage1&2 run time)
    Real64 S1EvapCondPumpElecPower;  // Stage 1   Evaporative condenser pump electric power input [W]
    Real64 S1EvapWaterConsumpRate;   // Stage 1   Evap condenser water consumption rate [m3/s]
    Real64 S1CrankcaseHeaterPower;   // Stage 1   Report variable for average crankcase heater power [W]
    Real64 S1FFullLoadOutAirTemp;    // Stage 1   Full load outlet temperature [C]
    Real64 S1FullLoadOutAirHumRat;   // Stage 1   Full load outlet humidity ratio [kgWater/kgDryAir]

    Real64 S12OutletAirTemp;     // Stage 1&2 Outlet air dry bulb temp [C]
    Real64 S12OutletAirHumRat;   // Stage 1&2 Outlet air humidity ratio [kgWater/kgDryAir]
    Real64 S12OutletAirEnthalpy; // Stage 1&2 Outlet air enthalpy
    //                                       !           steady-state sensible cooling capacity
    Real64 S12TotalCoolingEnergyRate; // Stage 1&2 Total cooling rate [W]
    Real64 S12SensCoolingEnergyRate;  // Stage 1&2 Sensible cooling rate [W]
    Real64 S12LatCoolingEnergyRate;   // Stage 1&2 Latent cooling rate [W]
    Real64 S12ElecCoolingPower;       // Stage 1&2 Electric power input [W]
    Real64 S12ElecCoolFullLoadPower;  // Stage 1&2 Electric power input at full load (PLR=1) [W]
    Real64 S12RuntimeFraction(0.0);   // Stage 1&2 Run time fraction (overlaps with stage1 run time)
    Real64 S12EvapCondPumpElecPower;  // Stage 1&2 Evaporative condenser pump electric power input [W]
    Real64 S12EvapWaterConsumpRate;   // Stage 1&2 Evap condenser water consumption rate [m3/s]
    Real64 S12CrankcaseHeaterPower;   // Stage 1&2 Report variable for average crankcase heater power [W]
    Real64 S2PLR;                     // Stage 2   Ratio of actual sensible cooling load to
    //           steady-state sensible cooling capacity
    Real64 TSat;      // calculation to avoid calling psych routines twice
    Real64 NodePress; // Pressure at condenser inlet node (Pa)

    // First time SimDXCoil is called, get the input for all the DX coils (condensing units)
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false; // Set GetInputFlag false so you don't get coil inputs again
    }

    //  find correct DX Coil
    if (CompIndex == 0) {
        DXCoilNum = Util::FindItemInList(CompName, state.dataDXCoils->DXCoil);
        if (DXCoilNum == 0) {
            ShowFatalError(state, format("DX Coil not found={}", CompName));
        }
        CompIndex = DXCoilNum;
    } else {
        DXCoilNum = CompIndex;
        if (DXCoilNum > state.dataDXCoils->NumDXCoils || DXCoilNum < 1) {
            ShowFatalError(state,
                           format("SimDXCoilMultiMode: Invalid CompIndex passed={}, Number of DX Coils={}, Coil name={}",
                                  DXCoilNum,
                                  state.dataDXCoils->NumDXCoils,
                                  CompName));
        }
        if (state.dataDXCoils->CheckEquipName(DXCoilNum)) {
            if ((CompName != "") && (CompName != state.dataDXCoils->DXCoil(DXCoilNum).Name)) {
                ShowFatalError(state,
                               format("SimDXCoilMultiMode: Invalid CompIndex passed={}, Coil name={}, stored Coil Name for that index={}",
                                      DXCoilNum,
                                      CompName,
                                      state.dataDXCoils->DXCoil(DXCoilNum).Name));
            }
            state.dataDXCoils->CheckEquipName(DXCoilNum) = false;
        }
    }

    // Initialize the DX coil unit
    InitDXCoil(state, DXCoilNum);

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
    // Select the correct unit type
    if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) {
        // Initialize local variables
        S1RuntimeFraction = 0.0;
        S1OutletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
        S1OutletAirHumRat = thisDXCoil.InletAirHumRat;
        S1OutletAirTemp = thisDXCoil.InletAirTemp;
        S1ElecCoolingPower = 0.0;
        S1TotalCoolingEnergyRate = 0.0;
        S1SensCoolingEnergyRate = 0.0;
        S1LatCoolingEnergyRate = 0.0;
        S1CrankcaseHeaterPower = 0.0;
        S1EvapWaterConsumpRate = 0.0;
        S1EvapCondPumpElecPower = 0.0;

        S12RuntimeFraction = 0.0;
        S12OutletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
        S12OutletAirHumRat = thisDXCoil.InletAirHumRat;
        S12OutletAirTemp = thisDXCoil.InletAirTemp;
        S12ElecCoolingPower = 0.0;
        S12TotalCoolingEnergyRate = 0.0;
        S12SensCoolingEnergyRate = 0.0;
        S12LatCoolingEnergyRate = 0.0;
        S12CrankcaseHeaterPower = 0.0;
        S12EvapWaterConsumpRate = 0.0;
        S12EvapCondPumpElecPower = 0.0;

        thisDXCoil.DehumidificationMode = DehumidMode;
        if ((int)DehumidMode > thisDXCoil.NumDehumidModes) {
            ShowFatalError(state,
                           format("{} \"{}\" - Requested enhanced dehumidification mode not available.", thisDXCoil.DXCoilType, thisDXCoil.Name));
        }

        // If a single-stage coil OR If part load is zero,
        // run stage 1 at zero part load to set leaving conditions
        if ((thisDXCoil.NumCapacityStages == 1) || (PartLoadRatio <= 0.0)) {
            // Run stage 1 at its part load
            PerfMode = (int)DehumidMode * 2 + 1; // This.  This is not good.  Don't do math on enums.
            CalcDoe2DXCoil(state, DXCoilNum, HVAC::CompressorOp::On, FirstHVACIteration, PartLoadRatio, fanOp, PerfMode);
            S1PLR = PartLoadRatio;
            S2PLR = 0.0;
        } else {
            // If a two-stage coil
            // Run stage 1 at full load
            PerfMode = (int)DehumidMode * 2 + 1;
            CalcDoe2DXCoil(state, DXCoilNum, HVAC::CompressorOp::On, FirstHVACIteration, 1.0, fanOp, PerfMode);
            S1SensCoolingEnergyRate = thisDXCoil.SensCoolingEnergyRate;
            if (S1SensCoolingEnergyRate > 0.0) {
                S1PLR = PartLoadRatio;
            } else {
                S1PLR = 0.0;
            }
            // Run stage 1+2 at full load
            if (thisDXCoil.NumCapacityStages >= 2) {
                PerfMode = (int)DehumidMode * 2 + 2;
                CalcDoe2DXCoil(state, DXCoilNum, HVAC::CompressorOp::On, FirstHVACIteration, 1.0, fanOp, PerfMode);
                S12SensCoolingEnergyRate = thisDXCoil.SensCoolingEnergyRate;
                S12ElecCoolFullLoadPower = thisDXCoil.ElecCoolingPower;
            }

            // Determine run-time fractions for each stage based on sensible capacities
            //   Relationships:
            //     Stage 1   PLR1=   Load/Cap1
            //     Stage1+2  PLR12=  Load/Cap12
            //     Stage 2   PLR2=   (Load-Cap1)/(Cap2)
            //     PLR = Load/(Cap1+Cap2)
            //     Load= PLR*(Cap1+Cap2)
            //     PLR1= MIN(1,(PLR*(Cap1+Cap2)/Cap1))
            //     PLR2= MIN(1,((PLR*(Cap1+Cap2)-Cap1)/Cap2))

            if (S1SensCoolingEnergyRate > 0.0) {
                S1PLR = PartLoadRatio * S12SensCoolingEnergyRate / S1SensCoolingEnergyRate;
            } else {
                S1PLR = 0.0;
            }
            S1PLR = min(1.0, S1PLR);
            S1PLR = max(0.0, S1PLR);
            if ((S12SensCoolingEnergyRate - S1SensCoolingEnergyRate) > 0.0) {
                S2PLR = (PartLoadRatio * S12SensCoolingEnergyRate - S1SensCoolingEnergyRate) / (S12SensCoolingEnergyRate - S1SensCoolingEnergyRate);
            } else {
                S2PLR = 0.0;
            }
            S2PLR = min(1.0, S2PLR);
            S2PLR = max(0.0, S2PLR);

            // Run stage 1 at its part load
            PerfMode = (int)DehumidMode * 2 + 1;
            CalcDoe2DXCoil(state, DXCoilNum, HVAC::CompressorOp::On, FirstHVACIteration, S1PLR, fanOp, PerfMode);
        }
        // For stage-1 only operation, all outputs are set by CalcDoe2DXCoil.
        // No further adjustments are necessary.

        // Run stage 2 if needed and available
        if ((S2PLR > 0.0) && (thisDXCoil.NumCapacityStages >= 2)) {
            // Store stage 1 outputs
            S1RuntimeFraction = thisDXCoil.CoolingCoilRuntimeFraction;
            S1OutletAirEnthalpy = thisDXCoil.OutletAirEnthalpy;
            S1OutletAirHumRat = thisDXCoil.OutletAirHumRat;
            S1OutletAirTemp = thisDXCoil.OutletAirTemp;
            S1ElecCoolingPower = thisDXCoil.ElecCoolingPower;
            S1TotalCoolingEnergyRate = thisDXCoil.TotalCoolingEnergyRate;
            S1SensCoolingEnergyRate = thisDXCoil.SensCoolingEnergyRate;
            S1LatCoolingEnergyRate = thisDXCoil.LatCoolingEnergyRate;
            S1CrankcaseHeaterPower = thisDXCoil.CrankcaseHeaterPower;
            S1EvapWaterConsumpRate = thisDXCoil.EvapWaterConsumpRate;
            S1EvapCondPumpElecPower = thisDXCoil.EvapCondPumpElecPower;

            // Save first stage full load outlet conditions to pass to heat recovery
            S1FFullLoadOutAirTemp = state.dataDXCoils->DXCoilFullLoadOutAirTemp(DXCoilNum);
            S1FullLoadOutAirHumRat = state.dataDXCoils->DXCoilFullLoadOutAirHumRat(DXCoilNum);

            // Run stage 1+2 at its part load
            PerfMode = (int)DehumidMode * 2 + 2;
            CalcDoe2DXCoil(state, DXCoilNum, HVAC::CompressorOp::On, FirstHVACIteration, S2PLR, fanOp, PerfMode);
            S12RuntimeFraction = thisDXCoil.CoolingCoilRuntimeFraction;
            S12OutletAirEnthalpy = thisDXCoil.OutletAirEnthalpy;
            S12OutletAirHumRat = thisDXCoil.OutletAirHumRat;
            S12OutletAirTemp = thisDXCoil.OutletAirTemp;
            S12ElecCoolingPower = thisDXCoil.ElecCoolingPower;
            S12TotalCoolingEnergyRate = thisDXCoil.TotalCoolingEnergyRate;
            S12SensCoolingEnergyRate = thisDXCoil.SensCoolingEnergyRate;
            S12LatCoolingEnergyRate = thisDXCoil.LatCoolingEnergyRate;
            S12CrankcaseHeaterPower = thisDXCoil.CrankcaseHeaterPower;
            S12EvapWaterConsumpRate = thisDXCoil.EvapWaterConsumpRate;
            S12EvapCondPumpElecPower = thisDXCoil.EvapCondPumpElecPower;

            // Determine combined performance
            thisDXCoil.OutletAirEnthalpy = (1.0 - S2PLR) * S1OutletAirEnthalpy + S2PLR * S12OutletAirEnthalpy;
            thisDXCoil.OutletAirHumRat = (1.0 - S2PLR) * S1OutletAirHumRat + S2PLR * S12OutletAirHumRat;
            thisDXCoil.OutletAirTemp = PsyTdbFnHW(thisDXCoil.OutletAirEnthalpy, thisDXCoil.OutletAirHumRat);
            // Check for saturation error and modify temperature at constant enthalpy
            if (thisDXCoil.CondenserInletNodeNum(PerfMode) != 0) {
                NodePress = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(PerfMode)).Press;
                // If node is not connected to anything, pressure = default, use weather data
                if (NodePress == state.dataLoopNodes->DefaultNodeValues.Press) NodePress = state.dataEnvrn->OutBaroPress;
                TSat = PsyTsatFnHPb(state, thisDXCoil.OutletAirEnthalpy, NodePress, RoutineName);
                if (thisDXCoil.OutletAirTemp < TSat) {
                    thisDXCoil.OutletAirTemp = TSat;
                }
                thisDXCoil.OutletAirHumRat = PsyWFnTdbH(state, thisDXCoil.OutletAirTemp, thisDXCoil.OutletAirEnthalpy, RoutineName);
            } else {
                TSat = PsyTsatFnHPb(state, thisDXCoil.OutletAirEnthalpy, state.dataEnvrn->OutBaroPress, RoutineName);
                if (thisDXCoil.OutletAirTemp < TSat) {
                    thisDXCoil.OutletAirTemp = TSat;
                }
                //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
                //      IF(DXCoil(DXCoilNum)%OutletAirTemp .LT. PsyTsatFnHPb(DXCoil(DXCoilNum)%OutletAirEnthalpy, &
                //                 Node(DXCoil(DXCoilNum)%AirInNode)%Press)) THEN
                //        DXCoil(DXCoilNum)%OutletAirTemp = PsyTsatFnHPb(DXCoil(DXCoilNum)%OutletAirEnthalpy, &
                //                 Node(DXCoil(DXCoilNum)%AirInNode)%Press)
                thisDXCoil.OutletAirHumRat = PsyWFnTdbH(state, thisDXCoil.OutletAirTemp, thisDXCoil.OutletAirEnthalpy, RoutineName);
            }

            //      DXCoil(DXCoilNum)%ElecCoolingPower = (1-S12RuntimeFraction)*S1ElecCoolingPower &
            //                                             +S12RuntimeFraction*S12ElecCoolingPower
            //  S12ElecCoolingPower overstates S1 portion of power, because it is also adjust by S12PLR
            //  So, must make an adjustment for S12ElecCoolingPower/S12ElecCoolFullLoadPower
            //  when subtracting off S1ElecCoolingPower
            if (S12ElecCoolFullLoadPower > 0.0) {
                thisDXCoil.ElecCoolingPower =
                    S1RuntimeFraction * S1ElecCoolingPower +
                    S12RuntimeFraction * (S12ElecCoolingPower - S1ElecCoolingPower * S12ElecCoolingPower / S12ElecCoolFullLoadPower);
            } else {
                thisDXCoil.ElecCoolingPower = 0.0;
            }

            thisDXCoil.CoolingCoilRuntimeFraction = S1RuntimeFraction;

            AirMassFlow = thisDXCoil.InletAirMassFlowRate;
            CalcComponentSensibleLatentOutput(AirMassFlow,
                                              thisDXCoil.InletAirTemp,
                                              thisDXCoil.InletAirHumRat,
                                              thisDXCoil.OutletAirTemp,
                                              thisDXCoil.OutletAirHumRat,
                                              thisDXCoil.SensCoolingEnergyRate,
                                              thisDXCoil.LatCoolingEnergyRate,
                                              thisDXCoil.TotalCoolingEnergyRate);

            thisDXCoil.EvapWaterConsumpRate = (1.0 - S12RuntimeFraction) * S1EvapWaterConsumpRate + S12RuntimeFraction * S12EvapWaterConsumpRate;
            thisDXCoil.EvapCondPumpElecPower = (1.0 - S12RuntimeFraction) * S1EvapCondPumpElecPower + S12RuntimeFraction * S12EvapCondPumpElecPower;

            // Stage 1 runtime sets the crankcase heater power
            thisDXCoil.CrankcaseHeaterPower = S1CrankcaseHeaterPower;

            state.dataDXCoils->DXCoilOutletTemp(DXCoilNum) = thisDXCoil.OutletAirTemp;
            state.dataDXCoils->DXCoilOutletHumRat(DXCoilNum) = thisDXCoil.OutletAirHumRat;

            //     calculate average full load outlet conditions for second stage operation
            state.dataDXCoils->DXCoilFullLoadOutAirTemp(DXCoilNum) =
                (1.0 - S2PLR) * S1FFullLoadOutAirTemp + S2PLR * state.dataDXCoils->DXCoilFullLoadOutAirTemp(DXCoilNum);
            state.dataDXCoils->DXCoilFullLoadOutAirHumRat(DXCoilNum) =
                (1.0 - S2PLR) * S1FullLoadOutAirHumRat + S2PLR * state.dataDXCoils->DXCoilFullLoadOutAirHumRat(DXCoilNum);

        } // End if stage 2 is operating

        //   set the part load ratio and heat reclaim capacity for use by desuperheater heating coils
        thisDXCoil.PartLoadRatio = S1PLR;
        state.dataDXCoils->DXCoilPartLoadRatio(DXCoilNum) = S1PLR;

        //   Calculation for heat reclaim needs to be corrected to use compressor power (not including condenser fan power)
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = thisDXCoil.TotalCoolingEnergyRate + thisDXCoil.ElecCoolingPower;

        thisDXCoil.CoolingCoilStg2RuntimeFrac = S12RuntimeFraction;

        //   Calculate basin heater power
        CalcBasinHeaterPowerForMultiModeDXCoil(state, DXCoilNum, DehumidMode);
    } else {
        ShowSevereError(state, format("Error detected in DX Coil={}", CompName));
        ShowContinueError(state, format("Invalid DX Coil Type={}", thisDXCoil.DXCoilType));
        ShowFatalError(state, "Preceding condition causes termination.");
    }

    // Update the unit outlet nodes
    UpdateDXCoil(state, DXCoilNum);

    // Report the result of the simulation
    ReportDXCoil(state, DXCoilNum);
}

void GetDXCoils(EnergyPlusData &state)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Fred Buhl
    //       DATE WRITTEN   May 2000
    //       MODIFIED       Aug 2000, Don Shirey, Sept 2000, Feb/Oct 2001, Sept 2003, Jan/July 2004
    //                      Feb 2005, M. J. Witte, GARD Analytics, Inc., Add new coil type COIL:DX:MultiMode:CoolingEmpirical:
    //                      May 2005, Rich Raustad, FSEC, Added COIL:DX:HeatPumpWaterHeater
    //                      Jun 2007, L. Gu, FSEC, Added new coil type COIL:DX:MULTISPEED:COOLING and COIL:DX:MULTISPEED:HEATING
    //                      Apr 2010, Chandan Sharma, FSEC, added basin heater inputs
    //                      Jul 2015, RP Zhang, XF Pang, LBNL, Added new coil type for VRF-FluidTemperatureControl Model

    // PURPOSE OF THIS SUBROUTINE:
    // Obtains input data for DX coils and stores it in DX coil data structure

    // METHODOLOGY EMPLOYED:
    // Uses "Get" routines to read in data.

    // Using/Aliasing
    using BranchNodeConnections::TestCompSet;
    using Curve::checkCurveIsNormalizedToOne;
    using Curve::CurveValue;
    using Curve::GetCurveIndex;
    using DataSizing::AutoSize;
    using EMSManager::ManageEMS;

    using GlobalNames::VerifyUniqueCoilName;
    using NodeInputManager::GetOnlySingleNode;
    using OutAirNodeManager::CheckOutAirNodeNumber;
    using ScheduleManager::GetScheduleIndex;
    using WaterManager::SetupTankDemandComponent;
    using WaterManager::SetupTankSupplyComponent;

    // SUBROUTINE PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineName("GetDXCoils: "); // include trailing blank space
    constexpr Real64 minOATCompDXCooling = -25.0;                  // min OAT for compressor operation for DX cooling coils

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int DXCoilIndex;                 // loop index
    int DXCoilNum;                   // current DX coil number
    int NumAlphas;                   // Number of alphas in input
    int NumNumbers;                  // Number of numeric items in input
    Array1D_string Alphas2;          // Alpha input items for object
    Array1D<Real64> Numbers2;        // Numeric input items for object
    Array1D_string cAlphaFields2;    // Alpha field names
    Array1D_string cNumericFields2;  // Numeric field names
    Array1D_bool lAlphaBlanks2;      // Logical array, alpha field input BLANK = .TRUE.
    Array1D_bool lNumericBlanks2;    // Logical array, numeric field input BLANK = .TRUE.
    int NumAlphas2;                  // Number of alphas in input for performance object
    int NumNumbers2;                 // Number of numeric items in input for performance object
    int IOStatus;                    // Input status returned from GetObjectItem
    bool ErrorsFound(false);         // Set to true if errors in input, fatal at end of routine
    int DXHPWaterHeaterCoilNum;      // Loop index for 1,NumDXHeatPumpWaterHeaterCoils
    int CapacityStageNum;            // Loop index for 1,Number of capacity stages
    int DehumidModeNum;              // Loop index for 1,Number of enhanced dehumidification modes
    int PerfModeNum;                 // Performance mode index
    int PerfObjectNum;               // Item number for performance object
    int AlphaIndex;                  // Index for current alpha field
    std::string CurrentModuleObject; // Object type for getting and error messages
    std::string PerfObjectType;      // Performance object type for getting and error messages
    std::string PerfObjectName;      // Performance object name for getting and error messages
    Real64 InletAirTemp;             // Used to pass proper inlet air temp to HPWH DX coil performance curves
    Real64 InletWaterTemp;           // Used to pass proper inlet water temp to HPWH DX coil performance curves
    int I;                           // Index of speeds
    Real64 CurveVal;                 // Used to verify modifier curves equal 1 at rated conditions
    Array1D_string Alphas;           // Alpha input items for object
    Array1D_string cAlphaFields;     // Alpha field names
    Array1D_string cNumericFields;   // Numeric field names
    Array1D<Real64> Numbers;         // Numeric input items for object
    Array1D_bool lAlphaBlanks;       // Logical array, alpha field input BLANK = .TRUE.
    Array1D_bool lNumericBlanks;     // Logical array, numeric field input BLANK = .TRUE.
    int MaxNumbers(0);               // Maximum number of numeric input fields
    int MaxAlphas(0);                // Maximum number of alpha input fields
    int TotalArgs(0);                // Total number of alpha and numeric arguments (max) for a
    //   certain object in the input file
    Real64 MinCurveVal; // used for testing PLF curve output
    Real64 MinCurvePLR; // used for testing PLF curve output
    Real64 MaxCurveVal; // used for testing PLF curve output
    Real64 MaxCurvePLR; // used for testing PLF curve output
    Real64 CurveInput;  // index used for testing PLF curve output

    // find number of each type of DX coil and calculate the total number
    state.dataDXCoils->NumDoe2DXCoils = state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, "Coil:Cooling:DX:SingleSpeed");
    state.dataDXCoils->NumDXHeatingCoils = state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, "Coil:Heating:DX:SingleSpeed");
    state.dataDXCoils->NumDXMulSpeedCoils = state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, "Coil:Cooling:DX:TwoSpeed");
    state.dataDXCoils->NumDXMulModeCoils =
        state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, "Coil:Cooling:DX:TwoStageWithHumidityControlMode");
    state.dataDXCoils->NumDXHeatPumpWaterHeaterPumpedCoils =
        state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, HVAC::cAllCoilTypes(HVAC::CoilDX_HeatPumpWaterHeaterPumped));
    state.dataDXCoils->NumDXHeatPumpWaterHeaterWrappedCoils =
        state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, HVAC::cAllCoilTypes(HVAC::CoilDX_HeatPumpWaterHeaterWrapped));
    state.dataDXCoils->NumDXMulSpeedCoolCoils = state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, "Coil:Cooling:DX:MultiSpeed");
    state.dataDXCoils->NumDXMulSpeedHeatCoils = state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, "Coil:Heating:DX:MultiSpeed");
    state.dataDXCoils->NumVRFCoolingCoils =
        state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, HVAC::cAllCoilTypes(HVAC::CoilVRF_Cooling));
    state.dataDXCoils->NumVRFHeatingCoils =
        state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, HVAC::cAllCoilTypes(HVAC::CoilVRF_Heating));
    state.dataDXCoils->NumVRFCoolingFluidTCtrlCoils =
        state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, HVAC::cAllCoilTypes(HVAC::CoilVRF_FluidTCtrl_Cooling));
    state.dataDXCoils->NumVRFHeatingFluidTCtrlCoils =
        state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, HVAC::cAllCoilTypes(HVAC::CoilVRF_FluidTCtrl_Heating));

    state.dataDXCoils->NumDXCoils = state.dataDXCoils->NumDoe2DXCoils + state.dataDXCoils->NumDXHeatingCoils + state.dataDXCoils->NumDXMulSpeedCoils +
                                    state.dataDXCoils->NumDXMulModeCoils + state.dataDXCoils->NumDXHeatPumpWaterHeaterPumpedCoils +
                                    state.dataDXCoils->NumDXHeatPumpWaterHeaterWrappedCoils + state.dataDXCoils->NumDXMulSpeedCoolCoils +
                                    state.dataDXCoils->NumDXMulSpeedHeatCoils + state.dataDXCoils->NumVRFCoolingCoils +
                                    state.dataDXCoils->NumVRFHeatingCoils + state.dataDXCoils->NumVRFCoolingFluidTCtrlCoils +
                                    state.dataDXCoils->NumVRFHeatingFluidTCtrlCoils;

    // Determine max number of alpha and numeric arguments for all objects being read, in order to allocate local arrays
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(state, "Coil:Cooling:DX:SingleSpeed", TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = NumNumbers;
    MaxAlphas = NumAlphas;
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(state, "Coil:Heating:DX:SingleSpeed", TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(state, "Coil:Cooling:DX:TwoSpeed", TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(
        state, "Coil:Cooling:DX:TwoStageWithHumidityControlMode", TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(
        state, HVAC::cAllCoilTypes(HVAC::CoilDX_HeatPumpWaterHeaterPumped), TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(
        state, HVAC::cAllCoilTypes(HVAC::CoilDX_HeatPumpWaterHeaterWrapped), TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(state, "Coil:Cooling:DX:MultiSpeed", TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(state, "Coil:Heating:DX:MultiSpeed", TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(
        state, HVAC::cAllCoilTypes(HVAC::CoilVRF_Cooling), TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(
        state, HVAC::cAllCoilTypes(HVAC::CoilVRF_Heating), TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(
        state, HVAC::cAllCoilTypes(HVAC::CoilVRF_FluidTCtrl_Cooling), TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(
        state, HVAC::cAllCoilTypes(HVAC::CoilVRF_FluidTCtrl_Heating), TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);
    state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(state, "CoilPerformance:DX:Cooling", TotalArgs, NumAlphas, NumNumbers);
    MaxNumbers = max(MaxNumbers, NumNumbers);
    MaxAlphas = max(MaxAlphas, NumAlphas);

    Alphas.allocate(MaxAlphas);
    cAlphaFields.allocate(MaxAlphas);
    cNumericFields.allocate(MaxNumbers);
    Numbers.dimension(MaxNumbers, 0.0);
    lAlphaBlanks.dimension(MaxAlphas, true);
    lNumericBlanks.dimension(MaxNumbers, true);

    Alphas2.allocate(MaxAlphas);
    cAlphaFields2.allocate(MaxAlphas);
    cNumericFields2.allocate(MaxNumbers);
    Numbers2.dimension(MaxNumbers, 0.0);
    lAlphaBlanks2.dimension(MaxAlphas, true);
    lNumericBlanks2.dimension(MaxNumbers, true);

    // allocate the data structure

    // Derived types
    state.dataDXCoils->DXCoil.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilNumericFields.allocate(state.dataDXCoils->NumDXCoils);
    state.dataHeatBal->HeatReclaimDXCoil.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->CheckEquipName.dimension(state.dataDXCoils->NumDXCoils, true);

    // Module level variable arrays
    state.dataDXCoils->DXCoilOutletTemp.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilOutletHumRat.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilPartLoadRatio.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilFanOp.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilFullLoadOutAirTemp.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilFullLoadOutAirHumRat.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilTotalCooling.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilTotalHeating.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilCoolInletAirWBTemp.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilHeatInletAirDBTemp.allocate(state.dataDXCoils->NumDXCoils);
    state.dataDXCoils->DXCoilHeatInletAirWBTemp.allocate(state.dataDXCoils->NumDXCoils);

    // initialize the module level arrays
    state.dataDXCoils->DXCoilOutletTemp = 0.0;
    state.dataDXCoils->DXCoilOutletHumRat = 0.0;
    state.dataDXCoils->DXCoilPartLoadRatio = 0.0;
    state.dataDXCoils->DXCoilFanOp = HVAC::FanOp::Invalid;
    state.dataDXCoils->DXCoilFullLoadOutAirTemp = 0.0;
    state.dataDXCoils->DXCoilFullLoadOutAirHumRat = 0.0;

    // initialize the coil counter
    DXCoilNum = 0;

    // Loop over the Doe2 DX Coils and get & load the data
    CurrentModuleObject = "Coil:Cooling:DX:SingleSpeed";
    for (DXCoilIndex = 1; DXCoilIndex <= state.dataDXCoils->NumDoe2DXCoils; ++DXCoilIndex) {

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXCoilIndex,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        ++DXCoilNum;
        // allocate single performance mode for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        // Initialize DataHeatBalance heat reclaim variable name for use by heat reclaim coils
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).Name = thisDXCoil.Name;
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).SourceType = CurrentModuleObject;
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilDX_CoolingSingleSpeed;
        thisDXCoil.Schedule = Alphas(2);
        if (lAlphaBlanks(2)) {
            thisDXCoil.SchedPtr = ScheduleManager::ScheduleAlwaysOn;
        } else {
            thisDXCoil.SchedPtr = GetScheduleIndex(state, Alphas(2)); // convert schedule name to pointer
            if (thisDXCoil.SchedPtr == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{}=\"{}\".", cAlphaFields(2), Alphas(2)));
                ErrorsFound = true;
            }
        }
        thisDXCoil.RatedTotCap(1) = Numbers(1);
        thisDXCoil.RatedSHR(1) = Numbers(2);
        thisDXCoil.RatedCOP(1) = Numbers(3);
        if (thisDXCoil.RatedCOP(1) <= 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 0.0, entered value=[{:.2T}].", cNumericFields(3), Numbers(3)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedAirVolFlowRate(1) = Numbers(4);
        thisDXCoil.FanPowerPerEvapAirFlowRate(1) = Numbers(5);
        thisDXCoil.FanPowerPerEvapAirFlowRate_2023(1) = Numbers(6);

        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(3),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilCoolingDXSingleSpeed,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);

        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(4),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilCoolingDXSingleSpeed,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(3), Alphas(4), "Air Nodes");

        thisDXCoil.CCapFTemp(1) = GetCurveIndex(state, Alphas(5)); // convert curve name to number
        if (thisDXCoil.CCapFTemp(1) == 0) {
            if (lAlphaBlanks(5)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(5)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(5), Alphas(5)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is BiQuadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CCapFTemp(1), // Curve index
                                                 {2},                     // Valid dimensions
                                                 RoutineName,             // Routine name
                                                 CurrentModuleObject,     // Object Type
                                                 thisDXCoil.Name,         // Object Name
                                                 cAlphaFields(5));        // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(state,
                                            std::string{RoutineName} + CurrentModuleObject,
                                            thisDXCoil.Name,
                                            thisDXCoil.CCapFTemp(1),
                                            cAlphaFields(5),
                                            Alphas(5),
                                            RatedInletWetBulbTemp,
                                            RatedOutdoorAirTemp);
            }
        }

        thisDXCoil.CCapFFlow(1) = GetCurveIndex(state, Alphas(6)); // convert curve name to number
        if (thisDXCoil.CCapFFlow(1) == 0) {
            if (lAlphaBlanks(6)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(6)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(6), Alphas(6)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is Quadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CCapFFlow(1), // Curve index
                                                 {1},                     // Valid dimensions
                                                 RoutineName,             // Routine name
                                                 CurrentModuleObject,     // Object Type
                                                 thisDXCoil.Name,         // Object Name
                                                 cAlphaFields(6));        // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(
                    state, std::string{RoutineName} + CurrentModuleObject, thisDXCoil.Name, thisDXCoil.CCapFFlow(1), cAlphaFields(6), Alphas(6), 1.0);
            }
        }

        thisDXCoil.EIRFTemp(1) = GetCurveIndex(state, Alphas(7)); // convert curve name to number
        if (thisDXCoil.EIRFTemp(1) == 0) {
            if (lAlphaBlanks(7)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(7)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(7), Alphas(7)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is BiQuadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.EIRFTemp(1), // Curve index
                                                 {2},                    // Valid dimensions
                                                 RoutineName,            // Routine name
                                                 CurrentModuleObject,    // Object Type
                                                 thisDXCoil.Name,        // Object Name
                                                 cAlphaFields(7));       // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(state,
                                            std::string{RoutineName} + CurrentModuleObject,
                                            thisDXCoil.Name,
                                            thisDXCoil.EIRFTemp(1),
                                            cAlphaFields(7),
                                            Alphas(7),
                                            RatedInletWetBulbTemp,
                                            RatedOutdoorAirTemp);
            }
        }

        thisDXCoil.EIRFFlow(1) = GetCurveIndex(state, Alphas(8)); // convert curve name to number
        if (thisDXCoil.EIRFFlow(1) == 0) {
            if (lAlphaBlanks(8)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(8)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(8), Alphas(8)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is Quadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.EIRFFlow(1), // Curve index
                                                 {1},                    // Valid dimensions
                                                 RoutineName,            // Routine name
                                                 CurrentModuleObject,    // Object Type
                                                 thisDXCoil.Name,        // Object Name
                                                 cAlphaFields(8));       // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(
                    state, std::string{RoutineName} + CurrentModuleObject, thisDXCoil.Name, thisDXCoil.EIRFFlow(1), cAlphaFields(8), Alphas(8), 1.0);
            }
        }

        thisDXCoil.PLFFPLR(1) = GetCurveIndex(state, Alphas(9)); // convert curve name to number
        if (thisDXCoil.PLFFPLR(1) == 0) {
            if (lAlphaBlanks(9)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(9)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(9), Alphas(9)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal types are Quadratic or Cubic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.PLFFPLR(1), // Curve index
                                                 {1},                   // Valid dimensions
                                                 RoutineName,           // Routine name
                                                 CurrentModuleObject,   // Object Type
                                                 thisDXCoil.Name,       // Object Name
                                                 cAlphaFields(9));      // Field Name

            if (!ErrorsFound) {
                //     Test PLF curve minimum and maximum. Cap if less than 0.7 or greater than 1.0.
                MinCurveVal = 999.0;
                MaxCurveVal = -999.0;
                CurveInput = 0.0;
                while (CurveInput <= 1.0) {
                    CurveVal = CurveValue(state, thisDXCoil.PLFFPLR(1), CurveInput);
                    if (CurveVal < MinCurveVal) {
                        MinCurveVal = CurveVal;
                        MinCurvePLR = CurveInput;
                    }
                    if (CurveVal > MaxCurveVal) {
                        MaxCurveVal = CurveVal;
                        MaxCurvePLR = CurveInput;
                    }
                    CurveInput += 0.01;
                }
                if (MinCurveVal < 0.7) {
                    ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...{}=\"{}\" has out of range values.", cAlphaFields(9), Alphas(9)));
                    ShowContinueError(state,
                                      format("...Curve minimum must be >= 0.7, curve min at PLR = {:.2T} is {:.3T}", MinCurvePLR, MinCurveVal));
                    ShowContinueError(state, "...Setting curve minimum to 0.7 and simulation continues.");
                    Curve::SetCurveOutputMinValue(state, thisDXCoil.PLFFPLR(1), ErrorsFound, 0.7);
                }

                if (MaxCurveVal > 1.0) {
                    ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields(9), Alphas(9)));
                    ShowContinueError(state,
                                      format("...Curve maximum must be <= 1.0, curve max at PLR = {:.2T} is {:.3T}", MaxCurvePLR, MaxCurveVal));
                    ShowContinueError(state, "...Setting curve maximum to 1.0 and simulation continues.");
                    Curve::SetCurveOutputMaxValue(state, thisDXCoil.PLFFPLR(1), ErrorsFound, 1.0);
                }
            }
        }

        // Set minimum OAT for compressor operation
        thisDXCoil.MinOATCompressor = Numbers(7);
        if (NumNumbers < 6)
            thisDXCoil.MinOATCompressor = minOATCompDXCooling; // input field is after min fields and won't default if field not included

        thisDXCoil.Twet_Rated(1) = Numbers(8);
        thisDXCoil.Gamma_Rated(1) = Numbers(9);
        thisDXCoil.MaxONOFFCyclesperHour(1) = Numbers(10);
        thisDXCoil.LatentCapacityTimeConstant(1) = Numbers(11);

        // Numbers (7) through (11) must all be greater than zero to use the latent capacity degradation model
        if ((Numbers(8) > 0.0 || Numbers(9) > 0.0 || Numbers(10) > 0.0 || Numbers(11) > 0.0) &&
            (Numbers(8) <= 0.0 || Numbers(9) <= 0.0 || Numbers(10) <= 0.0 || Numbers(11) <= 0.0)) {
            ShowWarningError(state, format("{}{}=\"{}\":", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, "...At least one of the four input parameters for the latent capacity degradation model");
            ShowContinueError(state, "...is set to zero. Therefore, the latent degradation model will not be used for this simulation.");
        }

        // outdoor condenser node
        if (lAlphaBlanks(10)) {
            thisDXCoil.CondenserInletNodeNum(1) = 0;
        } else {
            thisDXCoil.CondenserInletNodeNum(1) = GetOnlySingleNode(state,
                                                                    Alphas(10),
                                                                    ErrorsFound,
                                                                    DataLoopNode::ConnectionObjectType::CoilCoolingDXSingleSpeed,
                                                                    thisDXCoil.Name,
                                                                    DataLoopNode::NodeFluidType::Air,
                                                                    DataLoopNode::ConnectionType::OutsideAirReference,
                                                                    NodeInputManager::CompFluidStream::Primary,
                                                                    ObjectIsNotParent);

            if (!CheckOutAirNodeNumber(state, thisDXCoil.CondenserInletNodeNum(1))) {
                ShowWarningError(state, format("{}{}=\"{}\", may be invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(
                    state,
                    format("{}=\"{}\", node does not appear in an OutdoorAir:NodeList or as an OutdoorAir:Node.", cAlphaFields(10), Alphas(10)));
                ShowContinueError(
                    state, "This node needs to be included in an air system or the coil model will not be valid, and the simulation continues");
            }
        }

        if ((Util::SameString(Alphas(11), "AirCooled")) || lAlphaBlanks(11)) {
            thisDXCoil.CondenserType(1) = DataHeatBalance::RefrigCondenserType::Air;
        } else if (Util::SameString(Alphas(11), "EvaporativelyCooled")) {
            thisDXCoil.CondenserType(1) = DataHeatBalance::RefrigCondenserType::Evap;
            thisDXCoil.ReportEvapCondVars = true;
        } else {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{}=\"{}\":", cAlphaFields(11), Alphas(11)));
            ShowContinueError(state, "...must be AirCooled or EvaporativelyCooled.");
            ErrorsFound = true;
        }

        thisDXCoil.EvapCondEffect(1) = Numbers(12);
        if (thisDXCoil.EvapCondEffect(1) < 0.0 || thisDXCoil.EvapCondEffect(1) > 1.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0 or > 1.0.", cNumericFields(11)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(12)));
            ErrorsFound = true;
        }

        thisDXCoil.EvapCondAirFlow(1) = Numbers(13);
        if (thisDXCoil.EvapCondAirFlow(1) < 0.0 && thisDXCoil.EvapCondAirFlow(1) != AutoSize) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0.", cNumericFields(12)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(13)));
            ErrorsFound = true;
        }

        thisDXCoil.EvapCondPumpElecNomPower(1) = Numbers(14);
        if (thisDXCoil.EvapCondPumpElecNomPower(1) < 0.0 && thisDXCoil.EvapCondPumpElecNomPower(1) != AutoSize) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0.", cNumericFields(13)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(14)));
            ErrorsFound = true;
        }

        // Set crankcase heater capacity
        thisDXCoil.CrankcaseHeaterCapacity = Numbers(15);
        if (thisDXCoil.CrankcaseHeaterCapacity < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0.", cNumericFields(14)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(15)));
            ErrorsFound = true;
        }

        // Set crankcase heater cutout temperature
        thisDXCoil.MaxOATCrankcaseHeater = Numbers(16);

        if (thisDXCoil.RatedCOP(1) > 0.0) {
            thisDXCoil.RatedEIR(1) = 1.0 / thisDXCoil.RatedCOP(1);
        }

        // A12, \field Crankcase Heater Capacity Function of Outdoor Temperature Curve Name
        if (!lAlphaBlanks(12)) {
            thisDXCoil.CrankcaseHeaterCapacityCurveIndex = Curve::GetCurveIndex(state, Alphas(12));
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CrankcaseHeaterCapacityCurveIndex, // Curve index
                                                 {1},                                          // Valid dimensions
                                                 RoutineName,                                  // Routine name
                                                 CurrentModuleObject,                          // Object Type
                                                 thisDXCoil.Name,                              // Object Name
                                                 cAlphaFields(12));                            // Field Name
        }

        // Get Water System tank connections
        //  A13, \field Name of Water Storage Tank for Supply
        thisDXCoil.EvapWaterSupplyName = Alphas(13);
        if (lAlphaBlanks(13)) {
            thisDXCoil.EvapWaterSupplyMode = EvapWaterSupply::FromMains;
        } else {
            thisDXCoil.EvapWaterSupplyMode = EvapWaterSupply::FromTank;
            SetupTankDemandComponent(state,
                                     thisDXCoil.Name,
                                     CurrentModuleObject,
                                     thisDXCoil.EvapWaterSupplyName,
                                     ErrorsFound,
                                     thisDXCoil.EvapWaterSupTankID,
                                     thisDXCoil.EvapWaterTankDemandARRID);
        }

        // A14; \field Name of Water Storage Tank for Condensate Collection
        thisDXCoil.CondensateCollectName = Alphas(14);
        if (lAlphaBlanks(14)) {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::Discard;
        } else {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::ToTank;
            SetupTankSupplyComponent(state,
                                     thisDXCoil.Name,
                                     CurrentModuleObject,
                                     thisDXCoil.CondensateCollectName,
                                     ErrorsFound,
                                     thisDXCoil.CondensateTankID,
                                     thisDXCoil.CondensateTankSupplyARRID);
        }

        //   Basin heater power as a function of temperature must be greater than or equal to 0
        thisDXCoil.BasinHeaterPowerFTempDiff = Numbers(17);
        if (Numbers(17) < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0.0.", cNumericFields(16)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(17)));
            ErrorsFound = true;
        }

        thisDXCoil.BasinHeaterSetPointTemp = Numbers(18);
        if (thisDXCoil.BasinHeaterPowerFTempDiff > 0.0) {
            if (NumNumbers < 18) {
                thisDXCoil.BasinHeaterSetPointTemp = 2.0;
            }
            if (thisDXCoil.BasinHeaterSetPointTemp < 2.0) {
                ShowWarningError(state, format("{}{}=\"{}\", freeze possible", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{} is < 2 {{C}}. Freezing could occur.", cNumericFields(17)));
                ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(18)));
            }
        }

        if (!lAlphaBlanks(15)) {
            thisDXCoil.BasinHeaterSchedulePtr = GetScheduleIndex(state, Alphas(15));
            if (thisDXCoil.BasinHeaterSchedulePtr == 0) {
                ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(15), Alphas(15)));
                ShowContinueError(state, "Basin heater will be available to operate throughout the simulation.");
            }
        }

        if (!lAlphaBlanks(16) && NumAlphas > 15) {
            thisDXCoil.SHRFTemp(1) = GetCurveIndex(state, Alphas(16)); // convert curve name to number
            if (thisDXCoil.SHRFTemp(1) == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(16), Alphas(16)));
            } else {
                // Verify Curve Object, only legal type is BiQuadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.SHRFTemp(1), // Curve index
                                                     {2},                    // Valid dimensions
                                                     RoutineName,            // Routine name
                                                     CurrentModuleObject,    // Object Type
                                                     thisDXCoil.Name,        // Object Name
                                                     cAlphaFields(16));      // Field Name
            }
        }

        if (!lAlphaBlanks(17) && NumAlphas > 16) {
            thisDXCoil.SHRFFlow(1) = GetCurveIndex(state, Alphas(17)); // convert curve name to number
            if (thisDXCoil.SHRFTemp(1) == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(17), Alphas(17)));
            } else {
                // Verify Curve Object, only legal type is Quadratic and Cubic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.SHRFFlow(1), // Curve index
                                                     {1},                    // Valid dimensions
                                                     RoutineName,            // Routine name
                                                     CurrentModuleObject,    // Object Type
                                                     thisDXCoil.Name,        // Object Name
                                                     cAlphaFields(17));      // Field Name
            }
        }

        if (thisDXCoil.SHRFTemp(1) > 0 && thisDXCoil.SHRFFlow(1) > 0) {
            thisDXCoil.UserSHRCurveExists = true;
        }
        // get User Input flag for ASHRAE Standard 127 Standard Ratings Reporting
        if (lAlphaBlanks(18)) {
            thisDXCoil.ASHRAE127StdRprt = false;
        } else {
            if (Alphas(18) == "YES" || Alphas(18) == "Yes") {
                thisDXCoil.ASHRAE127StdRprt = true;
            } else {
                thisDXCoil.ASHRAE127StdRprt = false;
            }
        }
        // A19; \field Zone Name for Condenser Placement
        if (!lAlphaBlanks(19) && NumAlphas > 18) {
            thisDXCoil.SecZonePtr = Util::FindItemInList(Alphas(19), state.dataHeatBal->Zone);

            if (thisDXCoil.SecZonePtr > 0) {
                SetupZoneInternalGain(state,
                                      thisDXCoil.SecZonePtr,
                                      thisDXCoil.Name,
                                      DataHeatBalance::IntGainType::SecCoolingDXCoilSingleSpeed,
                                      &thisDXCoil.SecCoilSensibleHeatGainRate);
                thisDXCoil.IsSecondaryDXCoilInZone = true;
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(19), Alphas(19)));
            }
        }

    } // end of the Doe2 DX coil loop

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input. Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }

    // Loop over the Multimode DX Coils and get & load the data
    CurrentModuleObject = "Coil:Cooling:DX:TwoStageWithHumidityControlMode";
    for (DXCoilIndex = 1; DXCoilIndex <= state.dataDXCoils->NumDXMulModeCoils; ++DXCoilIndex) {

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXCoilIndex,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        ++DXCoilNum;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        // Initialize DataHeatBalance heat reclaim variable name for use by heat reclaim coils
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).Name = thisDXCoil.Name;
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).SourceType = CurrentModuleObject;
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilDX_CoolingTwoStageWHumControl;
        thisDXCoil.Schedule = Alphas(2);
        if (lAlphaBlanks(2)) {
            thisDXCoil.SchedPtr = ScheduleManager::ScheduleAlwaysOn;
        } else {
            thisDXCoil.SchedPtr = GetScheduleIndex(state, Alphas(2)); // convert schedule name to pointer
            if (thisDXCoil.SchedPtr == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{}=\"{}\".", cAlphaFields(2), Alphas(2)));
                ErrorsFound = true;
            }
        }

        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(3),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilCoolingDXTwoStageWithHumidityControlMode,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);

        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(4),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilCoolingDXTwoStageWithHumidityControlMode,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(3), Alphas(4), "Air Nodes");

        // A5; \field Crankcase Heater Capacity Function of Outdoor Temperature Curve Name
        if (!lAlphaBlanks(5)) {
            thisDXCoil.CrankcaseHeaterCapacityCurveIndex = Curve::GetCurveIndex(state, Alphas(5));
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CrankcaseHeaterCapacityCurveIndex, // Curve index
                                                 {1},                                          // Valid dimensions
                                                 RoutineName,                                  // Routine name
                                                 CurrentModuleObject,                          // Object Type
                                                 thisDXCoil.Name,                              // Object Name
                                                 cAlphaFields(5));                             // Field Name
        }

        // Set crankcase heater capacity
        thisDXCoil.CrankcaseHeaterCapacity = Numbers(1);
        if (thisDXCoil.CrankcaseHeaterCapacity < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0.0, entered value=[{:.2T}].", cNumericFields(1), Numbers(1)));
            ErrorsFound = true;
        }

        // Set crankcase heater cutout temperature
        thisDXCoil.MaxOATCrankcaseHeater = Numbers(2);

        //  Number of capacity stages
        thisDXCoil.NumCapacityStages = Numbers(3);
        //  Check if requested number of capacity stages exceeds limits
        if ((thisDXCoil.NumCapacityStages > MaxCapacityStages) || (thisDXCoil.NumCapacityStages < 1)) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...illegal {} = {}", cNumericFields(3), thisDXCoil.NumCapacityStages));
            ShowContinueError(state, format("...Valid range is 1 to {}", MaxCapacityStages));
            ErrorsFound = true;
        }

        //  Number of enhanced dehumidification modes
        thisDXCoil.NumDehumidModes = Numbers(4);
        //  Check if requested number of enhanced dehumidification modes exceeds limits
        if ((thisDXCoil.NumDehumidModes > MaxDehumidModes) || (thisDXCoil.NumDehumidModes < 0)) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...illegal {} = {}", cNumericFields(4), thisDXCoil.NumDehumidModes));
            ShowContinueError(state, format("...Valid range is 0 to {}", MaxDehumidModes));
            ErrorsFound = true;
        }

        //  Set starting alpha index for coil performance inputs
        AlphaIndex = 6;
        // allocate performance modes for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(
            thisDXCoil.NumDehumidModes * 2 + thisDXCoil.NumCapacityStages * 2); // not sure this math is correct, ask MW

        //  Loop through capacity stages and dehumidification modes
        for (DehumidModeNum = 0; DehumidModeNum <= thisDXCoil.NumDehumidModes; ++DehumidModeNum) {
            for (CapacityStageNum = 1; CapacityStageNum <= thisDXCoil.NumCapacityStages; ++CapacityStageNum) {
                //  Check if sufficient number of fields entered
                if ((AlphaIndex + 1) > NumAlphas) {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, "...not enough remaining fields for specified Number of Operating Modes.");
                    ShowContinueError(state, "...Need additional Coil Performance Object Type and Coil Performance Object Name fields.");
                    ErrorsFound = true;
                } else {
                    PerfObjectType = Alphas(AlphaIndex);
                    PerfObjectName = Alphas(AlphaIndex + 1);
                    PerfModeNum = DehumidModeNum * 2 + CapacityStageNum;
                    thisDXCoil.CoilPerformanceType(PerfModeNum) = PerfObjectType;
                    if (Util::SameString(PerfObjectType, "CoilPerformance:DX:Cooling")) {
                        thisDXCoil.CoilPerformanceType_Num(PerfModeNum) = HVAC::CoilPerfDX_CoolBypassEmpirical;
                    } else {
                        ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state, format("...illegal {}=\"{}\".", cAlphaFields(AlphaIndex), PerfObjectType));
                        ShowContinueError(state, "Must be \"CoilPerformance:DX:Cooling\".");
                        ErrorsFound = true;
                    }
                    thisDXCoil.CoilPerformanceName(PerfModeNum) = PerfObjectName;
                    // Get for CoilPerformance object
                    PerfObjectNum = state.dataInputProcessing->inputProcessor->getObjectItemNum(state, PerfObjectType, PerfObjectName);
                    if (PerfObjectNum > 0) {

                        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                                 PerfObjectType,
                                                                                 PerfObjectNum,
                                                                                 Alphas2,
                                                                                 NumAlphas2,
                                                                                 Numbers2,
                                                                                 NumNumbers2,
                                                                                 IOStatus,
                                                                                 lNumericBlanks2,
                                                                                 lAlphaBlanks2,
                                                                                 cAlphaFields2,
                                                                                 cNumericFields2);

                        // allocate performance mode numeric field strings used for sizing routine
                        state.dataDXCoils->DXCoilNumericFields(DXCoilNum)
                            .PerfMode(PerfModeNum)
                            .FieldNames.allocate(NumNumbers2); // use MaxNumbers here??
                        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(PerfModeNum).FieldNames = cNumericFields2;

                        thisDXCoil.RatedTotCap(PerfModeNum) = Numbers2(1);
                        thisDXCoil.RatedSHR(PerfModeNum) = Numbers2(2);
                        thisDXCoil.RatedCOP(PerfModeNum) = Numbers2(3);
                        // Rated flow is immediately adjusted for bypass fraction if not autosized
                        thisDXCoil.BypassedFlowFrac(PerfModeNum) = Numbers2(5);
                        thisDXCoil.RatedAirVolFlowRate(PerfModeNum) = Numbers2(4);
                        if (thisDXCoil.RatedAirVolFlowRate(PerfModeNum) != AutoSize) {
                            thisDXCoil.RatedAirVolFlowRate(PerfModeNum) *= (1.0 - thisDXCoil.BypassedFlowFrac(PerfModeNum));
                        }

                        thisDXCoil.CCapFTemp(PerfModeNum) = GetCurveIndex(state, Alphas2(2)); // convert curve name to number
                        if (thisDXCoil.CCapFTemp(PerfModeNum) == 0) {
                            if (lAlphaBlanks2(2)) {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("...required {} is blank.", cAlphaFields2(2)));
                            } else {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields2(2), Alphas2(2)));
                            }
                            ErrorsFound = true;
                        } else {
                            // Verify Curve Object, only legal type is BiQuadratic
                            ErrorsFound |= Curve::CheckCurveDims(state,
                                                                 thisDXCoil.CCapFTemp(PerfModeNum), // Curve index
                                                                 {2},                               // Valid dimensions
                                                                 RoutineName,                       // Routine name
                                                                 CurrentModuleObject,               // Object Type
                                                                 thisDXCoil.Name,                   // Object Name
                                                                 cAlphaFields2(2));                 // Field Name

                            if (!ErrorsFound) {
                                checkCurveIsNormalizedToOne(state,
                                                            std::string{RoutineName} + CurrentModuleObject,
                                                            thisDXCoil.Name,
                                                            thisDXCoil.CCapFTemp(PerfModeNum),
                                                            cAlphaFields2(2),
                                                            Alphas2(2),
                                                            RatedInletWetBulbTemp,
                                                            RatedOutdoorAirTemp);
                            }
                        }

                        thisDXCoil.CCapFFlow(PerfModeNum) = GetCurveIndex(state, Alphas2(3)); // convert curve name to number
                        if (thisDXCoil.CCapFFlow(PerfModeNum) == 0) {
                            if (lAlphaBlanks2(3)) {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("...required {} is blank.", cAlphaFields2(3)));
                            } else {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields2(3), Alphas2(3)));
                            }
                            ErrorsFound = true;
                        } else {
                            // Verify Curve Object, only legal type is Quadratic
                            ErrorsFound |= Curve::CheckCurveDims(state,
                                                                 thisDXCoil.CCapFFlow(PerfModeNum), // Curve index
                                                                 {1},                               // Valid dimensions
                                                                 RoutineName,                       // Routine name
                                                                 CurrentModuleObject,               // Object Type
                                                                 thisDXCoil.Name,                   // Object Name
                                                                 cAlphaFields2(3));                 // Field Name

                            if (!ErrorsFound) {
                                checkCurveIsNormalizedToOne(state,
                                                            std::string{RoutineName} + CurrentModuleObject,
                                                            thisDXCoil.Name,
                                                            thisDXCoil.CCapFFlow(PerfModeNum),
                                                            cAlphaFields2(3),
                                                            Alphas2(3),
                                                            1.0);
                            }
                        }

                        thisDXCoil.EIRFTemp(PerfModeNum) = GetCurveIndex(state, Alphas2(4)); // convert curve name to number
                        if (thisDXCoil.EIRFTemp(PerfModeNum) == 0) {
                            if (lAlphaBlanks2(4)) {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("...required {} is blank.", cAlphaFields2(4)));
                            } else {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields2(4), Alphas2(4)));
                            }
                            ErrorsFound = true;
                        } else {
                            // Verify Curve Object, only legal type is BiQuadratic
                            ErrorsFound |= Curve::CheckCurveDims(state,
                                                                 thisDXCoil.EIRFTemp(PerfModeNum), // Curve index
                                                                 {2},                              // Valid dimensions
                                                                 RoutineName,                      // Routine name
                                                                 CurrentModuleObject,              // Object Type
                                                                 thisDXCoil.Name,                  // Object Name
                                                                 cAlphaFields2(4));                // Field Name

                            if (!ErrorsFound) {
                                checkCurveIsNormalizedToOne(state,
                                                            std::string{RoutineName} + CurrentModuleObject,
                                                            thisDXCoil.Name,
                                                            thisDXCoil.EIRFTemp(PerfModeNum),
                                                            cAlphaFields2(4),
                                                            Alphas2(4),
                                                            RatedInletWetBulbTemp,
                                                            RatedOutdoorAirTemp);
                            }
                        }

                        thisDXCoil.EIRFFlow(PerfModeNum) = GetCurveIndex(state, Alphas2(5)); // convert curve name to number
                        if (thisDXCoil.EIRFFlow(PerfModeNum) == 0) {
                            if (lAlphaBlanks2(5)) {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("...required {} is blank.", cAlphaFields2(5)));
                            } else {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields2(5), Alphas2(5)));
                            }
                            ErrorsFound = true;
                        } else {
                            // Verify Curve Object, only legal type is Quadratic
                            ErrorsFound |= Curve::CheckCurveDims(state,
                                                                 thisDXCoil.EIRFFlow(PerfModeNum), // Curve index
                                                                 {1},                              // Valid dimensions
                                                                 RoutineName,                      // Routine name
                                                                 CurrentModuleObject,              // Object Type
                                                                 thisDXCoil.Name,                  // Object Name
                                                                 cAlphaFields2(5));                // Field Name

                            if (!ErrorsFound) {
                                checkCurveIsNormalizedToOne(state,
                                                            std::string{RoutineName} + CurrentModuleObject,
                                                            thisDXCoil.Name,
                                                            thisDXCoil.EIRFFlow(PerfModeNum),
                                                            cAlphaFields2(5),
                                                            Alphas2(5),
                                                            1.0);
                            }
                        }

                        thisDXCoil.PLFFPLR(PerfModeNum) = GetCurveIndex(state, Alphas2(6)); // convert curve name to number
                        if (thisDXCoil.PLFFPLR(PerfModeNum) == 0) {
                            if (lAlphaBlanks2(6)) {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("...required {} is blank.", cAlphaFields2(6)));
                            } else {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields2(6), Alphas2(6)));
                            }
                            ErrorsFound = true;
                        } else {
                            // Verify Curve Object, only legal types are Quadratic or Cubic
                            ErrorsFound |= Curve::CheckCurveDims(state,
                                                                 thisDXCoil.PLFFPLR(PerfModeNum), // Curve index
                                                                 {1},                             // Valid dimensions
                                                                 RoutineName,                     // Routine name
                                                                 CurrentModuleObject,             // Object Type
                                                                 thisDXCoil.Name,                 // Object Name
                                                                 cAlphaFields2(6));               // Field Name

                            if (!ErrorsFound) {
                                //             Test PLF curve minimum and maximum. Cap if less than 0.7 or greater than 1.0.
                                MinCurveVal = 999.0;
                                MaxCurveVal = -999.0;
                                CurveInput = 0.0;
                                while (CurveInput <= 1.0) {
                                    CurveVal = CurveValue(state, thisDXCoil.PLFFPLR(PerfModeNum), CurveInput);
                                    if (CurveVal < MinCurveVal) {
                                        MinCurveVal = CurveVal;
                                        MinCurvePLR = CurveInput;
                                    }
                                    if (CurveVal > MaxCurveVal) {
                                        MaxCurveVal = CurveVal;
                                        MaxCurvePLR = CurveInput;
                                    }
                                    CurveInput += 0.01;
                                }
                                if (MinCurveVal < 0.7) {
                                    ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                    ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields2(6), Alphas2(6)));
                                    ShowContinueError(
                                        state,
                                        format("...Curve minimum must be >= 0.7, curve min at PLR = {:.2T} is {:.3T}", MinCurvePLR, MinCurveVal));
                                    ShowContinueError(state, "...Setting curve minimum to 0.7 and simulation continues.");
                                    Curve::SetCurveOutputMinValue(state, thisDXCoil.PLFFPLR(PerfModeNum), ErrorsFound, 0.7);
                                }

                                if (MaxCurveVal > 1.0) {
                                    ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                                    ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields2(6), Alphas2(6)));
                                    ShowContinueError(
                                        state,
                                        format("...Curve maximum must be <= 1.0, curve max at PLR = {:.2T} is {:.3T}", MaxCurvePLR, MaxCurveVal));
                                    ShowContinueError(state, "...Setting curve maximum to 1.0 and simulation continues.");
                                    Curve::SetCurveOutputMaxValue(state, thisDXCoil.PLFFPLR(PerfModeNum), ErrorsFound, 1.0);
                                }
                            }
                        }

                        thisDXCoil.Twet_Rated(PerfModeNum) = Numbers2(6);
                        thisDXCoil.Gamma_Rated(PerfModeNum) = Numbers2(7);
                        thisDXCoil.MaxONOFFCyclesperHour(PerfModeNum) = Numbers2(8);
                        thisDXCoil.LatentCapacityTimeConstant(PerfModeNum) = Numbers2(9);
                        // Numbers2 (6) through (9) must all be greater than zero to use the latent capacity degradation model
                        if ((Numbers2(6) > 0.0 || Numbers2(7) > 0.0 || Numbers2(8) > 0.0 || Numbers2(9) > 0.0) &&
                            (Numbers2(6) <= 0.0 || Numbers2(7) <= 0.0 || Numbers2(8) <= 0.0 || Numbers2(9) <= 0.0)) {
                            ShowWarningError(state, format("{}{}=\"{}\":", RoutineName, PerfObjectType, PerfObjectName));
                            ShowContinueError(state, "...At least one of the four input parameters for the latent capacity degradation model");
                            ShowContinueError(state,
                                              "...is set to zero. Therefore, the latent degradation model will not be used for this simulation.");
                        }

                        // outdoor condenser node
                        if (lAlphaBlanks2(7)) {
                            thisDXCoil.CondenserInletNodeNum(PerfModeNum) = 0;
                        } else {
                            thisDXCoil.CondenserInletNodeNum(PerfModeNum) =
                                GetOnlySingleNode(state,
                                                  Alphas2(7),
                                                  ErrorsFound,
                                                  (DataLoopNode::ConnectionObjectType)getEnumValue(BranchNodeConnections::ConnectionObjectTypeNamesUC,
                                                                                                   Util::makeUPPER(PerfObjectType)),
                                                  PerfObjectName,
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::OutsideAirReference,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);
                            if (!CheckOutAirNodeNumber(state, thisDXCoil.CondenserInletNodeNum(PerfModeNum))) {
                                ShowWarningError(state, format("{}{}=\"{}\":", RoutineName, PerfObjectType, PerfObjectName));
                                ShowContinueError(state, format("may not be valid {}=\"{}\".", cAlphaFields2(7), Alphas2(7)));
                                ShowContinueError(state, "node does not appear in an OutdoorAir:NodeList or as an OutdoorAir:Node.");
                                ShowContinueError(state,
                                                  "This node needs to be included in an air system or the coil model will not be valid, and the "
                                                  "simulation continues");
                            }
                        }
                        if ((Util::SameString(Alphas2(8), "AirCooled")) || lAlphaBlanks2(8)) {
                            thisDXCoil.CondenserType(PerfModeNum) = DataHeatBalance::RefrigCondenserType::Air;
                        } else if (Util::SameString(Alphas2(8), "EvaporativelyCooled")) {
                            thisDXCoil.CondenserType(PerfModeNum) = DataHeatBalance::RefrigCondenserType::Evap;
                            thisDXCoil.ReportEvapCondVars = true;
                        } else {
                            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                            ShowContinueError(state, format("...{}=\"{}\":", cAlphaFields2(8), Alphas2(8)));
                            ShowContinueError(state, "...must be AirCooled or EvaporativelyCooled.");
                            ErrorsFound = true;
                        }

                        thisDXCoil.EvapCondEffect(PerfModeNum) = Numbers2(10);
                        if (thisDXCoil.EvapCondEffect(PerfModeNum) < 0.0 || thisDXCoil.EvapCondEffect(PerfModeNum) > 1.0) {
                            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                            ShowContinueError(state, format("...{} cannot be < 0.0 or > 1.0.", cNumericFields2(10)));
                            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers2(10)));
                            ErrorsFound = true;
                        }

                        thisDXCoil.EvapCondAirFlow(PerfModeNum) = Numbers2(11);
                        if (thisDXCoil.EvapCondAirFlow(PerfModeNum) < 0.0 && thisDXCoil.EvapCondAirFlow(PerfModeNum) != AutoSize) {
                            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                            ShowContinueError(state, format("...{} cannot be < 0.0.", cNumericFields2(11)));
                            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers2(11)));
                            ErrorsFound = true;
                        }

                        thisDXCoil.EvapCondPumpElecNomPower(PerfModeNum) = Numbers2(12);
                        if (thisDXCoil.EvapCondPumpElecNomPower(PerfModeNum) < 0.0 && thisDXCoil.EvapCondAirFlow(PerfModeNum) != AutoSize) {
                            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, PerfObjectType, PerfObjectName));
                            ShowContinueError(state, format("...{} cannot be less than zero.", cNumericFields2(12)));
                            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers2(12)));
                            ErrorsFound = true;
                        }

                        thisDXCoil.RatedEIR(PerfModeNum) = 1.0 / thisDXCoil.RatedCOP(PerfModeNum);

                        // read in user specified SHR modifier curves
                        if (!lAlphaBlanks2(9) && NumAlphas2 > 8) {
                            thisDXCoil.SHRFTemp(PerfModeNum) = GetCurveIndex(state, Alphas2(9)); // convert curve name to number
                            if (thisDXCoil.SHRFTemp(PerfModeNum) == 0) {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields2(9), Alphas2(9)));
                            } else {
                                // Verify Curve Object, only legal type is BiQuadratic
                                ErrorsFound |= Curve::CheckCurveDims(state,
                                                                     thisDXCoil.SHRFTemp(PerfModeNum), // Curve index
                                                                     {2},                              // Valid dimensions
                                                                     RoutineName,                      // Routine name
                                                                     CurrentModuleObject,              // Object Type
                                                                     thisDXCoil.Name,                  // Object Name
                                                                     cAlphaFields2(9));                // Field Name
                            }
                        }

                        if (!lAlphaBlanks2(10) && NumAlphas2 > 9) {
                            thisDXCoil.SHRFFlow(PerfModeNum) = GetCurveIndex(state, Alphas2(10)); // convert curve name to number
                            if (thisDXCoil.SHRFTemp(PerfModeNum) == 0) {
                                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields2(10), Alphas2(10)));
                            } else {
                                // Verify Curve Object, only legal type is BiQuadratic
                                ErrorsFound |= Curve::CheckCurveDims(state,
                                                                     thisDXCoil.SHRFFlow(PerfModeNum), // Curve index
                                                                     {1},                              // Valid dimensions
                                                                     RoutineName,                      // Routine name
                                                                     CurrentModuleObject,              // Object Type
                                                                     thisDXCoil.Name,                  // Object Name
                                                                     cAlphaFields2(10));               // Field Name
                            }
                        }
                        if (thisDXCoil.SHRFTemp(PerfModeNum) > 0 && thisDXCoil.SHRFFlow(PerfModeNum) > 0) {
                            thisDXCoil.UserSHRCurveExists = true;
                        } else {
                            thisDXCoil.UserSHRCurveExists = false;
                        }

                    } else { // invalid performance object
                        ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state, format("... not found {}=\"{}\".", PerfObjectType, PerfObjectName));
                        ErrorsFound = true;
                    } // end of valid performance object check
                    AlphaIndex += 2;
                } // end of sufficient number of fields entered check
            }     // End of multimode DX capacity stages loop
            // Warn if inputs entered for unused capacity stages
            for (CapacityStageNum = (thisDXCoil.NumCapacityStages + 1); CapacityStageNum <= MaxCapacityStages; ++CapacityStageNum) {
                if ((AlphaIndex <= NumAlphas) && ((!Alphas(AlphaIndex).empty()) || (!Alphas(AlphaIndex + 1).empty()))) {
                    ShowWarningError(state, format("{}{}=\"{}\":", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...Capacity Stage {} not active. Therefore,{}", CapacityStageNum, cAlphaFields(AlphaIndex)));
                    ShowContinueError(state, format("... and {} fields will be ignored.", cAlphaFields(AlphaIndex + 1)));
                }
                AlphaIndex += 2;
            } // End of unused capacity stages loop
        }     // End of multimode DX dehumidification modes loo

        // Get Water System tank connections
        //  A14, \field Name of Water Storage Tank for Supply
        thisDXCoil.EvapWaterSupplyName = Alphas(14);
        if (lAlphaBlanks(14)) {
            thisDXCoil.EvapWaterSupplyMode = EvapWaterSupply::FromMains;
        } else {
            thisDXCoil.EvapWaterSupplyMode = EvapWaterSupply::FromTank;
            SetupTankDemandComponent(state,
                                     thisDXCoil.Name,
                                     CurrentModuleObject,
                                     thisDXCoil.EvapWaterSupplyName,
                                     ErrorsFound,
                                     thisDXCoil.EvapWaterSupTankID,
                                     thisDXCoil.EvapWaterTankDemandARRID);
        }

        // A15; \field Name of Water Storage Tank for Condensate Collection
        thisDXCoil.CondensateCollectName = Alphas(15);
        if (lAlphaBlanks(15)) {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::Discard;
        } else {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::ToTank;
            SetupTankSupplyComponent(state,
                                     thisDXCoil.Name,
                                     CurrentModuleObject,
                                     thisDXCoil.CondensateCollectName,
                                     ErrorsFound,
                                     thisDXCoil.CondensateTankID,
                                     thisDXCoil.CondensateTankSupplyARRID);
        }

        // Set minimum OAT for compressor operation
        thisDXCoil.MinOATCompressor = Numbers(5);
        if (NumNumbers < 5)
            thisDXCoil.MinOATCompressor = minOATCompDXCooling; // input field is after min fields and won't default if field not included

        // Basin heater power as a function of temperature must be greater than or equal to 0
        thisDXCoil.BasinHeaterPowerFTempDiff = Numbers(6);
        if (Numbers(6) < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0.", cNumericFields(6)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(6)));
            ErrorsFound = true;
        }

        thisDXCoil.BasinHeaterSetPointTemp = Numbers(7);
        if (thisDXCoil.BasinHeaterPowerFTempDiff > 0.0) {
            if (NumNumbers < 7) {
                thisDXCoil.BasinHeaterSetPointTemp = 2.0;
            }
            if (thisDXCoil.BasinHeaterSetPointTemp < 2.0) {
                ShowWarningError(state, format("{}{}=\"{}\", freeze possible", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{} is < 2 {{C}}. Freezing could occur.", cNumericFields(7)));
                ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(7)));
            }
        }

        if (!lAlphaBlanks(16)) {
            thisDXCoil.BasinHeaterSchedulePtr = GetScheduleIndex(state, Alphas(16));
            if (thisDXCoil.BasinHeaterSchedulePtr == 0) {
                ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(16), Alphas(16)));
                ShowContinueError(state, "Basin heater will be available to operate throughout the simulation.");
            }
        }

    } // end of the Multimode DX coil loop

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input.  Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }

    //************* Read Heat Pump (DX Heating Coil) Input **********
    CurrentModuleObject = "Coil:Heating:DX:SingleSpeed";
    for (DXCoilIndex = 1; DXCoilIndex <= state.dataDXCoils->NumDXHeatingCoils; ++DXCoilIndex) {

        ++DXCoilNum;

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXCoilIndex,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        // allocate single performance mode for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilDX_HeatingEmpirical;
        thisDXCoil.Schedule = Alphas(2);
        if (lAlphaBlanks(2)) {
            thisDXCoil.SchedPtr = ScheduleManager::ScheduleAlwaysOn;
        } else {
            thisDXCoil.SchedPtr = GetScheduleIndex(state, Alphas(2)); // convert schedule name to pointer
            if (thisDXCoil.SchedPtr == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{}=\"{}\".", cAlphaFields(2), Alphas(2)));
                ErrorsFound = true;
            }
        }

        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(3),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilHeatingDXSingleSpeed,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);

        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(4),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilHeatingDXSingleSpeed,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(3), Alphas(4), "Air Nodes");

        thisDXCoil.CCapFTemp(1) = GetCurveIndex(state, Alphas(5)); // convert curve name to number
        if (thisDXCoil.CCapFTemp(1) == 0) {
            if (lAlphaBlanks(5)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(5)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(5), Alphas(5)));
            }
            ErrorsFound = true;
        } else {
            // only legal types are Quadratic, BiQuadratic and Cubic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CCapFTemp(1), // Curve index
                                                 {1, 2},                  // Valid dimensions  // MULTIPLECURVEDIMS
                                                 RoutineName,             // Routine name
                                                 CurrentModuleObject,     // Object Type
                                                 thisDXCoil.Name,         // Object Name
                                                 cAlphaFields(5));        // Field Name

            if (!ErrorsFound) {
                if (state.dataCurveManager->PerfCurve(thisDXCoil.CCapFTemp(1))->numDims == 1) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.CCapFTemp(1),
                                                cAlphaFields(5),
                                                Alphas(5),
                                                RatedOutdoorAirTempHeat);
                } else {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.CCapFTemp(1),
                                                cAlphaFields(5),
                                                Alphas(5),
                                                RatedInletAirTempHeat,
                                                RatedOutdoorAirTempHeat);
                }
            }
        }

        thisDXCoil.CCapFFlow(1) = GetCurveIndex(state, Alphas(6)); // convert curve name to number
        if (thisDXCoil.CCapFFlow(1) == 0) {
            if (lAlphaBlanks(6)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(6)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(6), Alphas(6)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is Quadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CCapFFlow(1), // Curve index
                                                 {1},                     // Valid dimensions
                                                 RoutineName,             // Routine name
                                                 CurrentModuleObject,     // Object Type
                                                 thisDXCoil.Name,         // Object Name
                                                 cAlphaFields(6));        // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(
                    state, std::string{RoutineName} + CurrentModuleObject, thisDXCoil.Name, thisDXCoil.CCapFFlow(1), cAlphaFields(6), Alphas(6), 1.0);
            }
        }

        thisDXCoil.EIRFTemp(1) = GetCurveIndex(state, Alphas(7)); // convert curve name to number
        if (thisDXCoil.EIRFTemp(1) == 0) {
            if (lAlphaBlanks(7)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(7)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(7), Alphas(7)));
            }
            ErrorsFound = true;
        } else {
            // only legal types are Quadratic, BiQuadratic and Cubic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.EIRFTemp(1), // Curve index
                                                 {1, 2},                 // Valid dimensions  // MULTIPLECURVEDIMS
                                                 RoutineName,            // Routine name
                                                 CurrentModuleObject,    // Object Type
                                                 thisDXCoil.Name,        // Object Name
                                                 cAlphaFields(7));       // Field Name

            if (!ErrorsFound) {
                if (state.dataCurveManager->PerfCurve(thisDXCoil.EIRFTemp(1))->numDims == 1) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.EIRFTemp(1),
                                                cAlphaFields(7),
                                                Alphas(7),
                                                RatedOutdoorAirTempHeat);
                } else {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.EIRFTemp(1),
                                                cAlphaFields(7),
                                                Alphas(7),
                                                RatedInletAirTempHeat,
                                                RatedOutdoorAirTempHeat);
                }
            }
        }

        thisDXCoil.EIRFFlow(1) = GetCurveIndex(state, Alphas(8)); // convert curve name to number
        if (thisDXCoil.EIRFFlow(1) == 0) {
            if (lAlphaBlanks(8)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(8)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(8), Alphas(8)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is Quadratic or Cubic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.EIRFFlow(1), // Curve index
                                                 {1},                    // Valid dimensions
                                                 RoutineName,            // Routine name
                                                 CurrentModuleObject,    // Object Type
                                                 thisDXCoil.Name,        // Object Name
                                                 cAlphaFields(8));       // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(
                    state, std::string{RoutineName} + CurrentModuleObject, thisDXCoil.Name, thisDXCoil.EIRFFlow(1), cAlphaFields(8), Alphas(8), 1.0);
            }
        }

        thisDXCoil.PLFFPLR(1) = GetCurveIndex(state, Alphas(9)); // convert curve name to number
        if (thisDXCoil.PLFFPLR(1) == 0) {
            if (lAlphaBlanks(9)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(9)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(9), Alphas(9)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal types are Quadratic or Cubic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.PLFFPLR(1), // Curve index
                                                 {1},                   // Valid dimensions
                                                 RoutineName,           // Routine name
                                                 CurrentModuleObject,   // Object Type
                                                 thisDXCoil.Name,       // Object Name
                                                 cAlphaFields(9));      // Field Name

            if (!ErrorsFound) {
                //     Test PLF curve minimum and maximum. Cap if less than 0.7 or greater than 1.0.
                MinCurveVal = 999.0;
                MaxCurveVal = -999.0;
                CurveInput = 0.0;
                while (CurveInput <= 1.0) {
                    CurveVal = CurveValue(state, thisDXCoil.PLFFPLR(1), CurveInput);
                    if (CurveVal < MinCurveVal) {
                        MinCurveVal = CurveVal;
                        MinCurvePLR = CurveInput;
                    }
                    if (CurveVal > MaxCurveVal) {
                        MaxCurveVal = CurveVal;
                        MaxCurvePLR = CurveInput;
                    }
                    CurveInput += 0.01;
                }
                if (MinCurveVal < 0.7) {
                    ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields(9), Alphas(9)));
                    ShowContinueError(state,
                                      format("...Curve minimum must be >= 0.7, curve min at PLR = {:.2T} is {:.3T}", MinCurvePLR, MinCurveVal));
                    ShowContinueError(state, "...Setting curve minimum to 0.7 and simulation continues.");
                    Curve::SetCurveOutputMinValue(state, thisDXCoil.PLFFPLR(1), ErrorsFound, 0.7);
                }

                if (MaxCurveVal > 1.0) {
                    ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields(9), Alphas(9)));
                    ShowContinueError(state,
                                      format("...Curve maximum must be <= 1.0, curve max at PLR = {:.2T} is {:.3T}", MaxCurvePLR, MaxCurveVal));
                    ShowContinueError(state, "...Setting curve maximum to 1.0 and simulation continues.");
                    Curve::SetCurveOutputMaxValue(state, thisDXCoil.PLFFPLR(1), ErrorsFound, 1.0);
                }
            }
        }

        // Only required for reverse cycle heat pumps
        thisDXCoil.DefrostEIRFT = GetCurveIndex(state, Alphas(10)); // convert curve name to number
        // A11; \field Crankcase Heater Capacity Function of Outdoor Temperature Curve Name
        if (!lAlphaBlanks(11)) {
            thisDXCoil.CrankcaseHeaterCapacityCurveIndex = Curve::GetCurveIndex(state, Alphas(11));
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CrankcaseHeaterCapacityCurveIndex, // Curve index
                                                 {1},                                          // Valid dimensions
                                                 RoutineName,                                  // Routine name
                                                 CurrentModuleObject,                          // Object Type
                                                 thisDXCoil.Name,                              // Object Name
                                                 cAlphaFields(11));                            // Field Name
        }

        if (Util::SameString(Alphas(12), "ReverseCycle")) {

            if (thisDXCoil.DefrostEIRFT == 0) {
                if (lAlphaBlanks(10)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(10)));
                    ShowContinueError(state, format("...field is required because {} is \"ReverseCycle\".", cAlphaFields(12)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(10), Alphas(10)));
                }
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal type is BiQuadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.DefrostEIRFT, // Curve index
                                                     {2},                     // Valid dimensions
                                                     RoutineName,             // Routine name
                                                     CurrentModuleObject,     // Object Type
                                                     thisDXCoil.Name,         // Object Name
                                                     cAlphaFields(10));       // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.DefrostEIRFT,
                                                cAlphaFields(10),
                                                Alphas(10),
                                                RatedInletAirTempHeat,
                                                RatedOutdoorAirTempHeat);
                }
            }
        }

        if (Util::SameString(Alphas(12), "ReverseCycle")) thisDXCoil.DefrostStrategy = StandardRatings::DefrostStrat::ReverseCycle;
        if (Util::SameString(Alphas(12), "Resistive")) thisDXCoil.DefrostStrategy = StandardRatings::DefrostStrat::Resistive;

        if (thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::Invalid) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...illegal {}=\"{}\".", cAlphaFields(12), Alphas(12)));
            ShowContinueError(state, "...valid values for this field are ReverseCycle or Resistive.");
            ErrorsFound = true;
        }

        if (Util::SameString(Alphas(13), "Timed")) thisDXCoil.DefrostControl = StandardRatings::HPdefrostControl::Timed;
        if (Util::SameString(Alphas(13), "OnDemand")) thisDXCoil.DefrostControl = StandardRatings::HPdefrostControl::OnDemand;
        if (thisDXCoil.DefrostControl == StandardRatings::HPdefrostControl::Invalid) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...illegal {}=\"{}\".", cAlphaFields(13), Alphas(13)));
            ShowContinueError(state, "...valid values for this field are Timed or OnDemand.");
            ErrorsFound = true;
        }

        thisDXCoil.RatedSHR(1) = 1.0;
        thisDXCoil.RatedTotCap(1) = Numbers(1);
        thisDXCoil.RatedCOP(1) = Numbers(2);
        thisDXCoil.RatedAirVolFlowRate(1) = Numbers(3);
        thisDXCoil.FanPowerPerEvapAirFlowRate(1) = Numbers(4);
        thisDXCoil.FanPowerPerEvapAirFlowRate_2023(1) = Numbers(5);

        // Set minimum OAT for heat pump compressor operation
        thisDXCoil.MinOATCompressor = Numbers(6);

        thisDXCoil.OATempCompressorOn = Numbers(7);

        if (lNumericBlanks(7) || lNumericBlanks(6)) { //??TBD:BPS 6 or 5 | 7 or 6
            thisDXCoil.OATempCompressorOnOffBlank = true;
        } else {
            thisDXCoil.OATempCompressorOnOffBlank = false;
        }

        if (thisDXCoil.OATempCompressorOn < thisDXCoil.MinOATCompressor) thisDXCoil.OATempCompressorOn = thisDXCoil.MinOATCompressor;

        // Set maximum outdoor temp for defrost to occur
        thisDXCoil.MaxOATDefrost = Numbers(8);

        // Set crankcase heater capacity
        thisDXCoil.CrankcaseHeaterCapacity = Numbers(9);
        if (thisDXCoil.CrankcaseHeaterCapacity < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0.", cNumericFields(8)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(9)));
            ErrorsFound = true;
        }

        // Set crankcase heater cutout temperature
        thisDXCoil.MaxOATCrankcaseHeater = Numbers(10);

        // Set defrost time period
        thisDXCoil.DefrostTime = Numbers(11);
        if (thisDXCoil.DefrostTime == 0.0 && thisDXCoil.DefrostControl == StandardRatings::HPdefrostControl::Timed) {
            ShowWarningError(state, format("{}{}=\"{}\", ", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} = 0.0 for defrost control = TIMED.", cNumericFields(11)));
        }

        // Set defrost capacity (for resistive defrost)
        thisDXCoil.DefrostCapacity = Numbers(12);
        if (thisDXCoil.DefrostCapacity == 0.0 && thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::Resistive) {
            ShowWarningError(state, format("{}{}=\"{}\", ", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} = 0.0 for defrost strategy = RESISTIVE.", cNumericFields(12)));
        }

        // Set Region number for calculating HSPF
        thisDXCoil.RegionNum = Numbers(13);

        if (lNumericBlanks(13)) {
            thisDXCoil.RegionNum = 4;
        }

        thisDXCoil.RatedEIR(1) = 1.0 / thisDXCoil.RatedCOP(1);

        // A14 is optional evaporator node name
        if (lAlphaBlanks(14)) {
            thisDXCoil.CondenserInletNodeNum(1) = 0;
        } else {
            thisDXCoil.CondenserInletNodeNum(1) = GetOnlySingleNode(state,
                                                                    Alphas(14),
                                                                    ErrorsFound,
                                                                    DataLoopNode::ConnectionObjectType::CoilHeatingDXSingleSpeed,
                                                                    thisDXCoil.Name,
                                                                    DataLoopNode::NodeFluidType::Air,
                                                                    DataLoopNode::ConnectionType::OutsideAirReference,
                                                                    NodeInputManager::CompFluidStream::Primary,
                                                                    ObjectIsNotParent);
            // warn if not an outdoor node, but allow
            if (!CheckOutAirNodeNumber(state, thisDXCoil.CondenserInletNodeNum(1))) {
                ShowWarningError(state, format("{}{}=\"{}\", may be invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(
                    state,
                    format("{}=\"{}\", node does not appear in an OutdoorAir:NodeList or as an OutdoorAir:Node.", cAlphaFields(14), Alphas(14)));
                ShowContinueError(
                    state, "This node needs to be included in an air system or the coil model will not be valid, and the simulation continues");
            }
        }

        // A14, \field Zone Name for Evaporator Placement
        if (!lAlphaBlanks(15) && NumAlphas > 14) {
            thisDXCoil.SecZonePtr = Util::FindItemInList(Alphas(15), state.dataHeatBal->Zone);
            if (thisDXCoil.SecZonePtr > 0) {
                SetupZoneInternalGain(state,
                                      thisDXCoil.SecZonePtr,
                                      thisDXCoil.Name,
                                      DataHeatBalance::IntGainType::SecHeatingDXCoilSingleSpeed,
                                      &thisDXCoil.SecCoilSensibleHeatRemovalRate,
                                      nullptr,
                                      nullptr,
                                      &thisDXCoil.SecCoilLatentHeatRemovalRate);
                thisDXCoil.IsSecondaryDXCoilInZone = true;
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(15), Alphas(15)));
            }
        }
        if (thisDXCoil.SecZonePtr > 0) {
            // N14, \field Secondary Coil Air Flow Rate
            if (!lNumericBlanks(13)) {
                thisDXCoil.SecCoilAirFlow = Numbers(14);
            }
            // N15, \field Secondary Coil Fan Flow Scaling Factor
            if (!lNumericBlanks(15)) {
                thisDXCoil.SecCoilAirFlowScalingFactor = Numbers(15);
            }
            // N16, \field Nominal Sensible Heat Ratio of Secondary Coil
            if (!lNumericBlanks(16)) {
                thisDXCoil.SecCoilRatedSHR = Numbers(16);
            } else {
                thisDXCoil.SecCoilRatedSHR = 1.0;
            }
            // A16, \field Sensible Heat Ratio Modifier Function of Temperature Curve Name
            if (!lAlphaBlanks(16)) {
                thisDXCoil.SecCoilSHRFT = GetCurveIndex(state, Alphas(16));
                if (thisDXCoil.SecCoilSHRFT == 0) {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(16), Alphas(16)));
                }
            }
            // A17; \field Sensible Heat Ratio Function of Flow Fraction Curve Name
            if (!lAlphaBlanks(17)) {
                thisDXCoil.SecCoilSHRFF = GetCurveIndex(state, Alphas(17));
                if (thisDXCoil.SecCoilSHRFF == 0) {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(17), Alphas(17)));
                }
            }
        }

    } // end of the DX heating coil loop

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input. Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }

    CurrentModuleObject = "Coil:Cooling:DX:TwoSpeed";
    for (DXCoilIndex = 1; DXCoilIndex <= state.dataDXCoils->NumDXMulSpeedCoils; ++DXCoilIndex) {

        ++DXCoilNum;

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXCoilIndex,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        // allocate single performance mode for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        // Initialize DataHeatBalance heat reclaim variable name for use by heat reclaim coils
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).Name = thisDXCoil.Name;
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).SourceType = CurrentModuleObject;
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilDX_CoolingTwoSpeed;
        thisDXCoil.Schedule = Alphas(2);
        if (lAlphaBlanks(2)) {
            thisDXCoil.SchedPtr = ScheduleManager::ScheduleAlwaysOn;
        } else {
            thisDXCoil.SchedPtr = GetScheduleIndex(state, Alphas(2)); // convert schedule name to pointer
            if (thisDXCoil.SchedPtr == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{}=\"{}\".", cAlphaFields(2), Alphas(2)));
                ErrorsFound = true;
            }
        }
        thisDXCoil.RatedTotCap(1) = Numbers(1);
        thisDXCoil.RatedSHR(1) = Numbers(2);
        thisDXCoil.RatedCOP(1) = Numbers(3);
        thisDXCoil.RatedAirVolFlowRate(1) = Numbers(4);

        thisDXCoil.FanPowerPerEvapAirFlowRate(1) = Numbers(5);
        thisDXCoil.FanPowerPerEvapAirFlowRate_2023(1) = Numbers(6);

        if (!lNumericBlanks(7)) {
            thisDXCoil.InternalStaticPressureDrop = Numbers(7);
            thisDXCoil.RateWithInternalStaticAndFanObject = true;
        } else {
            thisDXCoil.InternalStaticPressureDrop = -999.0;
            thisDXCoil.RateWithInternalStaticAndFanObject = false;
        }

        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(3),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilCoolingDXTwoSpeed,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);

        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(4),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilCoolingDXTwoSpeed,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(3), Alphas(4), "Air Nodes");

        thisDXCoil.CCapFTemp(1) = GetCurveIndex(state, Alphas(5)); // convert curve name to number
        if (thisDXCoil.CCapFTemp(1) == 0) {
            if (lAlphaBlanks(5)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(5)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(5), Alphas(5)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is BiQuadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CCapFTemp(1), // Curve index
                                                 {2},                     // Valid dimensions
                                                 RoutineName,             // Routine name
                                                 CurrentModuleObject,     // Object Type
                                                 thisDXCoil.Name,         // Object Name
                                                 cAlphaFields(5));        // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(state,
                                            std::string{RoutineName} + CurrentModuleObject,
                                            thisDXCoil.Name,
                                            thisDXCoil.CCapFTemp(1),
                                            cAlphaFields(5),
                                            Alphas(5),
                                            RatedInletWetBulbTemp,
                                            RatedOutdoorAirTemp);
            }
        }

        thisDXCoil.CCapFFlow(1) = GetCurveIndex(state, Alphas(6)); // convert curve name to number
        if (thisDXCoil.CCapFFlow(1) == 0) {
            if (lAlphaBlanks(6)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(6)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(6), Alphas(6)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is Quadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CCapFFlow(1), // Curve index
                                                 {1},                     // Valid dimensions
                                                 RoutineName,             // Routine name
                                                 CurrentModuleObject,     // Object Type
                                                 thisDXCoil.Name,         // Object Name
                                                 cAlphaFields(6));        // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(
                    state, std::string{RoutineName} + CurrentModuleObject, thisDXCoil.Name, thisDXCoil.CCapFFlow(1), cAlphaFields(6), Alphas(6), 1.0);
            }
        }

        thisDXCoil.EIRFTemp(1) = GetCurveIndex(state, Alphas(7)); // convert curve name to number
        if (thisDXCoil.EIRFTemp(1) == 0) {
            if (lAlphaBlanks(7)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(7)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(7), Alphas(7)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is BiQuadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.EIRFTemp(1), // Curve index
                                                 {2},                    // Valid dimensions
                                                 RoutineName,            // Routine name
                                                 CurrentModuleObject,    // Object Type
                                                 thisDXCoil.Name,        // Object Name
                                                 cAlphaFields(7));       // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(state,
                                            std::string{RoutineName} + CurrentModuleObject,
                                            thisDXCoil.Name,
                                            thisDXCoil.EIRFTemp(1),
                                            cAlphaFields(7),
                                            Alphas(7),
                                            RatedInletWetBulbTemp,
                                            RatedOutdoorAirTemp);
            }
        }

        thisDXCoil.EIRFFlow(1) = GetCurveIndex(state, Alphas(8)); // convert curve name to number
        if (thisDXCoil.EIRFFlow(1) == 0) {
            if (lAlphaBlanks(8)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(8)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(8), Alphas(8)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is Quadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.EIRFFlow(1), // Curve index
                                                 {1},                    // Valid dimensions
                                                 RoutineName,            // Routine name
                                                 CurrentModuleObject,    // Object Type
                                                 thisDXCoil.Name,        // Object Name
                                                 cAlphaFields(8));       // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(
                    state, std::string{RoutineName} + CurrentModuleObject, thisDXCoil.Name, thisDXCoil.EIRFFlow(1), cAlphaFields(8), Alphas(8), 1.0);
            }
        }

        thisDXCoil.PLFFPLR(1) = GetCurveIndex(state, Alphas(9)); // convert curve name to number
        if (thisDXCoil.PLFFPLR(1) == 0) {
            if (lAlphaBlanks(9)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(9)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(9), Alphas(9)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal types are Quadratic or Cubic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.PLFFPLR(1), // Curve index
                                                 {1},                   // Valid dimensions
                                                 RoutineName,           // Routine name
                                                 CurrentModuleObject,   // Object Type
                                                 thisDXCoil.Name,       // Object Name
                                                 cAlphaFields(9));      // Field Name

            if (!ErrorsFound) {
                //     Test PLF curve minimum and maximum. Cap if less than 0.7 or greater than 1.0.
                MinCurveVal = 999.0;
                MaxCurveVal = -999.0;
                CurveInput = 0.0;
                while (CurveInput <= 1.0) {
                    CurveVal = CurveValue(state, thisDXCoil.PLFFPLR(1), CurveInput);
                    if (CurveVal < MinCurveVal) {
                        MinCurveVal = CurveVal;
                        MinCurvePLR = CurveInput;
                    }
                    if (CurveVal > MaxCurveVal) {
                        MaxCurveVal = CurveVal;
                        MaxCurvePLR = CurveInput;
                    }
                    CurveInput += 0.01;
                }
                if (MinCurveVal < 0.7) {
                    ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields(9), Alphas(9)));
                    ShowContinueError(state,
                                      format("...Curve minimum must be >= 0.7, curve min at PLR = {:.2T} is {:.3T}", MinCurvePLR, MinCurveVal));
                    ShowContinueError(state, "...Setting curve minimum to 0.7 and simulation continues.");
                    Curve::SetCurveOutputMinValue(state, thisDXCoil.PLFFPLR(1), ErrorsFound, 0.7);
                }

                if (MaxCurveVal > 1.0) {
                    ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields(9), Alphas(9)));
                    ShowContinueError(state,
                                      format("...Curve maximum must be <= 1.0, curve max at PLR = {:.2T} is {:.3T}", MaxCurvePLR, MaxCurveVal));
                    ShowContinueError(state, "...Setting curve maximum to 1.0 and simulation continues.");
                    Curve::SetCurveOutputMaxValue(state, thisDXCoil.PLFFPLR(1), ErrorsFound, 1.0);
                }
            }
        }

        thisDXCoil.RatedEIR(1) = 1.0 / thisDXCoil.RatedCOP(1);

        thisDXCoil.RatedTotCap2 = Numbers(8);
        thisDXCoil.RatedSHR2 = Numbers(9);
        thisDXCoil.RatedCOP2 = Numbers(10);
        thisDXCoil.RatedAirVolFlowRate2 = Numbers(11);

        thisDXCoil.FanPowerPerEvapAirFlowRate_LowSpeed(1) = Numbers(12);
        thisDXCoil.FanPowerPerEvapAirFlowRate_2023_LowSpeed(1) = Numbers(13);

        if (lNumericBlanks(14)) {
            thisDXCoil.MinOATCompressor = -25.0;
        } else {
            thisDXCoil.MinOATCompressor = Numbers(14);
        }

        thisDXCoil.CCapFTemp2 = GetCurveIndex(state, Alphas(10)); // convert curve name to number
        if (thisDXCoil.CCapFTemp2 == 0) {
            if (lAlphaBlanks(10)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(10)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(10), Alphas(10)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is BiQuadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CCapFTemp2, // Curve index
                                                 {2},                   // Valid dimensions
                                                 RoutineName,           // Routine name
                                                 CurrentModuleObject,   // Object Type
                                                 thisDXCoil.Name,       // Object Name
                                                 cAlphaFields(10));     // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(state,
                                            std::string{RoutineName} + CurrentModuleObject,
                                            thisDXCoil.Name,
                                            thisDXCoil.CCapFTemp2,
                                            cAlphaFields(10),
                                            Alphas(10),
                                            RatedInletWetBulbTemp,
                                            RatedOutdoorAirTemp);
            }
        }

        thisDXCoil.EIRFTemp2 = GetCurveIndex(state, Alphas(11)); // convert curve name to number
        if (thisDXCoil.EIRFTemp2 == 0) {
            if (lAlphaBlanks(11)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(11)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(11), Alphas(11)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is BiQuadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.EIRFTemp2, // Curve index
                                                 {2},                  // Valid dimensions
                                                 RoutineName,          // Routine name
                                                 CurrentModuleObject,  // Object Type
                                                 thisDXCoil.Name,      // Object Name
                                                 cAlphaFields(11));    // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(state,
                                            std::string{RoutineName} + CurrentModuleObject,
                                            thisDXCoil.Name,
                                            thisDXCoil.EIRFTemp2,
                                            cAlphaFields(11),
                                            Alphas(11),
                                            RatedInletWetBulbTemp,
                                            RatedOutdoorAirTemp);
            }
        }

        // outdoor condenser node
        if (lAlphaBlanks(12)) {
            thisDXCoil.CondenserInletNodeNum(1) = 0;
        } else {
            thisDXCoil.CondenserInletNodeNum(1) = GetOnlySingleNode(state,
                                                                    Alphas(12),
                                                                    ErrorsFound,
                                                                    DataLoopNode::ConnectionObjectType::CoilCoolingDXTwoSpeed,
                                                                    thisDXCoil.Name,
                                                                    DataLoopNode::NodeFluidType::Air,
                                                                    DataLoopNode::ConnectionType::OutsideAirReference,
                                                                    NodeInputManager::CompFluidStream::Primary,
                                                                    ObjectIsNotParent);
            if (!CheckOutAirNodeNumber(state, thisDXCoil.CondenserInletNodeNum(1))) {
                ShowWarningError(state, format("{}{}=\"{}\", may be invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(
                    state,
                    format("{}=\"{}\", node does not appear in an OutdoorAir:NodeList or as an OutdoorAir:Node.", cAlphaFields(12), Alphas(12)));
                ShowContinueError(
                    state, "This node needs to be included in an air system or the coil model will not be valid, and the simulation continues");
            }
        }

        if ((Util::SameString(Alphas(13), "AirCooled")) || lAlphaBlanks(13)) {
            thisDXCoil.CondenserType(1) = DataHeatBalance::RefrigCondenserType::Air;
        } else if (Util::SameString(Alphas(13), "EvaporativelyCooled")) {
            thisDXCoil.CondenserType(1) = DataHeatBalance::RefrigCondenserType::Evap;
            thisDXCoil.ReportEvapCondVars = true;
        } else {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{}=\"{}\":", cAlphaFields(13), Alphas(13)));
            ShowContinueError(state, "...must be AirCooled or EvaporativelyCooled.");
            ErrorsFound = true;
        }

        thisDXCoil.EvapCondEffect(1) = Numbers(15);
        if (thisDXCoil.EvapCondEffect(1) < 0.0 || thisDXCoil.EvapCondEffect(1) > 1.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0 or > 1.0.", cNumericFields(15)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(15)));
            ErrorsFound = true;
        }

        thisDXCoil.EvapCondAirFlow(1) = Numbers(16);
        if (thisDXCoil.EvapCondAirFlow(1) < 0.0 && thisDXCoil.EvapCondAirFlow(1) != AutoSize) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0.", cNumericFields(16)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(16)));
            ErrorsFound = true;
        }

        thisDXCoil.EvapCondPumpElecNomPower(1) = Numbers(17);
        if (thisDXCoil.EvapCondPumpElecNomPower(1) < 0.0 && thisDXCoil.EvapCondPumpElecNomPower(1) != AutoSize) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0.", cNumericFields(17)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(17)));
            ErrorsFound = true;
        }

        thisDXCoil.EvapCondEffect2 = Numbers(18);
        if (thisDXCoil.EvapCondEffect2 < 0.0 || thisDXCoil.EvapCondEffect2 > 1.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be cannot be < 0.0 or > 1.0.", cNumericFields(18)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(18)));
            ErrorsFound = true;
        }

        thisDXCoil.EvapCondAirFlow2 = Numbers(19);
        if (thisDXCoil.EvapCondAirFlow2 < 0.0 && thisDXCoil.EvapCondAirFlow2 != AutoSize) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0.", cNumericFields(19)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(19)));
            ErrorsFound = true;
        }

        thisDXCoil.EvapCondPumpElecNomPower2 = Numbers(20);
        if (thisDXCoil.EvapCondPumpElecNomPower2 < 0.0 && thisDXCoil.EvapCondPumpElecNomPower2 != AutoSize) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0.", cNumericFields(20)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(20)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedEIR2 = 1.0 / thisDXCoil.RatedCOP2;

        // Get Water System tank connections
        //  A14, \field Name of Water Storage Tank for Supply
        thisDXCoil.EvapWaterSupplyName = Alphas(14);
        if (lAlphaBlanks(14)) {
            thisDXCoil.EvapWaterSupplyMode = EvapWaterSupply::FromMains;
        } else {
            thisDXCoil.EvapWaterSupplyMode = EvapWaterSupply::FromTank;
            SetupTankDemandComponent(state,
                                     thisDXCoil.Name,
                                     CurrentModuleObject,
                                     thisDXCoil.EvapWaterSupplyName,
                                     ErrorsFound,
                                     thisDXCoil.EvapWaterSupTankID,
                                     thisDXCoil.EvapWaterTankDemandARRID);
        }

        // A15; \field Name of Water Storage Tank for Condensate Collection
        thisDXCoil.CondensateCollectName = Alphas(15);
        if (lAlphaBlanks(15)) {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::Discard;
        } else {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::ToTank;
            SetupTankSupplyComponent(state,
                                     thisDXCoil.Name,
                                     CurrentModuleObject,
                                     thisDXCoil.CondensateCollectName,
                                     ErrorsFound,
                                     thisDXCoil.CondensateTankID,
                                     thisDXCoil.CondensateTankSupplyARRID);
        }

        // Basin heater power as a function of temperature must be greater than or equal to 0
        thisDXCoil.BasinHeaterPowerFTempDiff = Numbers(21);
        if (Numbers(21) < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0.0.", cNumericFields(21)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(21)));
            ErrorsFound = true;
        }

        thisDXCoil.BasinHeaterSetPointTemp = Numbers(22);
        if (thisDXCoil.BasinHeaterPowerFTempDiff > 0.0) {
            if (NumNumbers < 22) {
                thisDXCoil.BasinHeaterSetPointTemp = 2.0;
            }
            if (thisDXCoil.BasinHeaterSetPointTemp < 2.0) {
                ShowWarningError(state, format("{}{}=\"{}\", freeze possible", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{} is < 2 {{C}}. Freezing could occur.", cNumericFields(22)));
                ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(22)));
            }
        }

        if (!lAlphaBlanks(16)) {
            thisDXCoil.BasinHeaterSchedulePtr = GetScheduleIndex(state, Alphas(16));
            if (thisDXCoil.BasinHeaterSchedulePtr == 0) {
                ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(16), Alphas(16)));
                ShowContinueError(state, "Basin heater will be available to operate throughout the simulation.");
            }
        }

        if (!lAlphaBlanks(17) && NumAlphas > 16) {
            thisDXCoil.SHRFTemp(1) = GetCurveIndex(state, Alphas(17)); // convert curve name to number
            // DXCoil(DXCoilNum)%SHRFTemp2 = DXCoil(DXCoilNum)%SHRFTemp(1)
            if (thisDXCoil.SHRFTemp(1) == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(17), Alphas(17)));
            } else {
                // Verify Curve Object, only legal type is BiQuadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.SHRFTemp(1), // Curve index
                                                     {2},                    // Valid dimensions
                                                     RoutineName,            // Routine name
                                                     CurrentModuleObject,    // Object Type
                                                     thisDXCoil.Name,        // Object Name
                                                     cAlphaFields(17));      // Field Name
            }
        }

        if (!lAlphaBlanks(18) && NumAlphas > 17) {
            thisDXCoil.SHRFFlow(1) = GetCurveIndex(state, Alphas(18)); // convert curve name to number
            // DXCoil(DXCoilNum)%SHRFFlow2 = DXCoil(DXCoilNum)%SHRFFlow(1)
            if (thisDXCoil.SHRFFlow(1) == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(18), Alphas(18)));
            } else {
                // Verify Curve Object, only legal type is BiQuadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.SHRFFlow(1), // Curve index
                                                     {1},                    // Valid dimensions
                                                     RoutineName,            // Routine name
                                                     CurrentModuleObject,    // Object Type
                                                     thisDXCoil.Name,        // Object Name
                                                     cAlphaFields(18));      // Field Name
            }
        }

        if (!lAlphaBlanks(19) && NumAlphas > 18) {
            thisDXCoil.SHRFTemp2 = GetCurveIndex(state, Alphas(19)); // convert curve name to number
            if (thisDXCoil.SHRFTemp2 == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(19), Alphas(19)));
            } else {
                // Verify Curve Object, only legal type is BiQuadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.SHRFTemp2, // Curve index
                                                     {2},                  // Valid dimensions
                                                     RoutineName,          // Routine name
                                                     CurrentModuleObject,  // Object Type
                                                     thisDXCoil.Name,      // Object Name
                                                     cAlphaFields(19));    // Field Name
            }
        }

        if (!lAlphaBlanks(20) && NumAlphas > 19) {
            thisDXCoil.SHRFFlow2 = GetCurveIndex(state, Alphas(20)); // convert curve name to number
            if (thisDXCoil.SHRFTemp2 == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(20), Alphas(20)));
            } else {
                // Verify Curve Object, only legal type is BiQuadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.SHRFFlow2, // Curve index
                                                     {1},                  // Valid dimensions
                                                     RoutineName,          // Routine name
                                                     CurrentModuleObject,  // Object Type
                                                     thisDXCoil.Name,      // Object Name
                                                     cAlphaFields(20));    // Field Name
            }
        }
        if (thisDXCoil.SHRFTemp(1) > 0 && thisDXCoil.SHRFFlow(1) > 0 && thisDXCoil.SHRFTemp2 > 0 && thisDXCoil.SHRFFlow2 > 0) {
            thisDXCoil.UserSHRCurveExists = true;
        } else {
            thisDXCoil.UserSHRCurveExists = false;
        }
        // A21; \field Zone Name for Condenser Placement
        if (!lAlphaBlanks(21) && NumAlphas > 20) {
            thisDXCoil.SecZonePtr = Util::FindItemInList(Alphas(21), state.dataHeatBal->Zone);
            if (thisDXCoil.SecZonePtr > 0) {
                SetupZoneInternalGain(state,
                                      thisDXCoil.SecZonePtr,
                                      thisDXCoil.Name,
                                      DataHeatBalance::IntGainType::SecCoolingDXCoilTwoSpeed,
                                      &thisDXCoil.SecCoilSensibleHeatGainRate);
                thisDXCoil.IsSecondaryDXCoilInZone = true;
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(21), Alphas(21)));
            }
        }
    }

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input.  Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }

    // Loop over the Pumped DX Water Heater Coils and get & load the data
    CurrentModuleObject = HVAC::cAllCoilTypes(HVAC::CoilDX_HeatPumpWaterHeaterPumped);
    for (DXHPWaterHeaterCoilNum = 1; DXHPWaterHeaterCoilNum <= state.dataDXCoils->NumDXHeatPumpWaterHeaterPumpedCoils; ++DXHPWaterHeaterCoilNum) {

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXHPWaterHeaterCoilNum,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        ++DXCoilNum;

        // allocate single performance mode for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilDX_HeatPumpWaterHeaterPumped;
        thisDXCoil.SchedPtr = 0; // heat pump water heater DX coil has no schedule

        // Store the HPWH DX coil heating capacity in RatedTotCap2. After backing off pump and fan heat,
        // move to RatedTotCap() for use by DX coil
        thisDXCoil.RatedTotCap2 = Numbers(1);
        if (thisDXCoil.RatedTotCap2 <= 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 0.0, entered value=[{:.2T}].", cNumericFields(1), Numbers(1)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedCOP(1) = Numbers(2);
        if (thisDXCoil.RatedCOP(1) <= 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 0.0, entered value=[{:.2T}].", cNumericFields(2), Numbers(2)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedSHR(1) = Numbers(3);
        if (thisDXCoil.RatedSHR(1) <= 0.0 || thisDXCoil.RatedSHR(1) > 1.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 0 and <= 1.  entered value=[{:.3T}].", cNumericFields(3), Numbers(3)));

            ErrorsFound = true;
        }

        thisDXCoil.RatedInletDBTemp = Numbers(4);
        if (thisDXCoil.RatedInletDBTemp <= 5.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 5 {{C}}.  entered value=[{:.1T}].", cNumericFields(4), Numbers(4)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedInletWBTemp = Numbers(5);
        if (thisDXCoil.RatedInletWBTemp <= 5.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 5 {{C}}.  entered value=[{:.1T}].", cNumericFields(5), Numbers(5)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedInletWaterTemp = Numbers(6);
        if (thisDXCoil.RatedInletWaterTemp <= 25.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 25 {{C}}.  entered value=[{:.1T}].", cNumericFields(6), Numbers(6)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedAirVolFlowRate(1) = Numbers(7);
        if (thisDXCoil.RatedAirVolFlowRate(1) != Constant::AutoCalculate) {
            if (thisDXCoil.RatedAirVolFlowRate(1) <= 0.0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{} must be > 0.0.  entered value=[{:.3T}].", cNumericFields(7), Numbers(7)));
                ErrorsFound = true;
            }
        }

        thisDXCoil.RatedHPWHCondWaterFlow = Numbers(8);
        // move to init
        if (thisDXCoil.RatedHPWHCondWaterFlow != Constant::AutoCalculate) {
            if (thisDXCoil.RatedHPWHCondWaterFlow <= 0.0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{} must be > 0.0  entered value=[{:.3T}].", cNumericFields(8), Numbers(8)));
                ErrorsFound = true;
            }
            //   check the range of flow rate to be >= 1 gpm/ton and <= 5 gpm/ton
            if (thisDXCoil.RatedHPWHCondWaterFlow / thisDXCoil.RatedTotCap2 < 1.79405e-8 ||
                thisDXCoil.RatedHPWHCondWaterFlow / thisDXCoil.RatedTotCap2 > 8.97024e-8) {
                ShowWarningError(state, format("{}{}=\"{}\", outside range", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state,
                                  format("...{} per watt of {} is outside the recommended range of >= 1.79405E-8 m3/s/W (0.083 gpm/MBH) and <= "
                                         "8.97024E-8 m3/s/W (0.417 gpm/MBH).",
                                         cNumericFields(8),
                                         cNumericFields(1)));
                ShowContinueError(
                    state, format("...Entered Flow rate per watt = [{:.10T}].", (thisDXCoil.RatedHPWHCondWaterFlow / thisDXCoil.RatedTotCap2)));
            }
        }

        if (Util::SameString(Alphas(2), "Yes") || Util::SameString(Alphas(2), "No")) {
            //  initialized to TRUE on allocate
            if (Util::SameString(Alphas(2), "No")) thisDXCoil.FanPowerIncludedInCOP = false;
        } else {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format(",,,invalid choice for {}.  Entered choice = {}", cAlphaFields(2), Alphas(2)));
            ShowContinueError(state, "Valid choices are Yes or No.");
            ErrorsFound = true;
        }

        if (Util::SameString(Alphas(3), "Yes") || Util::SameString(Alphas(3), "No")) {
            //  initialized to FALSE on allocate
            if (Util::SameString(Alphas(3), "Yes")) thisDXCoil.CondPumpPowerInCOP = true;
        } else {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format(",,,invalid choice for {}.  Entered choice = {}", cAlphaFields(3), Alphas(3)));
            ShowContinueError(state, "Valid choices are Yes or No.");
            ErrorsFound = true;
        }

        if (Util::SameString(Alphas(4), "Yes") || Util::SameString(Alphas(4), "No")) {
            //  initialized to FALSE on allocate
            if (Util::SameString(Alphas(4), "Yes")) thisDXCoil.CondPumpHeatInCapacity = true;
        } else {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format(",,,invalid choice for {}.  Entered choice = {}", cAlphaFields(4), Alphas(4)));
            ShowContinueError(state, "Valid choices are Yes or No.");
            ErrorsFound = true;
        }

        thisDXCoil.HPWHCondPumpElecNomPower = Numbers(9);
        if (thisDXCoil.HPWHCondPumpElecNomPower < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0.0  entered value=[{:.3T}].", cNumericFields(9), Numbers(9)));
            ErrorsFound = true;
        }

        thisDXCoil.HPWHCondPumpFracToWater = Numbers(10);
        if (thisDXCoil.HPWHCondPumpFracToWater <= 0.0 || thisDXCoil.HPWHCondPumpFracToWater > 1.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0 and <= 1.  entered value=[{:.3T}].", cNumericFields(10), Numbers(10)));
            ErrorsFound = true;
        }

        // Air nodes
        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(5),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilWaterHeatingAirToWaterHeatPumpPumped,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);

        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(6),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilWaterHeatingAirToWaterHeatPumpPumped,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(5), Alphas(6), "Air Nodes");

        // Check if the air inlet node is OA node, to justify whether the coil is placed in zone or not
        thisDXCoil.IsDXCoilInZone = !CheckOutAirNodeNumber(state, thisDXCoil.AirInNode);

        // Water nodes
        thisDXCoil.WaterInNode = GetOnlySingleNode(state,
                                                   Alphas(7),
                                                   ErrorsFound,
                                                   DataLoopNode::ConnectionObjectType::CoilWaterHeatingAirToWaterHeatPumpPumped,
                                                   Alphas(1),
                                                   DataLoopNode::NodeFluidType::Water,
                                                   DataLoopNode::ConnectionType::Inlet,
                                                   NodeInputManager::CompFluidStream::Secondary,
                                                   ObjectIsNotParent);

        thisDXCoil.WaterOutNode = GetOnlySingleNode(state,
                                                    Alphas(8),
                                                    ErrorsFound,
                                                    DataLoopNode::ConnectionObjectType::CoilWaterHeatingAirToWaterHeatPumpPumped,
                                                    Alphas(1),
                                                    DataLoopNode::NodeFluidType::Water,
                                                    DataLoopNode::ConnectionType::Outlet,
                                                    NodeInputManager::CompFluidStream::Secondary,
                                                    ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(7), Alphas(8), "Water Nodes");

        thisDXCoil.CrankcaseHeaterCapacity = Numbers(11);
        if (thisDXCoil.CrankcaseHeaterCapacity < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0.0  entered value=[{:.1T}].", cNumericFields(11), Numbers(11)));
            ErrorsFound = true;
        }

        thisDXCoil.MaxOATCrankcaseHeater = Numbers(12);
        if (thisDXCoil.MaxOATCrankcaseHeater < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0 {{C}}.  entered value=[{:.1T}].", cNumericFields(12), Numbers(12)));
            ErrorsFound = true;
        }

        if (!lAlphaBlanks(9)) {
            thisDXCoil.CrankcaseHeaterCapacityCurveIndex = Curve::GetCurveIndex(state, Alphas(9));
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CrankcaseHeaterCapacityCurveIndex, // Curve index
                                                 {1},                                          // Valid dimensions
                                                 RoutineName,                                  // Routine name
                                                 CurrentModuleObject,                          // Object Type
                                                 thisDXCoil.Name,                              // Object Name
                                                 cAlphaFields(9));                             // Field Name
        }

        thisDXCoil.InletAirTemperatureType = static_cast<HVAC::OATType>(getEnumValue(HVAC::oatTypeNamesUC, Alphas(10)));

        // set rated inlet air temperature for curve object verification
        if (thisDXCoil.InletAirTemperatureType == HVAC::OATType::WetBulb) {
            InletAirTemp = thisDXCoil.RatedInletWBTemp;
        } else {
            InletAirTemp = thisDXCoil.RatedInletDBTemp;
        }
        // set rated water temperature for curve object verification
        InletWaterTemp = thisDXCoil.RatedInletWaterTemp;

        if (!lAlphaBlanks(11)) {
            thisDXCoil.HCapFTemp = GetCurveIndex(state, Alphas(11));
            if (thisDXCoil.HCapFTemp == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(11), Alphas(11)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are BiQuadratic or Cubic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.HCapFTemp, // Curve index
                                                     {1, 2},               // Valid dimensions  // MULTIPLECURVEDIMS
                                                     RoutineName,          // Routine name
                                                     CurrentModuleObject,  // Object Type
                                                     thisDXCoil.Name,      // Object Name
                                                     cAlphaFields(11));    // Field Name

                if (!ErrorsFound) {
                    if (state.dataCurveManager->PerfCurve(thisDXCoil.HCapFTemp)->numDims == 1) {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.HCapFTemp,
                                                    cAlphaFields(11),
                                                    Alphas(11),
                                                    InletAirTemp);
                    } else {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.HCapFTemp,
                                                    cAlphaFields(11),
                                                    Alphas(11),
                                                    InletAirTemp,
                                                    InletWaterTemp);
                    }
                }
            }
        }

        if (!lAlphaBlanks(12)) {
            thisDXCoil.HCapFAirFlow = GetCurveIndex(state, Alphas(12));
            if (thisDXCoil.HCapFAirFlow == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(12), Alphas(12)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are Cubic or Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.HCapFAirFlow, // Curve index
                                                     {1},                     // Valid dimensions
                                                     RoutineName,             // Routine name
                                                     CurrentModuleObject,     // Object Type
                                                     thisDXCoil.Name,         // Object Name
                                                     cAlphaFields(12));       // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.HCapFAirFlow,
                                                cAlphaFields(12),
                                                Alphas(12),
                                                1.0);
                }
            }
        }

        if (!lAlphaBlanks(13)) {
            thisDXCoil.HCapFWaterFlow = GetCurveIndex(state, Alphas(13));
            if (thisDXCoil.HCapFWaterFlow == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(13), Alphas(13)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are Cubic or Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.HCapFWaterFlow, // Curve index
                                                     {1},                       // Valid dimensions
                                                     RoutineName,               // Routine name
                                                     CurrentModuleObject,       // Object Type
                                                     thisDXCoil.Name,           // Object Name
                                                     cAlphaFields(13));         // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.HCapFWaterFlow,
                                                cAlphaFields(13),
                                                Alphas(13),
                                                1.0);
                }
            }
        }

        if (!lAlphaBlanks(14)) {
            thisDXCoil.HCOPFTemp = GetCurveIndex(state, Alphas(14));
            if (thisDXCoil.HCOPFTemp == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(14), Alphas(14)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are BiQuadratic or Cubic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.HCOPFTemp, // Curve index
                                                     {1, 2},               // Valid dimensions  // MULTIPLECURVEDIMS
                                                     RoutineName,          // Routine name
                                                     CurrentModuleObject,  // Object Type
                                                     thisDXCoil.Name,      // Object Name
                                                     cAlphaFields(14));    // Field Name

                if (!ErrorsFound) {
                    if (state.dataCurveManager->PerfCurve(thisDXCoil.HCOPFTemp)->numDims == 1) {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.HCOPFTemp,
                                                    cAlphaFields(14),
                                                    Alphas(14),
                                                    InletAirTemp);
                    } else {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.HCOPFTemp,
                                                    cAlphaFields(14),
                                                    Alphas(14),
                                                    InletAirTemp,
                                                    InletWaterTemp);
                    }
                }
            }
        }

        if (!lAlphaBlanks(15)) {
            thisDXCoil.HCOPFAirFlow = GetCurveIndex(state, Alphas(15));
            if (thisDXCoil.HCOPFAirFlow == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(15), Alphas(15)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are Cubic or Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.HCOPFAirFlow, // Curve index
                                                     {1},                     // Valid dimensions
                                                     RoutineName,             // Routine name
                                                     CurrentModuleObject,     // Object Type
                                                     thisDXCoil.Name,         // Object Name
                                                     cAlphaFields(15));       // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.HCOPFAirFlow,
                                                cAlphaFields(15),
                                                Alphas(15),
                                                1.0);
                }
            }
        }

        if (!lAlphaBlanks(16)) {
            thisDXCoil.HCOPFWaterFlow = GetCurveIndex(state, Alphas(16));
            if (thisDXCoil.HCOPFWaterFlow == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(16), Alphas(16)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are Cubic or Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.HCOPFWaterFlow, // Curve index
                                                     {1},                       // Valid dimensions
                                                     RoutineName,               // Routine name
                                                     CurrentModuleObject,       // Object Type
                                                     thisDXCoil.Name,           // Object Name
                                                     cAlphaFields(16));         // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.HCOPFWaterFlow,
                                                cAlphaFields(16),
                                                Alphas(16),
                                                1.0);
                }
            }
        }

        if (!lAlphaBlanks(17)) {
            thisDXCoil.PLFFPLR(1) = GetCurveIndex(state, Alphas(17));
            if (thisDXCoil.PLFFPLR(1) == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(17), Alphas(17)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are Cubic or Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.PLFFPLR(1), // Curve index
                                                     {1},                   // Valid dimensions
                                                     RoutineName,           // Routine name
                                                     CurrentModuleObject,   // Object Type
                                                     thisDXCoil.Name,       // Object Name
                                                     cAlphaFields(17));     // Field Name

                if (!ErrorsFound) {
                    //       Test PLF curve minimum and maximum. Cap if less than 0.7 or greater than 1.0.
                    MinCurveVal = 999.0;
                    MaxCurveVal = -999.0;
                    CurveInput = 0.0;
                    while (CurveInput <= 1.0) {
                        CurveVal = CurveValue(state, thisDXCoil.PLFFPLR(1), CurveInput);
                        if (CurveVal < MinCurveVal) {
                            MinCurveVal = CurveVal;
                            MinCurvePLR = CurveInput;
                        }
                        if (CurveVal > MaxCurveVal) {
                            MaxCurveVal = CurveVal;
                            MaxCurvePLR = CurveInput;
                        }
                        CurveInput += 0.01;
                    }
                    if (MinCurveVal < 0.7) {
                        ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields(17), Alphas(17)));
                        ShowContinueError(state,
                                          format("...Curve minimum must be >= 0.7, curve min at PLR = {:.2T} is {:.3T}", MinCurvePLR, MinCurveVal));
                        ShowContinueError(state, "...Setting curve minimum to 0.7 and simulation continues.");
                        Curve::SetCurveOutputMinValue(state, thisDXCoil.PLFFPLR(1), ErrorsFound, 0.7);
                    }

                    if (MaxCurveVal > 1.0) {
                        ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields(17), Alphas(17)));
                        ShowContinueError(state,
                                          format("...Curve maximum must be <= 1.0, curve max at PLR = {:.2T} is {:.3T}", MaxCurvePLR, MaxCurveVal));
                        ShowContinueError(state, "...Setting curve maximum to 1.0 and simulation continues.");
                        Curve::SetCurveOutputMaxValue(state, thisDXCoil.PLFFPLR(1), ErrorsFound, 1.0);
                    }
                }
            }
        }

        // assume compressor resides at the inlet to the DX Coil
        thisDXCoil.CondenserInletNodeNum(1) = thisDXCoil.AirInNode;

        // set condenser type as HPWH
        thisDXCoil.CondenserType(1) = DataHeatBalance::RefrigCondenserType::WaterHeater;

    } // end of the DX water heater coil loop

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input. Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }
    // Loop over the Wrapped DX Water Heater Coils and get & load the data
    CurrentModuleObject = HVAC::cAllCoilTypes(HVAC::CoilDX_HeatPumpWaterHeaterWrapped);
    for (DXHPWaterHeaterCoilNum = 1; DXHPWaterHeaterCoilNum <= state.dataDXCoils->NumDXHeatPumpWaterHeaterWrappedCoils; ++DXHPWaterHeaterCoilNum) {

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXHPWaterHeaterCoilNum,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        ++DXCoilNum;

        // allocate single performance mode for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilDX_HeatPumpWaterHeaterWrapped;
        thisDXCoil.SchedPtr = 0; // heat pump water heater DX coil has no schedule

        // Store the HPWH DX coil heating capacity in RatedTotCap2. After backing off pump and fan heat,
        // move to RatedTotCap() for use by DX coil
        thisDXCoil.RatedTotCap2 = Numbers(1);
        if (thisDXCoil.RatedTotCap2 <= 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 0.0, entered value=[{:.2T}].", cNumericFields(1), Numbers(1)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedCOP(1) = Numbers(2);
        if (thisDXCoil.RatedCOP(1) <= 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 0.0, entered value=[{:.2T}].", cNumericFields(2), Numbers(2)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedSHR(1) = Numbers(3);
        if (thisDXCoil.RatedSHR(1) <= 0.0 || thisDXCoil.RatedSHR(1) > 1.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 0 and <= 1.  entered value=[{:.3T}].", cNumericFields(3), Numbers(3)));

            ErrorsFound = true;
        }

        thisDXCoil.RatedInletDBTemp = Numbers(4);
        if (thisDXCoil.RatedInletDBTemp <= 5.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 5 {{C}}.  entered value=[{:.1T}].", cNumericFields(4), Numbers(4)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedInletWBTemp = Numbers(5);
        if (thisDXCoil.RatedInletWBTemp <= 5.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 5 {{C}}.  entered value=[{:.1T}].", cNumericFields(5), Numbers(5)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedInletWaterTemp = Numbers(6);
        if (thisDXCoil.RatedInletWaterTemp <= 25.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be > 25 {{C}}.  entered value=[{:.1T}].", cNumericFields(6), Numbers(6)));
            ErrorsFound = true;
        }

        thisDXCoil.RatedAirVolFlowRate(1) = Numbers(7);
        if (thisDXCoil.RatedAirVolFlowRate(1) != Constant::AutoCalculate) {
            if (thisDXCoil.RatedAirVolFlowRate(1) <= 0.0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{} must be > 0.0.  entered value=[{:.3T}].", cNumericFields(7), Numbers(7)));
                ErrorsFound = true;
            }
        }

        if (Util::SameString(Alphas(2), "Yes") || Util::SameString(Alphas(2), "No")) {
            //  initialized to TRUE on allocate
            if (Util::SameString(Alphas(2), "No")) thisDXCoil.FanPowerIncludedInCOP = false;
        } else {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format(",,,invalid choice for {}.  Entered choice = {}", cAlphaFields(2), Alphas(2)));
            ShowContinueError(state, "Valid choices are Yes or No.");
            ErrorsFound = true;
        }

        // Air nodes
        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(3),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilWaterHeatingAirToWaterHeatPumpWrapped,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);

        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(4),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilWaterHeatingAirToWaterHeatPumpWrapped,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(3), Alphas(4), "Air Nodes");

        // Check if the air inlet node is OA node, to justify whether the coil is placed in zone or not
        thisDXCoil.IsDXCoilInZone = !CheckOutAirNodeNumber(state, thisDXCoil.AirInNode);

        std::string const DummyCondenserInletName("DUMMY CONDENSER INLET " + thisDXCoil.Name);
        std::string const DummyCondenserOutletName("DUMMY CONDENSER OUTLET " + thisDXCoil.Name);
        thisDXCoil.WaterInNode = GetOnlySingleNode(state,
                                                   DummyCondenserInletName,
                                                   ErrorsFound,
                                                   DataLoopNode::ConnectionObjectType::CoilWaterHeatingAirToWaterHeatPumpWrapped,
                                                   Alphas(1),
                                                   DataLoopNode::NodeFluidType::Water,
                                                   DataLoopNode::ConnectionType::Inlet,
                                                   NodeInputManager::CompFluidStream::Secondary,
                                                   ObjectIsNotParent);

        thisDXCoil.WaterOutNode = GetOnlySingleNode(state,
                                                    DummyCondenserOutletName,
                                                    ErrorsFound,
                                                    DataLoopNode::ConnectionObjectType::CoilWaterHeatingAirToWaterHeatPumpWrapped,
                                                    Alphas(1),
                                                    DataLoopNode::NodeFluidType::Water,
                                                    DataLoopNode::ConnectionType::Outlet,
                                                    NodeInputManager::CompFluidStream::Secondary,
                                                    ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), DummyCondenserInletName, DummyCondenserOutletName, "Water Nodes");

        thisDXCoil.CrankcaseHeaterCapacity = Numbers(8);
        if (thisDXCoil.CrankcaseHeaterCapacity < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0.0  entered value=[{:.1T}].", cNumericFields(8), Numbers(8)));
            ErrorsFound = true;
        }

        thisDXCoil.MaxOATCrankcaseHeater = Numbers(9);
        if (thisDXCoil.MaxOATCrankcaseHeater < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0 {{C}}.  entered value=[{:.1T}].", cNumericFields(9), Numbers(9)));
            ErrorsFound = true;
        }

        // Coil:WaterHeating:AirToWaterHeatPump:Wrapped
        if (!lAlphaBlanks(5)) {
            thisDXCoil.CrankcaseHeaterCapacityCurveIndex = Curve::GetCurveIndex(state, Alphas(5));
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CrankcaseHeaterCapacityCurveIndex, // Curve index
                                                 {1},                                          // Valid dimensions
                                                 RoutineName,                                  // Routine name
                                                 CurrentModuleObject,                          // Object Type
                                                 thisDXCoil.Name,                              // Object Name
                                                 cAlphaFields(5));                             // Field Name
        }

        if (Util::SameString(Alphas(6), "DryBulbTemperature")) {
            thisDXCoil.InletAirTemperatureType = HVAC::OATType::DryBulb;
        } else if (Util::SameString(Alphas(6), "WetBulbTemperature")) {
            thisDXCoil.InletAirTemperatureType = HVAC::OATType::WetBulb;
        } else {
            //   wrong temperature type selection
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be DryBulbTemperature or WetBulbTemperature.", cAlphaFields(6)));
            ShowContinueError(state, format("...entered value=\"{}\".", Alphas(6)));
            ErrorsFound = true;
        }

        // set rated inlet air temperature for curve object verification
        if (thisDXCoil.InletAirTemperatureType == HVAC::OATType::WetBulb) {
            InletAirTemp = thisDXCoil.RatedInletWBTemp;
        } else {
            InletAirTemp = thisDXCoil.RatedInletDBTemp;
        }
        // set rated water temperature for curve object verification
        InletWaterTemp = thisDXCoil.RatedInletWaterTemp;

        if (!lAlphaBlanks(7)) {
            thisDXCoil.HCapFTemp = GetCurveIndex(state, Alphas(7));
            if (thisDXCoil.HCapFTemp == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(7), Alphas(7)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are BiQuadratic or Cubic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.HCapFTemp, // Curve index
                                                     {1, 2},               // Valid dimensions  // MULTIPLECURVEDIMS
                                                     RoutineName,          // Routine name
                                                     CurrentModuleObject,  // Object Type
                                                     thisDXCoil.Name,      // Object Name
                                                     cAlphaFields(7));     // Field Name

                if (!ErrorsFound) {
                    if (state.dataCurveManager->PerfCurve(thisDXCoil.HCapFTemp)->numDims == 1) {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.HCapFTemp,
                                                    cAlphaFields(7),
                                                    Alphas(7),
                                                    InletAirTemp);
                    } else {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.HCapFTemp,
                                                    cAlphaFields(7),
                                                    Alphas(7),
                                                    InletAirTemp,
                                                    InletWaterTemp);
                    }
                }
            }
        }

        if (!lAlphaBlanks(8)) {
            thisDXCoil.HCapFAirFlow = GetCurveIndex(state, Alphas(8));
            if (thisDXCoil.HCapFAirFlow == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(8), Alphas(8)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are Cubic or Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.HCapFAirFlow, // Curve index
                                                     {1},                     // Valid dimensions
                                                     RoutineName,             // Routine name
                                                     CurrentModuleObject,     // Object Type
                                                     thisDXCoil.Name,         // Object Name
                                                     cAlphaFields(8));        // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.HCapFAirFlow,
                                                cAlphaFields(8),
                                                Alphas(8),
                                                1.0);
                }
            }
        }

        if (!lAlphaBlanks(9)) {
            thisDXCoil.HCOPFTemp = GetCurveIndex(state, Alphas(9));
            if (thisDXCoil.HCOPFTemp == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(9), Alphas(9)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are BiQuadratic or Cubic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.HCOPFTemp, // Curve index
                                                     {1, 2},               // Valid dimensions  // MULTIPLECURVEDIMS
                                                     RoutineName,          // Routine name
                                                     CurrentModuleObject,  // Object Type
                                                     thisDXCoil.Name,      // Object Name
                                                     cAlphaFields(9));     // Field Name

                if (!ErrorsFound) {
                    if (state.dataCurveManager->PerfCurve(thisDXCoil.HCOPFTemp)->numDims == 1) {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.HCOPFTemp,
                                                    cAlphaFields(9),
                                                    Alphas(9),
                                                    InletAirTemp);
                    } else {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.HCOPFTemp,
                                                    cAlphaFields(9),
                                                    Alphas(9),
                                                    InletAirTemp,
                                                    InletWaterTemp);
                    }
                }
            }
        }

        if (!lAlphaBlanks(10)) {
            thisDXCoil.HCOPFAirFlow = GetCurveIndex(state, Alphas(10));
            if (thisDXCoil.HCOPFAirFlow == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(10), Alphas(10)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are Cubic or Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.HCOPFAirFlow, // Curve index
                                                     {1},                     // Valid dimensions
                                                     RoutineName,             // Routine name
                                                     CurrentModuleObject,     // Object Type
                                                     thisDXCoil.Name,         // Object Name
                                                     cAlphaFields(10));       // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.HCOPFAirFlow,
                                                cAlphaFields(10),
                                                Alphas(10),
                                                1.0);
                }
            }
        }

        if (!lAlphaBlanks(11)) {
            thisDXCoil.PLFFPLR(1) = GetCurveIndex(state, Alphas(11));
            if (thisDXCoil.PLFFPLR(1) == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(11), Alphas(11)));
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are Cubic or Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.PLFFPLR(1), // Curve index
                                                     {1},                   // Valid dimensions
                                                     RoutineName,           // Routine name
                                                     CurrentModuleObject,   // Object Type
                                                     thisDXCoil.Name,       // Object Name
                                                     cAlphaFields(11));     // Field Name

                if (!ErrorsFound) {
                    //       Test PLF curve minimum and maximum. Cap if less than 0.7 or greater than 1.0.
                    MinCurveVal = 999.0;
                    MaxCurveVal = -999.0;
                    CurveInput = 0.0;
                    while (CurveInput <= 1.0) {
                        CurveVal = CurveValue(state, thisDXCoil.PLFFPLR(1), CurveInput);
                        if (CurveVal < MinCurveVal) {
                            MinCurveVal = CurveVal;
                            MinCurvePLR = CurveInput;
                        }
                        if (CurveVal > MaxCurveVal) {
                            MaxCurveVal = CurveVal;
                            MaxCurvePLR = CurveInput;
                        }
                        CurveInput += 0.01;
                    }
                    if (MinCurveVal < 0.7) {
                        ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields(11), Alphas(11)));
                        ShowContinueError(state,
                                          format("...Curve minimum must be >= 0.7, curve min at PLR = {:.2T} is {:.3T}", MinCurvePLR, MinCurveVal));
                        ShowContinueError(state, "...Setting curve minimum to 0.7 and simulation continues.");
                        Curve::SetCurveOutputMinValue(state, thisDXCoil.PLFFPLR(1), ErrorsFound, 0.7);
                    }

                    if (MaxCurveVal > 1.0) {
                        ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state, format("...{} = {} has out of range value.", cAlphaFields(11), Alphas(11)));
                        ShowContinueError(state,
                                          format("...Curve maximum must be <= 1.0, curve max at PLR = {:.2T} is {:.3T}", MaxCurvePLR, MaxCurveVal));
                        ShowContinueError(state, "...Setting curve maximum to 1.0 and simulation continues.");
                        Curve::SetCurveOutputMaxValue(state, thisDXCoil.PLFFPLR(1), ErrorsFound, 1.0);
                    }
                }
            }
        }

        // assume compressor resides at the inlet to the DX Coil
        thisDXCoil.CondenserInletNodeNum(1) = thisDXCoil.AirInNode;

        // set condenser type as HPWH
        thisDXCoil.CondenserType(1) = DataHeatBalance::RefrigCondenserType::WaterHeater;

    } // end of the DX water heater wrapped coil loop

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input. Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }

    // DX Multispeed cooling coil
    CurrentModuleObject = "Coil:Cooling:DX:MultiSpeed";
    for (DXCoilIndex = 1; DXCoilIndex <= state.dataDXCoils->NumDXMulSpeedCoolCoils; ++DXCoilIndex) {

        ++DXCoilNum;

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXCoilIndex,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        // allocate single performance mode for numeric field strings used for sizing routine (all fields are in this object)
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        // Initialize DataHeatBalance heat reclaim variable name for use by heat reclaim coils
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).Name = thisDXCoil.Name;
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).SourceType = CurrentModuleObject;
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilDX_MultiSpeedCooling;
        thisDXCoil.Schedule = Alphas(2);
        if (lAlphaBlanks(2)) {
            thisDXCoil.SchedPtr = ScheduleManager::ScheduleAlwaysOn;
        } else {
            thisDXCoil.SchedPtr = GetScheduleIndex(state, Alphas(2)); // convert schedule name to pointer
            if (thisDXCoil.SchedPtr == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{}=\"{}\".", cAlphaFields(2), Alphas(2)));
                ErrorsFound = true;
            }
        }

        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(3),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilCoolingDXMultiSpeed,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);

        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(4),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilCoolingDXMultiSpeed,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(3), Alphas(4), "Air Nodes");

        // outdoor condenser node
        if (lAlphaBlanks(5)) {
            thisDXCoil.CondenserInletNodeNum(1) = 0;
        } else {
            thisDXCoil.CondenserInletNodeNum(1) = GetOnlySingleNode(state,
                                                                    Alphas(5),
                                                                    ErrorsFound,
                                                                    DataLoopNode::ConnectionObjectType::CoilCoolingDXMultiSpeed,
                                                                    thisDXCoil.Name,
                                                                    DataLoopNode::NodeFluidType::Air,
                                                                    DataLoopNode::ConnectionType::OutsideAirReference,
                                                                    NodeInputManager::CompFluidStream::Primary,
                                                                    ObjectIsNotParent);
            if (!CheckOutAirNodeNumber(state, thisDXCoil.CondenserInletNodeNum(1))) {
                ShowWarningError(state, format("{}{}=\"{}\", may be invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(
                    state, format("{}=\"{}\", node does not appear in an OutdoorAir:NodeList or as an OutdoorAir:Node.", cAlphaFields(5), Alphas(5)));
                ShowContinueError(
                    state, "This node needs to be included in an air system or the coil model will not be valid, and the simulation continues");
            }
        }

        if ((Util::SameString(Alphas(6), "AirCooled")) || lAlphaBlanks(6)) {
            thisDXCoil.CondenserType(1) = DataHeatBalance::RefrigCondenserType::Air;
        } else if (Util::SameString(Alphas(6), "EvaporativelyCooled")) {
            thisDXCoil.CondenserType(1) = DataHeatBalance::RefrigCondenserType::Evap;
            thisDXCoil.ReportEvapCondVars = true;
        } else {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{}=\"{}\":", cAlphaFields(6), Alphas(6)));
            ShowContinueError(state, "...must be AirCooled or EvaporativelyCooled.");
            ErrorsFound = true;
        }

        // Get Water System tank connections
        //  A8, \field Name of Water Storage Tank for Supply
        thisDXCoil.EvapWaterSupplyName = Alphas(7);
        if (lAlphaBlanks(7)) {
            thisDXCoil.EvapWaterSupplyMode = EvapWaterSupply::FromMains;
        } else {
            thisDXCoil.EvapWaterSupplyMode = EvapWaterSupply::FromTank;
            SetupTankDemandComponent(state,
                                     thisDXCoil.Name,
                                     CurrentModuleObject,
                                     thisDXCoil.EvapWaterSupplyName,
                                     ErrorsFound,
                                     thisDXCoil.EvapWaterSupTankID,
                                     thisDXCoil.EvapWaterTankDemandARRID);
        }

        // A9; \field Name of Water Storage Tank for Condensate Collection
        thisDXCoil.CondensateCollectName = Alphas(8);
        if (lAlphaBlanks(8)) {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::Discard;
        } else {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::ToTank;
            SetupTankSupplyComponent(state,
                                     thisDXCoil.Name,
                                     CurrentModuleObject,
                                     thisDXCoil.CondensateCollectName,
                                     ErrorsFound,
                                     thisDXCoil.CondensateTankID,
                                     thisDXCoil.CondensateTankSupplyARRID);
        }

        // Set minimum OAT for compressor operation
        thisDXCoil.MinOATCompressor = Numbers(1);

        // Set crankcase heater capacity
        thisDXCoil.CrankcaseHeaterCapacity = Numbers(2);
        if (thisDXCoil.CrankcaseHeaterCapacity < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0.", cNumericFields(2)));
            ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(2)));
            ErrorsFound = true;
        }

        // Set crankcase heater cutout temperature
        thisDXCoil.MaxOATCrankcaseHeater = Numbers(3);

        if (Util::SameString(Alphas(9), "Yes")) {
            thisDXCoil.PLRImpact = true;
        } else if (Util::SameString(Alphas(9), "No")) {
            thisDXCoil.PLRImpact = false;
        } else {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format(",,,invalid choice for {}.  Entered choice = {}", cAlphaFields(9), Alphas(9)));
            ShowContinueError(state, "The allowed choices are Yes or No.");
            ErrorsFound = true;
        }

        if (Util::SameString(Alphas(10), "Yes")) {
            thisDXCoil.LatentImpact = true;
        } else if (Util::SameString(Alphas(10), "No")) {
            thisDXCoil.LatentImpact = false;
        } else {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format(",,,invalid choice for {}.  Entered choice = {}", cAlphaFields(10), Alphas(10)));
            ShowContinueError(state, "The allowed choices are Yes or No.");
            ErrorsFound = true;
        }

        //   Basin heater power as a function of temperature must be greater than or equal to 0
        thisDXCoil.BasinHeaterPowerFTempDiff = Numbers(4);
        if (Numbers(4) < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 0.0, entered value=[{:.3T}].", cNumericFields(4), Numbers(4)));
            ErrorsFound = true;
        }

        thisDXCoil.BasinHeaterSetPointTemp = Numbers(5);
        if (thisDXCoil.BasinHeaterPowerFTempDiff > 0.0) {
            if (NumNumbers < 5) {
                thisDXCoil.BasinHeaterSetPointTemp = 2.0;
            }
            if (thisDXCoil.BasinHeaterSetPointTemp < 2.0) {
                ShowWarningError(state, format("{}{}=\"{}\", freeze possible", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{} is less than 2 {{C}}. Freezing could occur.", cNumericFields(5)));
                ShowContinueError(state, format("...entered value=[{:.2T}].", Numbers(5)));
            }
        }

        if (!lAlphaBlanks(11)) {
            thisDXCoil.CrankcaseHeaterCapacityCurveIndex = Curve::GetCurveIndex(state, Alphas(11));
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CrankcaseHeaterCapacityCurveIndex, // Curve index
                                                 {1},                                          // Valid dimensions
                                                 RoutineName,                                  // Routine name
                                                 CurrentModuleObject,                          // Object Type
                                                 thisDXCoil.Name,                              // Object Name
                                                 cAlphaFields(11));                            // Field Name
        }

        if (!lAlphaBlanks(12)) {
            thisDXCoil.BasinHeaterSchedulePtr = GetScheduleIndex(state, Alphas(12));
            if (thisDXCoil.BasinHeaterSchedulePtr == 0) {
                ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(12), Alphas(12)));
                ShowContinueError(state, "Basin heater will be available to operate throughout the simulation.");
            }
        }

        // A13; \field Fuel type, Validate fuel type input
        thisDXCoil.FuelType = static_cast<Constant::eFuel>(getEnumValue(Constant::eFuelNamesUC, Alphas(13)));

        thisDXCoil.NumOfSpeeds = Numbers(6); // Number of speeds
        if (thisDXCoil.NumOfSpeeds < 2) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 2. entered number is {:.0T}", cNumericFields(6), Numbers(6)));
            ErrorsFound = true;
        }

        // Allocate arrays based on the number of speeds
        thisDXCoil.MSErrIndex.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSErrIndex = 0;
        thisDXCoil.MSRatedTotCap.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedTotCapDes.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedSHR.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedCOP.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedAirVolFlowRate.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedAirMassFlowRate.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedAirMassFlowRate = 1.0; // avoid divide by 0, will get overwritten in InitDXCoil
        thisDXCoil.MSCCapFTemp.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSCCapFFlow.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSEIRFTemp.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSEIRFFlow.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSWasteHeat.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSEvapCondEffect.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSEvapCondAirFlow.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSEvapCondPumpElecNomPower.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedCBF.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSWasteHeatFrac.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSPLFFPLR.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSTwet_Rated.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSGamma_Rated.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSMaxONOFFCyclesperHour.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSLatentCapacityTimeConstant.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSFanPowerPerEvapAirFlowRate.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSFanPowerPerEvapAirFlowRate_2023.allocate(thisDXCoil.NumOfSpeeds);

        for (I = 1; I <= thisDXCoil.NumOfSpeeds; ++I) {
            thisDXCoil.MSRatedTotCap(I) = Numbers(7 + (I - 1) * 14);
            thisDXCoil.MSRatedSHR(I) = Numbers(8 + (I - 1) * 14);
            thisDXCoil.MSRatedCOP(I) = Numbers(9 + (I - 1) * 14);
            thisDXCoil.MSRatedAirVolFlowRate(I) = Numbers(10 + (I - 1) * 14);
            thisDXCoil.MSFanPowerPerEvapAirFlowRate(I) = Numbers(11 + (I - 1) * 14);
            thisDXCoil.MSFanPowerPerEvapAirFlowRate_2023(I) = Numbers(12 + (I - 1) * 14);

            thisDXCoil.MSCCapFTemp(I) = GetCurveIndex(state, Alphas(14 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.MSCCapFTemp(I) == 0) {
                if (lAlphaBlanks(14 + (I - 1) * 6)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(14 + (I - 1) * 6)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(14 + (I - 1) * 6), Alphas(14 + (I - 1) * 6)));
                }
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal type is BiQuadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.MSCCapFTemp(I),       // Curve index
                                                     {2},                             // Valid dimensions
                                                     RoutineName,                     // Routine name
                                                     CurrentModuleObject,             // Object Type
                                                     thisDXCoil.Name,                 // Object Name
                                                     cAlphaFields(14 + (I - 1) * 6)); // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.MSCCapFTemp(I),
                                                cAlphaFields(14 + (I - 1) * 6),
                                                Alphas(14 + (I - 1) * 6),
                                                RatedInletWetBulbTemp,
                                                RatedOutdoorAirTemp);
                }
            }

            thisDXCoil.MSCCapFFlow(I) = GetCurveIndex(state, Alphas(15 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.MSCCapFFlow(I) == 0) {
                if (lAlphaBlanks(15 + (I - 1) * 6)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(15 + (I - 1) * 6)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(15 + (I - 1) * 6), Alphas(15 + (I - 1) * 6)));
                }
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal type is Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.MSCCapFFlow(I),       // Curve index
                                                     {1},                             // Valid dimensions
                                                     RoutineName,                     // Routine name
                                                     CurrentModuleObject,             // Object Type
                                                     thisDXCoil.Name,                 // Object Name
                                                     cAlphaFields(15 + (I - 1) * 6)); // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.MSCCapFFlow(I),
                                                cAlphaFields(15 + (I - 1) * 6),
                                                Alphas(15 + (I - 1) * 6),
                                                1.0);
                }
            }

            thisDXCoil.MSEIRFTemp(I) = GetCurveIndex(state, Alphas(16 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.MSEIRFTemp(I) == 0) {
                if (lAlphaBlanks(16 + (I - 1) * 6)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(16 + (I - 1) * 6)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(16 + (I - 1) * 6), Alphas(16 + (I - 1) * 6)));
                }
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal type is BiQuadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.MSEIRFTemp(I),        // Curve index
                                                     {2},                             // Valid dimensions
                                                     RoutineName,                     // Routine name
                                                     CurrentModuleObject,             // Object Type
                                                     thisDXCoil.Name,                 // Object Name
                                                     cAlphaFields(16 + (I - 1) * 6)); // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.MSEIRFTemp(I),
                                                cAlphaFields(16 + (I - 1) * 6),
                                                Alphas(16 + (I - 1) * 6),
                                                RatedInletWetBulbTemp,
                                                RatedOutdoorAirTemp);
                }
            }

            thisDXCoil.MSEIRFFlow(I) = GetCurveIndex(state, Alphas(17 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.MSEIRFFlow(I) == 0) {
                if (lAlphaBlanks(17 + (I - 1) * 6)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(17 + (I - 1) * 6)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(17 + (I - 1) * 6), Alphas(17 + (I - 1) * 6)));
                }
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal type is Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.MSEIRFFlow(I),        // Curve index
                                                     {1},                             // Valid dimensions
                                                     RoutineName,                     // Routine name
                                                     CurrentModuleObject,             // Object Type
                                                     thisDXCoil.Name,                 // Object Name
                                                     cAlphaFields(17 + (I - 1) * 6)); // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.MSEIRFFlow(I),
                                                cAlphaFields(17 + (I - 1) * 6),
                                                Alphas(17 + (I - 1) * 6),
                                                1.0);
                }
            }

            thisDXCoil.MSPLFFPLR(I) = GetCurveIndex(state, Alphas(18 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.MSPLFFPLR(I) == 0) {
                if (lAlphaBlanks(18 + (I - 1) * 6)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(18 + (I - 1) * 6)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(18 + (I - 1) * 6), Alphas(18 + (I - 1) * 6)));
                }
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are Quadratic or Cubic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.MSPLFFPLR(I),         // Curve index
                                                     {1},                             // Valid dimensions
                                                     RoutineName,                     // Routine name
                                                     CurrentModuleObject,             // Object Type
                                                     thisDXCoil.Name,                 // Object Name
                                                     cAlphaFields(18 + (I - 1) * 6)); // Field Name

                if (!ErrorsFound) {
                    //       Test PLF curve minimum and maximum. Cap if less than 0.7 or greater than 1.0.
                    MinCurveVal = 999.0;
                    MaxCurveVal = -999.0;
                    CurveInput = 0.0;
                    while (CurveInput <= 1.0) {
                        CurveVal = CurveValue(state, thisDXCoil.MSPLFFPLR(I), CurveInput);
                        if (CurveVal < MinCurveVal) {
                            MinCurveVal = CurveVal;
                            MinCurvePLR = CurveInput;
                        }
                        if (CurveVal > MaxCurveVal) {
                            MaxCurveVal = CurveVal;
                            MaxCurvePLR = CurveInput;
                        }
                        CurveInput += 0.01;
                    }
                    if (MinCurveVal < 0.7) {
                        ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state,
                                          format("...{} = {} has out of range value.", cAlphaFields2(18 + (I - 1) * 6), Alphas2(18 + (I - 1) * 6)));
                        ShowContinueError(state,
                                          format("...Curve minimum must be >= 0.7, curve min at PLR = {:.2T} is {:.3T}", MinCurvePLR, MinCurveVal));
                        ShowContinueError(state, "...Setting curve minimum to 0.7 and simulation continues.");
                        Curve::SetCurveOutputMinValue(state, thisDXCoil.PLFFPLR(PerfModeNum), ErrorsFound, 0.7);
                    }

                    if (MaxCurveVal > 1.0) {
                        ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state,
                                          format("...{} = {} has out of range value.", cAlphaFields2(18 + (I - 1) * 6), Alphas2(18 + (I - 1) * 6)));
                        ShowContinueError(state,
                                          format("...Curve maximum must be <= 1.0, curve max at PLR = {:.2T} is {:.3T}", MaxCurvePLR, MaxCurveVal));
                        ShowContinueError(state, "...Setting curve maximum to 1.0 and simulation continues.");
                        Curve::SetCurveOutputMaxValue(state, thisDXCoil.MSPLFFPLR(I), ErrorsFound, 1.0);
                    }
                }
            }

            // read data for latent degradation
            thisDXCoil.MSTwet_Rated(I) = Numbers(13 + (I - 1) * 14);
            if (thisDXCoil.MSTwet_Rated(I) < 0.0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(
                    state, format("...{} cannot be < 0.0, entered value=[{:.4T}].", cNumericFields(13 + (I - 1) * 14), thisDXCoil.MSTwet_Rated(I)));
                ErrorsFound = true;
            }
            thisDXCoil.MSGamma_Rated(I) = Numbers(14 + (I - 1) * 14);
            if (thisDXCoil.MSGamma_Rated(I) < 0.0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(
                    state, format("...{} cannot be < 0.0, entered value=[{:.4T}].", cNumericFields(14 + (I - 1) * 14), thisDXCoil.MSGamma_Rated(I)));
                ErrorsFound = true;
            }
            thisDXCoil.MSMaxONOFFCyclesperHour(I) = Numbers(15 + (I - 1) * 14);
            if (thisDXCoil.Gamma_Rated(I) < 0.0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state,
                                  format("...{} cannot be < 0.0, entered value=[{:.2T}].",
                                         cNumericFields(15 + (I - 1) * 14),
                                         thisDXCoil.MSMaxONOFFCyclesperHour(I)));
                ErrorsFound = true;
            }
            thisDXCoil.MSLatentCapacityTimeConstant(I) = Numbers(16 + (I - 1) * 14);
            if (thisDXCoil.Gamma_Rated(I) < 0.0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state,
                                  format("...{} cannot be < 0.0, entered value=[{:.2T}].",
                                         cNumericFields(16 + (I - 1) * 14),
                                         thisDXCoil.MSLatentCapacityTimeConstant(I)));
                ErrorsFound = true;
            }

            thisDXCoil.MSWasteHeatFrac(I) = Numbers(17 + (I - 1) * 14);

            // Read waste heat modifier curve name
            thisDXCoil.MSWasteHeat(I) = GetCurveIndex(state, Alphas(19 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {
                if (thisDXCoil.MSWasteHeat(I) > 0) {
                    // Verify Curve Object, only legal types are BiQuadratic
                    ErrorsFound |= Curve::CheckCurveDims(state,
                                                         thisDXCoil.MSWasteHeat(I),       // Curve index
                                                         {2},                             // Valid dimensions
                                                         RoutineName,                     // Routine name
                                                         CurrentModuleObject,             // Object Type
                                                         thisDXCoil.Name,                 // Object Name
                                                         cAlphaFields(19 + (I - 1) * 6)); // Field Name

                    if (!ErrorsFound) {
                        CurveVal = CurveValue(state, thisDXCoil.MSWasteHeat(I), RatedOutdoorAirTemp, RatedInletAirTemp);
                        if (CurveVal > 1.10 || CurveVal < 0.90) {
                            ShowWarningError(state, format("{}{}=\"{}\", curve values", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                            ShowContinueError(state, format("{} = {}", cAlphaFields(19 + (I - 1) * 6), Alphas(19 + (I - 1) * 6)));
                            ShowContinueError(
                                state, format("...{} output is not equal to 1.0 (+ or - 10%) at rated conditions.", cAlphaFields(19 + (I - 1) * 6)));
                            ShowContinueError(state, format("...Curve output at rated conditions = {:.3T}", CurveVal));
                        }
                    }
                }
            }

            thisDXCoil.MSEvapCondEffect(I) = Numbers(18 + (I - 1) * 14);
            if (thisDXCoil.MSEvapCondEffect(I) < 0.0 || thisDXCoil.MSEvapCondEffect(I) > 1.0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(
                    state,
                    format("...{} cannot be < 0.0 or > 1.0, entered value=[{:.3T}].", cNumericFields(18 + (I - 1) * 14), Numbers(18 + (I - 1) * 14)));
                ErrorsFound = true;
            }

            thisDXCoil.MSEvapCondAirFlow(I) = Numbers(19 + (I - 1) * 14);
            if (thisDXCoil.MSEvapCondAirFlow(I) < 0.0 && thisDXCoil.MSEvapCondAirFlow(I) != AutoSize) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(
                    state, format("...{} cannot be < 0.0, entered value=[{:.3T}].", cNumericFields(19 + (I - 1) * 14), Numbers(19 + (I - 1) * 14)));
                ErrorsFound = true;
            }

            thisDXCoil.MSEvapCondPumpElecNomPower(I) = Numbers(20 + (I - 1) * 14);
            if (thisDXCoil.MSEvapCondPumpElecNomPower(I) < 0.0 && thisDXCoil.MSEvapCondPumpElecNomPower(I) != AutoSize) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(
                    state, format("...{} cannot be < 0.0, entered value=[{:.3T}].", cNumericFields(20 + (I - 1) * 14), Numbers(20 + (I - 1) * 14)));
                ErrorsFound = true;
            }
        }
        // A38; \field Zone Name for Condenser Placement
        if (!lAlphaBlanks(38) && NumAlphas > 37) {
            thisDXCoil.SecZonePtr = Util::FindItemInList(Alphas(38), state.dataHeatBal->Zone);
            if (thisDXCoil.SecZonePtr > 0) {
                SetupZoneInternalGain(state,
                                      thisDXCoil.SecZonePtr,
                                      thisDXCoil.Name,
                                      DataHeatBalance::IntGainType::SecCoolingDXCoilMultiSpeed,
                                      &thisDXCoil.SecCoilSensibleHeatGainRate);
                thisDXCoil.IsSecondaryDXCoilInZone = true;
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(38), Alphas(38)));
            }
        }
    }

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input. Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }

    // DX multispeed heating coil
    CurrentModuleObject = "Coil:Heating:DX:MultiSpeed";
    for (DXCoilIndex = 1; DXCoilIndex <= state.dataDXCoils->NumDXMulSpeedHeatCoils; ++DXCoilIndex) {

        ++DXCoilNum;

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXCoilIndex,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        // *** will have to circle back to this one to fix since the multispeed coil has all fields in this coil object ***
        // allocate single performance mode for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        // Initialize DataHeatBalance heat reclaim variable name for use by heat reclaim coils
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).Name = thisDXCoil.Name;
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).SourceType = CurrentModuleObject;
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilDX_MultiSpeedHeating;
        thisDXCoil.Schedule = Alphas(2);
        if (lAlphaBlanks(2)) {
            thisDXCoil.SchedPtr = ScheduleManager::ScheduleAlwaysOn;
        } else {
            thisDXCoil.SchedPtr = GetScheduleIndex(state, Alphas(2)); // convert schedule name to pointer
            if (thisDXCoil.SchedPtr == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{}=\"{}\".", cAlphaFields(2), Alphas(2)));
                ErrorsFound = true;
            }
        }

        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(3),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilHeatingDXMultiSpeed,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);

        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(4),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilHeatingDXMultiSpeed,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(3), Alphas(4), "Air Nodes");

        // Set minimum OAT for heat pump compressor operation
        thisDXCoil.MinOATCompressor = Numbers(1);

        // set Minimum Outdoor Dry-Bulb Temperature for Compressor Operation
        thisDXCoil.OATempCompressorOn = Numbers(2);
        // Set crankcase heater capacity
        thisDXCoil.CrankcaseHeaterCapacity = Numbers(3);
        if (thisDXCoil.CrankcaseHeaterCapacity < 0.0) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} cannot be < 0.0, entered value=[{:.2T}].", cNumericFields(3), Numbers(3)));
            ErrorsFound = true;
        }

        // Set crankcase heater cutout temperature
        thisDXCoil.MaxOATCrankcaseHeater = Numbers(4);

        if (!lAlphaBlanks(5)) {
            thisDXCoil.CrankcaseHeaterCapacityCurveIndex = Curve::GetCurveIndex(state, Alphas(5));
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CrankcaseHeaterCapacityCurveIndex, // Curve index
                                                 {1},                                          // Valid dimensions
                                                 RoutineName,                                  // Routine name
                                                 CurrentModuleObject,                          // Object Type
                                                 thisDXCoil.Name,                              // Object Name
                                                 cAlphaFields(5));                             // Field Name
        }

        // Only required for reverse cycle heat pumps
        thisDXCoil.DefrostEIRFT = GetCurveIndex(state, Alphas(6)); // convert curve name to number
        if (Util::SameString(Alphas(7), "ReverseCycle")) {
            if (thisDXCoil.DefrostEIRFT == 0) {
                if (lAlphaBlanks(6)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(6)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(6), Alphas(6)));
                }
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal type is BiQuadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.DefrostEIRFT, // Curve index
                                                     {2},                     // Valid dimensions
                                                     RoutineName,             // Routine name
                                                     CurrentModuleObject,     // Object Type
                                                     thisDXCoil.Name,         // Object Name
                                                     cAlphaFields(6));        // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.DefrostEIRFT,
                                                cAlphaFields(6),
                                                Alphas(6),
                                                RatedInletWetBulbTempHeat,
                                                RatedOutdoorAirTempHeat);
                }
            }
        }

        if (Util::SameString(Alphas(7), "ReverseCycle")) thisDXCoil.DefrostStrategy = StandardRatings::DefrostStrat::ReverseCycle;
        if (Util::SameString(Alphas(7), "Resistive")) thisDXCoil.DefrostStrategy = StandardRatings::DefrostStrat::Resistive;
        if (thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::Invalid) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...illegal {}=\"{}\".", cAlphaFields(7), Alphas(7)));
            ShowContinueError(state, "...valid values for this field are ReverseCycle or Resistive.");
            ErrorsFound = true;
        }

        if (Util::SameString(Alphas(8), "Timed")) thisDXCoil.DefrostControl = StandardRatings::HPdefrostControl::Timed;
        if (Util::SameString(Alphas(8), "OnDemand")) thisDXCoil.DefrostControl = StandardRatings::HPdefrostControl::OnDemand;
        if (thisDXCoil.DefrostControl == StandardRatings::HPdefrostControl::Invalid) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...illegal {}=\"{}\".", cAlphaFields(8), Alphas(8)));
            ShowContinueError(state, "...valid values for this field are Timed or OnDemand.");
            ErrorsFound = true;
        }

        // Set maximum outdoor temp for defrost to occur
        thisDXCoil.MaxOATDefrost = Numbers(5);

        // Set defrost time period
        thisDXCoil.DefrostTime = Numbers(6);
        if (thisDXCoil.DefrostTime == 0.0 && thisDXCoil.DefrostControl == StandardRatings::HPdefrostControl::Timed) {
            ShowWarningError(state, format("{}{}=\"{}\", ", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} = 0.0 for defrost control = TIMED.", cNumericFields(5)));
        }

        // Set defrost capacity (for resistive defrost)
        thisDXCoil.DefrostCapacity = Numbers(7);
        if (thisDXCoil.DefrostCapacity == 0.0 && thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::Resistive) {
            ShowWarningError(state, format("{}{}=\"{}\", ", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} = 0.0 for defrost strategy = RESISTIVE.", cNumericFields(7)));
        }

        if (Util::SameString(Alphas(9), "Yes")) {
            thisDXCoil.PLRImpact = true;
        } else if (Util::SameString(Alphas(9), "No")) {
            thisDXCoil.PLRImpact = false;
        } else {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format(",,,invalid choice for {}.  Entered choice = {}", cAlphaFields(9), Alphas(9)));
            ShowContinueError(state, "The allowed choices are Yes or No.");
            ErrorsFound = true;
        }

        // A10; \field Fuel type, Validate fuel type input
        thisDXCoil.FuelType = static_cast<Constant::eFuel>(getEnumValue(Constant::eFuelNamesUC, Alphas(10)));

        thisDXCoil.RegionNum = Numbers(8);   // Region Number for HSPF Calc
        thisDXCoil.NumOfSpeeds = Numbers(9); // Number of speeds
        if (thisDXCoil.NumOfSpeeds < 2) {
            ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
            ShowContinueError(state, format("...{} must be >= 2. entered number is {:.0T}", cNumericFields(9), Numbers(9)));
            ErrorsFound = true;
        }

        // Allocate arrays based on the number of speeds
        thisDXCoil.MSErrIndex.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSErrIndex = 0;
        thisDXCoil.MSRatedTotCap.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedCOP.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedAirVolFlowRate.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedAirMassFlowRate.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedAirMassFlowRate = 1.0; // avoid divide by 0, will get overwritten in InitDXCoil
        thisDXCoil.MSCCapFTemp.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSCCapFFlow.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSEIRFTemp.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSEIRFFlow.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSWasteHeat.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSPLFFPLR.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSRatedCBF.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSWasteHeatFrac.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSFanPowerPerEvapAirFlowRate.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSFanPowerPerEvapAirFlowRate_2023.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSSecCoilSHRFT.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSSecCoilSHRFF.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSSecCoilAirFlow.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSSecCoilAirFlowScalingFactor.allocate(thisDXCoil.NumOfSpeeds);
        thisDXCoil.MSSecCoilRatedSHR.allocate(thisDXCoil.NumOfSpeeds);

        thisDXCoil.RatedSHR(1) = 1.0;

        for (I = 1; I <= thisDXCoil.NumOfSpeeds; ++I) {
            thisDXCoil.MSRatedTotCap(I) = Numbers(10 + (I - 1) * 6);
            thisDXCoil.MSRatedCOP(I) = Numbers(11 + (I - 1) * 6);
            thisDXCoil.MSRatedAirVolFlowRate(I) = Numbers(12 + (I - 1) * 6);
            thisDXCoil.MSFanPowerPerEvapAirFlowRate(I) = Numbers(13 + (I - 1) * 6);
            thisDXCoil.MSFanPowerPerEvapAirFlowRate_2023(I) = Numbers(14 + (I - 1) * 6);
            thisDXCoil.MSWasteHeatFrac(I) = Numbers(15 + (I - 1) * 6);

            thisDXCoil.MSCCapFTemp(I) = GetCurveIndex(state, Alphas(11 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.MSCCapFTemp(I) == 0) {
                ShowSevereError(state,
                                format("{}, \"{}\" {} not found:{}",
                                       CurrentModuleObject,
                                       thisDXCoil.Name,
                                       cAlphaFields(11 + (I - 1) * 6),
                                       Alphas(11 + (I - 1) * 6)));
                ErrorsFound = true;
            } else {
                // only legal types are Quadratic, BiQuadratic and Cubic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.MSCCapFTemp(I),       // Curve index
                                                     {1, 2},                          // Valid dimensions  // MULTIPLECURVEDIMS
                                                     RoutineName,                     // Routine name
                                                     CurrentModuleObject,             // Object Type
                                                     thisDXCoil.Name,                 // Object Name
                                                     cAlphaFields(11 + (I - 1) * 6)); // Field Name

                if (!ErrorsFound) {
                    if (state.dataCurveManager->PerfCurve(thisDXCoil.MSCCapFTemp(I))->numDims == 1) {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.MSCCapFTemp(I),
                                                    cAlphaFields(11 + (I - 1) * 6),
                                                    Alphas(11 + (I - 1) * 6),
                                                    RatedOutdoorAirTempHeat);
                    } else {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.MSCCapFTemp(I),
                                                    cAlphaFields(11 + (I - 1) * 6),
                                                    Alphas(11 + (I - 1) * 6),
                                                    RatedInletAirTempHeat,
                                                    RatedOutdoorAirTempHeat);
                    }
                }
            }

            thisDXCoil.MSCCapFFlow(I) = GetCurveIndex(state, Alphas(12 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.MSCCapFFlow(I) == 0) {
                if (lAlphaBlanks(12 + (I - 1) * 6)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(12 + (I - 1) * 6)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(12 + (I - 1) * 6), Alphas(12 + (I - 1) * 6)));
                }
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal type is Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.MSCCapFFlow(I),       // Curve index
                                                     {1},                             // Valid dimensions
                                                     RoutineName,                     // Routine name
                                                     CurrentModuleObject,             // Object Type
                                                     thisDXCoil.Name,                 // Object Name
                                                     cAlphaFields(12 + (I - 1) * 6)); // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.MSCCapFFlow(I),
                                                cAlphaFields(12 + (I - 1) * 6),
                                                Alphas(12 + (I - 1) * 6),
                                                1.0);
                }
            }

            thisDXCoil.MSEIRFTemp(I) = GetCurveIndex(state, Alphas(13 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.MSEIRFTemp(I) == 0) {
                if (lAlphaBlanks(13 + (I - 1) * 6)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(13 + (I - 1) * 6)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(13 + (I - 1) * 6), Alphas(13 + (I - 1) * 6)));
                }
                ErrorsFound = true;
            } else {
                // only legal types are Quadratic, BiQuadratic and Cubic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.MSEIRFTemp(I),        // Curve index
                                                     {1, 2},                          // Valid dimensions  // MULTIPLECURVEDIMS
                                                     RoutineName,                     // Routine name
                                                     CurrentModuleObject,             // Object Type
                                                     thisDXCoil.Name,                 // Object Name
                                                     cAlphaFields(13 + (I - 1) * 6)); // Field Name

                if (!ErrorsFound) {
                    if (state.dataCurveManager->PerfCurve(thisDXCoil.MSEIRFTemp(I))->numDims == 1) {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.MSEIRFTemp(I),
                                                    cAlphaFields(13 + (I - 1) * 6),
                                                    Alphas(13 + (I - 1) * 6),
                                                    RatedOutdoorAirTempHeat);
                    } else {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.MSEIRFTemp(I),
                                                    cAlphaFields(13 + (I - 1) * 6),
                                                    Alphas(13 + (I - 1) * 6),
                                                    RatedInletAirTempHeat,
                                                    RatedOutdoorAirTempHeat);
                    }
                }
            }

            thisDXCoil.MSEIRFFlow(I) = GetCurveIndex(state, Alphas(14 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.MSEIRFFlow(I) == 0) {
                if (lAlphaBlanks(14 + (I - 1) * 6)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(14 + (I - 1) * 6)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(14 + (I - 1) * 6), Alphas(14 + (I - 1) * 6)));
                }
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal type is Quadratic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.MSEIRFFlow(I),        // Curve index
                                                     {1},                             // Valid dimensions
                                                     RoutineName,                     // Routine name
                                                     CurrentModuleObject,             // Object Type
                                                     thisDXCoil.Name,                 // Object Name
                                                     cAlphaFields(14 + (I - 1) * 6)); // Field Name

                if (!ErrorsFound) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.MSEIRFFlow(I),
                                                cAlphaFields(14 + (I - 1) * 6),
                                                Alphas(14 + (I - 1) * 6),
                                                1.0);
                }
            }

            thisDXCoil.MSPLFFPLR(I) = GetCurveIndex(state, Alphas(15 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.MSPLFFPLR(I) == 0) {
                if (lAlphaBlanks(15 + (I - 1) * 6)) {
                    ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...required {} is blank.", cAlphaFields(15 + (I - 1) * 6)));
                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(15 + (I - 1) * 6), Alphas(15 + (I - 1) * 6)));
                }
                ErrorsFound = true;
            } else {
                // Verify Curve Object, only legal types are Quadratic or Cubic
                ErrorsFound |= Curve::CheckCurveDims(state,
                                                     thisDXCoil.MSPLFFPLR(I),         // Curve index
                                                     {1},                             // Valid dimensions
                                                     RoutineName,                     // Routine name
                                                     CurrentModuleObject,             // Object Type
                                                     thisDXCoil.Name,                 // Object Name
                                                     cAlphaFields(15 + (I - 1) * 6)); // Field Name

                if (!ErrorsFound) {
                    //       Test PLF curve minimum and maximum. Cap if less than 0.7 or greater than 1.0.
                    MinCurveVal = 999.0;
                    MaxCurveVal = -999.0;
                    CurveInput = 0.0;
                    while (CurveInput <= 1.0) {
                        CurveVal = CurveValue(state, thisDXCoil.MSPLFFPLR(I), CurveInput);
                        if (CurveVal < MinCurveVal) {
                            MinCurveVal = CurveVal;
                            MinCurvePLR = CurveInput;
                        }
                        if (CurveVal > MaxCurveVal) {
                            MaxCurveVal = CurveVal;
                            MaxCurvePLR = CurveInput;
                        }
                        CurveInput += 0.01;
                    }
                    if (MinCurveVal < 0.7) {
                        ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state,
                                          format("...{} = {} has out of range value.", cAlphaFields(15 + (I - 1) * 6), Alphas(15 + (I - 1) * 6)));
                        ShowContinueError(state,
                                          format("...Curve minimum must be >= 0.7, curve min at PLR = {:.2T} is {:.3T}", MinCurvePLR, MinCurveVal));
                        ShowContinueError(state, "...Setting curve minimum to 0.7 and simulation continues.");
                        Curve::SetCurveOutputMinValue(state, thisDXCoil.MSPLFFPLR(I), ErrorsFound, 0.7);
                    }

                    if (MaxCurveVal > 1.0) {
                        ShowWarningError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state,
                                          format("...{} = {} has out of range value.", cAlphaFields(15 + (I - 1) * 6), Alphas(15 + (I - 1) * 6)));
                        ShowContinueError(state,
                                          format("...Curve maximum must be <= 1.0, curve max at PLR = {:.2T} is {:.3T}", MaxCurvePLR, MaxCurveVal));
                        ShowContinueError(state, "...Setting curve maximum to 1.0 and simulation continues.");
                        Curve::SetCurveOutputMaxValue(state, thisDXCoil.MSPLFFPLR(I), ErrorsFound, 1.0);
                    }
                }
            }

            // Read waste heat modifier curve name
            thisDXCoil.MSWasteHeat(I) = GetCurveIndex(state, Alphas(16 + (I - 1) * 6)); // convert curve name to number
            if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {
                if (thisDXCoil.MSWasteHeat(I) > 0) {
                    // Verify Curve Object, only legal types are BiQuadratic
                    ErrorsFound |= Curve::CheckCurveDims(state,
                                                         thisDXCoil.MSWasteHeat(I),       // Curve index
                                                         {2},                             // Valid dimensions
                                                         RoutineName,                     // Routine name
                                                         CurrentModuleObject,             // Object Type
                                                         thisDXCoil.Name,                 // Object Name
                                                         cAlphaFields(16 + (I - 1) * 6)); // Field Name

                    if (!ErrorsFound) {
                        checkCurveIsNormalizedToOne(state,
                                                    std::string{RoutineName} + CurrentModuleObject,
                                                    thisDXCoil.Name,
                                                    thisDXCoil.MSWasteHeat(I),
                                                    cAlphaFields(16 + (I - 1) * 6),
                                                    Alphas(16 + (I - 1) * 6),
                                                    RatedOutdoorAirTempHeat,
                                                    RatedInletAirTempHeat);
                    }
                }
            }
        }
        // A35; \field Zone Name for Condenser Placement
        if (!lAlphaBlanks(35) && NumAlphas > 34) {
            thisDXCoil.SecZonePtr = Util::FindItemInList(Alphas(35), state.dataHeatBal->Zone);
            if (thisDXCoil.SecZonePtr > 0) {
                SetupZoneInternalGain(state,
                                      thisDXCoil.SecZonePtr,
                                      thisDXCoil.Name,
                                      DataHeatBalance::IntGainType::SecHeatingDXCoilMultiSpeed,
                                      &thisDXCoil.SecCoilSensibleHeatRemovalRate,
                                      nullptr,
                                      nullptr,
                                      &thisDXCoil.SecCoilLatentHeatRemovalRate);
                thisDXCoil.IsSecondaryDXCoilInZone = true;
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(35), Alphas(35)));
            }
        }
        if (thisDXCoil.SecZonePtr > 0) {
            for (I = 1; I <= thisDXCoil.NumOfSpeeds; ++I) {
                thisDXCoil.MSSecCoilAirFlow(I) = Numbers(34 + (I - 1) * 3);
                thisDXCoil.MSSecCoilAirFlowScalingFactor(I) = Numbers(35 + (I - 1) * 3);
                thisDXCoil.MSSecCoilRatedSHR(I) = Numbers(36 + (I - 1) * 3);
                // Read SHR modifier curve function of temperature
                if (!lAlphaBlanks(36 + (I - 1) * 2)) {
                    thisDXCoil.MSSecCoilSHRFT(I) = GetCurveIndex(state, Alphas(36 + (I - 1) * 2)); // convert curve name to number
                    if (thisDXCoil.MSSecCoilSHRFT(I) == 0) {
                        ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(36 + (I - 1) * 2), Alphas(36 + (I - 1) * 2)));
                    }
                }
                // Read SHR modifier curve function of flow fraction
                if (!lAlphaBlanks(36 + (I - 1) * 2)) {
                    thisDXCoil.MSSecCoilSHRFF(I) = GetCurveIndex(state, Alphas(36 + (I - 1) * 2)); // convert curve name to number
                    if (thisDXCoil.MSSecCoilSHRFF(I) == 0) {
                        ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                        ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(36 + (I - 1) * 2), Alphas(36 + (I - 1) * 2)));
                    }
                }
            }
        }
    }

    // Loop over the VRF Cooling Coils and get & load the data
    CurrentModuleObject = HVAC::cAllCoilTypes(HVAC::CoilVRF_Cooling);
    for (DXCoilIndex = 1; DXCoilIndex <= state.dataDXCoils->NumVRFCoolingCoils; ++DXCoilIndex) {

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXCoilIndex,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        ++DXCoilNum;

        // allocate single performance mode for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilVRF_Cooling;
        thisDXCoil.Schedule = Alphas(2);
        if (lAlphaBlanks(2)) {
            thisDXCoil.SchedPtr = ScheduleManager::ScheduleAlwaysOn;
        } else {
            thisDXCoil.SchedPtr = GetScheduleIndex(state, Alphas(2)); // convert schedule name to pointer
            if (thisDXCoil.SchedPtr == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{}=\"{}\".", cAlphaFields(2), Alphas(2)));
                ErrorsFound = true;
            }
        }
        thisDXCoil.RatedTotCap(1) = Numbers(1);
        thisDXCoil.RatedSHR(1) = Numbers(2);
        thisDXCoil.RatedAirVolFlowRate(1) = Numbers(3);

        thisDXCoil.CCapFTemp(1) = GetCurveIndex(state, Alphas(3));
        // Verify Curve Object, only legal type is Linear, Quadratic, Cubic, or BiQuadratic
        ErrorsFound |= Curve::CheckCurveDims(state,
                                             thisDXCoil.CCapFTemp(1), // Curve index
                                             {1, 2},                  // Valid dimensions  // MULTIPLECURVEDIMS
                                             RoutineName,             // Routine name
                                             CurrentModuleObject,     // Object Type
                                             thisDXCoil.Name,         // Object Name
                                             cAlphaFields(3));        // Field Name

        if (!ErrorsFound) {
            if (state.dataCurveManager->PerfCurve(thisDXCoil.CCapFTemp(1))->numDims == 1) {
                checkCurveIsNormalizedToOne(state,
                                            std::string{RoutineName} + CurrentModuleObject,
                                            thisDXCoil.Name,
                                            thisDXCoil.CCapFTemp(1),
                                            cAlphaFields(3),
                                            Alphas(3),
                                            RatedInletWetBulbTemp);
            } else {
                checkCurveIsNormalizedToOne(state,
                                            std::string{RoutineName} + CurrentModuleObject,
                                            thisDXCoil.Name,
                                            thisDXCoil.CCapFTemp(1),
                                            cAlphaFields(3),
                                            Alphas(3),
                                            RatedInletWetBulbTemp,
                                            RatedOutdoorAirTemp);
            }
        }

        thisDXCoil.CCapFFlow(1) = GetCurveIndex(state, Alphas(4)); // convert curve name to number
        if (thisDXCoil.CCapFFlow(1) == 0) {
            if (lAlphaBlanks(4)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(4)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(4), Alphas(4)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is Linear, Quadratic or Cubic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CCapFFlow(1), // Curve index
                                                 {1},                     // Valid dimensions
                                                 RoutineName,             // Routine name
                                                 CurrentModuleObject,     // Object Type
                                                 thisDXCoil.Name,         // Object Name
                                                 cAlphaFields(4));        // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(
                    state, std::string{RoutineName} + CurrentModuleObject, thisDXCoil.Name, thisDXCoil.CCapFFlow(1), cAlphaFields(4), Alphas(4), 1.0);
            }
        }

        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(5),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilCoolingDXVariableRefrigerantFlow,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);

        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(6),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilCoolingDXVariableRefrigerantFlow,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(5), Alphas(6), "Air Nodes");

        thisDXCoil.CondensateCollectName = Alphas(7);
        if (lAlphaBlanks(7)) {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::Discard;
        } else {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::ToTank;
            SetupTankSupplyComponent(state,
                                     thisDXCoil.Name,
                                     CurrentModuleObject,
                                     thisDXCoil.CondensateCollectName,
                                     ErrorsFound,
                                     thisDXCoil.CondensateTankID,
                                     thisDXCoil.CondensateTankSupplyARRID);
        }
    }

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input. Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }

    // Loop over the VRF Heating Coils and get & load the data
    CurrentModuleObject = HVAC::cAllCoilTypes(HVAC::CoilVRF_Heating);
    for (DXCoilIndex = 1; DXCoilIndex <= state.dataDXCoils->NumVRFHeatingCoils; ++DXCoilIndex) {

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXCoilIndex,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        ++DXCoilNum;

        // allocate single performance mode for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilVRF_Heating;
        thisDXCoil.Schedule = Alphas(2);
        if (lAlphaBlanks(2)) {
            thisDXCoil.SchedPtr = ScheduleManager::ScheduleAlwaysOn;
        } else {
            thisDXCoil.SchedPtr = GetScheduleIndex(state, Alphas(2)); // convert schedule name to pointer
            if (thisDXCoil.SchedPtr == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{}=\"{}\".", cAlphaFields(2), Alphas(2)));
                ErrorsFound = true;
            }
        }
        thisDXCoil.RatedTotCap(1) = Numbers(1);
        thisDXCoil.RatedAirVolFlowRate(1) = Numbers(2);

        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(3),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilHeatingDXVariableRefrigerantFlow,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);

        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(4),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilHeatingDXVariableRefrigerantFlow,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);

        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(3), Alphas(4), "Air Nodes");

        thisDXCoil.CCapFTemp = GetCurveIndex(state, Alphas(5));
        if (thisDXCoil.CCapFTemp(1) == 0) {
            if (lAlphaBlanks(5)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(5)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(5), Alphas(5)));
            }
            ErrorsFound = true;
        } else {
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CCapFTemp(1), // Curve index
                                                 {1, 2},                  // Valid dimensions  // MULTIPLECURVEDIMS
                                                 RoutineName,             // Routine name
                                                 CurrentModuleObject,     // Object Type
                                                 thisDXCoil.Name,         // Object Name
                                                 cAlphaFields(5));        // Field Name

            if (!ErrorsFound) {
                if (state.dataCurveManager->PerfCurve(thisDXCoil.CCapFTemp(1))->numDims == 1) {
                    checkCurveIsNormalizedToOne(state,
                                                std::string{RoutineName} + CurrentModuleObject,
                                                thisDXCoil.Name,
                                                thisDXCoil.CCapFTemp(1),
                                                cAlphaFields(5),
                                                Alphas(5),
                                                RatedInletAirTempHeat);
                } else {
                    // Can't check this here, don't know if using outdoor dry-bulb or outdoor wet-bulb temp as input. Make this check in VRF TU
                    // GetInput.
                }
            }
        }

        thisDXCoil.CCapFFlow(1) = GetCurveIndex(state, Alphas(6)); // convert curve name to number
        if (thisDXCoil.CCapFFlow(1) == 0) {
            if (lAlphaBlanks(6)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(6)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(6), Alphas(6)));
            }
            ErrorsFound = true;
        } else {
            // Verify Curve Object, only legal type is Quadratic
            ErrorsFound |= Curve::CheckCurveDims(state,
                                                 thisDXCoil.CCapFFlow(1), // Curve index
                                                 {1},                     // Valid dimensions
                                                 RoutineName,             // Routine name
                                                 CurrentModuleObject,     // Object Type
                                                 thisDXCoil.Name,         // Object Name
                                                 cAlphaFields(6));        // Field Name

            if (!ErrorsFound) {
                checkCurveIsNormalizedToOne(
                    state, std::string{RoutineName} + CurrentModuleObject, thisDXCoil.Name, thisDXCoil.CCapFFlow(1), cAlphaFields(6), Alphas(6), 1.0);
            }
        }
    }

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input. Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }

    // Loop over the VRF Cooling Coils for VRF FluidTCtrl Model_zrp 2015
    CurrentModuleObject = HVAC::cAllCoilTypes(HVAC::CoilVRF_FluidTCtrl_Cooling);
    for (DXCoilIndex = 1; DXCoilIndex <= state.dataDXCoils->NumVRFCoolingFluidTCtrlCoils; ++DXCoilIndex) {

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXCoilIndex,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        ++DXCoilNum;

        // allocate single performance mode for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilVRF_FluidTCtrl_Cooling;
        thisDXCoil.Schedule = Alphas(2);
        if (lAlphaBlanks(2)) {
            thisDXCoil.SchedPtr = ScheduleManager::ScheduleAlwaysOn;
        } else {
            thisDXCoil.SchedPtr = GetScheduleIndex(state, Alphas(2)); // convert schedule name to pointer
            if (thisDXCoil.SchedPtr == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{}=\"{}\".", cAlphaFields(2), Alphas(2)));
                ErrorsFound = true;
            }
        }

        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(3),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilCoolingDXVariableRefrigerantFlowFluidTemperatureControl,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);
        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(4),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilCoolingDXVariableRefrigerantFlowFluidTemperatureControl,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);
        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(3), Alphas(4), "Air Nodes");

        thisDXCoil.RatedTotCap(1) = Numbers(1);
        thisDXCoil.RatedSHR(1) = Numbers(2);
        thisDXCoil.SH = Numbers(3);
        // @@ DXCoil( DXCoilNum ).RateBFVRFIUEvap = 0.0592; there will be a new field for this, which will be handled in a separate issue to
        // update VRF-HP idd. It is not handled here to avoid transition issues for VRF-HP.

        int indexSHCurve = GetCurveIndex(state, Alphas(5)); // convert curve name to index number
        // Verify curve name and type
        if (indexSHCurve == 0) {
            if (lAlphaBlanks(5)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(5)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(5), Alphas(5)));
            }
            ErrorsFound = true;
        } else {
            {
                if (state.dataCurveManager->PerfCurve(indexSHCurve)->curveType == Curve::CurveType::Quadratic) {
                    thisDXCoil.C1Te = state.dataCurveManager->PerfCurve(indexSHCurve)->coeff[0];
                    thisDXCoil.C2Te = state.dataCurveManager->PerfCurve(indexSHCurve)->coeff[1];
                    thisDXCoil.C3Te = state.dataCurveManager->PerfCurve(indexSHCurve)->coeff[2];

                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state,
                                      format("...illegal {} type for this object = {}",
                                             cAlphaFields(5),
                                             Curve::objectNames[static_cast<int>(state.dataCurveManager->PerfCurve(indexSHCurve)->curveType)]));
                    ShowContinueError(state, "... Curve type must be Quadratic.");
                    ErrorsFound = true;
                }
            }
        }

        thisDXCoil.CondensateCollectName = Alphas(6);
        if (lAlphaBlanks(6)) {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::Discard;
        } else {
            thisDXCoil.CondensateCollectMode = CondensateCollectAction::ToTank;
            SetupTankSupplyComponent(state,
                                     thisDXCoil.Name,
                                     CurrentModuleObject,
                                     thisDXCoil.CondensateCollectName,
                                     ErrorsFound,
                                     thisDXCoil.CondensateTankID,
                                     thisDXCoil.CondensateTankSupplyARRID);
        }
    }

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input. Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }

    // Loop over the VRF Heating Coils for VRF FluidTCtrl Model_zrp 2015
    CurrentModuleObject = HVAC::cAllCoilTypes(HVAC::CoilVRF_FluidTCtrl_Heating);
    for (DXCoilIndex = 1; DXCoilIndex <= state.dataDXCoils->NumVRFHeatingFluidTCtrlCoils; ++DXCoilIndex) {

        state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                 CurrentModuleObject,
                                                                 DXCoilIndex,
                                                                 Alphas,
                                                                 NumAlphas,
                                                                 Numbers,
                                                                 NumNumbers,
                                                                 IOStatus,
                                                                 lNumericBlanks,
                                                                 lAlphaBlanks,
                                                                 cAlphaFields,
                                                                 cNumericFields);

        ++DXCoilNum;

        // allocate single performance mode for numeric field strings used for sizing routine
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode.allocate(1);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames.allocate(MaxNumbers);
        state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames = cNumericFields;
        // ErrorsFound will be set to True if problem was found, left untouched otherwise
        VerifyUniqueCoilName(state, CurrentModuleObject, Alphas(1), ErrorsFound, CurrentModuleObject + " Name");

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
        thisDXCoil.Name = Alphas(1);
        thisDXCoil.DXCoilType = CurrentModuleObject;
        thisDXCoil.DXCoilType_Num = HVAC::CoilVRF_FluidTCtrl_Heating;
        thisDXCoil.Schedule = Alphas(2);
        if (lAlphaBlanks(2)) {
            thisDXCoil.SchedPtr = ScheduleManager::ScheduleAlwaysOn;
        } else {
            thisDXCoil.SchedPtr = GetScheduleIndex(state, Alphas(2)); // convert schedule name to pointer
            if (thisDXCoil.SchedPtr == 0) {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...{}=\"{}\".", cAlphaFields(2), Alphas(2)));
                ErrorsFound = true;
            }
        }

        thisDXCoil.AirInNode = GetOnlySingleNode(state,
                                                 Alphas(3),
                                                 ErrorsFound,
                                                 DataLoopNode::ConnectionObjectType::CoilHeatingDXVariableRefrigerantFlowFluidTemperatureControl,
                                                 Alphas(1),
                                                 DataLoopNode::NodeFluidType::Air,
                                                 DataLoopNode::ConnectionType::Inlet,
                                                 NodeInputManager::CompFluidStream::Primary,
                                                 ObjectIsNotParent);
        thisDXCoil.AirOutNode = GetOnlySingleNode(state,
                                                  Alphas(4),
                                                  ErrorsFound,
                                                  DataLoopNode::ConnectionObjectType::CoilHeatingDXVariableRefrigerantFlowFluidTemperatureControl,
                                                  Alphas(1),
                                                  DataLoopNode::NodeFluidType::Air,
                                                  DataLoopNode::ConnectionType::Outlet,
                                                  NodeInputManager::CompFluidStream::Primary,
                                                  ObjectIsNotParent);
        TestCompSet(state, CurrentModuleObject, Alphas(1), Alphas(3), Alphas(4), "Air Nodes");

        thisDXCoil.RatedTotCap(1) = Numbers(1);
        thisDXCoil.SC = Numbers(2);
        //@@ DXCoil( DXCoilNum ).RateBFVRFIUCond = 0.136;

        int indexSCCurve = GetCurveIndex(state, Alphas(5)); // convert curve name to index number
        // Verify curve name and type
        if (indexSCCurve == 0) {
            if (lAlphaBlanks(5)) {
                ShowSevereError(state, format("{}{}=\"{}\", missing", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...required {} is blank.", cAlphaFields(5)));
            } else {
                ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                ShowContinueError(state, format("...not found {}=\"{}\".", cAlphaFields(5), Alphas(5)));
            }
            ErrorsFound = true;
        } else {
            {
                if (state.dataCurveManager->PerfCurve(indexSCCurve)->curveType == Curve::CurveType::Quadratic) {
                    thisDXCoil.C1Tc = state.dataCurveManager->PerfCurve(indexSCCurve)->coeff[0];
                    thisDXCoil.C2Tc = state.dataCurveManager->PerfCurve(indexSCCurve)->coeff[1];
                    thisDXCoil.C3Tc = state.dataCurveManager->PerfCurve(indexSCCurve)->coeff[2];

                } else {
                    ShowSevereError(state, format("{}{}=\"{}\", invalid", RoutineName, CurrentModuleObject, thisDXCoil.Name));
                    ShowContinueError(state,
                                      format("...illegal {} type for this object = {}",
                                             cAlphaFields(5),
                                             Curve::objectNames[static_cast<int>(state.dataCurveManager->PerfCurve(indexSCCurve)->curveType)]));
                    ShowContinueError(state, "... Curve type must be Quadratic.");
                    ErrorsFound = true;
                }
            }
        }
    }

    if (ErrorsFound) {
        ShowFatalError(state,
                       format("{}Errors found in getting {} input. Preceding condition(s) causes termination.", RoutineName, CurrentModuleObject));
    }

    for (DXCoilNum = 1; DXCoilNum <= state.dataDXCoils->NumDXCoils; ++DXCoilNum) {

        auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingSingleSpeed || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) {
            // Setup Report Variables for Cooling Equipment
            // CurrentModuleObject='Coil:Cooling:DX:SingleSpeed/Coil:Cooling:DX:TwoStageWithHumidityControlMode'
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.TotalCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::EnergyTransfer,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::CoolingCoils);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.SensCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.SensCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.LatCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.LatCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Electricity Rate",
                                Constant::Units::W,
                                thisDXCoil.ElecCoolingPower,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Electricity Energy",
                                Constant::Units::J,
                                thisDXCoil.ElecCoolingConsumption,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::Electricity,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::Cooling);
            SetupOutputVariable(state,
                                "Cooling Coil Runtime Fraction",
                                Constant::Units::None,
                                thisDXCoil.CoolingCoilRuntimeFraction,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            if (thisDXCoil.IsSecondaryDXCoilInZone) {
                SetupOutputVariable(state,
                                    "Secondary Coil Heat Rejection Rate",
                                    Constant::Units::W,
                                    thisDXCoil.SecCoilSensibleHeatGainRate,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
            }

            // do we report these even if no storage tank?
            if (thisDXCoil.CondensateCollectMode == CondensateCollectAction::ToTank) {
                SetupOutputVariable(state,
                                    "Cooling Coil Condensate Volume Flow Rate",
                                    Constant::Units::m3_s,
                                    thisDXCoil.CondensateVdot,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Condensate Volume",
                                    Constant::Units::m3,
                                    thisDXCoil.CondensateVol,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::OnSiteWater,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Condensate);
            }

            if (thisDXCoil.ReportEvapCondVars) {
                SetupOutputVariable(state,
                                    "Cooling Coil Condenser Inlet Temperature",
                                    Constant::Units::C,
                                    thisDXCoil.CondInletTemp,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Water Volume",
                                    Constant::Units::m3,
                                    thisDXCoil.EvapWaterConsump,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::Water,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Cooling);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Mains Supply Water Volume",
                                    Constant::Units::m3,
                                    thisDXCoil.EvapWaterConsump,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::MainsWater,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Cooling);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Pump Electricity Rate",
                                    Constant::Units::W,
                                    thisDXCoil.EvapCondPumpElecPower,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Pump Electricity Energy",
                                    Constant::Units::J,
                                    thisDXCoil.EvapCondPumpElecConsumption,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::Electricity,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Cooling);
                if (thisDXCoil.BasinHeaterPowerFTempDiff > 0.0) {
                    SetupOutputVariable(state,
                                        "Cooling Coil Basin Heater Electricity Rate",
                                        Constant::Units::W,
                                        thisDXCoil.BasinHeaterPower,
                                        OutputProcessor::TimeStepType::System,
                                        OutputProcessor::StoreType::Average,
                                        thisDXCoil.Name);
                    SetupOutputVariable(state,
                                        "Cooling Coil Basin Heater Electricity Energy",
                                        Constant::Units::J,
                                        thisDXCoil.BasinHeaterConsumption,
                                        OutputProcessor::TimeStepType::System,
                                        OutputProcessor::StoreType::Sum,
                                        thisDXCoil.Name,
                                        Constant::eResource::Electricity,
                                        OutputProcessor::Group::HVAC,
                                        OutputProcessor::EndUseCat::Cooling);
                }
            }

            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) {
                // Setup Report Variables for Cooling Equipment
                // CurrentModuleObject='Cooling:DX:TwoStageWithHumidityControlMode'
                SetupOutputVariable(state,
                                    "Cooling Coil Stage 2 Runtime Fraction",
                                    Constant::Units::None,
                                    thisDXCoil.CoolingCoilStg2RuntimeFrac,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Dehumidification Mode",
                                    Constant::Units::None,
                                    (int &)thisDXCoil.DehumidificationMode,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
            }

        }

        else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical) {
            // Setup Report Variables for Heating Equipment
            // CurrentModuleObject='Coil:Heating:DX:SingleSpeed'
            SetupOutputVariable(state,
                                "Heating Coil Heating Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalHeatingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Heating Coil Heating Energy",
                                Constant::Units::J,
                                thisDXCoil.TotalHeatingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::EnergyTransfer,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::HeatingCoils);
            SetupOutputVariable(state,
                                "Heating Coil Electricity Rate",
                                Constant::Units::W,
                                thisDXCoil.ElecHeatingPower,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Heating Coil Electricity Energy",
                                Constant::Units::J,
                                thisDXCoil.ElecHeatingConsumption,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::Electricity,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::Heating);
            SetupOutputVariable(state,
                                "Heating Coil Defrost Electricity Rate",
                                Constant::Units::W,
                                thisDXCoil.DefrostPower,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Heating Coil Defrost Electricity Energy",
                                Constant::Units::J,
                                thisDXCoil.DefrostConsumption,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::Electricity,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::Heating);
            SetupOutputVariable(state,
                                "Heating Coil Crankcase Heater Electricity Rate",
                                Constant::Units::W,
                                thisDXCoil.CrankcaseHeaterPower,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Heating Coil Crankcase Heater Electricity Energy",
                                Constant::Units::J,
                                thisDXCoil.CrankcaseHeaterConsumption,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::Electricity,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::Heating);
            SetupOutputVariable(state,
                                "Heating Coil Runtime Fraction",
                                Constant::Units::None,
                                thisDXCoil.HeatingCoilRuntimeFraction,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            if (thisDXCoil.IsSecondaryDXCoilInZone) {
                SetupOutputVariable(state,
                                    "Secondary Coil Total Heat Removal Rate",
                                    Constant::Units::W,
                                    thisDXCoil.SecCoilTotalHeatRemovalRate,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Secondary Coil Sensible Heat Removal Rate",
                                    Constant::Units::W,
                                    thisDXCoil.SecCoilSensibleHeatRemovalRate,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Secondary Coil Latent Heat Removal Rate",
                                    Constant::Units::W,
                                    thisDXCoil.SecCoilLatentHeatRemovalRate,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Secondary Coil Sensible Heat Ratio",
                                    Constant::Units::None,
                                    thisDXCoil.SecCoilSHR,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Secondary Coil Compressor Part Load Ratio",
                                    Constant::Units::None,
                                    thisDXCoil.CompressorPartLoadRatio,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
            }
        }

        else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
            // Setup Report Variables for Cooling Equipment
            // CurrentModuleObject='Coil:Cooling:DX:TwoSpeed'
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.TotalCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::EnergyTransfer,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::CoolingCoils);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.SensCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.SensCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.LatCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.LatCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Electricity Rate",
                                Constant::Units::W,
                                thisDXCoil.ElecCoolingPower,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Electricity Energy",
                                Constant::Units::J,
                                thisDXCoil.ElecCoolingConsumption,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::Electricity,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::Cooling);
            SetupOutputVariable(state,
                                "Cooling Coil Runtime Fraction",
                                Constant::Units::None,
                                thisDXCoil.CoolingCoilRuntimeFraction,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            if (thisDXCoil.IsSecondaryDXCoilInZone) {
                SetupOutputVariable(state,
                                    "Secondary Coil Heat Rejection Rate",
                                    Constant::Units::W,
                                    thisDXCoil.SecCoilSensibleHeatGainRate,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
            }

            if (thisDXCoil.ReportEvapCondVars) {
                SetupOutputVariable(state,
                                    "Cooling Coil Condenser Inlet Temperature",
                                    Constant::Units::C,
                                    thisDXCoil.CondInletTemp,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Water Volume",
                                    Constant::Units::m3,
                                    thisDXCoil.EvapWaterConsump,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::Water,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Cooling);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Mains Supply Water Volume",
                                    Constant::Units::m3,
                                    thisDXCoil.EvapWaterConsump,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::MainsWater,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Cooling);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Pump Electricity Rate",
                                    Constant::Units::W,
                                    thisDXCoil.EvapCondPumpElecPower,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Pump Electricity Energy",
                                    Constant::Units::J,
                                    thisDXCoil.EvapCondPumpElecConsumption,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::Electricity,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Cooling);
                if (thisDXCoil.BasinHeaterPowerFTempDiff > 0.0) {
                    SetupOutputVariable(state,
                                        "Cooling Coil Basin Heater Electricity Rate",
                                        Constant::Units::W,
                                        thisDXCoil.BasinHeaterPower,
                                        OutputProcessor::TimeStepType::System,
                                        OutputProcessor::StoreType::Average,
                                        thisDXCoil.Name);
                    SetupOutputVariable(state,
                                        "Cooling Coil Basin Heater Electricity Energy",
                                        Constant::Units::J,
                                        thisDXCoil.BasinHeaterConsumption,
                                        OutputProcessor::TimeStepType::System,
                                        OutputProcessor::StoreType::Sum,
                                        thisDXCoil.Name,
                                        Constant::eResource::Electricity,
                                        OutputProcessor::Group::HVAC,
                                        OutputProcessor::EndUseCat::Cooling);
                }
            }

        }

        else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
                 thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
            // Setup Report Variables for Cooling Equipment
            // CurrentModuleObject='Coil:WaterHeating:AirToWaterHeatPump:Pumped'
            // or 'Coil:WaterHeating:AirToWaterHeatPump:Wrapped'
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);

            if (thisDXCoil.IsDXCoilInZone) {
                SetupOutputVariable(state,
                                    "Cooling Coil Total Cooling Energy",
                                    Constant::Units::J,
                                    thisDXCoil.TotalCoolingEnergy,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::EnergyTransfer,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::CoolingCoils);
            } else {
                SetupOutputVariable(state,
                                    "Cooling Coil Total Cooling Energy",
                                    Constant::Units::J,
                                    thisDXCoil.TotalCoolingEnergy,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name);
            }

            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.SensCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.SensCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.LatCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.LatCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Runtime Fraction",
                                Constant::Units::None,
                                thisDXCoil.CoolingCoilRuntimeFraction,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);

            if (thisDXCoil.ReportCoolingCoilCrankcasePower) {
                SetupOutputVariable(state,
                                    "Cooling Coil Crankcase Heater Electricity Rate",
                                    Constant::Units::W,
                                    thisDXCoil.CrankcaseHeaterPower,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Crankcase Heater Electricity Energy",
                                    Constant::Units::J,
                                    thisDXCoil.CrankcaseHeaterConsumption,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::Electricity,
                                    OutputProcessor::Group::Plant,
                                    OutputProcessor::EndUseCat::WaterSystem); // DHW
            }

            // new report variables for a HP water heater DX coil
            SetupOutputVariable(state,
                                "Cooling Coil Total Water Heating Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalHeatingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Total Water Heating Energy",
                                Constant::Units::J,
                                thisDXCoil.TotalHeatingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name); //, &
            //                           ResourceTypeKey='ENERGYTRANSFER',EndUseKey='HEATING',GroupKey='Plant')
            SetupOutputVariable(state,
                                "Cooling Coil Water Heating Electricity Rate",
                                Constant::Units::W,
                                thisDXCoil.ElecWaterHeatingPower,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Water Heating Electricity Energy",
                                Constant::Units::J,
                                thisDXCoil.ElecWaterHeatingConsumption,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::Electricity,
                                OutputProcessor::Group::Plant,
                                OutputProcessor::EndUseCat::WaterSystem); // DHW
        }

        else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedCooling) {
            // Setup Report Variables for Cooling Equipment:
            // CurrentModuleObject='Coil:Cooling:DX:MultiSpeed'
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.TotalCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::EnergyTransfer,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::CoolingCoils);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.SensCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.SensCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.LatCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.LatCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Electricity Rate",
                                Constant::Units::W,
                                thisDXCoil.ElecCoolingPower,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Electricity Energy",
                                Constant::Units::J,
                                thisDXCoil.ElecCoolingConsumption,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::Electricity,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::Cooling);

            if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {
                std::string_view sFuelType = Constant::eFuelNames[static_cast<int>(thisDXCoil.FuelType)];
                SetupOutputVariable(state,
                                    format("Cooling Coil {} Rate", sFuelType),
                                    Constant::Units::W,
                                    thisDXCoil.FuelUsed,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    format("Cooling Coil {} Energy", sFuelType),
                                    Constant::Units::J,
                                    thisDXCoil.FuelConsumed,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eFuel2eResource[(int)thisDXCoil.FuelType],
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Cooling);
            }

            SetupOutputVariable(state,
                                "Cooling Coil Runtime Fraction",
                                Constant::Units::None,
                                thisDXCoil.CoolingCoilRuntimeFraction,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);

            if (thisDXCoil.ReportEvapCondVars) {
                SetupOutputVariable(state,
                                    "Cooling Coil Condenser Inlet Temperature",
                                    Constant::Units::C,
                                    thisDXCoil.CondInletTemp,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Water Volume",
                                    Constant::Units::m3,
                                    thisDXCoil.EvapWaterConsump,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::Water,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Cooling);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Mains Supply Water Volume",
                                    Constant::Units::m3,
                                    thisDXCoil.EvapWaterConsump,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::MainsWater,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Cooling);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Pump Electricity Rate",
                                    Constant::Units::W,
                                    thisDXCoil.EvapCondPumpElecPower,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Evaporative Condenser Pump Electricity Energy",
                                    Constant::Units::J,
                                    thisDXCoil.EvapCondPumpElecConsumption,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::Electricity,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Cooling);
                if (thisDXCoil.BasinHeaterPowerFTempDiff > 0.0) {
                    SetupOutputVariable(state,
                                        "Cooling Coil Basin Heater Electricity Rate",
                                        Constant::Units::W,
                                        thisDXCoil.BasinHeaterPower,
                                        OutputProcessor::TimeStepType::System,
                                        OutputProcessor::StoreType::Average,
                                        thisDXCoil.Name);
                    SetupOutputVariable(state,
                                        "Cooling Coil Basin Heater Electricity Energy",
                                        Constant::Units::J,
                                        thisDXCoil.BasinHeaterConsumption,
                                        OutputProcessor::TimeStepType::System,
                                        OutputProcessor::StoreType::Sum,
                                        thisDXCoil.Name,
                                        Constant::eResource::Electricity,
                                        OutputProcessor::Group::HVAC,
                                        OutputProcessor::EndUseCat::Cooling);
                }
            }
            if (thisDXCoil.IsSecondaryDXCoilInZone) {
                SetupOutputVariable(state,
                                    "Secondary Coil Heat Rejection Rate",
                                    Constant::Units::W,
                                    thisDXCoil.SecCoilSensibleHeatGainRate,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
            }

        }

        else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating) {
            // Setup Report Variables for Heating Equipment:
            // CurrentModuleObject='Coil:Heating:DX:MultiSpeed'
            SetupOutputVariable(state,
                                "Heating Coil Heating Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalHeatingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Heating Coil Heating Energy",
                                Constant::Units::J,
                                thisDXCoil.TotalHeatingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::EnergyTransfer,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::HeatingCoils);
            SetupOutputVariable(state,
                                "Heating Coil Electricity Rate",
                                Constant::Units::W,
                                thisDXCoil.ElecHeatingPower,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Heating Coil Electricity Energy",
                                Constant::Units::J,
                                thisDXCoil.ElecHeatingConsumption,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::Electricity,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::Heating);

            if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {
                std::string_view sFuelType = Constant::eFuelNames[static_cast<int>(thisDXCoil.FuelType)];
                SetupOutputVariable(state,
                                    format("Heating Coil {} Rate", sFuelType),
                                    Constant::Units::W,
                                    thisDXCoil.FuelUsed,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    format("Heating Coil {} Energy", sFuelType),
                                    Constant::Units::J,
                                    thisDXCoil.FuelConsumed,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eFuel2eResource[(int)thisDXCoil.FuelType],
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::HeatingCoils);
            }

            if (thisDXCoil.FuelType != Constant::eFuel::Electricity && thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::ReverseCycle) {
                std::string_view sFuelType = Constant::eFuelNames[static_cast<int>(thisDXCoil.FuelType)];
                SetupOutputVariable(state,
                                    format("Heating Coil Defrost {} Rate", sFuelType),
                                    Constant::Units::W,
                                    thisDXCoil.DefrostPower,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    format("Heating Coil Defrost {} Energy", sFuelType),
                                    Constant::Units::J,
                                    thisDXCoil.DefrostConsumption,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eFuel2eResource[(int)thisDXCoil.FuelType],
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Heating);
            } else {
                SetupOutputVariable(state,
                                    "Heating Coil Defrost Electricity Rate",
                                    Constant::Units::W,
                                    thisDXCoil.DefrostPower,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Heating Coil Defrost Electricity Energy",
                                    Constant::Units::J,
                                    thisDXCoil.DefrostConsumption,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::Electricity,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Heating);
            }

            SetupOutputVariable(state,
                                "Heating Coil Crankcase Heater Electricity Rate",
                                Constant::Units::W,
                                thisDXCoil.CrankcaseHeaterPower,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Heating Coil Crankcase Heater Electricity Energy",
                                Constant::Units::J,
                                thisDXCoil.CrankcaseHeaterConsumption,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::Electricity,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::Heating);
            SetupOutputVariable(state,
                                "Heating Coil Runtime Fraction",
                                Constant::Units::None,
                                thisDXCoil.HeatingCoilRuntimeFraction,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);

            if (thisDXCoil.IsSecondaryDXCoilInZone) {
                SetupOutputVariable(state,
                                    "Secondary Coil Total Heat Removal Rate",
                                    Constant::Units::W,
                                    thisDXCoil.SecCoilTotalHeatRemovalRate,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Secondary Coil Sensible Heat Removal Rate",
                                    Constant::Units::W,
                                    thisDXCoil.SecCoilSensibleHeatRemovalRate,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Secondary Coil Latent Heat Removal Rate",
                                    Constant::Units::W,
                                    thisDXCoil.SecCoilLatentHeatRemovalRate,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Secondary Coil Sensible Heat Ratio",
                                    Constant::Units::None,
                                    thisDXCoil.SecCoilSHR,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
            }
        }

        // VRF cooling coil report variables
        else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Cooling) {
            // Setup Report Variables for Cooling Equipment:
            // CurrentModuleObject='Coil:Cooling:DX:VariableRefrigerantFlow
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.TotalCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::EnergyTransfer,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::CoolingCoils);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.SensCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.SensCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.LatCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.LatCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Runtime Fraction",
                                Constant::Units::None,
                                thisDXCoil.CoolingCoilRuntimeFraction,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            if (thisDXCoil.CondensateCollectMode == CondensateCollectAction::ToTank) {
                SetupOutputVariable(state,
                                    "Cooling Coil Condensate Volume Flow Rate",
                                    Constant::Units::m3_s,
                                    thisDXCoil.CondensateVdot,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Condensate Volume",
                                    Constant::Units::m3,
                                    thisDXCoil.CondensateVol,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::OnSiteWater,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Condensate);
            }
        }

        // VRF heating coil report variables
        else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Heating) {
            // Setup Report Variables for Heating Equipment:
            // CurrentModuleObject='Coil:Heating:DX:VariableRefrigerantFlow
            SetupOutputVariable(state,
                                "Heating Coil Heating Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalHeatingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Heating Coil Heating Energy",
                                Constant::Units::J,
                                thisDXCoil.TotalHeatingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::EnergyTransfer,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::HeatingCoils);
            SetupOutputVariable(state,
                                "Heating Coil Runtime Fraction",
                                Constant::Units::None,
                                thisDXCoil.HeatingCoilRuntimeFraction,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
        }

        // VRF cooling coil for FluidTCtrl, report variables
        else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Cooling) {
            // Setup Report Variables for Cooling Equipment:
            // CurrentModuleObject='Coil:Cooling:DX:VariableRefrigerantFlow:FluidTemperatureControl
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Total Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.TotalCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::EnergyTransfer,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::CoolingCoils);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.SensCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Sensible Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.SensCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Rate",
                                Constant::Units::W,
                                thisDXCoil.LatCoolingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Latent Cooling Energy",
                                Constant::Units::J,
                                thisDXCoil.LatCoolingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil Runtime Fraction",
                                Constant::Units::None,
                                thisDXCoil.CoolingCoilRuntimeFraction,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            // Followings for VRF_FluidTCtrl Only
            SetupOutputVariable(state,
                                "Cooling Coil VRF Evaporating Temperature",
                                Constant::Units::C,
                                thisDXCoil.EvaporatingTemp,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Cooling Coil VRF Super Heating Degrees",
                                Constant::Units::C,
                                thisDXCoil.ActualSH,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);

            if (thisDXCoil.CondensateCollectMode == CondensateCollectAction::ToTank) {
                SetupOutputVariable(state,
                                    "Cooling Coil Condensate Volume Flow Rate",
                                    Constant::Units::m3_s,
                                    thisDXCoil.CondensateVdot,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Average,
                                    thisDXCoil.Name);
                SetupOutputVariable(state,
                                    "Cooling Coil Condensate Volume",
                                    Constant::Units::m3,
                                    thisDXCoil.CondensateVol,
                                    OutputProcessor::TimeStepType::System,
                                    OutputProcessor::StoreType::Sum,
                                    thisDXCoil.Name,
                                    Constant::eResource::OnSiteWater,
                                    OutputProcessor::Group::HVAC,
                                    OutputProcessor::EndUseCat::Condensate);
            }
        }

        // VRF heating coil for FluidTCtrl, report variables
        else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Heating) {
            // Setup Report Variables for Heating Equipment:
            // CurrentModuleObject='Coil:Heating:DX:VariableRefrigerantFlow:FluidTemperatureControl
            SetupOutputVariable(state,
                                "Heating Coil Heating Rate",
                                Constant::Units::W,
                                thisDXCoil.TotalHeatingEnergyRate,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Heating Coil Heating Energy",
                                Constant::Units::J,
                                thisDXCoil.TotalHeatingEnergy,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Sum,
                                thisDXCoil.Name,
                                Constant::eResource::EnergyTransfer,
                                OutputProcessor::Group::HVAC,
                                OutputProcessor::EndUseCat::HeatingCoils);
            SetupOutputVariable(state,
                                "Heating Coil Runtime Fraction",
                                Constant::Units::None,
                                thisDXCoil.HeatingCoilRuntimeFraction,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            // Followings for VRF_FluidTCtrl Only
            SetupOutputVariable(state,
                                "Heating Coil VRF Condensing Temperature",
                                Constant::Units::C,
                                thisDXCoil.CondensingTemp,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
            SetupOutputVariable(state,
                                "Heating Coil VRF Subcooling Degrees",
                                Constant::Units::C,
                                thisDXCoil.ActualSC,
                                OutputProcessor::TimeStepType::System,
                                OutputProcessor::StoreType::Average,
                                thisDXCoil.Name);
        }
    }

    if (state.dataGlobal->AnyEnergyManagementSystemInModel) {
        // setup EMS sizing actuators for single speed DX
        for (DXCoilNum = 1; DXCoilNum <= state.dataDXCoils->NumDoe2DXCoils; ++DXCoilNum) {

            auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

            SetupEMSActuator(state,
                             "Coil:Cooling:DX:SingleSpeed",
                             thisDXCoil.Name,
                             "Autosized Rated Air Flow Rate",
                             "[m3/s]",
                             thisDXCoil.RatedAirVolFlowRateEMSOverrideON(1),
                             thisDXCoil.RatedAirVolFlowRateEMSOverrideValue(1));

            SetupEMSActuator(state,
                             "Coil:Cooling:DX:SingleSpeed",
                             thisDXCoil.Name,
                             "Autosized Rated Sensible Heat Ratio",
                             "[W/W]",
                             thisDXCoil.RatedSHREMSOverrideOn(1),
                             thisDXCoil.RatedSHREMSOverrideValue(1));

            SetupEMSActuator(state,
                             "Coil:Cooling:DX:SingleSpeed",
                             thisDXCoil.Name,
                             "Autosized Rated Total Cooling Capacity",
                             "[W]",
                             thisDXCoil.RatedTotCapEMSOverrideOn(1),
                             thisDXCoil.RatedTotCapEMSOverrideValue(1));
        }
    }
    Alphas.deallocate();
    cAlphaFields.deallocate();
    cNumericFields.deallocate();
    Numbers.deallocate();
    lAlphaBlanks.deallocate();
    lNumericBlanks.deallocate();

    Alphas2.deallocate();
    cAlphaFields2.deallocate();
    cNumericFields2.deallocate();
    Numbers2.deallocate();
    lAlphaBlanks2.deallocate();
    lNumericBlanks2.deallocate();
    bool anyEMSRan;
    ManageEMS(state, EMSManager::EMSCallFrom::ComponentGetInput, anyEMSRan, ObjexxFCL::Optional_int_const());
}

void InitDXCoil(EnergyPlusData &state, int const DXCoilNum) // number of the current DX coil unit being simulated
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Fred Buhl
    //       DATE WRITTEN   May 2000
    //                      Feb 2005, M. J. Witte, GARD Analytics, Inc. Add new coil type COIL:DX:MultiMode:CoolingEmpirical:
    //                      Jul 2005, R. Raustad, FSEC. Add new coil type COIL:DX:HEATPUMPWATERHEATER
    //                      Jun 2007, L. Gu, FSEC. Add new coil type COIL:DX:MULTISPEED:COOLING and HEATING
    //                      Aug 2015, R. Zhang, LBNL. Add new coil types for VRF_FluidTCtrl

    // PURPOSE OF THIS SUBROUTINE:
    // This subroutine is for initializations of DX Coil Components.

    // METHODOLOGY EMPLOYED:
    // Uses the status flags to trigger initializations.

    // SUBROUTINE PARAMETER DEFINITIONS:
    constexpr Real64 SmallDifferenceTest(0.00000001);
    static constexpr std::string_view RoutineName("InitDXCoil");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 RatedHeatPumpIndoorAirTemp; // Indoor dry-bulb temperature to heat pump evaporator at rated conditions [C]
    Real64 RatedHeatPumpIndoorHumRat;  // Inlet humidity ratio to heat pump evaporator at rated conditions [kgWater/kgDryAir]
    Real64 RatedVolFlowPerRatedTotCap; // Rated Air Volume Flow Rate divided by Rated Total Capacity [m3/s-W)
    Real64 HPInletAirHumRat;           // Rated inlet air humidity ratio for heat pump water heater [kgWater/kgDryAir]
    bool ErrorsFound(false);           // TRUE when errors found
    int CapacityStageNum;              // Loop index for 1,Number of capacity stages
    int DehumidModeNum;                // Loop index for 1,Number of enhanced dehumidification modes
    int Mode;                          // Performance mode for MultiMode DX coil; Always 1 for other coil types
    int DXCoilNumTemp;                 // Counter for crankcase heater report variable DO loop
    int AirInletNode;                  // Air inlet node number
    int SpeedNum;                      // Speed number for multispeed coils

    if (state.dataDXCoils->MyOneTimeFlag) {
        // initialize the environment and sizing flags
        state.dataDXCoils->MyEnvrnFlag.dimension(state.dataDXCoils->NumDXCoils, true);
        state.dataDXCoils->MySizeFlag.dimension(state.dataDXCoils->NumDXCoils, true);
        state.dataDXCoils->MyOneTimeFlag = false;
    }

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    // if "ISHundredPercentDOASDXCoil" =.TRUE., then set coil as 100% DOAS dx coil
    state.dataHVACGlobal->DXCT = (thisDXCoil.ISHundredPercentDOASDXCoil) ? HVAC::DXCoilType::DOAS : HVAC::DXCoilType::Regular;

    if ((thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
         thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) &&
        state.dataDXCoils->MyEnvrnFlag(DXCoilNum)) {

        SizeDXCoil(state, DXCoilNum);

        RatedVolFlowPerRatedTotCap = thisDXCoil.RatedAirVolFlowRate(1) / thisDXCoil.RatedTotCap2;
        if (((HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT] - RatedVolFlowPerRatedTotCap) > SmallDifferenceTest) ||
            ((RatedVolFlowPerRatedTotCap - HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) > SmallDifferenceTest)) {
            ShowWarningError(state,
                             format("{} \"{}\": Rated air volume flow rate per watt of rated total water heating capacity is out of range",
                                    thisDXCoil.DXCoilType,
                                    thisDXCoil.Name));
            ShowContinueError(state,
                              format("Min Rated Vol Flow Per Watt=[{:.3T}], Rated Vol Flow Per Watt=[{:.3T}], Max Rated Vol Flow Per "
                                     "Watt=[{:.3T}]. See Input-Output Reference Manual for valid range.",
                                     HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                     RatedVolFlowPerRatedTotCap,
                                     HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
        }
        HPInletAirHumRat =
            PsyWFnTdbTwbPb(state, thisDXCoil.RatedInletDBTemp, thisDXCoil.RatedInletWBTemp, DataEnvironment::StdPressureSeaLevel, RoutineName);
        state.dataHVACGlobal->HPWHInletDBTemp = thisDXCoil.RatedInletDBTemp;
        state.dataHVACGlobal->HPWHInletWBTemp = thisDXCoil.RatedInletWBTemp;
        thisDXCoil.RatedAirMassFlowRate(1) =
            thisDXCoil.RatedAirVolFlowRate(1) *
            PsyRhoAirFnPbTdbW(state, state.dataEnvrn->StdBaroPress, thisDXCoil.RatedInletDBTemp, HPInletAirHumRat, RoutineName);
        //   get rated coil bypass factor excluding fan heat

        //   call CalcHPWHDXCoil to determine DXCoil%RatedTotCap(1) for rated CBF calculation below
        CalcHPWHDXCoil(state, DXCoilNum, 1.0);
        if (state.dataDXCoils->MySizeFlag(DXCoilNum)) {
            SizeDXCoil(state, DXCoilNum);
            state.dataDXCoils->MySizeFlag(DXCoilNum) = false;
        }

        thisDXCoil.RatedCBF(1) = CalcCBF(state,
                                         thisDXCoil.DXCoilType,
                                         thisDXCoil.Name,
                                         thisDXCoil.RatedInletDBTemp,
                                         HPInletAirHumRat,
                                         thisDXCoil.RatedTotCap(1),
                                         thisDXCoil.RatedAirVolFlowRate(1),
                                         thisDXCoil.RatedSHR(1),
                                         true);
        state.dataDXCoils->MyEnvrnFlag(DXCoilNum) = false;
    }

    if ((thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedCooling || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating) &&
        state.dataDXCoils->MyEnvrnFlag(DXCoilNum)) {
        if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {
            if (thisDXCoil.MSHPHeatRecActive) {
                for (SpeedNum = 1; SpeedNum <= thisDXCoil.NumOfSpeeds; ++SpeedNum) {
                    if (thisDXCoil.MSWasteHeat(SpeedNum) == 0) {
                        ShowWarningError(
                            state,
                            format("GetDXCoils:{}. The value of Waste Heat Function of Temperature Curve is assumed to be 1. Simulation continues. ",
                                   thisDXCoil.Name));
                        break;
                    }
                }
            }
        }
        state.dataDXCoils->MyEnvrnFlag(DXCoilNum) = false;
    }

    // Find the companion upstream coil (DX cooling coil) that is used with DX heating coils (HP AC units only)
    if (thisDXCoil.FindCompanionUpStreamCoil) {
        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating) {
            thisDXCoil.CompanionUpstreamDXCoil = GetHPCoolingCoilIndex(state, thisDXCoil.DXCoilType, thisDXCoil.Name, DXCoilNum);
            if (thisDXCoil.CompanionUpstreamDXCoil > 0) {
                state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).ReportCoolingCoilCrankcasePower = false;
                thisDXCoil.FindCompanionUpStreamCoil = false;
                //       Copy condenser node number from DX cooling coil when used with a companion DX heating coil
                for (Mode = 1; Mode <= MaxModes; ++Mode) {
                    thisDXCoil.CondenserInletNodeNum(Mode) =
                        state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).CondenserInletNodeNum(Mode);
                }
            }
        } else {
            thisDXCoil.FindCompanionUpStreamCoil = false;
        }
    } // IF(DXCoil(DXCoilNum)%FindCompanionUpStreamCoil)THEN

    // CR7308 - Wait for zone and air loop equipment to be simulated, then print out report variables
    if (state.dataDXCoils->CrankcaseHeaterReportVarFlag) {
        if (state.dataAirLoop->AirLoopInputsFilled) {
            //     Set report variables for DX cooling coils that will have a crankcase heater (all DX coils not used in a HP AC unit)
            for (DXCoilNumTemp = 1; DXCoilNumTemp <= state.dataDXCoils->NumDXCoils; ++DXCoilNumTemp) {
                if ((state.dataDXCoils->DXCoil(DXCoilNumTemp).DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) ||
                    (state.dataDXCoils->DXCoil(DXCoilNumTemp).DXCoilType_Num == HVAC::CoilDX_CoolingSingleSpeed) ||
                    (state.dataDXCoils->DXCoil(DXCoilNumTemp).DXCoilType_Num == HVAC::CoilDX_MultiSpeedCooling)) {
                    if (state.dataDXCoils->DXCoil(DXCoilNumTemp).ReportCoolingCoilCrankcasePower) {
                        SetupOutputVariable(state,
                                            "Cooling Coil Crankcase Heater Electricity Rate",
                                            Constant::Units::W,
                                            state.dataDXCoils->DXCoil(DXCoilNumTemp).CrankcaseHeaterPower,
                                            OutputProcessor::TimeStepType::System,
                                            OutputProcessor::StoreType::Average,
                                            state.dataDXCoils->DXCoil(DXCoilNumTemp).Name);
                        SetupOutputVariable(state,
                                            "Cooling Coil Crankcase Heater Electricity Energy",
                                            Constant::Units::J,
                                            state.dataDXCoils->DXCoil(DXCoilNumTemp).CrankcaseHeaterConsumption,
                                            OutputProcessor::TimeStepType::System,
                                            OutputProcessor::StoreType::Sum,
                                            state.dataDXCoils->DXCoil(DXCoilNumTemp).Name,
                                            Constant::eResource::Electricity,
                                            OutputProcessor::Group::HVAC,
                                            OutputProcessor::EndUseCat::Cooling);
                        state.dataDXCoils->DXCoil(DXCoilNumTemp).ReportCoolingCoilCrankcasePower = false;
                    }
                }
            }
            state.dataDXCoils->CrankcaseHeaterReportVarFlag = false;
        } //(AirLoopInputsFilled)THEN
    }     //(CrankcaseHeaterReportVarFlag)THEN

    if (!state.dataGlobal->SysSizingCalc && state.dataDXCoils->MySizeFlag(DXCoilNum)) {
        // for each coil, do the sizing once.
        SizeDXCoil(state, DXCoilNum);
        state.dataDXCoils->MySizeFlag(DXCoilNum) = false;

        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingSingleSpeed || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed ||
            thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Cooling || thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Cooling) {

            Mode = 1;
            // Check for zero capacity or zero max flow rate
            if (thisDXCoil.RatedTotCap(Mode) <= 0.0) {
                ShowSevereError(state, format("Sizing: {} {} has zero rated total capacity", thisDXCoil.DXCoilType, thisDXCoil.Name));
                ErrorsFound = true;
            }
            if (thisDXCoil.RatedAirVolFlowRate(Mode) <= 0.0) {
                ShowSevereError(state, format("Sizing: {} {} has zero rated air flow rate", thisDXCoil.DXCoilType, thisDXCoil.Name));
                ErrorsFound = true;
            }
            if (ErrorsFound) {
                ShowFatalError(state, "Preceding condition causes termination.");
            }

            // Check for valid range of (Rated Air Volume Flow Rate / Rated Total Capacity)
            if (thisDXCoil.DXCoilType_Num !=
                HVAC::CoilVRF_FluidTCtrl_Cooling) { // the VolFlowPerRatedTotCap check is not applicable for VRF-FluidTCtrl coil
                RatedVolFlowPerRatedTotCap = thisDXCoil.RatedAirVolFlowRate(Mode) / thisDXCoil.RatedTotCap(Mode);
                if (((HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT] - RatedVolFlowPerRatedTotCap) > SmallDifferenceTest) ||
                    ((RatedVolFlowPerRatedTotCap - HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) > SmallDifferenceTest)) {
                    ShowWarningError(state,
                                     format("Sizing: {} \"{}\": Rated air volume flow rate per watt of rated total cooling capacity is out of range.",
                                            thisDXCoil.DXCoilType,
                                            thisDXCoil.Name));
                    ShowContinueError(state,
                                      format("Min Rated Vol Flow Per Watt=[{:.3T}], Rated Vol Flow Per Watt=[{:.3T}], Max Rated Vol Flow Per "
                                             "Watt=[{:.3T}]. See Input Output Reference Manual for valid range.",
                                             HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             RatedVolFlowPerRatedTotCap,
                                             HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
                }
            }

            thisDXCoil.RatedAirMassFlowRate(Mode) =
                thisDXCoil.RatedAirVolFlowRate(Mode) *
                PsyRhoAirFnPbTdbW(state, state.dataEnvrn->StdBaroPress, RatedInletAirTemp, RatedInletAirHumRat, RoutineName);
            // get high speed rated coil bypass factor
            thisDXCoil.RatedCBF(Mode) = CalcCBF(state,
                                                thisDXCoil.DXCoilType,
                                                thisDXCoil.Name,
                                                RatedInletAirTemp,
                                                RatedInletAirHumRat,
                                                thisDXCoil.RatedTotCap(Mode),
                                                thisDXCoil.RatedAirVolFlowRate(Mode),
                                                thisDXCoil.RatedSHR(Mode));

            // call coil model with everything set at rating point
            thisDXCoil.InletAirMassFlowRate = thisDXCoil.RatedAirMassFlowRate(Mode);
            thisDXCoil.InletAirMassFlowRateMax = thisDXCoil.RatedAirMassFlowRate(Mode);
            thisDXCoil.InletAirTemp = RatedInletAirTemp;
            Real64 tempInletAirHumRat =
                Psychrometrics::PsyWFnTdbTwbPb(state, RatedInletAirTemp, RatedInletWetBulbTemp, DataEnvironment::StdPressureSeaLevel, RoutineName);
            // DXCoil( DXCoilNum ).InletAirHumRat = RatedInletAirHumRat; // this seems inconsistent with dry bulb and wetbulb, filed NREL issue
            // #5934  Real64 tempInletAirWetBulb = Psychrometrics::PsyTwbFnTdbWPb( RatedInletAirTemp, RatedInletAirHumRat,
            // DataEnvironment::StdPressureSeaLevel );
            thisDXCoil.InletAirHumRat = tempInletAirHumRat;
            thisDXCoil.InletAirEnthalpy = Psychrometrics::PsyHFnTdbW(RatedInletAirTemp, tempInletAirHumRat);

            // store environment data fill back in after rating point calc is over
            Real64 holdOutDryBulbTemp = state.dataEnvrn->OutDryBulbTemp;
            Real64 holdOutHumRat = state.dataEnvrn->OutHumRat;
            Real64 holdOutWetBulb = state.dataEnvrn->OutWetBulbTemp;
            Real64 holdOutBaroPress = state.dataEnvrn->OutBaroPress;
            Real64 ratedOutdoorAirWetBulb = 23.9; // from I/O ref. more precise value?
            state.dataEnvrn->OutDryBulbTemp = RatedOutdoorAirTemp;
            state.dataEnvrn->OutWetBulbTemp = ratedOutdoorAirWetBulb;
            state.dataEnvrn->OutBaroPress = DataEnvironment::StdPressureSeaLevel; // assume rating is for sea level.
            state.dataEnvrn->OutHumRat =
                Psychrometrics::PsyWFnTdbTwbPb(state, RatedOutdoorAirTemp, ratedOutdoorAirWetBulb, DataEnvironment::StdPressureSeaLevel, RoutineName);
            if (thisDXCoil.CondenserInletNodeNum(1) > 0) { // set condenser inlet node values
                state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).Temp = RatedOutdoorAirTemp;
                state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).HumRat = state.dataEnvrn->OutHumRat;
                state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).OutAirWetBulb = ratedOutdoorAirWetBulb;
            }

            // calculate coil model at rating point
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingSingleSpeed) {
                CalcDoe2DXCoil(state, DXCoilNum, HVAC::CompressorOp::On, false, 1.0, HVAC::FanOp::Cycling, _, 1.0);
            } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
                CalcMultiSpeedDXCoil(state, DXCoilNum, 1.0, 1.0);
            } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Cooling) {
                CalcVRFCoolingCoil(state, DXCoilNum, HVAC::CompressorOp::On, false, 1.0, HVAC::FanOp::Cycling, 1.0, _, _, _);
            } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Cooling) {
                CalcVRFCoolingCoil_FluidTCtrl(
                    state, DXCoilNum, HVAC::CompressorOp::On, false, 1.0, HVAC::FanOp::Cycling, 1.0, _, _, Constant::MaxCap);
            }

            // coil outlets
            Real64 RatedOutletWetBulb(0.0);
            RatedOutletWetBulb = Psychrometrics::PsyTwbFnTdbWPb(
                state, thisDXCoil.OutletAirTemp, thisDXCoil.OutletAirHumRat, DataEnvironment::StdPressureSeaLevel, RoutineName);

            state.dataRptCoilSelection->coilSelectionReportObj->setRatedCoilConditions(
                state,
                thisDXCoil.Name,
                thisDXCoil.DXCoilType,
                thisDXCoil.TotalCoolingEnergyRate, // this is the report variable
                thisDXCoil.SensCoolingEnergyRate,  // this is the report variable
                thisDXCoil.InletAirMassFlowRate,
                thisDXCoil.InletAirTemp,
                thisDXCoil.InletAirHumRat,
                RatedInletWetBulbTemp,
                thisDXCoil.OutletAirTemp,
                thisDXCoil.OutletAirHumRat,
                RatedOutletWetBulb,
                RatedOutdoorAirTemp,
                ratedOutdoorAirWetBulb,
                thisDXCoil.RatedCBF(Mode),
                -999.0); // coil effectiveness not define for DX

            // now replace the outdoor air conditions set above for one time rating point calc
            state.dataEnvrn->OutDryBulbTemp = holdOutDryBulbTemp;
            state.dataEnvrn->OutHumRat = holdOutHumRat;
            state.dataEnvrn->OutWetBulbTemp = holdOutWetBulb;
            state.dataEnvrn->OutBaroPress = holdOutBaroPress;
        }

        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) {
            for (DehumidModeNum = 0; DehumidModeNum <= thisDXCoil.NumDehumidModes; ++DehumidModeNum) {
                for (CapacityStageNum = 1; CapacityStageNum <= thisDXCoil.NumCapacityStages; ++CapacityStageNum) {
                    Mode = DehumidModeNum * 2 + CapacityStageNum;
                    // Check for zero capacity or zero max flow rate
                    if (thisDXCoil.RatedTotCap(Mode) <= 0.0) {
                        ShowSevereError(state, format("Sizing: {} {} has zero rated total capacity", thisDXCoil.DXCoilType, thisDXCoil.Name));
                        ShowContinueError(state, format("for CoilPerformance:DX:Cooling mode: {}", thisDXCoil.CoilPerformanceName(Mode)));
                        ErrorsFound = true;
                    }
                    if (thisDXCoil.RatedAirVolFlowRate(Mode) <= 0.0) {
                        ShowSevereError(state, format("Sizing: {} {} has zero rated air flow rate", thisDXCoil.DXCoilType, thisDXCoil.Name));
                        ShowContinueError(state, format("for CoilPerformance:DX:Cooling mode: {}", thisDXCoil.CoilPerformanceName(Mode)));
                        ErrorsFound = true;
                    }
                    if (ErrorsFound) {
                        ShowFatalError(state, "Preceding condition causes termination.");
                    }
                    // Check for valid range of (Rated Air Volume Flow Rate / Rated Total Capacity)
                    RatedVolFlowPerRatedTotCap = thisDXCoil.RatedAirVolFlowRate(Mode) / thisDXCoil.RatedTotCap(Mode);
                    if (((HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT] - RatedVolFlowPerRatedTotCap) > SmallDifferenceTest) ||
                        ((RatedVolFlowPerRatedTotCap - HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) > SmallDifferenceTest)) {
                        ShowWarningError(
                            state,
                            format("Sizing: {} \"{}\": Rated air volume flow rate per watt of rated total cooling capacity is out of range.",
                                   thisDXCoil.DXCoilType,
                                   thisDXCoil.Name));
                        ShowContinueError(state,
                                          format("Min Rated Vol Flow Per Watt=[{:.3T}], Rated Vol Flow Per Watt=[{:.3T}], Max Rated Vol Flow Per "
                                                 "Watt=[{:.3T}]. See Input Output Reference Manual for valid range.",
                                                 HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                                 RatedVolFlowPerRatedTotCap,
                                                 HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
                        ShowContinueError(state, format("for CoilPerformance:DX:Cooling mode: {}", thisDXCoil.CoilPerformanceName(Mode)));
                    }
                    thisDXCoil.RatedAirMassFlowRate(Mode) =
                        thisDXCoil.RatedAirVolFlowRate(Mode) *
                        PsyRhoAirFnPbTdbW(state, state.dataEnvrn->StdBaroPress, RatedInletAirTemp, RatedInletAirHumRat, RoutineName);
                    // get rated coil bypass factor
                    thisDXCoil.RatedCBF(Mode) = CalcCBF(state,
                                                        thisDXCoil.CoilPerformanceType(Mode),
                                                        thisDXCoil.CoilPerformanceName(Mode),
                                                        RatedInletAirTemp,
                                                        RatedInletAirHumRat,
                                                        thisDXCoil.RatedTotCap(Mode),
                                                        thisDXCoil.RatedAirVolFlowRate(Mode),
                                                        thisDXCoil.RatedSHR(Mode));
                } // End capacity stages loop
            }     // End dehumidification modes loop
        }

        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical || thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Heating ||
            thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Heating) {

            Mode = 1;
            if (thisDXCoil.RatedTotCap(Mode) <= 0.0) {
                ShowSevereError(state, format("Sizing: {} {} has zero rated total capacity", thisDXCoil.DXCoilType, thisDXCoil.Name));
                ErrorsFound = true;
            }
            if (thisDXCoil.RatedAirVolFlowRate(Mode) <= 0.0) {
                ShowSevereError(state, format("Sizing: {} {} has zero rated air flow rate", thisDXCoil.DXCoilType, thisDXCoil.Name));
                ErrorsFound = true;
            }
            if (ErrorsFound) {
                ShowFatalError(state, "Preceding condition causes termination.");
            }
            RatedHeatPumpIndoorAirTemp = 21.11;  // 21.11C or 70F
            RatedHeatPumpIndoorHumRat = 0.00881; // Humidity ratio corresponding to 70F dry bulb/60F wet bulb
            thisDXCoil.RatedAirMassFlowRate(Mode) =
                thisDXCoil.RatedAirVolFlowRate(Mode) *
                PsyRhoAirFnPbTdbW(state, state.dataEnvrn->StdBaroPress, RatedHeatPumpIndoorAirTemp, RatedHeatPumpIndoorHumRat, RoutineName);

            // Check for valid range of (Rated Air Volume Flow Rate / Rated Total Capacity)
            if (thisDXCoil.DXCoilType_Num !=
                HVAC::CoilVRF_FluidTCtrl_Heating) { // the VolFlowPerRatedTotCap check is not applicable for VRF-FluidTCtrl coil
                RatedVolFlowPerRatedTotCap = thisDXCoil.RatedAirVolFlowRate(Mode) / thisDXCoil.RatedTotCap(Mode);
                if (((HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT] - RatedVolFlowPerRatedTotCap) > SmallDifferenceTest) ||
                    ((RatedVolFlowPerRatedTotCap - HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) > SmallDifferenceTest)) {
                    ShowWarningError(state,
                                     format("Sizing: {} {}: Rated air volume flow rate per watt of rated total heating capacity is out of range.",
                                            thisDXCoil.DXCoilType,
                                            thisDXCoil.Name));
                    ShowContinueError(state,
                                      format("Min Rated Vol Flow Per Watt=[{:.3T}], Rated Vol Flow Per Watt=[{:.3T}], Max Rated Vol Flow Per "
                                             "Watt=[{:.3T}]. See Input-Output Reference Manual for valid range.",
                                             HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             RatedVolFlowPerRatedTotCap,
                                             HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
                }
            }

            // call coil model with everything set at rating point
            thisDXCoil.InletAirMassFlowRate = thisDXCoil.RatedAirMassFlowRate(Mode);
            thisDXCoil.InletAirMassFlowRateMax = thisDXCoil.RatedAirMassFlowRate(Mode);

            thisDXCoil.InletAirTemp = RatedInletAirTempHeat;
            Real64 tempInletAirHumRat = Psychrometrics::PsyWFnTdbTwbPb(
                state, RatedInletAirTempHeat, RatedInletWetBulbTempHeat, DataEnvironment::StdPressureSeaLevel, RoutineName);
            thisDXCoil.InletAirHumRat = tempInletAirHumRat;
            thisDXCoil.InletAirEnthalpy = Psychrometrics::PsyHFnTdbW(RatedInletAirTempHeat, tempInletAirHumRat);

            // store environment data fill back in after rating point calc is over
            Real64 holdOutDryBulbTemp = state.dataEnvrn->OutDryBulbTemp;
            Real64 holdOutHumRat = state.dataEnvrn->OutHumRat;
            Real64 holdOutWetBulb = state.dataEnvrn->OutWetBulbTemp;
            Real64 holdOutBaroPress = state.dataEnvrn->OutBaroPress;

            state.dataEnvrn->OutDryBulbTemp = RatedOutdoorAirTempHeat;

            Real64 ratedOutdoorAirWetBulb = 6.11; // from I/O ref. more precise value?
            state.dataEnvrn->OutWetBulbTemp = ratedOutdoorAirWetBulb;
            state.dataEnvrn->OutBaroPress = DataEnvironment::StdPressureSeaLevel; // assume rating is for sea level.
            state.dataEnvrn->OutHumRat = Psychrometrics::PsyWFnTdbTwbPb(
                state, RatedOutdoorAirTempHeat, ratedOutdoorAirWetBulb, DataEnvironment::StdPressureSeaLevel, RoutineName);

            if (thisDXCoil.CondenserInletNodeNum(1) > 0) { // set condenser inlet node values
                state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).Temp = RatedOutdoorAirTempHeat;
                state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).HumRat = state.dataEnvrn->OutHumRat;
                state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).OutAirWetBulb = ratedOutdoorAirWetBulb;
            }

            // calculate coil model at rating point
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical) {
                CalcDXHeatingCoil(state, DXCoilNum, 1.0, HVAC::FanOp::Cycling, 1.0);
            } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Heating) {
                CalcDXHeatingCoil(state, DXCoilNum, 1.0, HVAC::FanOp::Cycling, _, _);
            } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Heating) {
                CalcVRFHeatingCoil_FluidTCtrl(state, HVAC::CompressorOp::On, DXCoilNum, 1.0, HVAC::FanOp::Cycling, _, _);
            }
            // coil outlets
            Real64 RatedOutletWetBulb(0.0);
            RatedOutletWetBulb = Psychrometrics::PsyTwbFnTdbWPb(
                state, thisDXCoil.OutletAirTemp, thisDXCoil.OutletAirHumRat, DataEnvironment::StdPressureSeaLevel, RoutineName);

            state.dataRptCoilSelection->coilSelectionReportObj->setRatedCoilConditions(
                state,
                thisDXCoil.Name,
                thisDXCoil.DXCoilType,
                thisDXCoil.TotalHeatingEnergyRate, // this is the report variable
                thisDXCoil.TotalHeatingEnergyRate, // this is the report variable
                thisDXCoil.InletAirMassFlowRate,
                thisDXCoil.InletAirTemp,
                thisDXCoil.InletAirHumRat,
                RatedInletWetBulbTempHeat,
                thisDXCoil.OutletAirTemp,
                thisDXCoil.OutletAirHumRat,
                RatedOutletWetBulb,
                RatedOutdoorAirTempHeat,
                ratedOutdoorAirWetBulb,
                thisDXCoil.RatedCBF(Mode),
                -999.0); // coil effectiveness not define for DX

            // now replace the outdoor air conditions set above for one time rating point calc
            state.dataEnvrn->OutDryBulbTemp = holdOutDryBulbTemp;
            state.dataEnvrn->OutHumRat = holdOutHumRat;
            state.dataEnvrn->OutWetBulbTemp = holdOutWetBulb;
            state.dataEnvrn->OutBaroPress = holdOutBaroPress;
        }

        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
            // Check for valid range of (Rated Air Volume Flow Rate / Rated Total Capacity)
            RatedVolFlowPerRatedTotCap = thisDXCoil.RatedAirVolFlowRate2 / thisDXCoil.RatedTotCap2;
            if (((HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT] - RatedVolFlowPerRatedTotCap) > SmallDifferenceTest) ||
                ((RatedVolFlowPerRatedTotCap - HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) > SmallDifferenceTest)) {
                ShowWarningError(state,
                                 format("Coil:Cooling:DX:TwoSpeed \"{}\": At low speed rated air volume flow rate per watt of rated total cooling "
                                        "capacity is out of range.",
                                        thisDXCoil.Name));
                ShowContinueError(state,
                                  format("Min Rated Vol Flow Per Watt=[{:.3T}], Rated Vol Flow Per Watt=[{:.3T}], Max Rated Vol Flow Per "
                                         "Watt=[{:.3T}]. See Input-Output Reference Manual for valid range.",
                                         HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                         RatedVolFlowPerRatedTotCap,
                                         HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
            }

            thisDXCoil.RatedAirMassFlowRate2 =
                thisDXCoil.RatedAirVolFlowRate2 *
                PsyRhoAirFnPbTdbW(state, state.dataEnvrn->StdBaroPress, RatedInletAirTemp, RatedInletAirHumRat, RoutineName);
            // get low speed rated coil bypass factor
            thisDXCoil.RatedCBF2 = CalcCBF(state,
                                           thisDXCoil.DXCoilType,
                                           thisDXCoil.Name,
                                           RatedInletAirTemp,
                                           RatedInletAirHumRat,
                                           thisDXCoil.RatedTotCap2,
                                           thisDXCoil.RatedAirVolFlowRate2,
                                           thisDXCoil.RatedSHR2);

            // call for standard ratings for two-speed DX coil
            if (thisDXCoil.CondenserType(1) == DataHeatBalance::RefrigCondenserType::Air) {
                CalcTwoSpeedDXCoilStandardRating(state, DXCoilNum);
            }
        }

        // Multispeed Cooling
        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedCooling) {
            for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds; ++Mode) {
                // Check for zero capacity or zero max flow rate
                if (thisDXCoil.MSRatedTotCap(Mode) <= 0.0) {
                    ShowSevereError(state,
                                    format("Sizing: {} {} has zero rated total capacity at speed {}", thisDXCoil.DXCoilType, thisDXCoil.Name, Mode));
                    ErrorsFound = true;
                }
                if (thisDXCoil.MSRatedAirVolFlowRate(Mode) <= 0.0) {
                    ShowSevereError(state,
                                    format("Sizing: {} {} has zero rated air flow rate at speed {}", thisDXCoil.DXCoilType, thisDXCoil.Name, Mode));
                    ErrorsFound = true;
                }
                if (ErrorsFound) {
                    ShowFatalError(state, "Preceding condition causes termination.");
                }
                // Check for valid range of (Rated Air Volume Flow Rate / Rated Total Capacity)
                RatedVolFlowPerRatedTotCap = thisDXCoil.MSRatedAirVolFlowRate(Mode) / thisDXCoil.MSRatedTotCap(Mode);
                if (((HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT] - RatedVolFlowPerRatedTotCap) > SmallDifferenceTest) ||
                    ((RatedVolFlowPerRatedTotCap - HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) > SmallDifferenceTest)) {
                    ShowWarningError(
                        state,
                        format("Sizing: {} \"{}\": Rated air volume flow rate per watt of rated total cooling capacity is out of range at speed {}",
                               thisDXCoil.DXCoilType,
                               thisDXCoil.Name,
                               Mode));
                    ShowContinueError(state,
                                      format("Min Rated Vol Flow Per Watt=[{:.3T}], Rated Vol Flow Per Watt=[{:.3T}], Max Rated Vol Flow Per "
                                             "Watt=[{:.3T}]. See Input Output Reference Manual for valid range.",
                                             HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             RatedVolFlowPerRatedTotCap,
                                             HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
                }
                thisDXCoil.MSRatedAirMassFlowRate(Mode) =
                    thisDXCoil.MSRatedAirVolFlowRate(Mode) *
                    PsyRhoAirFnPbTdbW(state, state.dataEnvrn->StdBaroPress, RatedInletAirTemp, RatedInletAirHumRat, RoutineName);
                // get high speed rated coil bypass factor
                thisDXCoil.MSRatedCBF(Mode) = CalcCBF(state,
                                                      thisDXCoil.DXCoilType,
                                                      thisDXCoil.Name,
                                                      RatedInletAirTemp,
                                                      RatedInletAirHumRat,
                                                      thisDXCoil.MSRatedTotCap(Mode),
                                                      thisDXCoil.MSRatedAirVolFlowRate(Mode),
                                                      thisDXCoil.MSRatedSHR(Mode));
            }
        }

        // Multispeed Heating
        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating) {
            RatedHeatPumpIndoorAirTemp = 21.11;  // 21.11C or 70F
            RatedHeatPumpIndoorHumRat = 0.00881; // Humidity ratio corresponding to 70F dry bulb/60F wet bulb
            for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds; ++Mode) {

                thisDXCoil.MSRatedAirMassFlowRate(Mode) =
                    thisDXCoil.MSRatedAirVolFlowRate(Mode) *
                    PsyRhoAirFnPbTdbW(state, state.dataEnvrn->StdBaroPress, RatedHeatPumpIndoorAirTemp, RatedHeatPumpIndoorHumRat, RoutineName);
                // Check for valid range of (Rated Air Volume Flow Rate / Rated Total Capacity)
                RatedVolFlowPerRatedTotCap = thisDXCoil.MSRatedAirVolFlowRate(Mode) / thisDXCoil.MSRatedTotCap(Mode);
                if (((HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT] - RatedVolFlowPerRatedTotCap) > SmallDifferenceTest) ||
                    ((RatedVolFlowPerRatedTotCap - HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) > SmallDifferenceTest)) {
                    ShowWarningError(state,
                                     format("Coil:Heating:DX:MultiSpeed {}: Rated air volume flow rate per watt of rated total heating capacity "
                                            "is out of range at speed {}",
                                            thisDXCoil.Name,
                                            Mode));
                    ShowContinueError(state,
                                      format("Min Rated Vol Flow Per Watt=[{:.3T}], Rated Vol Flow Per Watt=[{:.3T}], Max Rated Vol Flow Per "
                                             "Watt=[{:.3T}]. See Input Output Reference Manual for valid range.",
                                             HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             RatedVolFlowPerRatedTotCap,
                                             HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
                }
            }
        }

        // store fan info for coil
        state.dataRptCoilSelection->coilSelectionReportObj->setCoilSupplyFanInfo(
            state, thisDXCoil.Name, thisDXCoil.DXCoilType, thisDXCoil.SupplyFanName, thisDXCoil.supplyFanType, thisDXCoil.SupplyFanIndex);
    }

    AirInletNode = thisDXCoil.AirInNode;

    // Each iteration, load the coil data structure with the inlet conditions

    thisDXCoil.InletAirMassFlowRate = state.dataLoopNodes->Node(AirInletNode).MassFlowRate;
    thisDXCoil.InletAirMassFlowRateMax =
        max(state.dataLoopNodes->Node(AirInletNode).MassFlowRateMax, state.dataLoopNodes->Node(AirInletNode).MassFlowRate);
    thisDXCoil.InletAirTemp = state.dataLoopNodes->Node(AirInletNode).Temp;
    thisDXCoil.InletAirHumRat = state.dataLoopNodes->Node(AirInletNode).HumRat;
    thisDXCoil.InletAirEnthalpy = state.dataLoopNodes->Node(AirInletNode).Enthalpy;
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    //  DXCoil(DXCoilNum)%InletAirPressure        = Node(AirInletNode)%Press

    if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating) {
        if (thisDXCoil.IsSecondaryDXCoilInZone) {
            thisDXCoil.EvapInletWetBulb = PsyTwbFnTdbWPb(state,
                                                         state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr).ZT,
                                                         state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr).airHumRat,
                                                         state.dataEnvrn->OutBaroPress,
                                                         RoutineName);
        }
    }

    if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
        thisDXCoil.TotalHeatingEnergyRate = 0.0;
        thisDXCoil.ElecWaterHeatingPower = 0.0;
        //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
        //  DXCoil(DXCoilNum)%InletAirPressure         = StdBaroPress

        //   HPWH's that use an inlet air temperature schedule also need to have a valid barometric pressure
        //   The DX Coil used in HPWH's does not know if it is using a scheduled inlet temperature so check the node pressure
        if (thisDXCoil.CondenserInletNodeNum(1) > 0) {
            if (state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).Press == 0.0) {
                state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).Press = state.dataEnvrn->StdBaroPress;
            }
        }
    }
    thisDXCoil.BasinHeaterPower = 0.0;

    if (thisDXCoil.IsSecondaryDXCoilInZone) {
        thisDXCoil.CompressorPartLoadRatio = 0.0;
        thisDXCoil.SecCoilSensibleHeatGainRate = 0.0;
        thisDXCoil.SecCoilTotalHeatRemovalRate = 0.0;
        thisDXCoil.SecCoilSensibleHeatRemovalRate = 0.0;
        thisDXCoil.SecCoilLatentHeatRemovalRate = 0.0;
    }
}

void SizeDXCoil(EnergyPlusData &state, int const DXCoilNum)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Fred Buhl
    //       DATE WRITTEN   January 2002
    //                      Feb 2005, M. J. Witte, GARD Analytics, Inc. Add new coil type COIL:DX:MultiMode:CoolingEmpirical.
    //                      Jul 2005, R. Raustad, FSEC. Add new coil type COIL:DX:HEATPUMPWATERHEATER
    //                      Jun 2007, L. Gu, FSEC. Add new coil type COIL:DX:MULTISPEED:COOLING and HEATING
    //                      Jan 2011, B. Griffith, NREL. add EMS overrides for autosized fields
    //                      Aug 2013, D. Kang. add component sizing table entries
    //                      May 2014, R. Raustad, FSEC. moved sizing calculations to common routine
    //                      Aug 2015, R. Zhang, LBNL. Add new coil types for VRF_FluidTCtrl
    //       RE-ENGINEERED  na

    // PURPOSE OF THIS SUBROUTINE:
    // This subroutine is for sizing DX Coil components for which nominal capacity and air flow rate
    // have not been specified in the input.

    // METHODOLOGY EMPLOYED:
    // Obtains cooling capacities and air flow rates from the zone or system sizing arrays.

    // Using/Aliasing
    using namespace DataSizing;
    using Curve::CurveValue;

    using namespace OutputReportPredefined;
    using StandardRatings::CalcDXCoilStandardRating;

    // SUBROUTINE PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineName("SizeDXCoil");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 CoilInTemp;       // DX coil inlet temperature
    int CapacityStageNum;    // Loop index for 1,Number of capacity stages
    int DehumidModeNum;      // Loop index for 1,Number of enhanced dehumidification modes
    int Mode;                // Operating mode for MultiMode DX coil; Always 1 for other coil types
    int NumOfSpeedCompanion; // Number of speed for a companion cooling coil (Multispeed HO heating coil only
    std::string equipName;
    Real64 DefrostCapacityDes;             // Design defrost heater capacity for reporting
    Real64 DefrostCapacityUser;            // Hard-sized defrost heater capacity for reporting
    Real64 MSRatedAirVolFlowRateDes;       // Design multispeed rated air volume flow rate for reporting
    Real64 MSRatedTotCapDesAtMaxSpeed;     // Design multispeed rated total capacity for reporting (at maximum speed)
    Real64 MSRatedSHRDes;                  // Design multispeed rated SHR for reporting
    Real64 MSEvapCondAirFlowDes;           // Design evaporative condenser air flow for reporting
    Real64 MSEvapCondAirFlowUser;          // Hard-sized evaporative condenser air flow for reporting
    Real64 MSEvapCondPumpElecNomPowerDes;  // Design evaporative condenser pump rated power consumption for reporting
    Real64 MSEvapCondPumpElecNomPowerUser; // Hard-sized evaporative condenser pump rated power consumption for reporting
    bool HardSizeNoDesRun;                 // Indicator to a hard-sized field with no design sizing data
    bool IsAutoSize;                       // Indicator to autosize for reporting
    bool SizingDesRunThisAirSys;           // true if a particular air system had a Sizing:System object and system sizing done
    bool SizingDesRunThisZone;             // true if a particular zone had a Sizing:Zone object and zone sizing was done
    std::string CompName;                  // component name
    std::string CompType;                  // component type
    std::string SizingString;              // input field sizing description (e.g., Nominal Capacity)
    bool bPRINT = true;                    // TRUE if sizing is reported to output (eio)
    Real64 TempSize;                       // autosized value of coil input field
    int FieldNum = 2;                      // IDD numeric field number where input field description is found
    bool PrintFlag;                        // TRUE when sizing information is reported in the eio file
    bool SizeSecDXCoil;                    // if true do sizing calculation for secondary coil
    Real64 SecCoilAirFlowDes;              // Design secondary DX coil air flow for reporting
    Real64 SecCoilAirFlowUser;             // Hard-sized secondary DX coil air flow for reporting

    // Initiate all reporting variables
    if (state.dataSize->SysSizingRunDone || state.dataSize->ZoneSizingRunDone) {
        HardSizeNoDesRun = false;
    } else {
        HardSizeNoDesRun = true;
    }

    if (state.dataSize->CurSysNum > 0) {
        CheckThisAirSystemForSizing(state, state.dataSize->CurSysNum, SizingDesRunThisAirSys);
    } else {
        SizingDesRunThisAirSys = false;
    }
    if (state.dataSize->CurZoneEqNum > 0) {
        CheckThisZoneForSizing(state, state.dataSize->CurZoneEqNum, SizingDesRunThisZone);
    } else {
        SizingDesRunThisZone = false;
    }

    IsAutoSize = false;
    SizeSecDXCoil = false;
    MSRatedTotCapDesAtMaxSpeed = 0.0;
    DefrostCapacityDes = 0.0;
    DefrostCapacityUser = 0.0;
    MSRatedAirVolFlowRateDes = 0.0;
    MSRatedSHRDes = 0.0;
    MSEvapCondAirFlowDes = 0.0;
    MSEvapCondAirFlowUser = 0.0;
    MSEvapCondPumpElecNomPowerDes = 0.0;
    MSEvapCondPumpElecNomPowerUser = 0.0;
    SecCoilAirFlowDes = 0.0;
    SecCoilAirFlowUser = 0.0;

    // Sizer classes
    CoolingSHRSizer sizerCoolingSHR;
    bool ErrorsFound = false;

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    // NOTE: we are sizing COIL:DX:HeatingEmpirical on the COOLING load. Thus the cooling and
    // and heating capacities of a DX heat pump system will be identical. In real life the AHRI
    // heating and cooling capacities are close but not identical.
    for (DehumidModeNum = 0; DehumidModeNum <= thisDXCoil.NumDehumidModes; ++DehumidModeNum) {
        for (CapacityStageNum = 1; CapacityStageNum <= thisDXCoil.NumCapacityStages; ++CapacityStageNum) {
            Mode = DehumidModeNum * 2 + CapacityStageNum;
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
                thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
                if (thisDXCoil.RatedAirVolFlowRate(1) == Constant::AutoCalculate) {
                    // report autocalculated sizing
                    PrintFlag = true;
                    CompName = thisDXCoil.Name;
                    CompType = thisDXCoil.DXCoilType;
                    // DXCoil( DXCoilNum ).RatedAirVolFlowRate( 1 ) = DXCoil( DXCoilNum ).RatedTotCap2 * 0.00005035
                    state.dataSize->DataConstantUsedForSizing = thisDXCoil.RatedTotCap2;
                    state.dataSize->DataFractionUsedForSizing = 0.00005035;
                    TempSize = AutoSize;
                    AutoCalculateSizer sizerHPRatedAirVolFlow;
                    std::string stringOverride = "Rated Evaporator Air Flow Rate [m3/s]";
                    if (state.dataGlobal->isEpJSON) stringOverride = "rated_evaporator_air_flow_rate [m3/s]";
                    sizerHPRatedAirVolFlow.overrideSizingString(stringOverride);
                    sizerHPRatedAirVolFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                    thisDXCoil.RatedAirVolFlowRate(1) = sizerHPRatedAirVolFlow.size(state, TempSize, ErrorsFound);
                    PrintFlag = false;
                }

                if (thisDXCoil.RatedHPWHCondWaterFlow == Constant::AutoCalculate) {
                    // report autocalculated sizing
                    PrintFlag = true;
                    CompName = thisDXCoil.Name;
                    CompType = thisDXCoil.DXCoilType;
                    // DXCoil( DXCoilNum ).RatedAirVolFlowRate( 1 ) = DXCoil( DXCoilNum ).RatedTotCap2 * 0.00000004487
                    state.dataSize->DataConstantUsedForSizing = thisDXCoil.RatedTotCap2;
                    state.dataSize->DataFractionUsedForSizing = 0.00000004487;
                    TempSize = AutoSize;
                    AutoCalculateSizer sizerHPWHCondWaterFlow;
                    std::string stringOverride = "Rated Condenser Water Flow Rate [m3/s]";
                    if (state.dataGlobal->isEpJSON) stringOverride = "rated_condenser_water_flow_rate [m3/s]";
                    sizerHPWHCondWaterFlow.overrideSizingString(stringOverride);
                    sizerHPWHCondWaterFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                    thisDXCoil.RatedHPWHCondWaterFlow = sizerHPWHCondWaterFlow.size(state, TempSize, ErrorsFound);
                    PrintFlag = false;
                }
            } else {
                PrintFlag = true;
                FieldNum = 0;
                if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) {
                    CompName = thisDXCoil.Name + ":" + thisDXCoil.CoilPerformanceName(Mode);
                    FieldNum = 4;
                    state.dataSize->DataBypassFrac = thisDXCoil.BypassedFlowFrac(Mode);
                } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical) {
                    CompName = thisDXCoil.Name;
                    FieldNum = 3;
                    // doesn't look like this is needed for air flow sizing, only for heating capacity sizing
                    state.dataSize->DataCoolCoilCap =
                        state.dataSize->DXCoolCap; // pass global variable used only for heat pumps (i.e., DX cooling and heating coils)
                    if ((thisDXCoil.IsSecondaryDXCoilInZone) &&
                        (thisDXCoil.CondenserType(1) ==
                         DataHeatBalance::RefrigCondenserType::Air)) { // secondary DX coil in secondary zone is specified
                        SizeSecDXCoil = true;
                    }
                } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Heating) {
                    CompName = thisDXCoil.Name;
                    FieldNum = 2;
                } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Cooling) {
                    CompName = thisDXCoil.Name;
                    FieldNum = 3;
                } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Heating) {
                    CompName = thisDXCoil.Name;
                } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Cooling) {
                    CompName = thisDXCoil.Name;
                } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedCooling) {
                    thisDXCoil.RatedAirVolFlowRate(Mode) = thisDXCoil.MSRatedAirVolFlowRate(thisDXCoil.NumOfSpeeds);
                    CompName = thisDXCoil.Name;
                    PrintFlag = false;
                } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating) {
                    thisDXCoil.RatedAirVolFlowRate(Mode) = thisDXCoil.MSRatedAirVolFlowRate(thisDXCoil.NumOfSpeeds);
                    CompName = thisDXCoil.Name;
                    PrintFlag = false;
                } else {
                    CompName = thisDXCoil.Name;
                    FieldNum = 4;
                }

                TempSize = thisDXCoil.RatedAirVolFlowRate(Mode);
                if (FieldNum > 0) {
                    SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(Mode).FieldNames(FieldNum) + " [m3/s]";
                } else {
                    SizingString = "Rated Air Flow Rate [m3/s]";
                }
                CompType = thisDXCoil.DXCoilType;
                state.dataSize->DataIsDXCoil = true;
                state.dataSize->DataEMSOverrideON = thisDXCoil.RatedAirVolFlowRateEMSOverrideON(Mode);
                state.dataSize->DataEMSOverride = thisDXCoil.RatedAirVolFlowRateEMSOverrideValue(Mode);
                if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating || thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Heating ||
                    thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Heating || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical) {
                    bool errorsFound = false;
                    HeatingAirFlowSizer sizingHeatingAirFlow;
                    sizingHeatingAirFlow.overrideSizingString(SizingString);
                    // sizingHeatingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                    sizingHeatingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                    thisDXCoil.RatedAirVolFlowRate(Mode) = sizingHeatingAirFlow.size(state, TempSize, errorsFound);
                } else {
                    bool errorsFound = false;
                    CoolingAirFlowSizer sizingCoolingAirFlow;
                    sizingCoolingAirFlow.overrideSizingString(SizingString);
                    // sizingCoolingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                    sizingCoolingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                    thisDXCoil.RatedAirVolFlowRate(Mode) = sizingCoolingAirFlow.size(state, TempSize, errorsFound);
                }
                state.dataSize->DataIsDXCoil = false;
                state.dataSize->DataEMSOverrideON = false;
                state.dataSize->DataEMSOverride = 0.0;
                state.dataSize->DataBypassFrac = 0.0;
            }

            state.dataSize->DataFlowUsedForSizing = thisDXCoil.RatedAirVolFlowRate(Mode);
            // get autosized air flow for capacity calc's if capacity is not autosized
            // *** RAR this if block is a last minute addition to correct capacity reporting when not autosized and a sizing run is done. Test
            // suite was not run with this code included. *** The question here is if the autosized air flow rate or the user specified air flow
            // rate should be used to calculate capacity removing this for now until more is known
            //                if ( DXCoil( DXCoilNum ).RatedTotCap( Mode ) != AutoSize && ( ( SysSizingRunDone && CurSysNum > 0 ) ||
            //(  ZoneSizingRunDone && CurZoneEqNum > 0 ) ) ) {                     if ( DXCoil( DXCoilNum ).DXCoilType_Num ==
            // HVAC::CoilDX_CoolingTwoStageWHumControl ) {                         SizingMethod = CoolingAirflowSizing;
            //                        DataBypassFrac = DXCoil ( DXCoilNum ).BypassedFlowFrac ( Mode );
            //                    } else if ( DXCoil( DXCoilNum ).DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical ) {
            //                        SizingMethod = HeatingAirflowSizing;
            ////                        DataCoolCoilCap = DXCoolCap; // pass global variable used only for heat pumps (i.e.,
            /// DX  cooling  and  heating coils)
            //                    } else if ( DXCoil( DXCoilNum ).DXCoilType_Num == HVAC::CoilVRF_Heating ) {
            //                        SizingMethod = HeatingAirflowSizing;
            //                    } else if ( DXCoil( DXCoilNum ).DXCoilType_Num == HVAC::CoilVRF_Cooling ) {
            //                        SizingMethod = CoolingAirflowSizing;
            //                    } else {
            //                        SizingMethod = CoolingAirflowSizing;
            //                    }
            //                    CompName = DXCoil( DXCoilNum ).Name;
            //                    TempSize = AutoSize;
            //                    SizingString.clear(); // don't care
            //                    CompType = DXCoil( DXCoilNum ).DXCoilType;
            //                    DataIsDXCoil = true;
            //                    DataEMSOverrideON = DXCoil ( DXCoilNum ).RatedAirVolFlowRateEMSOverrideON ( Mode );
            //                    DataEMSOverride = DXCoil( DXCoilNum ).RatedAirVolFlowRateEMSOverrideValue( Mode );
            //                  CoolingAirFlowSizer sizingCoolingAirFlow;
            //                  sizingCoolingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
            //                  sizingCoolingAirFlow.initializeWithinEP(state, CompType, CompName, bPRINT, RoutineName);
            //                  DataAirFlowUsedForSizing = sizingCoolingAirFlow.size(state, TempSize, errorsFound);
            //                    DataIsDXCoil = false; // don't need this and next 2, they are just overwritten below. Delete
            // on  next  pass so testing will show problems if any.                     DataEMSOverrideON = false;
            //                    DataEMSOverride = 0.0;
            //                    DataBypassFrac = 0.0;
            //                }
            PrintFlag = true;
            state.dataSize->DataTotCapCurveIndex = thisDXCoil.CCapFTemp(Mode);
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) {
                CompName = thisDXCoil.Name + ":" + thisDXCoil.CoilPerformanceName(Mode);
                FieldNum = 1;
                TempSize = thisDXCoil.RatedTotCap(Mode);
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(Mode).FieldNames(FieldNum) + " [W]";
            } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical || thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Heating ||
                       thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Heating) {
                CompName = thisDXCoil.Name;
                FieldNum = 1;
                TempSize = thisDXCoil.RatedTotCap(Mode);
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(Mode).FieldNames(FieldNum) + " [W]";
                state.dataSize->DataCoolCoilCap = state.dataSize->DXCoolCap;
            } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
                       thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
                CompName = thisDXCoil.Name;
                FieldNum = 1;
                TempSize = thisDXCoil.RatedTotCap(Mode);
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(Mode).FieldNames(FieldNum) + " [W]";
                PrintFlag = false;
                state.dataLoopNodes->Node(thisDXCoil.WaterInNode).Temp =
                    thisDXCoil.RatedInletWaterTemp; // set the rated water inlet node for HPWHs for use in CalcHPWHDXCoil
            } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Cooling) {
                CompName = thisDXCoil.Name;
                FieldNum = 1;
                TempSize = thisDXCoil.RatedTotCap(Mode);
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(Mode).FieldNames(FieldNum) + " [W]";
                if (state.dataSize->CurZoneEqNum > 0) {
                    CoilInTemp =
                        state.dataSize->ZoneSizingRunDone ? state.dataSize->FinalZoneSizing(state.dataSize->CurZoneEqNum).DesCoolCoilInTemp : 26;
                } else {
                    if (state.dataSize->CurOASysNum > 0) {
                        CoilInTemp =
                            state.dataSize->SysSizingRunDone ? state.dataSize->FinalSysSizing(state.dataSize->CurSysNum).OutTempAtCoolPeak : 32;
                    } else {
                        CoilInTemp =
                            state.dataSize->SysSizingRunDone ? state.dataSize->FinalSysSizing(state.dataSize->CurSysNum).MixTempAtCoolPeak : 26;
                    }
                }
                CalcVRFCoilCapModFac(state, 0, _, CompName, CoilInTemp, _, _, _, state.dataSize->DataTotCapCurveValue);
            } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedCooling) {
                CompName = thisDXCoil.Name;
                FieldNum = 7 + (thisDXCoil.NumOfSpeeds - 1) * 13;
                state.dataSize->DataTotCapCurveIndex = thisDXCoil.MSCCapFTemp(thisDXCoil.NumOfSpeeds);
                TempSize = thisDXCoil.MSRatedTotCap(thisDXCoil.NumOfSpeeds);
                PrintFlag = false;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(Mode).FieldNames(FieldNum) + " [W]";
            } else if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating) {
                CompName = thisDXCoil.Name;
                FieldNum = 10 + (thisDXCoil.NumOfSpeeds - 1) * 6;
                state.dataSize->DataTotCapCurveIndex = thisDXCoil.MSCCapFTemp(thisDXCoil.NumOfSpeeds);
                TempSize = thisDXCoil.MSRatedTotCap(thisDXCoil.NumOfSpeeds);
                PrintFlag = false;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(Mode).FieldNames(FieldNum) + " [W]";
            } else {
                CompName = thisDXCoil.Name;
                FieldNum = 1;
                TempSize = thisDXCoil.RatedTotCap(Mode);
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(Mode).FieldNames(FieldNum) + " [W]";
            }
            CompType = thisDXCoil.DXCoilType;
            state.dataSize->DataIsDXCoil = true;
            state.dataSize->DataEMSOverrideON = thisDXCoil.RatedTotCapEMSOverrideOn(Mode);
            state.dataSize->DataEMSOverride = thisDXCoil.RatedTotCapEMSOverrideValue(Mode);
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical ||
                thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Heating || thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Heating) {
                HeatingCapacitySizer sizerHeatingCapacity;
                sizerHeatingCapacity.overrideSizingString(SizingString);
                sizerHeatingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.RatedTotCap(Mode) = sizerHeatingCapacity.size(state, TempSize, ErrorsFound);
            } else {
                CoolingCapacitySizer sizerCoolingCapacity;
                sizerCoolingCapacity.overrideSizingString(SizingString);
                sizerCoolingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.RatedTotCap(Mode) = sizerCoolingCapacity.size(state, TempSize, ErrorsFound);
            }
            state.dataSize->DataIsDXCoil = false;
            state.dataSize->DataFlowUsedForSizing = 0.0;
            state.dataSize->DataCoolCoilCap = 0.0;
            state.dataSize->DataTotCapCurveIndex = 0;
            state.dataSize->DataEMSOverrideON = false;
            state.dataSize->DataEMSOverride = 0.0;
            state.dataSize->DataConstantUsedForSizing = 0.0;
            state.dataSize->DataFractionUsedForSizing = 0.0;
            state.dataSize->DataTotCapCurveValue = 0.0;

            // Cooling coil capacity
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingSingleSpeed || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed ||
                thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl || thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Cooling ||
                thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Cooling) {
                state.dataSize->DXCoolCap = thisDXCoil.RatedTotCap(Mode);
            }

            // Sizing DX cooling coil SHR
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingSingleSpeed || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed ||
                thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl || thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_Cooling ||
                thisDXCoil.DXCoilType_Num == HVAC::CoilVRF_FluidTCtrl_Cooling) {

                if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) {
                    CompName = thisDXCoil.Name + ":" + thisDXCoil.CoilPerformanceName(Mode);
                } else {
                    CompName = thisDXCoil.Name;
                }
                CompType = thisDXCoil.DXCoilType;
                TempSize = thisDXCoil.RatedSHR(Mode);
                state.dataSize->DataDXSpeedNum = Mode;
                state.dataSize->DataFlowUsedForSizing = thisDXCoil.RatedAirVolFlowRate(Mode);
                state.dataSize->DataCapacityUsedForSizing = thisDXCoil.RatedTotCap(Mode);
                state.dataSize->DataEMSOverrideON = thisDXCoil.RatedSHREMSOverrideOn(Mode);
                state.dataSize->DataEMSOverride = thisDXCoil.RatedSHREMSOverrideValue(Mode);
                bool ErrorsFound = false;
                sizerCoolingSHR.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.RatedSHR(Mode) = sizerCoolingSHR.size(state, TempSize, ErrorsFound);
                state.dataSize->DataDXSpeedNum = 0;
                state.dataSize->DataFlowUsedForSizing = 0.0;
                state.dataSize->DataCapacityUsedForSizing = 0.0;
                state.dataSize->DataEMSOverrideON = false;
                state.dataSize->DataEMSOverride = 0.0;

            } // End of Rated SHR

            // Sizing evaporator condenser air flow
            if (thisDXCoil.CondenserType(1) == DataHeatBalance::RefrigCondenserType::Evap && thisDXCoil.EvapCondAirFlow(Mode) != 0.0 &&
                (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingSingleSpeed || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed ||
                 thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl)) {

                AutoCalculateSizer sizerEvapCondAirFlow;
                std::string stringOverride = "Evaporative Condenser Air Flow Rate [m3/s]";
                if (state.dataGlobal->isEpJSON) stringOverride = "evaporative_condenser_air_flow_rate [m3/s]";
                if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) {
                    CompName = thisDXCoil.Name + ":" + thisDXCoil.CoilPerformanceName(Mode);
                } else {
                    CompName = thisDXCoil.Name;
                    if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
                        stringOverride = "High Speed Evaporative Condenser Air Flow Rate [m3/s]";
                        if (state.dataGlobal->isEpJSON) stringOverride = "high_speed_evaporative_condenser_air_flow_rate [m3/s]";
                    } else {
                        stringOverride = "Evaporative Condenser Air Flow Rate [m3/s]";
                        if (state.dataGlobal->isEpJSON) stringOverride = "evaporative_condenser_air_flow_rate [m3/s]";
                    }
                }
                CompType = thisDXCoil.DXCoilType;
                // Auto-size condenser air flow to Total Capacity * 0.000114 m3/s/w (850 cfm/ton)
                state.dataSize->DataConstantUsedForSizing = thisDXCoil.RatedTotCap(Mode);
                state.dataSize->DataFractionUsedForSizing = 0.000114;
                TempSize = thisDXCoil.EvapCondAirFlow(Mode);
                sizerEvapCondAirFlow.overrideSizingString(stringOverride);
                sizerEvapCondAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.EvapCondAirFlow(Mode) = sizerEvapCondAirFlow.size(state, TempSize, ErrorsFound);
            }

            if (SizeSecDXCoil) { // autosize secondary coil air flow rate for AirCooled condenser type
                IsAutoSize = false;
                if (thisDXCoil.SecCoilAirFlow == AutoSize) {
                    IsAutoSize = true;
                }
                // Autosize Primary Coil Air Flow * Secondary Coil Scaling Factor
                SecCoilAirFlowDes = thisDXCoil.RatedAirVolFlowRate(1) * thisDXCoil.SecCoilAirFlowScalingFactor;
                if (IsAutoSize) {
                    thisDXCoil.SecCoilAirFlow = SecCoilAirFlowDes;
                    BaseSizer::reportSizerOutput(
                        state, thisDXCoil.DXCoilType, thisDXCoil.Name, "Design Size Secondary Coil Air Flow Rate [m3/s]", SecCoilAirFlowDes);
                } else {
                    if (thisDXCoil.SecCoilAirFlow > 0.0 && SecCoilAirFlowDes > 0.0 && !HardSizeNoDesRun) {
                        SecCoilAirFlowUser = thisDXCoil.SecCoilAirFlow;
                        BaseSizer::reportSizerOutput(state,
                                                     thisDXCoil.DXCoilType,
                                                     thisDXCoil.Name,
                                                     "Design Size Secondary Coil Air Flow Rate [m3/s]",
                                                     SecCoilAirFlowDes,
                                                     "User-Specified Secondary Coil Air Flow Rate [m3/s]",
                                                     SecCoilAirFlowUser);
                        if (state.dataGlobal->DisplayExtraWarnings) {
                            if ((std::abs(SecCoilAirFlowDes - SecCoilAirFlowUser) / SecCoilAirFlowUser) > state.dataSize->AutoVsHardSizingThreshold) {
                                ShowMessage(
                                    state,
                                    format("SizeDxCoil: Potential issue with equipment sizing for {} {}", thisDXCoil.DXCoilType, thisDXCoil.Name));
                                ShowContinueError(state, format("User-Specified Secondary Coil Air Flow Rate of {:.5R} [m3/s]", SecCoilAirFlowUser));
                                ShowContinueError(
                                    state, format("differs from Design Size Secondary Coil Air Flow Rate of {:.5R} [m3/s]", SecCoilAirFlowDes));
                                ShowContinueError(state, "This may, or may not, indicate mismatched component sizes.");
                                ShowContinueError(state, "Verify that the value entered is intended and is consistent with other components.");
                            }
                        }
                    }
                }
            }

            // Sizing evaporative condenser air flow 2
            PrintFlag = true;
            if (thisDXCoil.CondenserType(1) == DataHeatBalance::RefrigCondenserType::Evap && thisDXCoil.EvapCondAirFlow2 != 0.0 &&
                thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
                CompName = thisDXCoil.Name;
                FieldNum = 15; // Low Speed Evaporative Condenser Air Flow Rate
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(Mode).FieldNames(FieldNum) + " [m3/s]";
                CompType = thisDXCoil.DXCoilType;
                // Autosize low speed condenser air flow to 1/3 Total Capacity * 0.000114 m3/s/w (850 cfm/ton)
                state.dataSize->DataConstantUsedForSizing = thisDXCoil.RatedTotCap(Mode);
                state.dataSize->DataFractionUsedForSizing = 0.000114 * 0.3333;
                TempSize = thisDXCoil.EvapCondAirFlow2;
                AutoCalculateSizer sizerEvapCondAirFlow2;
                std::string stringOverride = "Low Speed Evaporative Condenser Air Flow Rate [m3/s]";
                if (state.dataGlobal->isEpJSON) stringOverride = "low_speed_evaporative_condenser_air_flow_rate [m3/s]";
                sizerEvapCondAirFlow2.overrideSizingString(stringOverride);
                sizerEvapCondAirFlow2.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.EvapCondAirFlow2 = sizerEvapCondAirFlow2.size(state, TempSize, ErrorsFound);
            }

            // Sizing evaporative condenser pump electric nominal power
            if (thisDXCoil.CondenserType(1) == DataHeatBalance::RefrigCondenserType::Evap && thisDXCoil.EvapCondPumpElecNomPower(Mode) != 0.0 &&
                (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingSingleSpeed || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed ||
                 thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl)) {

                AutoCalculateSizer sizerEvapCondPumpPower;
                std::string stringOverride = "Evaporative Condenser Pump Rated Power Consumption [W]";
                if (state.dataGlobal->isEpJSON) stringOverride = "evaporative_condenser_pump_rated_power_consumption [W]";
                if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) {
                    CompName = thisDXCoil.Name + ":" + thisDXCoil.CoilPerformanceName(Mode);
                } else {
                    CompName = thisDXCoil.Name;
                    if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
                        stringOverride = "High Speed Evaporative Condenser Pump Rated Power Consumption [W]";
                        if (state.dataGlobal->isEpJSON) stringOverride = "high_speed_evaporative_condenser_pump_rated_power_consumption [W]";
                    } else {
                        stringOverride = "Evaporative Condenser Pump Rated Power Consumption [W]";
                        if (state.dataGlobal->isEpJSON) stringOverride = "evaporative_condenser_pump_rated_power_consumption [W]";
                    }
                }
                CompType = thisDXCoil.DXCoilType;
                // Autosize high speed evap condenser pump power to Total Capacity * 0.004266 w/w (15 w/ton)
                state.dataSize->DataConstantUsedForSizing = thisDXCoil.RatedTotCap(Mode);
                state.dataSize->DataFractionUsedForSizing = 0.004266;
                TempSize = thisDXCoil.EvapCondPumpElecNomPower(Mode);
                sizerEvapCondPumpPower.overrideSizingString(stringOverride);
                sizerEvapCondPumpPower.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.EvapCondPumpElecNomPower(Mode) = sizerEvapCondPumpPower.size(state, TempSize, ErrorsFound);
            }

            // Sizing low speed evaporative condenser pump electric nominal power
            if (thisDXCoil.CondenserType(1) == DataHeatBalance::RefrigCondenserType::Evap && thisDXCoil.EvapCondPumpElecNomPower2 != 0.0 &&
                thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
                CompName = thisDXCoil.Name;
                CompType = thisDXCoil.DXCoilType;
                // Autosize low speed evap condenser pump power to 1/3 Total Capacity * 0.004266 w/w (15 w/ton)
                state.dataSize->DataConstantUsedForSizing = thisDXCoil.RatedTotCap(Mode);
                state.dataSize->DataFractionUsedForSizing = 0.004266 * 0.3333;
                TempSize = thisDXCoil.EvapCondPumpElecNomPower2;
                AutoCalculateSizer sizerEvapCondPumpPower2;
                std::string stringOverride = "Low Speed Evaporative Condenser Pump Rated Power Consumption [W]";
                if (state.dataGlobal->isEpJSON) stringOverride = "low_speed_evaporative_condenser_pump_rated_power_consumption [W]";
                sizerEvapCondPumpPower2.overrideSizingString(stringOverride);
                sizerEvapCondPumpPower2.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.EvapCondPumpElecNomPower2 = sizerEvapCondPumpPower2.size(state, TempSize, ErrorsFound);
            }

            //                // Sizing rated low speed air flow rate
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
                CompName = thisDXCoil.Name;
                CompType = thisDXCoil.DXCoilType;
                // Autosize low speed air flow rate to 1/3 high speed air flow rate
                state.dataSize->DataConstantUsedForSizing = thisDXCoil.RatedAirVolFlowRate(Mode);
                state.dataSize->DataFractionUsedForSizing = 0.3333;
                TempSize = thisDXCoil.RatedAirVolFlowRate2;
                AutoCalculateSizer sizerLowSpdAirFlow;
                std::string stringOverride = "Low Speed Rated Air Flow Rate [m3/s]";
                if (state.dataGlobal->isEpJSON) stringOverride = "low_speed_rated_air_flow_rate [m3/s]";
                sizerLowSpdAirFlow.overrideSizingString(stringOverride);
                sizerLowSpdAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.RatedAirVolFlowRate2 = sizerLowSpdAirFlow.size(state, TempSize, ErrorsFound);
            }

            //                // Sizing rated low speed total cooling capacity
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
                CompName = thisDXCoil.Name;
                CompType = thisDXCoil.DXCoilType;
                // Autosize low speed capacity to 1/3 high speed capacity
                state.dataSize->DataConstantUsedForSizing = thisDXCoil.RatedTotCap(Mode);
                state.dataSize->DataFractionUsedForSizing = 0.3333;
                TempSize = thisDXCoil.RatedTotCap2;
                AutoCalculateSizer sizerLowSpdCap;
                std::string stringOverride = "Low Speed Gross Rated Total Cooling Capacity [W]";
                if (state.dataGlobal->isEpJSON) stringOverride = "low_speed_gross_rated_total_cooling_capacity [W]";
                sizerLowSpdCap.overrideSizingString(stringOverride);
                sizerLowSpdCap.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.RatedTotCap2 = sizerLowSpdCap.size(state, TempSize, ErrorsFound);
            }

            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
                if (thisDXCoil.EvapCondAirFlow2 > thisDXCoil.EvapCondAirFlow(Mode)) {
                    ShowSevereError(
                        state,
                        format("SizeDXCoil: {} {}, Evaporative Condenser low speed air flow must be less than or equal to high speed air flow.",
                               thisDXCoil.DXCoilType,
                               thisDXCoil.Name));
                    ShowContinueError(state, format("Instead, {:.2R} > {:.2R}", thisDXCoil.EvapCondAirFlow2, thisDXCoil.EvapCondAirFlow(Mode)));
                    ShowFatalError(state, "Preceding conditions cause termination.");
                }

                if (thisDXCoil.EvapCondPumpElecNomPower2 > thisDXCoil.EvapCondPumpElecNomPower(Mode)) {
                    ShowSevereError(
                        state,
                        format("SizeDXCoil: {} {}, Evaporative Condenser low speed pump power must be less than or equal to high speed pump power.",
                               thisDXCoil.DXCoilType,
                               thisDXCoil.Name));
                    ShowContinueError(
                        state, format("Instead, {:.2R} > {:.2R}", thisDXCoil.EvapCondPumpElecNomPower2, thisDXCoil.EvapCondPumpElecNomPower(Mode)));
                    ShowFatalError(state, "Preceding conditions cause termination.");
                }

                if (thisDXCoil.RatedTotCap2 > thisDXCoil.RatedTotCap(Mode)) {
                    ShowSevereError(state,
                                    format("SizeDXCoil: {} {}, Rated Total Cooling Capacity, Low Speed must be less than or equal to Rated Total "
                                           "Cooling Capacity, High Speed.",
                                           thisDXCoil.DXCoilType,
                                           thisDXCoil.Name));
                    ShowContinueError(state, format("Instead, {:.2R} > {:.2R}", thisDXCoil.RatedTotCap2, thisDXCoil.RatedTotCap(Mode)));
                    ShowFatalError(state, "Preceding conditions cause termination.");
                }

                if (thisDXCoil.RatedAirVolFlowRate2 > thisDXCoil.RatedAirVolFlowRate(Mode)) {
                    ShowFatalError(state,
                                   format("SizeDXCoil: {} {}, Rated Air Volume Flow Rate, low speed must be less than or equal to Rated Air Volume "
                                          "Flow Rate, high speed.",
                                          thisDXCoil.DXCoilType,
                                          thisDXCoil.Name));
                    ShowContinueError(state,
                                      format("Instead, {:.2R} > {:.2R}", thisDXCoil.RatedAirVolFlowRate2, thisDXCoil.RatedAirVolFlowRate(Mode)));
                    ShowFatalError(state, "Preceding conditions cause termination.");
                }
            }

            //                // Sizing rated low speed SHR2
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
                CompName = thisDXCoil.Name;
                FieldNum = 7;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(Mode).FieldNames(FieldNum);
                CompType = thisDXCoil.DXCoilType;
                // Autosize low speed SHR to be the same as high speed SHR
                state.dataSize->DataConstantUsedForSizing = thisDXCoil.RatedSHR(Mode);
                state.dataSize->DataFractionUsedForSizing = 1.0;
                state.dataSize->DataDXSpeedNum = 2; // refers to low speed in sizer
                bool ErrorsFound = false;
                TempSize = thisDXCoil.RatedSHR2;
                sizerCoolingSHR.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.RatedSHR2 = sizerCoolingSHR.size(state, TempSize, ErrorsFound);
                state.dataSize->DataConstantUsedForSizing = 0.0;
                state.dataSize->DataFractionUsedForSizing = 0.0;
                state.dataSize->DataDXSpeedNum = 0;
            }

            //                // Sizing resistive defrost heater capacity
            if (thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_Heating && thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_FluidTCtrl_Heating &&
                thisDXCoil.DXCoilType_Num != HVAC::CoilDX_MultiSpeedHeating) {
                // IF (DXCoil(DXCoilNum)%DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating .OR. &
                //    DXCoil(DXCoilNum)%DXCoilType_Num == Coil_HeatingAirToAirVariableSpeed) THEN
                if (thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::Resistive) {
                    CompName = thisDXCoil.Name;
                    CompType = thisDXCoil.DXCoilType;
                    // Autosize low speed capacity to 1/3 high speed capacity
                    state.dataSize->DataConstantUsedForSizing = state.dataSize->DXCoolCap;
                    state.dataSize->DataFractionUsedForSizing = 1.0;
                    TempSize = thisDXCoil.DefrostCapacity;
                    AutoCalculateSizer sizerResDefCap;
                    std::string stringOverride = "Resistive Defrost Heater Capacity [W]";
                    if (state.dataGlobal->isEpJSON) stringOverride = "resistive_defrost_heater_capacity [W]";
                    sizerResDefCap.overrideSizingString(stringOverride);
                    sizerResDefCap.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                    thisDXCoil.DefrostCapacity = sizerResDefCap.size(state, TempSize, ErrorsFound);
                } else {
                    thisDXCoil.DefrostCapacity = 0.0;
                }
            }

        } // End capacity stages loop
    }     // End dehumidification modes loop

    // Autosizing for multispeed cooling coil
    if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedCooling) {
        // flow rate autosize
        for (Mode = thisDXCoil.NumOfSpeeds; Mode >= 1; --Mode) {
            // Sizing multispeed air volume flow rate
            IsAutoSize = false;
            if (thisDXCoil.MSRatedAirVolFlowRate(Mode) == AutoSize) {
                IsAutoSize = true;
            }
            state.dataSize->DataIsDXCoil = true;
            CompName = thisDXCoil.Name;
            CompType = thisDXCoil.DXCoilType;
            if (Mode == thisDXCoil.NumOfSpeeds) {
                FieldNum = 10 + (Mode - 1) * 14;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames(FieldNum) + " [m3/s]";
                TempSize = thisDXCoil.MSRatedAirVolFlowRate(Mode);
                state.dataSize->DataEMSOverrideON = thisDXCoil.RatedAirVolFlowRateEMSOverrideON(Mode);
                state.dataSize->DataEMSOverride = thisDXCoil.RatedAirVolFlowRateEMSOverrideValue(Mode);
                bool errorsFound = false;
                CoolingAirFlowSizer sizingCoolingAirFlow;
                sizingCoolingAirFlow.overrideSizingString(SizingString);
                // sizingCoolingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                sizingCoolingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                TempSize = sizingCoolingAirFlow.size(state, TempSize, errorsFound);
                thisDXCoil.MSRatedAirVolFlowRate(Mode) = TempSize;
                state.dataSize->DataEMSOverrideON = false;
                state.dataSize->DataEMSOverride = 0.0;
                if (!IsAutoSize && !HardSizeNoDesRun) {
                    TempSize = AutoSize;
                    bPRINT = false;
                    sizingCoolingAirFlow.initializeWithinEP(state, CompType, CompName, bPRINT, RoutineName);
                    MSRatedAirVolFlowRateDes = sizingCoolingAirFlow.size(state, TempSize, errorsFound);
                    bPRINT = true;
                }
                if (IsAutoSize) {
                    MSRatedAirVolFlowRateDes = TempSize;
                }
            } else {
                FieldNum = 10 + (Mode - 1) * 14;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames(FieldNum) + " [m3/s]";
                if (IsAutoSize || !HardSizeNoDesRun) {
                    // Autosize low speed flow to fraction of the highest speed flow
                    state.dataSize->DataConstantUsedForSizing = thisDXCoil.MSRatedAirVolFlowRate(thisDXCoil.NumOfSpeeds);
                    if (!IsAutoSize && !HardSizeNoDesRun) state.dataSize->DataConstantUsedForSizing = MSRatedAirVolFlowRateDes;
                    state.dataSize->DataFractionUsedForSizing = (float)Mode / thisDXCoil.NumOfSpeeds;
                }
                TempSize = thisDXCoil.MSRatedAirVolFlowRate(Mode);
                state.dataSize->DataEMSOverrideON = thisDXCoil.RatedAirVolFlowRateEMSOverrideON(Mode);
                state.dataSize->DataEMSOverride = thisDXCoil.RatedAirVolFlowRateEMSOverrideValue(Mode);
                bool errorsFound = false;
                CoolingAirFlowSizer sizingCoolingAirFlow;
                sizingCoolingAirFlow.overrideSizingString(SizingString);
                sizingCoolingAirFlow.initializeWithinEP(state, CompType, CompName, bPRINT, RoutineName);
                thisDXCoil.MSRatedAirVolFlowRate(Mode) = sizingCoolingAirFlow.size(state, TempSize, errorsFound);
            }
            state.dataSize->DataEMSOverride = 0.0;
            state.dataSize->DataEMSOverrideON = false;
            state.dataSize->DataIsDXCoil = false;
            state.dataSize->DataTotCapCurveIndex = 0;
            state.dataSize->DataConstantUsedForSizing = 0.0;
            state.dataSize->DataFractionUsedForSizing = 0.0;
        }

        // Ensure flow rate at lower speed must be lower or equal to the flow rate at higher speed. Otherwise, a severe error is issued.
        for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds - 1; ++Mode) {
            if (thisDXCoil.MSRatedAirVolFlowRate(Mode) > thisDXCoil.MSRatedAirVolFlowRate(Mode + 1)) {
                ShowWarningError(state,
                                 format("SizeDXCoil: {} {}, Speed {} Rated Air Flow Rate must be less than or equal to Speed {} Rated Air Flow Rate.",
                                        thisDXCoil.DXCoilType,
                                        thisDXCoil.Name,
                                        Mode,
                                        Mode + 1));
                ShowContinueError(
                    state, format("Instead, {:.2R} > {:.2R}", thisDXCoil.MSRatedAirVolFlowRate(Mode), thisDXCoil.MSRatedAirVolFlowRate(Mode + 1)));
                ShowFatalError(state, "Preceding conditions cause termination.");
            }
        }

        // Sizing multispeed rated total cooling capacity
        for (Mode = thisDXCoil.NumOfSpeeds; Mode >= 1; --Mode) {
            IsAutoSize = false;
            if (thisDXCoil.MSRatedTotCap(Mode) == AutoSize) {
                IsAutoSize = true;
            }
            CompName = thisDXCoil.Name;
            CompType = thisDXCoil.DXCoilType;
            state.dataSize->DataIsDXCoil = true;
            state.dataSize->DataTotCapCurveIndex = thisDXCoil.MSCCapFTemp(Mode);
            if (Mode == thisDXCoil.NumOfSpeeds) {
                PrintFlag = true;
                state.dataSize->DataFlowUsedForSizing = thisDXCoil.MSRatedAirVolFlowRate(Mode);
                FieldNum = 7 + (Mode - 1) * 14;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames(FieldNum) + " [W]";
                state.dataSize->DataEMSOverrideON = thisDXCoil.RatedTotCapEMSOverrideOn(Mode);
                state.dataSize->DataEMSOverride = thisDXCoil.RatedTotCapEMSOverrideValue(Mode);
                MSRatedTotCapDesAtMaxSpeed = thisDXCoil.MSRatedTotCap(Mode);
                if (!HardSizeNoDesRun) {
                    PrintFlag = false;
                    TempSize = DataSizing::AutoSize;
                    // Auto-size capacity at the highest speed
                    CoolingCapacitySizer sizerCoolingCapacity;
                    sizerCoolingCapacity.overrideSizingString(SizingString);
                    sizerCoolingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                    TempSize = sizerCoolingCapacity.size(state, TempSize, ErrorsFound);
                    state.dataSize->DataConstantUsedForSizing = TempSize;
                    state.dataSize->DataFractionUsedForSizing = 1.0;
                    MSRatedTotCapDesAtMaxSpeed = TempSize;
                    thisDXCoil.MSRatedTotCapDes(Mode) = TempSize;
                    PrintFlag = true;
                }
                TempSize = thisDXCoil.MSRatedTotCap(Mode);
                CoolingCapacitySizer sizerCoolingCapacity2;
                sizerCoolingCapacity2.overrideSizingString(SizingString);
                sizerCoolingCapacity2.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                TempSize = sizerCoolingCapacity2.size(state, TempSize, ErrorsFound);
                thisDXCoil.MSRatedTotCap(Mode) = TempSize;
                if (IsAutoSize) {
                    MSRatedTotCapDesAtMaxSpeed = TempSize;
                    thisDXCoil.MSRatedTotCapDes(Mode) = TempSize;
                }
            } else {
                // cooling capacity at lower speeds
                PrintFlag = true;
                FieldNum = 7 + (Mode - 1) * 14;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames(FieldNum) + " [W]";
                if (IsAutoSize || !HardSizeNoDesRun) {
                    // autosize low speed capacity to fraction of the highest speed capacity
                    if (!HardSizeNoDesRun) {
                        state.dataSize->DataConstantUsedForSizing = MSRatedTotCapDesAtMaxSpeed;
                    } else {
                        state.dataSize->DataConstantUsedForSizing = thisDXCoil.MSRatedTotCap(thisDXCoil.NumOfSpeeds);
                    }
                    state.dataSize->DataFractionUsedForSizing = (float)Mode / thisDXCoil.NumOfSpeeds;
                    thisDXCoil.MSRatedTotCapDes(Mode) = state.dataSize->DataConstantUsedForSizing * state.dataSize->DataFractionUsedForSizing;
                }
                TempSize = thisDXCoil.MSRatedTotCap(Mode);
                state.dataSize->DataEMSOverrideON = thisDXCoil.RatedTotCapEMSOverrideOn(Mode);
                state.dataSize->DataEMSOverride = thisDXCoil.RatedTotCapEMSOverrideValue(Mode);
                CoolingCapacitySizer sizerCoolingCapacity;
                sizerCoolingCapacity.overrideSizingString(SizingString);
                sizerCoolingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.MSRatedTotCap(Mode) = sizerCoolingCapacity.size(state, TempSize, ErrorsFound);
            }
            state.dataSize->DataEMSOverride = 0.0;
            state.dataSize->DataEMSOverrideON = false;
            state.dataSize->DataIsDXCoil = false;
            state.dataSize->DataCoolCoilCap = 0.0;
            state.dataSize->DataTotCapCurveIndex = 0;
            state.dataSize->DataConstantUsedForSizing = 0.0;
            state.dataSize->DataFractionUsedForSizing = 0.0;
        }

        // Ensure capacity at lower speed must be lower or equal to the capacity at higher speed.
        for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds - 1; ++Mode) {
            if (thisDXCoil.MSRatedTotCap(Mode) > thisDXCoil.MSRatedTotCap(Mode + 1)) {
                ShowWarningError(state,
                                 format("SizeDXCoil: {} {}, Speed {} Rated Total Cooling Capacity must be less than or equal to Speed {} Rated "
                                        "Total Cooling Capacity.",
                                        thisDXCoil.DXCoilType,
                                        thisDXCoil.Name,
                                        Mode,
                                        Mode + 1));
                ShowContinueError(state, format("Instead, {:.2R} > {:.2R}", thisDXCoil.MSRatedTotCap(Mode), thisDXCoil.MSRatedTotCap(Mode + 1)));
                ShowFatalError(state, "Preceding conditions cause termination.");
            }
        }

        // Rated SHR
        for (Mode = thisDXCoil.NumOfSpeeds; Mode >= 1; --Mode) {
            IsAutoSize = false;
            if (thisDXCoil.MSRatedSHR(Mode) == AutoSize) {
                IsAutoSize = true;
            }
            if (Mode == thisDXCoil.NumOfSpeeds) {
                CompType = thisDXCoil.DXCoilType;
                CompName = thisDXCoil.Name;
                TempSize = thisDXCoil.MSRatedSHR(Mode);
                state.dataSize->DataFlowUsedForSizing = MSRatedAirVolFlowRateDes;
                state.dataSize->DataCapacityUsedForSizing = MSRatedTotCapDesAtMaxSpeed;
                state.dataSize->DataEMSOverrideON = thisDXCoil.RatedSHREMSOverrideOn(Mode);
                state.dataSize->DataEMSOverride = thisDXCoil.RatedSHREMSOverrideValue(Mode);
                bool ErrorsFound = false;
                state.dataSize->DataDXSpeedNum = Mode;
                sizerCoolingSHR.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.MSRatedSHR(Mode) = sizerCoolingSHR.size(state, TempSize, ErrorsFound);
                // added for rated sensible cooling capacity estimate for html reporting, issue #7381
                thisDXCoil.RatedSHR(1) = thisDXCoil.MSRatedSHR(Mode);
                // design SHR value at the maximum speed calculated above was supposed to be used for all speeds
                // Now user specified SHR value is used when the SHR field is not autosized and design day run is
                // set to yes unless the code below is commented out
                MSRatedSHRDes = thisDXCoil.MSRatedSHR(Mode);
            } else {
                TempSize = thisDXCoil.MSRatedSHR(Mode);
                bool ErrorsFound = false;
                state.dataSize->DataDXSpeedNum = Mode;
                state.dataSize->DataFractionUsedForSizing = MSRatedSHRDes;
                state.dataSize->DataConstantUsedForSizing = 1.0;
                sizerCoolingSHR.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                thisDXCoil.MSRatedSHR(Mode) = sizerCoolingSHR.size(state, TempSize, ErrorsFound);
            }
        }
        state.dataSize->DataFlowUsedForSizing = 0.0;
        state.dataSize->DataCapacityUsedForSizing = 0.0;
        state.dataSize->DataEMSOverrideON = false;
        state.dataSize->DataEMSOverride = 0.0;
        state.dataSize->DataDXSpeedNum = 0;
        state.dataSize->DataFractionUsedForSizing = 0.0;
        state.dataSize->DataConstantUsedForSizing = 0.0;

        // Rated Evaporative condenser airflow rates
        for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds; ++Mode) {
            IsAutoSize = false;
            if (thisDXCoil.MSEvapCondAirFlow(Mode) == AutoSize) {
                IsAutoSize = true;
            }
            if (IsAutoSize || !HardSizeNoDesRun) {
                // Autosize condenser air flow to Total Capacity * 0.000114 m3/s/w (850 cfm/ton)
                MSEvapCondAirFlowDes = ((float)Mode / thisDXCoil.NumOfSpeeds) * MSRatedTotCapDesAtMaxSpeed * 0.000114;
            } else {
                // this is done to duplicate any existing calc method
                MSEvapCondAirFlowDes = thisDXCoil.MSRatedTotCap(Mode) * 0.000114;
            }
            if (IsAutoSize) {
                thisDXCoil.MSEvapCondAirFlow(Mode) = MSEvapCondAirFlowDes;
                BaseSizer::reportSizerOutput(state,
                                             thisDXCoil.DXCoilType,
                                             thisDXCoil.Name,
                                             format("Design Size Speed {} Evaporative Condenser Air Flow Rate [m3/s]", Mode),
                                             MSEvapCondAirFlowDes);
            } else {
                if (thisDXCoil.MSEvapCondAirFlow(Mode) > 0.0 && MSEvapCondAirFlowDes > 0.0 && !HardSizeNoDesRun) {
                    MSEvapCondAirFlowUser = thisDXCoil.MSEvapCondAirFlow(Mode);
                    BaseSizer::reportSizerOutput(state,
                                                 thisDXCoil.DXCoilType,
                                                 thisDXCoil.Name,
                                                 format("Design Size Speed {} Evaporative Condenser Air Flow Rate [m3/s]", Mode),
                                                 MSEvapCondAirFlowDes,
                                                 format("User-Specified Speed {} Evaporative Condenser Air Flow Rate [m3/s]", Mode),
                                                 MSEvapCondAirFlowUser);
                    if (state.dataGlobal->DisplayExtraWarnings) {
                        if ((std::abs(MSEvapCondAirFlowDes - MSEvapCondAirFlowUser) / MSEvapCondAirFlowUser) >
                            state.dataSize->AutoVsHardSizingThreshold) {
                            ShowMessage(
                                state, format("SizeDxCoil: Potential issue with equipment sizing for {} {}", thisDXCoil.DXCoilType, thisDXCoil.Name));
                            ShowContinueError(state,
                                              format("User-Specified Evaporative Condenser Air Flow Rate of {:.5R} [m3/s]", MSEvapCondAirFlowUser));
                            ShowContinueError(
                                state, format("differs from Design Size Evaporative Condenser Air Flow Rate of {:.5R} [m3/s]", MSEvapCondAirFlowDes));
                            ShowContinueError(state, "This may, or may not, indicate mismatched component sizes.");
                            ShowContinueError(state, "Verify that the value entered is intended and is consistent with other components.");
                        }
                    }
                }
            }
        }

        // Ensure evaporative condenser airflow rate at lower speed must be lower or equal to one at higher speed.
        for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds - 1; ++Mode) {
            if (thisDXCoil.MSEvapCondAirFlow(Mode) > thisDXCoil.MSEvapCondAirFlow(Mode + 1)) {
                ShowWarningError(state,
                                 format("SizeDXCoil: {} {}, Speed {} Evaporative Condenser Air Flow Rate must be less than or equal to Speed {} "
                                        "Evaporative Condenser Air Flow Rate.",
                                        thisDXCoil.DXCoilType,
                                        thisDXCoil.Name,
                                        Mode,
                                        Mode + 1));
                ShowContinueError(state,
                                  format("Instead, {:.2R} > {:.2R}", thisDXCoil.MSEvapCondAirFlow(Mode), thisDXCoil.MSEvapCondAirFlow(Mode + 1)));
                ShowFatalError(state, "Preceding conditions cause termination.");
            }
        }

        // Sizing multispeed rated evaporative condenser pump power
        for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds; ++Mode) {
            IsAutoSize = false;
            if (thisDXCoil.MSEvapCondPumpElecNomPower(Mode) == AutoSize) {
                IsAutoSize = true;
            }

            if (IsAutoSize || !HardSizeNoDesRun) {
                // Autosize low speed evap condenser pump power to 1/3 Total Capacity * 0.004266 w/w (15 w/ton)
                MSEvapCondPumpElecNomPowerDes = ((float)Mode / thisDXCoil.NumOfSpeeds) * MSRatedTotCapDesAtMaxSpeed * 0.004266;
            } else {
                // this is done to duplicate any existing calc method
                MSEvapCondPumpElecNomPowerDes = thisDXCoil.MSRatedTotCap(Mode) * 0.004266;
            }
            // Design Size data is always available
            if (IsAutoSize) {
                thisDXCoil.MSEvapCondPumpElecNomPower(Mode) = MSEvapCondPumpElecNomPowerDes;
                BaseSizer::reportSizerOutput(state,
                                             thisDXCoil.DXCoilType,
                                             thisDXCoil.Name,
                                             format("Design Size Speed {} Rated Evaporative Condenser Pump Power Consumption [W]", Mode),
                                             MSEvapCondPumpElecNomPowerDes);
            } else {
                if (thisDXCoil.MSEvapCondPumpElecNomPower(Mode) > 0.0 && MSEvapCondPumpElecNomPowerDes > 0.0 && !HardSizeNoDesRun) {
                    MSEvapCondPumpElecNomPowerUser = thisDXCoil.MSEvapCondPumpElecNomPower(Mode);
                    BaseSizer::reportSizerOutput(state,
                                                 thisDXCoil.DXCoilType,
                                                 thisDXCoil.Name,
                                                 format("Design Size Speed {} Rated Evaporative Condenser Pump Power Consumption [W]", Mode),
                                                 MSEvapCondPumpElecNomPowerDes,
                                                 format("User-Specified Speed {} Rated Evaporative Condenser Pump Power Consumption [W]", Mode),
                                                 MSEvapCondPumpElecNomPowerUser);
                    if (state.dataGlobal->DisplayExtraWarnings) {
                        if ((std::abs(MSEvapCondPumpElecNomPowerDes - MSEvapCondPumpElecNomPowerUser) / MSEvapCondPumpElecNomPowerUser) >
                            state.dataSize->AutoVsHardSizingThreshold) {
                            ShowMessage(
                                state, format("SizeDxCoil: Potential issue with equipment sizing for {} {}", thisDXCoil.DXCoilType, thisDXCoil.Name));
                            ShowContinueError(state,
                                              format("User-Specified Evaporative Condenser Pump Rated Power Consumption of {:.2R} [W]",
                                                     MSEvapCondPumpElecNomPowerUser));
                            ShowContinueError(state,
                                              format("differs from Design Size Evaporative Condenser Pump Rated Power Consumption of {:.2R} [W]",
                                                     MSEvapCondPumpElecNomPowerDes));
                            ShowContinueError(state, "This may, or may not, indicate mismatched component sizes.");
                            ShowContinueError(state, "Verify that the value entered is intended and is consistent with other components.");
                        }
                    }
                }
            }
        }

        // Ensure evaporative condenser pump power at lower speed must be lower or equal to one at higher speed.
        for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds - 1; ++Mode) {
            if (thisDXCoil.MSEvapCondPumpElecNomPower(Mode) > thisDXCoil.MSEvapCondPumpElecNomPower(Mode + 1)) {
                ShowWarningError(state,
                                 format("SizeDXCoil: {} {}, Speed {} Rated Evaporative Condenser Pump Power Consumption must be less than or "
                                        "equal to Speed {} Rated Evaporative Condenser Pump Power Consumption.",
                                        thisDXCoil.DXCoilType,
                                        thisDXCoil.Name,
                                        Mode,
                                        Mode + 1));
                ShowContinueError(
                    state,
                    format("Instead, {:.2R} > {:.2R}", thisDXCoil.MSEvapCondPumpElecNomPower(Mode), thisDXCoil.MSEvapCondPumpElecNomPower(Mode + 1)));
                ShowFatalError(state, "Preceding conditions cause termination.");
            }
        }
    }

    // Autosizing for multispeed heating coil
    if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating) {
        // flow rate autosize
        for (Mode = thisDXCoil.NumOfSpeeds; Mode >= 1; --Mode) {
            IsAutoSize = false;
            if (thisDXCoil.MSRatedAirVolFlowRate(Mode) == AutoSize) {
                IsAutoSize = true;
            }
            state.dataSize->DataIsDXCoil = true;
            CompName = thisDXCoil.Name;
            CompType = thisDXCoil.DXCoilType;
            // Sizing rated air flow rate
            if (Mode == thisDXCoil.NumOfSpeeds) {
                FieldNum = 12 + (Mode - 1) * 6;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames(FieldNum) + " [m3/s]";
                TempSize = thisDXCoil.MSRatedAirVolFlowRate(Mode);
                state.dataSize->DataEMSOverrideON = thisDXCoil.RatedAirVolFlowRateEMSOverrideON(Mode);
                state.dataSize->DataEMSOverride = thisDXCoil.RatedAirVolFlowRateEMSOverrideValue(Mode);
                bool errorsFound = false;
                HeatingAirFlowSizer sizingHeatingAirFlow;
                sizingHeatingAirFlow.overrideSizingString(SizingString);
                // sizingHeatingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                sizingHeatingAirFlow.initializeWithinEP(state, CompType, CompName, bPRINT, RoutineName);
                thisDXCoil.MSRatedAirVolFlowRate(Mode) = sizingHeatingAirFlow.size(state, TempSize, errorsFound);
                if (!IsAutoSize && !HardSizeNoDesRun) {
                    TempSize = AutoSize;
                    bPRINT = false;
                    errorsFound = false;
                    HeatingAirFlowSizer sizingHeatingAirFlow2;
                    sizingHeatingAirFlow2.overrideSizingString(SizingString);
                    // sizingHeatingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                    sizingHeatingAirFlow2.initializeWithinEP(state, CompType, CompName, bPRINT, RoutineName);
                    MSRatedAirVolFlowRateDes = sizingHeatingAirFlow2.size(state, TempSize, errorsFound);
                    bPRINT = true;
                }
            } else {
                FieldNum = 12 + (Mode - 1) * 6;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames(FieldNum) + " [m3/s]";
                if (IsAutoSize || !HardSizeNoDesRun) {
                    // Auto-size low speed flow to fraction of the highest speed capacity
                    state.dataSize->DataConstantUsedForSizing = thisDXCoil.MSRatedAirVolFlowRate(thisDXCoil.NumOfSpeeds);
                    if (!IsAutoSize && !HardSizeNoDesRun) state.dataSize->DataConstantUsedForSizing = MSRatedAirVolFlowRateDes;
                    state.dataSize->DataFractionUsedForSizing = (float)Mode / thisDXCoil.NumOfSpeeds;
                }
                TempSize = thisDXCoil.MSRatedAirVolFlowRate(Mode);
                bool errorsFound = false;
                HeatingAirFlowSizer sizingHeatingAirFlow;
                sizingHeatingAirFlow.overrideSizingString(SizingString);
                // sizingHeatingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                sizingHeatingAirFlow.initializeWithinEP(state, CompType, CompName, bPRINT, RoutineName);
                thisDXCoil.MSRatedAirVolFlowRate(Mode) = sizingHeatingAirFlow.size(state, TempSize, errorsFound);
            }
            state.dataSize->DataEMSOverride = 0.0;
            state.dataSize->DataEMSOverrideON = false;
            state.dataSize->DataIsDXCoil = false;
            state.dataSize->DataTotCapCurveIndex = 0;
            state.dataSize->DataConstantUsedForSizing = 0.0;
            state.dataSize->DataFractionUsedForSizing = 0.0;
        }

        // Ensure flow rate at lower speed must be lower or equal to the flow rate at higher speed. Otherwise, a severe error is issued.
        for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds - 1; ++Mode) {
            if (thisDXCoil.MSRatedAirVolFlowRate(Mode) > thisDXCoil.MSRatedAirVolFlowRate(Mode + 1)) {
                ShowWarningError(state,
                                 format("SizeDXCoil: {} {}, Speed {} Rated Air Flow Rate must be less than or equal to Speed {} Rated Air Flow Rate.",
                                        thisDXCoil.DXCoilType,
                                        thisDXCoil.Name,
                                        Mode,
                                        Mode + 1));
                ShowContinueError(
                    state, format("Instead, {:.2R} > {:.2R}", thisDXCoil.MSRatedAirVolFlowRate(Mode), thisDXCoil.MSRatedAirVolFlowRate(Mode + 1)));
                ShowFatalError(state, "Preceding conditions cause termination.");
            }
        }
        // Rated Secondary Coil Airflow Rates for AirCooled condenser type
        if (thisDXCoil.IsSecondaryDXCoilInZone) {
            for (Mode = thisDXCoil.NumOfSpeeds; Mode >= 1; --Mode) {
                IsAutoSize = false;
                if (thisDXCoil.MSSecCoilAirFlow(Mode) == AutoSize) {
                    IsAutoSize = true;
                }
                // Autosize Primary Coil air flow * Secondary Coil Scaling Factor
                SecCoilAirFlowDes = thisDXCoil.MSRatedAirVolFlowRate(Mode) * thisDXCoil.MSSecCoilAirFlowScalingFactor(Mode);
                if (IsAutoSize) {
                    thisDXCoil.MSSecCoilAirFlow(Mode) = SecCoilAirFlowDes;
                    BaseSizer::reportSizerOutput(state,
                                                 thisDXCoil.DXCoilType,
                                                 thisDXCoil.Name,
                                                 format("Design Size Speed {} Secondary Coil Air Flow Rate [m3/s]", Mode),
                                                 SecCoilAirFlowDes);
                } else {
                    if (thisDXCoil.MSSecCoilAirFlow(Mode) > 0.0 && SecCoilAirFlowDes > 0.0 && !HardSizeNoDesRun) {
                        SecCoilAirFlowUser = thisDXCoil.MSSecCoilAirFlow(Mode);
                        BaseSizer::reportSizerOutput(state,
                                                     thisDXCoil.DXCoilType,
                                                     thisDXCoil.Name,
                                                     format("Design Size Speed {} Secondary Coil Air Flow Rate [m3/s]", Mode),
                                                     SecCoilAirFlowDes,
                                                     format("User-Specified Speed {} Secondary Coil Air Flow Rate [m3/s]", Mode),
                                                     SecCoilAirFlowUser);
                        if (state.dataGlobal->DisplayExtraWarnings) {
                            if ((std::abs(SecCoilAirFlowDes - SecCoilAirFlowUser) / SecCoilAirFlowUser) > state.dataSize->AutoVsHardSizingThreshold) {
                                ShowMessage(
                                    state,
                                    format("SizeDxCoil: Potential issue with equipment sizing for {} {}", thisDXCoil.DXCoilType, thisDXCoil.Name));
                                ShowContinueError(state, format("User-Specified Secondary Coil Air Flow Rate of {:.5R} [m3/s]", SecCoilAirFlowUser));
                                ShowContinueError(
                                    state, format("differs from Design Size Secondary Coil Air Flow Rate of {:.5R} [m3/s]", SecCoilAirFlowDes));
                                ShowContinueError(state, "This may, or may not, indicate mismatched component sizes.");
                                ShowContinueError(state, "Verify that the value entered is intended and is consistent with other components.");
                            }
                        }
                    }
                }
            }
        }

        // Sizing rated total heating capacity
        for (Mode = thisDXCoil.NumOfSpeeds; Mode >= 1; --Mode) {
            IsAutoSize = false;
            if (thisDXCoil.MSRatedTotCap(Mode) == AutoSize) {
                IsAutoSize = true;
            }
            state.dataSize->DataIsDXCoil = true;
            CompName = thisDXCoil.Name;
            CompType = thisDXCoil.DXCoilType;
            if (Mode == thisDXCoil.NumOfSpeeds) {
                state.dataSize->DataFlowUsedForSizing = thisDXCoil.MSRatedAirVolFlowRate(Mode);
                FieldNum = 10 + (Mode - 1) * 6;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames(FieldNum) + " [W]";
                state.dataSize->DataTotCapCurveIndex = thisDXCoil.MSCCapFTemp(Mode);
                if (IsAutoSize || !HardSizeNoDesRun) {
                    // Heating capacity is assumed to be equal to the cooling capacity
                    PrintFlag = false;
                    state.dataSize->DataFractionUsedForSizing = 1.0;
                    if (thisDXCoil.CompanionUpstreamDXCoil > 0) {
                        NumOfSpeedCompanion = state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).NumOfSpeeds;
                        state.dataSize->DataConstantUsedForSizing =
                            state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).MSRatedTotCapDes(NumOfSpeedCompanion);
                    } else {
                        state.dataSize->DataConstantUsedForSizing = thisDXCoil.RatedTotCap(1); // sized above
                    }
                    TempSize = DataSizing::AutoSize;
                    state.dataSize->DataEMSOverrideON = thisDXCoil.RatedTotCapEMSOverrideOn(Mode);
                    state.dataSize->DataEMSOverride = thisDXCoil.RatedTotCapEMSOverrideValue(Mode);
                    HeatingCapacitySizer sizerHeatingCapacity;
                    sizerHeatingCapacity.overrideSizingString(SizingString);
                    sizerHeatingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                    MSRatedTotCapDesAtMaxSpeed = sizerHeatingCapacity.size(state, TempSize, ErrorsFound);
                    state.dataSize->DataConstantUsedForSizing = MSRatedTotCapDesAtMaxSpeed;
                    state.dataSize->DataFractionUsedForSizing = 1.0;
                }
                PrintFlag = true;
                TempSize = thisDXCoil.MSRatedTotCap(Mode);
                state.dataSize->DataEMSOverrideON = thisDXCoil.RatedTotCapEMSOverrideOn(Mode);
                state.dataSize->DataEMSOverride = thisDXCoil.RatedTotCapEMSOverrideValue(Mode);
                HeatingCapacitySizer sizerHeatingCapacity;
                sizerHeatingCapacity.overrideSizingString(SizingString);
                sizerHeatingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                TempSize = sizerHeatingCapacity.size(state, TempSize, ErrorsFound);
                thisDXCoil.MSRatedTotCap(Mode) = TempSize;
                if (IsAutoSize) {
                    MSRatedTotCapDesAtMaxSpeed = TempSize;
                }
            } else {
                PrintFlag = true;
                FieldNum = 10 + (Mode - 1) * 6;
                SizingString = state.dataDXCoils->DXCoilNumericFields(DXCoilNum).PerfMode(1).FieldNames(FieldNum) + " [W]";
                if (IsAutoSize || !HardSizeNoDesRun) {
                    // autosize low speed capacity to fraction of the highest speed capacity
                    if (!HardSizeNoDesRun) {
                        state.dataSize->DataConstantUsedForSizing = MSRatedTotCapDesAtMaxSpeed;
                    } else {
                        state.dataSize->DataConstantUsedForSizing = thisDXCoil.MSRatedTotCap(thisDXCoil.NumOfSpeeds);
                    }
                    state.dataSize->DataFractionUsedForSizing = (float)Mode / thisDXCoil.NumOfSpeeds;
                }
                TempSize = thisDXCoil.MSRatedTotCap(Mode);
                state.dataSize->DataEMSOverrideON = thisDXCoil.RatedTotCapEMSOverrideOn(Mode);
                state.dataSize->DataEMSOverride = thisDXCoil.RatedTotCapEMSOverrideValue(Mode);
                HeatingCapacitySizer sizerHeatingCapacity;
                sizerHeatingCapacity.overrideSizingString(SizingString);
                sizerHeatingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                TempSize = sizerHeatingCapacity.size(state, TempSize, ErrorsFound);
                thisDXCoil.MSRatedTotCap(Mode) = TempSize;
            }
            PrintFlag = false;
            state.dataSize->DataEMSOverrideON = false;
            state.dataSize->DataEMSOverride = 0.0;
            state.dataSize->DataIsDXCoil = false;
            state.dataSize->DataFlowUsedForSizing = 0.0;
            state.dataSize->DataCoolCoilCap = 0.0;
            state.dataSize->DataTotCapCurveIndex = 0;
            state.dataSize->DataConstantUsedForSizing = 0.0;
            state.dataSize->DataFractionUsedForSizing = 0.0;
        }
        // Ensure capacity at lower speed must be lower or equal to the capacity at higher speed.
        for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds - 1; ++Mode) {
            if (thisDXCoil.MSRatedTotCap(Mode) > thisDXCoil.MSRatedTotCap(Mode + 1)) {
                ShowWarningError(state,
                                 format("SizeDXCoil: {} {}, Speed {} Rated Total Heating Capacity must be less than or equal to Speed {} Rated "
                                        "Total Heating Capacity.",
                                        thisDXCoil.DXCoilType,
                                        thisDXCoil.Name,
                                        Mode,
                                        Mode + 1));
                ShowContinueError(state, format("Instead, {:.2R} > {:.2R}", thisDXCoil.MSRatedTotCap(Mode), thisDXCoil.MSRatedTotCap(Mode + 1)));
                ShowFatalError(state, "Preceding conditions cause termination.");
            }
        }

        // Resistive Defrost Heater Capacity = capacity at the first stage
        // Sizing defrost heater capacity
        IsAutoSize = false;
        if (thisDXCoil.DefrostCapacity == AutoSize) {
            IsAutoSize = true;
        }
        if (thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::Resistive) {
            DefrostCapacityDes = thisDXCoil.MSRatedTotCap(1);
        } else {
            DefrostCapacityDes = 0.0;
        }
        if (IsAutoSize) {
            thisDXCoil.DefrostCapacity = DefrostCapacityDes;
            BaseSizer::reportSizerOutput(
                state, thisDXCoil.DXCoilType, thisDXCoil.Name, "Design Size Resistive Defrost Heater Capacity", DefrostCapacityDes);
        } else {
            if (thisDXCoil.DefrostCapacity > 0.0 && DefrostCapacityDes > 0.0 && !HardSizeNoDesRun) {
                DefrostCapacityUser = thisDXCoil.DefrostCapacity;
                BaseSizer::reportSizerOutput(state,
                                             thisDXCoil.DXCoilType,
                                             thisDXCoil.Name,
                                             "Design Size Resistive Defrost Heater Capacity",
                                             DefrostCapacityDes,
                                             "User-Specified Resistive Defrost Heater Capacity",
                                             DefrostCapacityUser);
                if (state.dataGlobal->DisplayExtraWarnings) {
                    if ((std::abs(DefrostCapacityDes - DefrostCapacityUser) / DefrostCapacityUser) > state.dataSize->AutoVsHardSizingThreshold) {
                        ShowWarningMessage(
                            state, format("SizeDxCoil: Potential issue with equipment sizing for {} {}", thisDXCoil.DXCoilType, thisDXCoil.Name));
                        ShowContinueError(state, format("User-Specified Resistive Defrost Heater Capacity of {:.2R}[W]", DefrostCapacityUser));
                        ShowContinueError(state,
                                          format("differs from Design Size Resistive Defrost Heater Capacity of {:.2R}[W]", DefrostCapacityDes));
                        ShowContinueError(state, "This may, or may not, indicate mismatched component sizes.");
                        ShowContinueError(state, "Verify that the value entered is intended and is consistent with other components.");
                    }
                }
            }
        }
    }

    // Call routine that computes AHRI certified rating for single-speed DX Coils
    if ((thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingSingleSpeed &&
         (thisDXCoil.CondenserType(1) == DataHeatBalance::RefrigCondenserType::Air ||
          thisDXCoil.CondenserType(1) == DataHeatBalance::RefrigCondenserType::Evap)) ||
        thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatingEmpirical) {
        CalcDXCoilStandardRating(state,
                                 thisDXCoil.Name,
                                 thisDXCoil.DXCoilType,
                                 thisDXCoil.DXCoilType_Num,
                                 1,
                                 thisDXCoil.RatedTotCap(1),
                                 thisDXCoil.RatedCOP(1),
                                 thisDXCoil.CCapFFlow(1),
                                 thisDXCoil.CCapFTemp(1),
                                 thisDXCoil.EIRFFlow(1),
                                 thisDXCoil.EIRFTemp(1),
                                 thisDXCoil.PLFFPLR(1),
                                 thisDXCoil.RatedAirVolFlowRate(1),
                                 thisDXCoil.FanPowerPerEvapAirFlowRate(1),
                                 thisDXCoil.FanPowerPerEvapAirFlowRate_2023(1),
                                 thisDXCoil.CondenserType,
                                 thisDXCoil.RegionNum,
                                 thisDXCoil.MinOATCompressor,
                                 thisDXCoil.OATempCompressorOn,
                                 thisDXCoil.OATempCompressorOnOffBlank,
                                 thisDXCoil.DefrostControl,
                                 thisDXCoil.ASHRAE127StdRprt);
    }
    // Call routine that computes AHRI certified rating for multi-speed DX cooling Coils
    if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedCooling || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_MultiSpeedHeating) {
        CalcDXCoilStandardRating(state,
                                 thisDXCoil.Name,
                                 thisDXCoil.DXCoilType,
                                 thisDXCoil.DXCoilType_Num,
                                 thisDXCoil.NumOfSpeeds,
                                 thisDXCoil.MSRatedTotCap,
                                 thisDXCoil.MSRatedCOP,
                                 thisDXCoil.MSCCapFFlow,
                                 thisDXCoil.MSCCapFTemp,
                                 thisDXCoil.MSEIRFFlow,
                                 thisDXCoil.MSEIRFTemp,
                                 thisDXCoil.MSPLFFPLR,
                                 thisDXCoil.MSRatedAirVolFlowRate,
                                 thisDXCoil.MSFanPowerPerEvapAirFlowRate,
                                 thisDXCoil.MSFanPowerPerEvapAirFlowRate_2023,
                                 thisDXCoil.CondenserType,
                                 thisDXCoil.RegionNum,
                                 thisDXCoil.MinOATCompressor,
                                 thisDXCoil.OATempCompressorOn,
                                 thisDXCoil.OATempCompressorOnOffBlank,
                                 thisDXCoil.DefrostControl,
                                 ObjexxFCL::Optional_bool_const());
    }

    if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed && (thisDXCoil.CondenserType(1) == DataHeatBalance::RefrigCondenserType::Air ||
                                                                      thisDXCoil.CondenserType(1) == DataHeatBalance::RefrigCondenserType::Evap)) {
        StandardRatings::CalcTwoSpeedDXCoilRating(state,
                                                  thisDXCoil.Name,
                                                  thisDXCoil.DXCoilType,
                                                  thisDXCoil.DXCoilType_Num,
                                                  thisDXCoil.RatedTotCap,
                                                  thisDXCoil.RatedTotCap2,
                                                  thisDXCoil.RatedCOP,
                                                  thisDXCoil.RatedCOP2,
                                                  thisDXCoil.CCapFFlow, // High Speed
                                                  thisDXCoil.CCapFTemp,
                                                  thisDXCoil.CCapFTemp2,
                                                  thisDXCoil.EIRFFlow, // High Speed
                                                  thisDXCoil.EIRFTemp,
                                                  thisDXCoil.EIRFTemp2,
                                                  thisDXCoil.RatedAirVolFlowRate,
                                                  thisDXCoil.RatedAirVolFlowRate2,
                                                  thisDXCoil.FanPowerPerEvapAirFlowRate_2023,
                                                  thisDXCoil.FanPowerPerEvapAirFlowRate_2023_LowSpeed,
                                                  thisDXCoil.CondenserType,
                                                  thisDXCoil.PLFFPLR(1));
    }

    // create predefined report entries
    equipName = thisDXCoil.Name;
    // put tables for cooling and heating separate
    switch (thisDXCoil.DXCoilType_Num) {
    case HVAC::CoilDX_CoolingSingleSpeed:
    case HVAC::CoilDX_CoolingTwoSpeed:
    case HVAC::CoilDX_CoolingTwoStageWHumControl:
    case HVAC::CoilDX_MultiSpeedCooling: {
        PreDefTableEntry(state, state.dataOutRptPredefined->pdchCoolCoilType, equipName, thisDXCoil.DXCoilType);
        if (thisDXCoil.NumOfSpeeds == 0) {
            if (thisDXCoil.NumCapacityStages == 1) {
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchCoolCoilTotCap, equipName, thisDXCoil.RatedTotCap(1));
                PreDefTableEntry(
                    state, state.dataOutRptPredefined->pdchCoolCoilSensCap, equipName, thisDXCoil.RatedTotCap(1) * thisDXCoil.RatedSHR(1));
                PreDefTableEntry(state,
                                 state.dataOutRptPredefined->pdchCoolCoilLatCap,
                                 equipName,
                                 thisDXCoil.RatedTotCap(1) - thisDXCoil.RatedTotCap(1) * thisDXCoil.RatedSHR(1));
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchCoolCoilSHR, equipName, thisDXCoil.RatedSHR(1));
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchCoolCoilNomEff, equipName, thisDXCoil.RatedCOP(1));
            } else {
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchCoolCoilTotCap, equipName, thisDXCoil.RatedTotCap(2));
                PreDefTableEntry(
                    state, state.dataOutRptPredefined->pdchCoolCoilSensCap, equipName, thisDXCoil.RatedTotCap(2) * thisDXCoil.RatedSHR(2));
                PreDefTableEntry(state,
                                 state.dataOutRptPredefined->pdchCoolCoilLatCap,
                                 equipName,
                                 thisDXCoil.RatedTotCap(2) - thisDXCoil.RatedTotCap(2) * thisDXCoil.RatedSHR(2));
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchCoolCoilSHR, equipName, thisDXCoil.RatedSHR(2));
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchCoolCoilNomEff, equipName, thisDXCoil.RatedCOP(2));
            }
        } else {
            for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds; ++Mode) {
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchCoolCoilTotCap, equipName, thisDXCoil.MSRatedTotCap(Mode));
                PreDefTableEntry(
                    state, state.dataOutRptPredefined->pdchCoolCoilSensCap, equipName, thisDXCoil.MSRatedTotCap(Mode) * thisDXCoil.MSRatedSHR(Mode));
                PreDefTableEntry(state,
                                 state.dataOutRptPredefined->pdchCoolCoilLatCap,
                                 equipName,
                                 thisDXCoil.MSRatedTotCap(Mode) - thisDXCoil.MSRatedTotCap(Mode) * thisDXCoil.MSRatedSHR(Mode));
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchCoolCoilSHR, equipName, thisDXCoil.MSRatedSHR(Mode));
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchCoolCoilNomEff, equipName, thisDXCoil.MSRatedCOP(Mode));
            }
        }
        addFootNoteSubTable(state,
                            state.dataOutRptPredefined->pdstCoolCoil,
                            "Nominal values are gross at rated conditions, i.e., the supply air fan heat and electric power NOT accounted for.");
    } break;
    case HVAC::CoilDX_HeatingEmpirical:
    case HVAC::CoilDX_MultiSpeedHeating:
    case HVAC::CoilDX_HeatPumpWaterHeaterPumped:
    case HVAC::CoilDX_HeatPumpWaterHeaterWrapped: {
        PreDefTableEntry(state, state.dataOutRptPredefined->pdchHeatCoilType, equipName, thisDXCoil.DXCoilType);
        if (thisDXCoil.NumOfSpeeds == 0) {
            if (thisDXCoil.NumCapacityStages == 1) {
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchHeatCoilNomCap, equipName, thisDXCoil.RatedTotCap(1));
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchHeatCoilNomEff, equipName, thisDXCoil.RatedCOP(1));
            } else {
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchHeatCoilNomCap, equipName, thisDXCoil.RatedTotCap(2));
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchHeatCoilNomEff, equipName, thisDXCoil.RatedCOP(2));
            }
        } else {
            for (Mode = 1; Mode <= thisDXCoil.NumOfSpeeds; ++Mode) {
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchHeatCoilNomCap, equipName, thisDXCoil.MSRatedTotCap(Mode));
                PreDefTableEntry(state, state.dataOutRptPredefined->pdchHeatCoilNomEff, equipName, thisDXCoil.MSRatedCOP(Mode));
            }
        }
        addFootNoteSubTable(state,
                            state.dataOutRptPredefined->pdstHeatCoil,
                            "Nominal values are gross at rated conditions, i.e., the supply air fan heat and electric power NOT accounted for.");

        // std 229 existing table DX Heating coil new reporting variables
        OutputReportPredefined::PreDefTableEntry(
            state, state.dataOutRptPredefined->pdchDXHeatCoilMinOADBTforCompOp, equipName, thisDXCoil.MinOATCompressor);
        OutputReportPredefined::PreDefTableEntry(state,
                                                 state.dataOutRptPredefined->pdchDXHeatCoilAirloopName,
                                                 equipName,
                                                 thisDXCoil.AirLoopNum > 0 ? state.dataAirSystemsData->PrimaryAirSystems(thisDXCoil.AirLoopNum).Name
                                                                           : "N/A");
        // std 229 existing table DX Heating coil 2023 AHRI new reporting variables
        OutputReportPredefined::PreDefTableEntry(
            state, state.dataOutRptPredefined->pdchDXHeatCoilMinOADBTforCompOp_2023, equipName, thisDXCoil.MinOATCompressor);
        OutputReportPredefined::PreDefTableEntry(state,
                                                 state.dataOutRptPredefined->pdchDXHeatCoilAirloopName_2023,
                                                 equipName,
                                                 thisDXCoil.AirLoopNum > 0 ? state.dataAirSystemsData->PrimaryAirSystems(thisDXCoil.AirLoopNum).Name
                                                                           : "N/A");
    } break;
    default:
        break;
    }
}

void CalcHPWHDXCoil(EnergyPlusData &state,
                    int const DXCoilNum,       // the number of the DX coil to be simulated
                    Real64 const PartLoadRatio // sensible water heating load / full load sensible water heating capacity
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Richard Raustad
    //       DATE WRITTEN   May 2005

    // PURPOSE OF THIS SUBROUTINE:
    // Calculates the gross cooling capacity of a heat pump water heater evaporator and
    // heating capacity of the condenser coil given the rated heating capacity and COP.

    // METHODOLOGY EMPLOYED:
    // The routine requires the user to enter the total heating capacity and COP for the
    // heat pump water heater along with logicals defining if fan and condenser pump are included.
    // Since manufacturer's can rate their HPWH equipment with or without including condenser
    // pump heat, this information is required to accurately determine the condenser's leaving
    // water temperature. In addition, knowledge of the fan heat is required to back into
    // a compressor COP.

    // Using/Aliasing
    using Curve::CurveValue;

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 RatedHeatingCapacity;     // Water heating rated capacity with or without condenser water pump heat (W)
    Real64 RatedHeatingCOP;          // Water heating rated COP with or without evap fan and cond water pump heat (W/W)
    Real64 OperatingHeatingCapacity; // Water heating operating capacity including the impact of capacity and COP curves (W)
    Real64 OperatingHeatingCOP;      // Water heating operating COP including the impact of capacity and COP curves (W/W)
    Real64 OperatingHeatingPower;    // Water heating operating Power (W)
    Real64 CompressorPower;          // Power consumed by compressor only (W)

    Real64 TotalTankHeatingCapacity; // Water heating capacity corrected for condenser water pump heat (W)
    Real64 TankHeatingCOP;           // Water heating COP corrected for fan and condenser water pump power (W/W)
    // (these previous 2 variables also include the impact of capacity and COP curves)
    Real64 EvapCoolingCapacity;   // Air cooling capacity corrected for evap fan and cond water pump heat (W)
    Real64 InletWaterTemp;        // Condenser water inlet temperature (C)
    Real64 OutletWaterTemp;       // Condenser water outlet temperature (C)
    Real64 EvapInletMassFlowRate; // Evaporator air inlet mass flow rate (m3/s)
    Real64 CondInletMassFlowRate; // Condenser water inlet mass flow rate (m3/s)
    Real64 CpWater;               // Specific heat of condenser inlet water (J/Kg/k)
    Real64 InletAirTemp;          // HPWH inlet air temperature (dry-bulb or wet-bulb) (C)
    Real64 HeatCapFTemp;          // Output of HPWH Heating Capacity as a Function of Temperature curve
    Real64 HeatCapFAirFlow;       // Output of HPWH Heating Capacity as a Function of Air Flow Rate Ratio curve
    Real64 HeatCapFWaterFlow;     // Output of HPWH Heating Capacity as a Function of Water Flow Rate Ratio curve
    Real64 HeatCOPFTemp;          // Output of HPWH COP as a Function of Temperature curve
    Real64 HeatCOPFAirFlow;       // Output of HPWH COP as a Function of Air Flow Rate Ratio curve
    Real64 HeatCOPFWaterFlow;     // Output of HPWH COP as a Function of Water Flow Rate Ratio curve
    Real64 AirFlowRateRatio;      // Ratio of evaporator inlet air mass flow rate to rated mass flow rate
    Real64 WaterFlowRateRatio;    // Ratio of evaporator inlet water mass flow rate to rated mass flow rate
    Real64 PartLoadFraction;      // Output of Part Load Fraction as a Function of Part Load Ratio curve
    Real64 PumpHeatToWater;       // Amount of pump heat attributed to heating water
    Real64 HPRTF;                 // Heat pump run time fraction

    // References to Coil and Node struct
    DXCoilData &Coil = state.dataDXCoils->DXCoil(DXCoilNum);
    NodeData &AirInletNode = state.dataLoopNodes->Node(Coil.AirInNode);
    NodeData &WaterInletNode = state.dataLoopNodes->Node(Coil.WaterInNode);
    NodeData &WaterOutletNode = state.dataLoopNodes->Node(Coil.WaterOutNode);

    // If heat pump water heater is OFF, set outlet to inlet and RETURN
    // Also set the heating energy rate to zero
    if (PartLoadRatio == 0.0) {
        WaterOutletNode = WaterInletNode;
        Coil.TotalHeatingEnergyRate = 0.0;
        return;
    } else {
        RatedHeatingCapacity = Coil.RatedTotCap2;
        RatedHeatingCOP = Coil.RatedCOP(1);
        InletWaterTemp = WaterInletNode.Temp;
        CondInletMassFlowRate = WaterInletNode.MassFlowRate / PartLoadRatio;
        EvapInletMassFlowRate = AirInletNode.MassFlowRate / PartLoadRatio;
        CpWater = CPHW(InletWaterTemp);
        CompressorPower = 0.0;
        OperatingHeatingPower = 0.0;
        TankHeatingCOP = 0.0;
    }

    // determine inlet air temperature type for curve objects
    if (Coil.InletAirTemperatureType == HVAC::OATType::WetBulb) {
        InletAirTemp = state.dataHVACGlobal->HPWHInletWBTemp;
    } else {
        InletAirTemp = state.dataHVACGlobal->HPWHInletDBTemp;
    }

    // get output of Heating Capacity and Heating COP curves (curves default to 1 if user has not specified curve name)
    if (Coil.HCapFTemp > 0) {
        if (state.dataCurveManager->PerfCurve(Coil.HCapFTemp)->numDims == 1) {
            HeatCapFTemp = CurveValue(state, Coil.HCapFTemp, InletAirTemp);
        } else {
            HeatCapFTemp = CurveValue(state, Coil.HCapFTemp, InletAirTemp, InletWaterTemp);
        }
        //   Warn user if curve output goes negative
        if (HeatCapFTemp < 0.0) {
            if (Coil.HCapFTempErrorIndex == 0) {
                ShowWarningMessage(state, format("{} \"{}\":", Coil.DXCoilType, Coil.Name));
                ShowContinueError(
                    state, format(" HPWH Heating Capacity Modifier curve (function of temperature) output is negative ({:.3T}).", HeatCapFTemp));
                if (state.dataCurveManager->PerfCurve(Coil.HCapFTemp)->numDims == 2) {
                    ShowContinueError(
                        state,
                        format(" Negative value occurs using an inlet air temperature of {:.1T} and an inlet water temperature of {:.1T}.",
                               InletAirTemp,
                               InletWaterTemp));
                } else {
                    ShowContinueError(state, format(" Negative value occurs using an inlet air temperature of {:.1T}.", InletAirTemp));
                }
                ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                Coil.DXCoilType + " \"" + Coil.Name +
                    "\": HPWH Heating Capacity Modifier curve (function of temperature) output is negative warning continues...",
                Coil.HCapFTempErrorIndex,
                HeatCapFTemp,
                HeatCapFTemp,
                _,
                "[C]",
                "[C]");
            HeatCapFTemp = 0.0;
        }
    } else {
        HeatCapFTemp = 1.0;
    }

    if (Coil.HCOPFTemp > 0) {
        if (state.dataCurveManager->PerfCurve(Coil.HCOPFTemp)->numDims == 1) {
            HeatCOPFTemp = CurveValue(state, Coil.HCOPFTemp, InletAirTemp);
        } else {
            HeatCOPFTemp = CurveValue(state, Coil.HCOPFTemp, InletAirTemp, InletWaterTemp);
        }
        //   Warn user if curve output goes negative
        if (HeatCOPFTemp < 0.0) {
            if (Coil.HCOPFTempErrorIndex == 0) {
                ShowWarningMessage(state, format("{} \"{}\":", Coil.DXCoilType, Coil.Name));
                ShowContinueError(state,
                                  format(" HPWH Heating COP Modifier curve (function of temperature) output is negative ({:.3T}).", HeatCOPFTemp));
                if (state.dataCurveManager->PerfCurve(Coil.HCOPFTemp)->numDims == 2) {
                    ShowContinueError(
                        state,
                        format(" Negative value occurs using an inlet air temperature of {:.1T} and an inlet water temperature of {:.1T}.",
                               InletAirTemp,
                               InletWaterTemp));
                } else {
                    ShowContinueError(state, format(" Negative value occurs using an inlet air temperature of {:.1T}.", InletAirTemp));
                }
                ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                Coil.DXCoilType + " \"" + Coil.Name +
                    "\": HPWH Heating COP Modifier curve (function of temperature) output is negative warning continues...",
                Coil.HCOPFTempErrorIndex,
                HeatCOPFTemp,
                HeatCOPFTemp,
                _,
                "[C]",
                "[C]");
            HeatCOPFTemp = 0.0;
        }
    } else {
        HeatCOPFTemp = 1.0;
    }

    if (Coil.HCapFAirFlow > 0) {
        AirFlowRateRatio = EvapInletMassFlowRate / (Coil.RatedAirMassFlowRate(1));
        HeatCapFAirFlow = CurveValue(state, Coil.HCapFAirFlow, AirFlowRateRatio);
        //   Warn user if curve output goes negative
        if (HeatCapFAirFlow < 0.0) {
            if (Coil.HCapFAirFlowErrorIndex == 0) {
                ShowWarningMessage(state, format("{} \"{}\":", Coil.DXCoilType, Coil.Name));
                ShowContinueError(
                    state,
                    format(" HPWH Heating Capacity Modifier curve (function of air flow fraction) output is negative ({:.3T}).", HeatCapFAirFlow));
                ShowContinueError(state, format(" Negative value occurs using an air flow fraction of {:.3T}.", AirFlowRateRatio));
                ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                Coil.DXCoilType + " \"" + Coil.Name +
                    "\": HPWH Heating Capacity Modifier curve (function of air flow fraction) output is negative warning continues...",
                Coil.HCapFAirFlowErrorIndex,
                HeatCapFAirFlow,
                HeatCapFAirFlow);
            HeatCapFAirFlow = 0.0;
        }
    } else {
        HeatCapFAirFlow = 1.0;
    }

    if (Coil.HCOPFAirFlow > 0) {
        AirFlowRateRatio = EvapInletMassFlowRate / (Coil.RatedAirMassFlowRate(1));
        HeatCOPFAirFlow = CurveValue(state, Coil.HCOPFAirFlow, AirFlowRateRatio);
        //   Warn user if curve output goes negative
        if (HeatCOPFAirFlow < 0.0) {
            if (Coil.HCOPFAirFlowErrorIndex == 0) {
                ShowWarningMessage(state, format("{} \"{}\":", Coil.DXCoilType, Coil.Name));
                ShowContinueError(
                    state, format(" HPWH Heating COP Modifier curve (function of air flow fraction) output is negative ({:.3T}).", HeatCOPFAirFlow));
                ShowContinueError(state, format(" Negative value occurs using an air flow fraction of {:.3T}.", AirFlowRateRatio));
                ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                Coil.DXCoilType + " \"" + Coil.Name +
                    "\": HPWH Heating COP Modifier curve (function of air flow fraction) output is negative warning continues...",
                Coil.HCOPFAirFlowErrorIndex,
                HeatCOPFAirFlow,
                HeatCOPFAirFlow);
            HeatCOPFAirFlow = 0.0;
        }
    } else {
        HeatCOPFAirFlow = 1.0;
    }

    if (Coil.HCapFWaterFlow > 0) {
        WaterFlowRateRatio = CondInletMassFlowRate / (Coil.RatedHPWHCondWaterFlow * RhoH2O(InletWaterTemp));
        HeatCapFWaterFlow = CurveValue(state, Coil.HCapFWaterFlow, WaterFlowRateRatio);
        //   Warn user if curve output goes negative
        if (HeatCapFWaterFlow < 0.0) {
            if (Coil.HCapFWaterFlowErrorIndex == 0) {
                ShowWarningMessage(state, format("{} \"{}\":", Coil.DXCoilType, Coil.Name));
                ShowContinueError(state,
                                  format(" HPWH Heating Capacity Modifier curve (function of water flow fraction) output is negative ({:.3T}).",
                                         HeatCapFWaterFlow));
                ShowContinueError(state, format(" Negative value occurs using a water flow fraction of {:.3T}.", WaterFlowRateRatio));
                ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                Coil.DXCoilType + " \"" + Coil.Name +
                    "\": HPWH Heating Capacity Modifier curve (function of water flow fraction) output is negative warning continues...",
                Coil.HCapFWaterFlowErrorIndex,
                HeatCapFWaterFlow,
                HeatCapFWaterFlow);
            HeatCapFWaterFlow = 0.0;
        }
    } else {
        HeatCapFWaterFlow = 1.0;
    }

    if (Coil.HCOPFWaterFlow > 0) {
        WaterFlowRateRatio = CondInletMassFlowRate / (Coil.RatedHPWHCondWaterFlow * RhoH2O(InletWaterTemp));
        HeatCOPFWaterFlow = CurveValue(state, Coil.HCOPFWaterFlow, WaterFlowRateRatio);
        //   Warn user if curve output goes negative
        if (HeatCOPFWaterFlow < 0.0) {
            if (Coil.HCOPFWaterFlowErrorIndex == 0) {
                ShowWarningMessage(state, format("{} \"{}\":", Coil.DXCoilType, Coil.Name));
                ShowContinueError(
                    state,
                    format(" HPWH Heating COP Modifier curve (function of water flow fraction) output is negative ({:.3T}).", HeatCOPFWaterFlow));
                ShowContinueError(state, format(" Negative value occurs using a water flow fraction of {:.3T}.", WaterFlowRateRatio));
                ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                Coil.DXCoilType + " \"" + Coil.Name +
                    "\": HPWH Heating COP Modifier curve (function of water flow fraction) output is negative warning continues...",
                Coil.HCOPFWaterFlowErrorIndex,
                HeatCOPFWaterFlow,
                HeatCOPFWaterFlow);
            HeatCOPFWaterFlow = 0.0;
        }
    } else {
        HeatCOPFWaterFlow = 1.0;
    }

    // adjust Heating Capacity and COP for off-design conditions
    OperatingHeatingCapacity = RatedHeatingCapacity * HeatCapFTemp * HeatCapFAirFlow * HeatCapFWaterFlow;
    OperatingHeatingCOP = RatedHeatingCOP * HeatCOPFTemp * HeatCOPFAirFlow * HeatCOPFWaterFlow;

    if (OperatingHeatingCOP > 0.0) OperatingHeatingPower = OperatingHeatingCapacity / OperatingHeatingCOP;

    PumpHeatToWater = Coil.HPWHCondPumpElecNomPower * Coil.HPWHCondPumpFracToWater;
    TankHeatingCOP = OperatingHeatingCOP;

    // account for pump heat if not included in total water heating capacity
    if (Coil.CondPumpHeatInCapacity) {
        TotalTankHeatingCapacity = OperatingHeatingCapacity;
    } else {
        TotalTankHeatingCapacity = OperatingHeatingCapacity + PumpHeatToWater;
    }

    // find part load fraction to calculate RTF
    if (Coil.PLFFPLR(1) > 0) {
        PartLoadFraction = max(0.7, CurveValue(state, Coil.PLFFPLR(1), PartLoadRatio));
    } else {
        PartLoadFraction = 1.0;
    }

    HPRTF = min(1.0, (PartLoadRatio / PartLoadFraction));

    Real64 locFanElecPower = state.dataFans->fans(Coil.SupplyFanIndex)->totalPower;

    // calculate evaporator total cooling capacity
    if (HPRTF > 0.0) {
        if (Coil.FanPowerIncludedInCOP) {
            if (Coil.CondPumpPowerInCOP) {
                //       make sure fan power is full load fan power
                CompressorPower = OperatingHeatingPower - locFanElecPower / HPRTF - Coil.HPWHCondPumpElecNomPower;
                if (OperatingHeatingPower > 0.0) TankHeatingCOP = TotalTankHeatingCapacity / OperatingHeatingPower;
            } else {
                CompressorPower = OperatingHeatingPower - locFanElecPower / HPRTF;
                if ((OperatingHeatingPower + Coil.HPWHCondPumpElecNomPower) > 0.0)
                    TankHeatingCOP = TotalTankHeatingCapacity / (OperatingHeatingPower + Coil.HPWHCondPumpElecNomPower);
            }
        } else {
            if (Coil.CondPumpPowerInCOP) {
                //       make sure fan power is full load fan power
                CompressorPower = OperatingHeatingPower - Coil.HPWHCondPumpElecNomPower;
                if ((OperatingHeatingPower + locFanElecPower / HPRTF) > 0.0)
                    TankHeatingCOP = TotalTankHeatingCapacity / (OperatingHeatingPower + locFanElecPower / HPRTF);
            } else {
                CompressorPower = OperatingHeatingPower;
                if ((OperatingHeatingPower + locFanElecPower / HPRTF + Coil.HPWHCondPumpElecNomPower) > 0.0)
                    TankHeatingCOP = TotalTankHeatingCapacity / (OperatingHeatingPower + locFanElecPower / HPRTF + Coil.HPWHCondPumpElecNomPower);
            }
        }
    }

    if (Coil.CondPumpHeatInCapacity) {
        EvapCoolingCapacity = TotalTankHeatingCapacity - PumpHeatToWater - CompressorPower;
    } else {
        EvapCoolingCapacity = TotalTankHeatingCapacity - CompressorPower;
    }

    // set evaporator total cooling capacity prior to CalcDOE2DXCoil subroutine
    Coil.RatedTotCap(1) = EvapCoolingCapacity;

    // determine condenser water inlet/outlet condition at full capacity
    if (CondInletMassFlowRate == 0.0) {
        OutletWaterTemp = InletWaterTemp;
    } else {
        OutletWaterTemp = InletWaterTemp + TotalTankHeatingCapacity / (CpWater * CondInletMassFlowRate);
    }

    WaterOutletNode.Temp = OutletWaterTemp;

    WaterOutletNode.MassFlowRate = WaterInletNode.MassFlowRate;

    // send heating capacity and COP to water heater module for standards rating calculation
    // total heating capacity including condenser pump
    state.dataDXCoils->HPWHHeatingCapacity = TotalTankHeatingCapacity;
    // total heating COP including compressor, fan, and condenser pump
    state.dataDXCoils->HPWHHeatingCOP = TankHeatingCOP;

    // send DX coil total cooling capacity to HPWH for reporting
    state.dataHVACGlobal->DXCoilTotalCapacity = EvapCoolingCapacity;

    Coil.TotalHeatingEnergyRate = TotalTankHeatingCapacity * PartLoadRatio;

    // calculate total compressor plus condenser pump power, fan power reported in fan module
    Coil.ElecWaterHeatingPower = (CompressorPower + Coil.HPWHCondPumpElecNomPower) * HPRTF;
}

void CalcDoe2DXCoil(EnergyPlusData &state,
                    int const DXCoilNum,                                 // the number of the DX coil to be simulated
                    HVAC::CompressorOp const compressorOp,               // compressor operation; 1=on, 0=off
                    bool const FirstHVACIteration,                       // true if this is the first iteration of HVAC
                    Real64 const PartLoadRatio,                          // sensible cooling load / full load sensible cooling capacity
                    HVAC::FanOp const fanOp,                             // Allows parent object to control fan operation
                    ObjexxFCL::Optional_int_const PerfMode,              // Performance mode for MultiMode DX coil; Always 1 for other coil types
                    ObjexxFCL::Optional<Real64 const> OnOffAirFlowRatio, // ratio of compressor on airflow to compressor off airflow
                    ObjexxFCL::Optional<Real64 const> CoolingHeatingPLR  // used for cycling fan RH control
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Fred Buhl
    //       DATE WRITTEN   May 2000
    //       MODIFIED       Shirey, Feb/October 2001, Feb/Mar 2004
    //                      Feb 2005 M. J. Witte, GARD Analytics, Inc.
    //                        Add new coil type COIL:DX:MultiMode:CoolingEmpirical:
    //                      April 2010 Chandan Sharma, FSEC, Added basin heater
    //       RE-ENGINEERED  Don Shirey, Aug/Sept 2000

    // PURPOSE OF THIS SUBROUTINE:
    // Calculates the air-side performance and electrical energy use of a direct-
    // expansion, air-cooled cooling unit.

    // METHODOLOGY EMPLOYED:
    // This routine simulates the performance of air-cooled DX cooling equipment.
    // The routine requires the user to enter the total cooling capacity, sensible heat ratio,
    // and COP for the unit at ARI 210/240 rating conditions (26.67C [80F] dry-bulb, 19.44C [67F]
    // wet-bulb air entering the cooling coil, 35C [95F] dry-bulb air entering the outdoor
    // condenser. Since different manufacturer's rate their equipment at different air flow rates,
    // the supply air flow rate corresponding to the rated capacities and rated COP must also be
    // entered (should be between 300 cfm/ton and 450 cfm/ton). The rated information entered by
    // the user should NOT include the thermal or electrical impacts of the supply air fan, as
    // this is addressed by another module.

    // With the rated performance data entered by the user, the model employs some of the
    // DOE-2.1E curve fits to adjust the capacity and efficiency of the unit as a function
    // of entering air temperatures and supply air flow rate (actual vs rated flow). The model
    // does NOT employ the exact same methodology to calculate performance as DOE-2, although
    // some of the DOE-2 curve fits are employed by this model.

    // The model checks for coil dryout conditions, and adjusts the calculated performance
    // appropriately.

    // REFERENCES:
    // ASHRAE HVAC 2 Toolkit page 4-81.
    // Henderson, H.I. Jr., K. Rengarajan and D.B. Shirey, III. 1992.The impact of comfort
    // control on air conditioner energy use in humid climates. ASHRAE Transactions 98(2):
    // 104-113.
    // Henderson, H.I. Jr., Danny Parker and Y.J. Huang. 2000.Improving DOE-2's RESYS routine:
    // User Defined Functions to Provide More Accurate Part Load Energy Use and Humidity
    // Predictions. Proceedings of ACEEE Conference.

    // Using/Aliasing
    using Curve::CurveValue;
    Real64 SysTimeElapsed = state.dataHVACGlobal->SysTimeElapsed;
    Real64 TimeStepSys = state.dataHVACGlobal->TimeStepSys;
    using General::CreateSysTimeIntervalString;

    // SUBROUTINE PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineName("CalcDoe2DXCoil: ");
    static constexpr std::string_view calcDoe2DXCoil("CalcDoe2DXCoil");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 AirMassFlow;       // dry air mass flow rate through coil [kg/s] (adjusted for bypass if any)
    Real64 AirMassFlowRatio;  // Ratio of actual air mass flow to rated air mass flow (adjusted for bypass if any)
    Real64 AirVolumeFlowRate; // Air volume flow rate across the cooling coil [m3/s] (adjusted for bypass if any)
    // (average flow if cycling fan, full flow if constant fan)
    Real64 VolFlowperRatedTotCap; // Air volume flow rate divided by rated total cooling capacity [m3/s-W] (adjusted for bypass)
    Real64 BypassFlowFraction;    // Fraction of total flow which is bypassed around the cooling coil
    Real64 TotCap;                // gross total cooling capacity at off-rated conditions [W]
    Real64 TotCapTempModFac;      // Total capacity modifier (function of entering wetbulb, outside drybulb)
    Real64 TotCapFlowModFac;      // Total capacity modifier (function of actual supply air flow vs rated flow)
    Real64 InletAirWetBulbC;      // wetbulb temperature of inlet air [C]
    Real64 InletAirDryBulbTemp;   // inlet air dry bulb temperature [C]
    Real64 InletAirEnthalpy;      // inlet air enthalpy [J/kg]
    Real64 InletAirHumRat;        // inlet air humidity ratio [kg/kg]
    Real64 InletAirHumRatTemp;    // inlet air humidity ratio used in ADP/BF loop [kg/kg]
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // REAL(r64) :: InletAirPressure      ! inlet air pressure [Pa]
    Real64 RatedCBF;             // coil bypass factor at rated conditions
    Real64 SHR;                  // Sensible Heat Ratio (sensible/total) of the cooling coil
    Real64 CBF;                  // coil bypass factor at off rated conditions
    Real64 A0;                   // NTU * air mass flow rate, used in CBF calculation
    Real64 hDelta;               // Change in air enthalpy across the cooling coil [J/kg]
    Real64 hADP;                 // Apparatus dew point enthalpy [J/kg]
    Real64 hTinwADP;             // Enthalpy at inlet dry-bulb and wADP [J/kg]
    Real64 hTinwout;             // Enthalpy at inlet dry-bulb and outlet humidity ratio [J/kg]
    Real64 tADP;                 // Apparatus dew point temperature [C]
    Real64 wADP;                 // Apparatus dew point humidity ratio [kg/kg]
    Real64 FullLoadOutAirEnth;   // outlet full load enthalpy [J/kg]
    Real64 FullLoadOutAirHumRat; // outlet humidity ratio at full load
    Real64 FullLoadOutAirTemp;   // outlet air temperature at full load [C]
    Real64 EIRTempModFac;        // EIR modifier (function of entering wetbulb, outside drybulb)
    Real64 EIRFlowModFac;        // EIR modifier (function of actual supply air flow vs rated flow)
    Real64 EIR;                  // EIR at part load and off rated conditions
    Real64 PLF;                  // Part load factor, accounts for thermal lag at compressor startup, used in power calculation
    Real64 QLatActual;           // operating latent capacity of DX coil
    Real64 QLatRated;            // Rated latent capacity of DX coil
    Real64 SHRUnadjusted;        // SHR prior to latent degradation effective SHR calculation
    int Counter;                 // Counter for dry evaporator iterations
    int MaxIter;                 // Maximum number of iterations for dry evaporator calculations
    Real64 RF;                   // Relaxation factor for dry evaporator iterations
    Real64 Tolerance;            // Error tolerance for dry evaporator iterations
    Real64 werror;               // Deviation of humidity ratio in dry evaporator iteration loop
    Real64 CondInletTemp;        // Condenser inlet temperature (C). Outdoor dry-bulb temp for air-cooled condenser.
    // Outdoor Wetbulb +(1 - effectiveness)*(outdoor drybulb - outdoor wetbulb) for evap condenser.
    Real64 CondInletHumRat; // Condenser inlet humidity ratio (kg/kg). Zero for air-cooled condenser.
    // For evap condenser, its the humidity ratio of the air leaving the evap cooling pads.
    Real64 CondAirMassFlow;       // Condenser air mass flow rate [kg/s]
    Real64 RhoAir;                // Density of air [kg/m3]
    Real64 RhoWater;              // Density of water [kg/m3]
    Real64 CrankcaseHeatingPower; // power due to crankcase heater
    Real64 CompAmbTemp(0.0);      // Ambient temperature at compressor
    Real64 AirFlowRatio;          // ratio of compressor on airflow to average timestep airflow
    // used when constant fan mode yields different air flow rates when compressor is ON and OFF
    // (e.g. Packaged Terminal Heat Pump)
    Real64 OutdoorDryBulb;  // Outdoor dry-bulb temperature at condenser (C)
    Real64 OutdoorWetBulb;  // Outdoor wet-bulb temperature at condenser (C)
    Real64 OutdoorHumRat;   // Outdoor humidity ratio at condenser (kg/kg)
    Real64 OutdoorPressure; // Outdoor barometric pressure at condenser (Pa)

    int Mode;                    // Performance mode for Multimode DX coil; Always 1 for other coil types
    Real64 OutletAirTemp;        // Supply air temperature (average value if constant fan, full output if cycling fan)
    Real64 OutletAirHumRat;      // Supply air humidity ratio (average value if constant fan, full output if cycling fan)
    Real64 OutletAirEnthalpy;    // Supply air enthalpy (average value if constant fan, full output if cycling fan)
    Real64 ADiff;                // Used for exponential
    Real64 DXcoolToHeatPLRRatio; // ratio of cooling PLR to heating PLR, used for cycling fan RH control
    Real64 HeatRTF;              // heating coil part-load ratio, used for cycling fan RH control
    Real64 HeatingCoilPLF;       // heating coil PLF (function of PLR), used for cycling fan RH control

    // If Performance mode not present, then set to 1.  Used only by Multimode/Multispeed DX coil (otherwise mode = 1)
    if (present(PerfMode)) {
        Mode = PerfMode;
    } else {
        Mode = 1;
    }

    // If AirFlowRatio not present, then set to 1. Used only by DX coils with different air flow
    // during cooling and when no cooling is required (constant fan, fan speed changes)
    if (present(OnOffAirFlowRatio)) {
        AirFlowRatio = OnOffAirFlowRatio;
    } else {
        AirFlowRatio = 1.0;
    }

    // If CoolingHeatingPLR not present, then set to 1. Used for cycling fan systems where
    // heating PLR is greater than cooling PLR, otherwise CoolingHeatingPLR = 1.
    if (present(CoolingHeatingPLR)) {
        DXcoolToHeatPLRRatio = CoolingHeatingPLR;
    } else {
        DXcoolToHeatPLRRatio = 1.0;
    }

    MaxIter = 30;
    RF = 0.4;
    Counter = 0;
    Tolerance = 0.01;
    CondInletTemp = 0.0;
    CondInletHumRat = 0.0;

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    BypassFlowFraction = thisDXCoil.BypassedFlowFrac(Mode);
    AirMassFlow = thisDXCoil.InletAirMassFlowRate * (1.0 - BypassFlowFraction);
    InletAirDryBulbTemp = thisDXCoil.InletAirTemp;
    InletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
    InletAirHumRat = thisDXCoil.InletAirHumRat;
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // InletAirPressure    = DXCoil(DXCoilNum)%InletAirPressure
    state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = 0.0;
    thisDXCoil.CoolingCoilRuntimeFraction = 0.0;
    thisDXCoil.PartLoadRatio = 0.0;
    thisDXCoil.BasinHeaterPower = 0.0;

    if (thisDXCoil.CondenserType(Mode) != DataHeatBalance::RefrigCondenserType::WaterHeater) {
        if (thisDXCoil.CondenserInletNodeNum(Mode) != 0) {
            OutdoorPressure = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).Press;
            // If node is not connected to anything, pressure = default, use weather data
            if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press) {
                OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
                OutdoorHumRat = state.dataEnvrn->OutHumRat;
                OutdoorPressure = state.dataEnvrn->OutBaroPress;
                OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
            } else {
                OutdoorDryBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).Temp;
                OutdoorHumRat = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).HumRat;
                // this should use Node%WetBulbTemp or a PSYC function, not OAWB
                OutdoorWetBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).OutAirWetBulb;
            }
        } else {
            OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
            OutdoorHumRat = state.dataEnvrn->OutHumRat;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
            OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
        }
        if (thisDXCoil.IsSecondaryDXCoilInZone) {
            auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
            OutdoorDryBulb = secZoneHB.ZT;
            OutdoorHumRat = secZoneHB.airHumRat;
            OutdoorWetBulb = thisDXCoil.EvapInletWetBulb;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
        }
    } else {
        if (thisDXCoil.CondenserInletNodeNum(Mode) != 0) {
            OutdoorPressure = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).Press;
            // If node is not connected to anything, pressure = default, use weather data
            if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press)
                OutdoorPressure = state.dataEnvrn->OutBaroPress; // node not connected
        } else {
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
        }
    }

    if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Air) {
        CondInletTemp = OutdoorDryBulb; // Outdoor dry-bulb temp
        CompAmbTemp = OutdoorDryBulb;
        if (thisDXCoil.IsSecondaryDXCoilInZone) {
            auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
            CondInletTemp = secZoneHB.ZT;
            CompAmbTemp = CondInletTemp; // assumes compressor is in same location as secondary coil
            OutdoorDryBulb = CondInletTemp;
            OutdoorHumRat = secZoneHB.airHumRat;
            OutdoorWetBulb = thisDXCoil.EvapInletWetBulb;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
        }
    } else if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Evap) {
        RhoAir = PsyRhoAirFnPbTdbW(state, OutdoorPressure, OutdoorDryBulb, OutdoorHumRat);
        CondAirMassFlow = RhoAir * thisDXCoil.EvapCondAirFlow(Mode);
        // (Outdoor wet-bulb temp from DataEnvironment) + (1.0-EvapCondEffectiveness) * (drybulb - wetbulb)
        CondInletTemp = OutdoorWetBulb + (OutdoorDryBulb - OutdoorWetBulb) * (1.0 - thisDXCoil.EvapCondEffect(Mode));
        CondInletHumRat = PsyWFnTdbTwbPb(state, CondInletTemp, OutdoorWetBulb, OutdoorPressure);
        CompAmbTemp = OutdoorDryBulb;
    } else if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::WaterHeater) {
        CompAmbTemp = state.dataHVACGlobal->HPWHCrankcaseDBTemp;   // Temperature at HP water heater compressor
        CondInletTemp = state.dataHVACGlobal->HPWHCrankcaseDBTemp; // Temperature at HP water heater compressor
    }

    // Initialize crankcase heater, operates below OAT defined in input deck for HP DX cooling coil
    // If used in a heat pump, the value of MaxOAT in the heating coil overrides that in the cooling coil (in GetInput)
    if (CompAmbTemp < thisDXCoil.MaxOATCrankcaseHeater) {
        CrankcaseHeatingPower = thisDXCoil.CrankcaseHeaterCapacity;
        if (thisDXCoil.CrankcaseHeaterCapacityCurveIndex > 0) {
            CrankcaseHeatingPower *= Curve::CurveValue(state, thisDXCoil.CrankcaseHeaterCapacityCurveIndex, CompAmbTemp);
        }
    } else {
        CrankcaseHeatingPower = 0.0;
    }

    // calculate end time of current time step to determine if error messages should be printed
    state.dataDXCoils->CurrentEndTime = state.dataGlobal->CurrentTime + SysTimeElapsed;

    //   Print warning messages only when valid and only for the first occurrence. Let summary provide statistics.
    //   Wait for next time step to print warnings. If simulation iterates, print out
    //   the warning for the last iteration only. Must wait for next time step to accomplish this.
    //   If a warning occurs and the simulation down shifts, the warning is not valid.

    if (thisDXCoil.PrintLowAmbMessage) { // .AND. &
        if (state.dataDXCoils->CurrentEndTime > thisDXCoil.CurrentEndTimeLast && TimeStepSys >= thisDXCoil.TimeStepSysLast) {
            if (thisDXCoil.LowAmbErrIndex == 0) {
                ShowWarningMessage(state, format("{}{}", RoutineName, thisDXCoil.LowAmbBuffer1));
                ShowContinueError(state, thisDXCoil.LowAmbBuffer2);
                ShowContinueError(state, "... Operation at low ambient temperatures may require special performance curves.");
            }
            if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Air) {
                ShowRecurringWarningErrorAtEnd(state,
                                               std::string{RoutineName} + thisDXCoil.DXCoilType + "=\"" + thisDXCoil.Name +
                                                   "\" - Low condenser dry-bulb temperature error continues...",
                                               thisDXCoil.LowAmbErrIndex,
                                               thisDXCoil.LowTempLast,
                                               thisDXCoil.LowTempLast,
                                               _,
                                               "[C]",
                                               "[C]");
            } else {
                ShowRecurringWarningErrorAtEnd(state,
                                               std::string{RoutineName} + thisDXCoil.DXCoilType + "=\"" + thisDXCoil.Name +
                                                   "\" - Low condenser wet-bulb temperature error continues...",
                                               thisDXCoil.LowAmbErrIndex,
                                               thisDXCoil.LowTempLast,
                                               thisDXCoil.LowTempLast,
                                               _,
                                               "[C]",
                                               "[C]");
            }
        }
    }

    if (thisDXCoil.PrintLowOutTempMessage) {
        if (state.dataDXCoils->CurrentEndTime > thisDXCoil.CurrentEndTimeLast && TimeStepSys >= thisDXCoil.TimeStepSysLast) {
            if (thisDXCoil.LowOutletTempIndex == 0) {
                ShowWarningMessage(state, format("{}{}", RoutineName, thisDXCoil.LowOutTempBuffer1));
                ShowContinueError(state, thisDXCoil.LowOutTempBuffer2);
                ShowContinueError(state, "... Possible reasons for low outlet air dry-bulb temperatures are: This DX coil");
                ShowContinueError(state,
                                  format("   1) may have a low inlet air dry-bulb temperature. Inlet air temperature = {:.3T} C.",
                                         thisDXCoil.FullLoadInletAirTempLast));
                ShowContinueError(state, "   2) may have a low air flow rate per watt of cooling capacity. Check inputs.");
                ShowContinueError(state,
                                  "   3) is used as part of a HX assisted cooling coil which uses a high sensible effectiveness. Check inputs.");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           std::string{RoutineName} + thisDXCoil.DXCoilType + "=\"" + thisDXCoil.Name +
                                               "\" - Full load outlet temperature indicates a possibility of frost/freeze error continues. "
                                               "Outlet air temperature statistics follow:",
                                           thisDXCoil.LowOutletTempIndex,
                                           thisDXCoil.FullLoadOutAirTempLast,
                                           thisDXCoil.FullLoadOutAirTempLast);
        }
    }

    // save last system time step and last end time of current time step (used to determine if warning is valid)
    thisDXCoil.TimeStepSysLast = TimeStepSys;
    thisDXCoil.CurrentEndTimeLast = state.dataDXCoils->CurrentEndTime;
    thisDXCoil.PrintLowAmbMessage = false;
    thisDXCoil.PrintLowOutTempMessage = false;

    if ((AirMassFlow > 0.0) &&
        (GetCurrentScheduleValue(state, thisDXCoil.SchedPtr) > 0.0 || thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
         thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) &&
        (PartLoadRatio > 0.0) && (compressorOp == HVAC::CompressorOp::On) &&
        CompAmbTemp > thisDXCoil.MinOATCompressor) { // criteria for coil operation
        if (fanOp == HVAC::FanOp::Cycling) {
            AirMassFlow /= (PartLoadRatio / DXcoolToHeatPLRRatio);
        } else if (fanOp == HVAC::FanOp::Continuous && thisDXCoil.DXCoilType_Num != HVAC::CoilDX_CoolingTwoSpeed) {
            AirMassFlow *= AirFlowRatio;
        } else {
            AirMassFlow = thisDXCoil.RatedAirMassFlowRate(Mode);
        }

        // Check for valid air volume flow per rated total cooling capacity (200 - 500 cfm/ton)

        // for some reason there are diff's when using coil inlet air pressure
        // these lines (more to follow) are commented out for the time being

        InletAirWetBulbC = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRat, OutdoorPressure);
        AirVolumeFlowRate = AirMassFlow / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat);
        //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
        //  InletAirWetBulbC = PsyTwbFnTdbWPb(InletAirDryBulbTemp,InletAirHumRat,InletAirPressure)
        //  AirVolumeFlowRate = AirMassFlow/ PsyRhoAirFnPbTdbW(InletAirPressure,InletAirDryBulbTemp, InletAirHumRat)
        if (thisDXCoil.RatedTotCap(Mode) <= 0.0) {
            ShowFatalError(
                state, format("{}{}=\"{}\" - Rated total cooling capacity is zero or less.", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
        }
        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
            thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
            VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.RatedTotCap2;
        } else {
            VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.RatedTotCap(Mode);
        }
        if (!FirstHVACIteration && !state.dataGlobal->WarmupFlag && thisDXCoil.DXCoilType_Num != HVAC::CoilDX_HeatPumpWaterHeaterPumped &&
            thisDXCoil.DXCoilType_Num != HVAC::CoilDX_HeatPumpWaterHeaterWrapped &&
            ((VolFlowperRatedTotCap < HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) ||
             (VolFlowperRatedTotCap > HVAC::MaxCoolVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]))) {
            if (thisDXCoil.ErrIndex1 == 0) {
                ShowWarningMessage(
                    state,
                    format("{}{}=\"{}\" - Air volume flow rate per watt of rated total cooling capacity is out of range at {:.3R} m3/s/W.",
                           RoutineName,
                           thisDXCoil.DXCoilType,
                           thisDXCoil.Name,
                           VolFlowperRatedTotCap));
                ShowContinueErrorTimeStamp(state, "");
                ShowContinueError(state,
                                  format("Expected range for VolumeFlowPerRatedTotalCapacity=[{:.3R}--{:.3R}]",
                                         HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                         HVAC::MaxCoolVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
                ShowContinueError(state, "Possible causes include inconsistent air flow rates in system components,");
                ShowContinueError(state, "or variable air volume [VAV] system using incorrect coil type.");
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                std::string{RoutineName} + thisDXCoil.DXCoilType + "=\"" + thisDXCoil.Name +
                    "\" - Air volume flow rate per watt of rated total cooling capacity is out of range error continues...",
                thisDXCoil.ErrIndex1,
                VolFlowperRatedTotCap,
                VolFlowperRatedTotCap);
        } else if (!state.dataGlobal->WarmupFlag &&
                   (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
                    thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) &&
                   ((VolFlowperRatedTotCap < HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) ||
                    (VolFlowperRatedTotCap > HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]))) {
            if (thisDXCoil.ErrIndex1 == 0) {
                ShowWarningMessage(
                    state,
                    format("{}{}=\"{}\" - Air volume flow rate per watt of rated total water heating capacity is out of range at {:.2R} m3/s/W.",
                           RoutineName,
                           thisDXCoil.DXCoilType,
                           thisDXCoil.Name,
                           VolFlowperRatedTotCap));
                ShowContinueErrorTimeStamp(state, "");
                ShowContinueError(state,
                                  format("Expected range for VolumeFlowPerRatedTotalCapacity=[{:.3R}--{:.3R}]",
                                         HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                         HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
                ShowContinueError(state,
                                  "Possible causes may be that the parent object is calling for an actual supply air flow rate that is much "
                                  "higher or lower than the DX coil rated supply air flow rate.");
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                std::string{RoutineName} + thisDXCoil.DXCoilType + "=\"" + thisDXCoil.Name +
                    "\" - Air volume flow rate per watt of rated total water heating capacity is out of range error continues...",
                thisDXCoil.ErrIndex1,
                VolFlowperRatedTotCap,
                VolFlowperRatedTotCap);
        }
        //    Adjust coil bypass factor for actual air flow rate. Use relation CBF = exp(-NTU) where
        //    NTU = A0/(m*cp). Relationship models the cooling coil as a heat exchanger with Cmin/Cmax = 0.

        RatedCBF = thisDXCoil.RatedCBF(Mode);
        if (RatedCBF > 0.0) {
            A0 = -std::log(RatedCBF) * thisDXCoil.RatedAirMassFlowRate(Mode);
        } else {
            A0 = 0.0;
        }
        ADiff = -A0 / AirMassFlow;
        if (ADiff >= DataPrecisionGlobals::EXP_LowerLimit) {
            CBF = std::exp(ADiff);
        } else {
            CBF = 0.0;
        }

        //   check boundary for low ambient temperature and post warnings to individual DX coil buffers to print at end of time step
        if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Air) {
            if (OutdoorDryBulb < 0.0 && !state.dataGlobal->WarmupFlag) { // Same threshold as for air-cooled electric chiller
                thisDXCoil.PrintLowAmbMessage = true;
                thisDXCoil.LowTempLast = OutdoorDryBulb;
                if (thisDXCoil.LowAmbErrIndex == 0) {
                    thisDXCoil.LowAmbBuffer1 =
                        format("{} \"{}\" - Air-cooled condenser inlet dry-bulb temperature below 0 C. Outdoor dry-bulb temperature = {:.2R}",
                               thisDXCoil.DXCoilType,
                               thisDXCoil.Name,
                               OutdoorDryBulb);
                    thisDXCoil.LowAmbBuffer2 = " ... Occurrence info = " + state.dataEnvrn->EnvironmentName + ", " + state.dataEnvrn->CurMnDy + ' ' +
                                               CreateSysTimeIntervalString(state);
                }
            }
        } else if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Evap) {
            if (OutdoorWetBulb < 10.0 && !state.dataGlobal->WarmupFlag) { // Same threshold as for evap-cooled electric chiller
                thisDXCoil.PrintLowAmbMessage = true;
                thisDXCoil.LowTempLast = OutdoorWetBulb;
                if (thisDXCoil.LowAmbErrIndex == 0) {
                    thisDXCoil.LowAmbBuffer1 =
                        format("{} \"{}\" - Evap-cooled condenser inlet wet-bulb temperature below 10 C. Outdoor wet-bulb temperature = {:.2R}",
                               thisDXCoil.DXCoilType,
                               thisDXCoil.Name,
                               OutdoorWetBulb);
                    thisDXCoil.LowAmbBuffer2 = " ... Occurrence info = " + state.dataEnvrn->EnvironmentName + ", " + state.dataEnvrn->CurMnDy + ' ' +
                                               CreateSysTimeIntervalString(state);
                }
            }
        }

        //  Get total capacity modifying factor (function of temperature) for off-rated conditions
        //  InletAirHumRat may be modified in this ADP/BF loop, use temporary variable for calculations
        InletAirHumRatTemp = InletAirHumRat;
        AirMassFlowRatio = AirMassFlow / thisDXCoil.RatedAirMassFlowRate(Mode);
        while (true) {
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
                thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
                // Coil:DX:HeatPumpWaterHeater does not have total cooling capacity as a function of temp or flow curve
                TotCapTempModFac = 1.0;
                TotCapFlowModFac = 1.0;
            } else {
                if (state.dataCurveManager->PerfCurve(thisDXCoil.CCapFTemp(Mode))->numDims == 2) {
                    TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(Mode), InletAirWetBulbC, CondInletTemp);
                } else {
                    TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(Mode), CondInletTemp);
                }

                //    Warn user if curve output goes negative
                if (TotCapTempModFac < 0.0) {
                    if (thisDXCoil.CCapFTempErrorIndex == 0) {
                        ShowWarningMessage(state, format("{}{} \"{}\":", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                        ShowContinueError(state,
                                          format(" Total Cooling Capacity Modifier curve (function of temperature) output is negative ({:.3T}).",
                                                 TotCapTempModFac));
                        if (state.dataCurveManager->PerfCurve(thisDXCoil.CCapFTemp(Mode))->numDims == 2) {
                            ShowContinueError(state,
                                              format(" Negative value occurs using a condenser inlet air temperature of {:.1T} and an inlet air "
                                                     "wet-bulb temperature of {:.1T}.",
                                                     CondInletTemp,
                                                     InletAirWetBulbC));
                        } else {
                            ShowContinueError(state,
                                              format(" Negative value occurs using a condenser inlet air temperature of {:.1T}.", CondInletTemp));
                        }
                        if (Mode > 1) {
                            ShowContinueError(state, format(" Negative output results from stage {} compressor operation.", Mode));
                        }
                        ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
                    }
                    ShowRecurringWarningErrorAtEnd(
                        state,
                        std::string{RoutineName} + thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                            "\": Total Cooling Capacity Modifier curve (function of temperature) output is negative warning continues...",
                        thisDXCoil.CCapFTempErrorIndex,
                        TotCapTempModFac,
                        TotCapTempModFac);
                    TotCapTempModFac = 0.0;
                }

                //    Get total capacity modifying factor (function of mass flow) for off-rated conditions
                TotCapFlowModFac = CurveValue(state, thisDXCoil.CCapFFlow(Mode), AirMassFlowRatio);
                //    Warn user if curve output goes negative
                if (TotCapFlowModFac < 0.0) {
                    if (thisDXCoil.CCapFFlowErrorIndex == 0) {
                        ShowWarningMessage(state, format("{}{} \"{}\":", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                        ShowContinueError(state,
                                          format(" Total Cooling Capacity Modifier curve (function of flow fraction) output is negative ({:.3T}).",
                                                 TotCapFlowModFac));
                        ShowContinueError(state, format(" Negative value occurs using an air flow fraction of {:.3T}.", AirMassFlowRatio));
                        ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
                        if (Mode > 1) {
                            ShowContinueError(state, format(" Negative output results from stage {} compressor operation.", Mode));
                        }
                    }
                    ShowRecurringWarningErrorAtEnd(
                        state,
                        std::string{RoutineName} + thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                            "\": Total Cooling Capacity Modifier curve (function of flow fraction) output is negative warning continues...",
                        thisDXCoil.CCapFFlowErrorIndex,
                        TotCapFlowModFac,
                        TotCapFlowModFac);
                    TotCapFlowModFac = 0.0;
                }
            }
            TotCap = thisDXCoil.RatedTotCap(Mode) * TotCapFlowModFac * TotCapTempModFac;
            // if user specified SHR modifier curves are available calculate the SHR as follows:
            if (thisDXCoil.UserSHRCurveExists) {
                SHR = CalcSHRUserDefinedCurves(state,
                                               InletAirDryBulbTemp,
                                               InletAirWetBulbC,
                                               AirMassFlowRatio,
                                               thisDXCoil.SHRFTemp(Mode),
                                               thisDXCoil.SHRFFlow(Mode),
                                               thisDXCoil.RatedSHR(Mode));
                hDelta = TotCap / AirMassFlow;
                break;
            } else {
                // Calculate apparatus dew point conditions using TotCap and CBF
                hDelta = TotCap / AirMassFlow;
                hADP = InletAirEnthalpy - hDelta / (1.0 - CBF);
                tADP = PsyTsatFnHPb(state, hADP, OutdoorPressure, calcDoe2DXCoil);
                //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
                //  tADP = PsyTsatFnHPb(hADP,InletAirPressure)
                wADP = PsyWFnTdbH(state, tADP, hADP, calcDoe2DXCoil);
                hTinwADP = PsyHFnTdbW(InletAirDryBulbTemp, wADP);
                if ((InletAirEnthalpy - hADP) > 1.e-10) {
                    SHR = min((hTinwADP - hADP) / (InletAirEnthalpy - hADP), 1.0);
                } else {
                    SHR = 1.0;
                }
                // Check for dry evaporator conditions (win < wadp)
                if (wADP > InletAirHumRatTemp || (Counter >= 1 && Counter < MaxIter)) {
                    if (InletAirHumRatTemp == 0.0) InletAirHumRatTemp = 0.00001;
                    werror = (InletAirHumRatTemp - wADP) / InletAirHumRatTemp;
                    // Increase InletAirHumRatTemp at constant InletAirTemp to find coil dry-out point. Then use the
                    // capacity at the dry-out point to determine exiting conditions from coil. This is required
                    // since the TotCapTempModFac doesn't work properly with dry-coil conditions.
                    InletAirHumRatTemp = RF * wADP + (1.0 - RF) * InletAirHumRatTemp;
                    InletAirWetBulbC = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRatTemp, OutdoorPressure);
                    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment
                    //  line InletAirWetBulbC = PsyTwbFnTdbWPb(InletAirDryBulbTemp,InletAirHumRatTemp,InletAirPressure)
                    ++Counter;
                    if (std::abs(werror) > Tolerance) continue; // Recalculate with modified inlet conditions
                    break;
                } else {
                    break;
                }
            }
        } // end of DO iteration loop

        if (thisDXCoil.PLFFPLR(Mode) > 0) {
            PLF = CurveValue(state, thisDXCoil.PLFFPLR(Mode), PartLoadRatio); // Calculate part-load factor
        } else {
            PLF = 1.0;
        }

        if (PLF < 0.7) {
            if (thisDXCoil.ErrIndex2 == 0) {
                if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
                    thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
                    ShowWarningMessage(state, format("{}{}=\"{}\", PLF curve value", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                    ShowContinueError(state, format("The PLF curve value = {:.3T} for part-load ratio = {:.3T}", PLF, PartLoadRatio));
                    ShowContinueErrorTimeStamp(state, "PLF curve values must be >= 0.7. PLF has been reset to 0.7 and simulation is continuing.");
                    ShowContinueError(state, format("Check the IO reference manual for PLF curve guidance [{}].", thisDXCoil.DXCoilType));
                } else {
                    ShowWarningMessage(state, format("{}{}=\"{}\", PLF curve value", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                    ShowContinueError(state, format("The PLF curve value = {:.3T} for part-load ratio = {:.3T}", PLF, PartLoadRatio));
                    ShowContinueErrorTimeStamp(state, "PLF curve values must be >= 0.7. PLF has been reset to 0.7 and simulation is continuing.");
                    ShowContinueError(state, format("Check the IO reference manual for PLF curve guidance [{}].", thisDXCoil.DXCoilType));
                }
            }
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
                thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
                ShowRecurringWarningErrorAtEnd(
                    state, thisDXCoil.Name + ", " + thisDXCoil.DXCoilType + " PLF curve < 0.7 warning continues...", thisDXCoil.ErrIndex2, PLF, PLF);
            } else {
                ShowRecurringWarningErrorAtEnd(
                    state, thisDXCoil.Name + ", " + thisDXCoil.DXCoilType + " PLF curve < 0.7 warning continues...", thisDXCoil.ErrIndex2, PLF, PLF);
            }
            PLF = 0.7;
        }

        thisDXCoil.PartLoadRatio = PartLoadRatio;
        thisDXCoil.CoolingCoilRuntimeFraction = PartLoadRatio / PLF;
        if (thisDXCoil.CoolingCoilRuntimeFraction > 1.0 && std::abs(thisDXCoil.CoolingCoilRuntimeFraction - 1.0) > 0.001) {
            if (thisDXCoil.ErrIndex3 == 0) {
                if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
                    thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
                    ShowWarningMessage(state, format("{}{}=\"{}\", runtime fraction", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                    ShowWarningMessage(state, format("The runtime fraction exceeded 1.0. [{:.4R}].", thisDXCoil.CoolingCoilRuntimeFraction));
                    ShowContinueError(state, "Runtime fraction reset to 1 and the simulation will continue.");
                    ShowContinueError(state, format("Check the IO reference manual for PLF curve guidance [{}].", thisDXCoil.DXCoilType));
                    ShowContinueErrorTimeStamp(state, "");
                } else {
                    ShowWarningMessage(state, format("{}{}=\"{}\", runtime fraction", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                    ShowWarningMessage(state, format("The runtime fraction exceeded 1.0. [{:.4R}].", thisDXCoil.CoolingCoilRuntimeFraction));
                    ShowContinueError(state, "Runtime fraction reset to 1 and the simulation will continue.");
                    ShowContinueError(state, format("Check the IO reference manual for PLF curve guidance [{}].", thisDXCoil.DXCoilType));
                    ShowContinueErrorTimeStamp(state, "");
                }
            }
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
                thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
                ShowRecurringWarningErrorAtEnd(state,
                                               thisDXCoil.Name + ", " + thisDXCoil.DXCoilType + " runtime fraction > 1.0 warning continues...",
                                               thisDXCoil.ErrIndex3,
                                               thisDXCoil.CoolingCoilRuntimeFraction,
                                               thisDXCoil.CoolingCoilRuntimeFraction);
            } else {
                ShowRecurringWarningErrorAtEnd(state,
                                               thisDXCoil.Name + ", " + thisDXCoil.DXCoilType + " runtime fraction > 1.0 warning continues...",
                                               thisDXCoil.ErrIndex3,
                                               thisDXCoil.CoolingCoilRuntimeFraction,
                                               thisDXCoil.CoolingCoilRuntimeFraction);
            }
            thisDXCoil.CoolingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
        } else if (thisDXCoil.CoolingCoilRuntimeFraction > 1.0) {
            thisDXCoil.CoolingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
        }

        // If cycling fan, send coil part-load fraction to on/off fan via HVACDataGlobals
        if (fanOp == HVAC::FanOp::Cycling) state.dataHVACGlobal->OnOffFanPartLoadFraction = PLF;

        //  Calculate full load output conditions
        if (thisDXCoil.UserSHRCurveExists) {
            FullLoadOutAirEnth = InletAirEnthalpy - hDelta;
            if (SHR < 1.0) {
                hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                FullLoadOutAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
                if (FullLoadOutAirHumRat <= 0.0) {
                    FullLoadOutAirHumRat = min(DryCoilOutletHumRatioMin, InletAirHumRat);
                }
            } else {
                SHR = 1.0;
                FullLoadOutAirHumRat = InletAirHumRat;
            }
        } else {
            if (SHR > 1.0 || Counter > 0) SHR = 1.0;
            FullLoadOutAirEnth = InletAirEnthalpy - TotCap / AirMassFlow;
            hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
            if (SHR < 1.0) {
                FullLoadOutAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
            } else {
                FullLoadOutAirHumRat = InletAirHumRat;
            }
        }
        FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, FullLoadOutAirHumRat);

        // Check for saturation error and modify temperature at constant enthalpy
        if (FullLoadOutAirTemp < PsyTsatFnHPb(state, FullLoadOutAirEnth, OutdoorPressure)) {
            FullLoadOutAirTemp = PsyTsatFnHPb(state, FullLoadOutAirEnth, OutdoorPressure);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //   IF(FullLoadOutAirTemp .LT. PsyTsatFnHPb(FullLoadOutAirEnth,InletAirPressure)) THEN
            //    FullLoadOutAirTemp = PsyTsatFnHPb(FullLoadOutAirEnth,InletAirPressure)
            FullLoadOutAirHumRat = PsyWFnTdbH(state, FullLoadOutAirTemp, FullLoadOutAirEnth);
        }

        // Store actual outlet conditions when DX coil is ON for use in heat recovery module
        state.dataDXCoils->DXCoilFullLoadOutAirTemp(DXCoilNum) = FullLoadOutAirTemp;
        state.dataDXCoils->DXCoilFullLoadOutAirHumRat(DXCoilNum) = FullLoadOutAirHumRat;

        // Add warning message for cold cooling coil (FullLoadOutAirTemp < 2 C)
        if (FullLoadOutAirTemp < 2.0 && !FirstHVACIteration && !state.dataGlobal->WarmupFlag) {
            thisDXCoil.PrintLowOutTempMessage = true;
            thisDXCoil.FullLoadOutAirTempLast = FullLoadOutAirTemp;
            if (thisDXCoil.LowOutletTempIndex == 0) {
                thisDXCoil.FullLoadInletAirTempLast = InletAirDryBulbTemp;
                thisDXCoil.LowOutTempBuffer1 = format("{} \"{}\" - Full load outlet air dry-bulb temperature < 2C. This indicates the "
                                                      "possibility of coil frost/freeze. Outlet temperature = {:.2R} C.",
                                                      thisDXCoil.DXCoilType,
                                                      thisDXCoil.Name,
                                                      FullLoadOutAirTemp);
                thisDXCoil.LowOutTempBuffer2 = " ...Occurrence info = " + state.dataEnvrn->EnvironmentName + ", " + state.dataEnvrn->CurMnDy + ' ' +
                                               CreateSysTimeIntervalString(state);
            }
        }

        //  If constant fan with cycling compressor, call function to determine "effective SHR"
        //  which includes the part-load degradation on latent capacity
        if (fanOp == HVAC::FanOp::Continuous) {
            QLatRated = thisDXCoil.RatedTotCap(Mode) * (1.0 - thisDXCoil.RatedSHR(Mode));
            QLatActual = TotCap * (1.0 - SHR);
            SHRUnadjusted = SHR;
            SHR = CalcEffectiveSHR(
                state, DXCoilNum, SHR, thisDXCoil.CoolingCoilRuntimeFraction, QLatRated, QLatActual, InletAirDryBulbTemp, InletAirWetBulbC, Mode);
            // For multimode coil, if stage-2 operation (modes 2 or 4), adjust Stage1&2 SHR to account for
            // Stage 1 operating at full load, so there is no degradation for that portion
            // Use the stage 1 bypass fraction to allocate
            if (Mode == 2 || Mode == 4) {
                SHR = SHRUnadjusted * (1.0 - thisDXCoil.BypassedFlowFrac(Mode - 1)) + SHR * thisDXCoil.BypassedFlowFrac(Mode - 1);
            }

            //  Calculate full load output conditions
            if (thisDXCoil.UserSHRCurveExists) {
                FullLoadOutAirEnth = InletAirEnthalpy - hDelta;
                if (SHR < 1.0) {
                    hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                    FullLoadOutAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
                    if (FullLoadOutAirHumRat <= 0.0) {
                        FullLoadOutAirHumRat = min(DryCoilOutletHumRatioMin, InletAirHumRat);
                    }
                } else {
                    SHR = 1.0;
                    FullLoadOutAirHumRat = InletAirHumRat;
                }
            } else {
                if (SHR > 1.0 || Counter > 0) SHR = 1.0;
                FullLoadOutAirEnth = InletAirEnthalpy - TotCap / AirMassFlow;
                hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                if (SHR < 1.0) {
                    FullLoadOutAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
                } else {
                    FullLoadOutAirHumRat = InletAirHumRat;
                }
            }
            FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, FullLoadOutAirHumRat);

            // apply latent degradation model to cycling fan when RH control is desired and heating coil operates
            // longer than the cooling coil. DXcoolToHeatPLRRatio = Cooling coil PLR / Heating coil PLR.
        } else if (fanOp == HVAC::FanOp::Cycling) {
            if (DXcoolToHeatPLRRatio < 1.0) {
                QLatRated = thisDXCoil.RatedTotCap(Mode) * (1.0 - thisDXCoil.RatedSHR(Mode));
                QLatActual = TotCap * (1.0 - SHR);
                HeatRTF = PartLoadRatio / DXcoolToHeatPLRRatio;
                if (thisDXCoil.HeatingCoilPLFCurvePTR > 0) {
                    HeatingCoilPLF = CurveValue(state, thisDXCoil.HeatingCoilPLFCurvePTR, HeatRTF);
                    if (HeatingCoilPLF > 0) HeatRTF /= HeatingCoilPLF;
                }
                SHRUnadjusted = SHR;
                SHR = CalcEffectiveSHR(state,
                                       DXCoilNum,
                                       SHR,
                                       thisDXCoil.CoolingCoilRuntimeFraction,
                                       QLatRated,
                                       QLatActual,
                                       InletAirDryBulbTemp,
                                       InletAirWetBulbC,
                                       Mode,
                                       HeatRTF);
                //   Calculate full load output conditions
                if (thisDXCoil.UserSHRCurveExists) {
                    FullLoadOutAirEnth = InletAirEnthalpy - hDelta;
                    if (SHR < 1.0) {
                        hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                        FullLoadOutAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
                        if (FullLoadOutAirHumRat <= 0.0) {
                            FullLoadOutAirHumRat = min(DryCoilOutletHumRatioMin, InletAirHumRat);
                        }
                    } else {
                        SHR = 1.0;
                        FullLoadOutAirHumRat = InletAirHumRat;
                    }
                } else {
                    if (SHR > 1.0 || Counter > 0) SHR = 1.0;
                    FullLoadOutAirEnth = InletAirEnthalpy - TotCap / AirMassFlow;
                    hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                    if (SHR < 1.0) {
                        FullLoadOutAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
                    } else {
                        FullLoadOutAirHumRat = InletAirHumRat;
                    }
                }
                FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, FullLoadOutAirHumRat);
            }
        }

        //  Calculate actual outlet conditions for the input part load ratio
        //  Actual outlet conditions are "average" for time step

        // For multimode coil, if stage-2 operation (modes 2 or 4), return "full load" outlet conditions
        if (((fanOp == HVAC::FanOp::Continuous) && (Mode == 1)) || (Mode == 3)) {
            // Continuous fan, cycling compressor
            OutletAirEnthalpy = ((PartLoadRatio * AirFlowRatio) * FullLoadOutAirEnth + (1.0 - (PartLoadRatio * AirFlowRatio)) * InletAirEnthalpy);
            OutletAirHumRat = ((PartLoadRatio * AirFlowRatio) * FullLoadOutAirHumRat + (1.0 - (PartLoadRatio * AirFlowRatio)) * InletAirHumRat);
            OutletAirTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
        } else {
            // Default to cycling fan, cycling compressor
            // Also return this result for stage 2 operation of multimode coil
            // Cycling fan typically provides full outlet conditions. When RH control is used, account for additional
            // heating run time by using cooing/heating ratio the same as constant fan (otherwise PLRRatio = 1).
            OutletAirEnthalpy = FullLoadOutAirEnth * DXcoolToHeatPLRRatio + InletAirEnthalpy * (1.0 - DXcoolToHeatPLRRatio);
            OutletAirHumRat = FullLoadOutAirHumRat * DXcoolToHeatPLRRatio + InletAirHumRat * (1.0 - DXcoolToHeatPLRRatio);
            OutletAirTemp = FullLoadOutAirTemp * DXcoolToHeatPLRRatio + InletAirDryBulbTemp * (1.0 - DXcoolToHeatPLRRatio);
        }

        // Check for saturation error and modify temperature at constant enthalpy
        if (OutletAirTemp < PsyTsatFnHPb(state, OutletAirEnthalpy, OutdoorPressure, calcDoe2DXCoil)) {
            OutletAirTemp = PsyTsatFnHPb(state, OutletAirEnthalpy, OutdoorPressure);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //   IF(OutletAirTemp .LT. PsyTsatFnHPb(OutletAirEnthalpy,InletAirPressure)) THEN
            //    OutletAirTemp = PsyTsatFnHPb(OutletAirEnthalpy,InletAirPressure)
            OutletAirHumRat = PsyWFnTdbH(state, OutletAirTemp, OutletAirEnthalpy);
        }

        // Mix with air that was bypassed around coil, if any
        if (BypassFlowFraction > 0.0) {
            OutletAirEnthalpy = (1.0 - BypassFlowFraction) * OutletAirEnthalpy + BypassFlowFraction * InletAirEnthalpy;
            OutletAirHumRat = (1.0 - BypassFlowFraction) * OutletAirHumRat + BypassFlowFraction * InletAirHumRat;
            OutletAirTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
            // Check for saturation error and modify temperature at constant enthalpy
            if (OutletAirTemp < PsyTsatFnHPb(state, OutletAirEnthalpy, OutdoorPressure)) {
                OutletAirTemp = PsyTsatFnHPb(state, OutletAirEnthalpy, OutdoorPressure);
                //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
                //     IF(OutletAirTemp .LT. PsyTsatFnHPb(OutletAirEnthalpy,InletAirPressure)) THEN
                //       OutletAirTemp = PsyTsatFnHPb(OutletAirEnthalpy,InletAirPressure)
                OutletAirHumRat = PsyWFnTdbH(state, OutletAirTemp, OutletAirEnthalpy);
            }
        }

        // Calculate electricity consumed. First, get EIR modifying factors for off-rated conditions
        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterPumped ||
            thisDXCoil.DXCoilType_Num == HVAC::CoilDX_HeatPumpWaterHeaterWrapped) {
            //   Coil:DX:HeatPumpWaterHeater does not have EIR temp or flow curves
            EIRTempModFac = 1.0;
            EIRFlowModFac = 1.0;
        } else {
            EIRTempModFac = CurveValue(state, thisDXCoil.EIRFTemp(Mode), InletAirWetBulbC, CondInletTemp);

            //   Warn user if curve output goes negative
            if (EIRTempModFac < 0.0) {
                if (thisDXCoil.EIRFTempErrorIndex == 0) {
                    ShowWarningMessage(state, format("{}{}=\"{}\":", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                    ShowContinueError(
                        state, format(" Energy Input Ratio Modifier curve (function of temperature) output is negative ({:.3T}).", EIRTempModFac));
                    if (state.dataCurveManager->PerfCurve(thisDXCoil.EIRFTemp(Mode))->numDims == 2) {
                        ShowContinueError(state,
                                          format(" Negative value occurs using a condenser inlet air temperature of {:.1T} and an inlet air "
                                                 "wet-bulb temperature of {:.1T}.",
                                                 CondInletTemp,
                                                 InletAirWetBulbC));
                    } else {
                        ShowContinueError(state, format(" Negative value occurs using a condenser inlet air temperature of {:.1T}.", CondInletTemp));
                    }
                    if (Mode > 1) {
                        ShowContinueError(state, format(" Negative output results from stage {} compressor operation.", Mode));
                    }
                    ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
                }
                ShowRecurringWarningErrorAtEnd(
                    state,
                    std::string{RoutineName} + thisDXCoil.DXCoilType + "=\"" + thisDXCoil.Name +
                        "\": Energy Input Ratio Modifier curve (function of temperature) output is negative warning continues...",
                    thisDXCoil.EIRFTempErrorIndex,
                    EIRTempModFac,
                    EIRTempModFac);
                EIRTempModFac = 0.0;
            }

            EIRFlowModFac = CurveValue(state, thisDXCoil.EIRFFlow(Mode), AirMassFlowRatio);

            //   Warn user if curve output goes negative
            if (EIRFlowModFac < 0.0) {
                if (thisDXCoil.EIRFFlowErrorIndex == 0) {
                    ShowWarningMessage(state, format("{}{}=\"{}\":", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                    ShowContinueError(
                        state, format(" Energy Input Ratio Modifier curve (function of flow fraction) output is negative ({:.3T}).", EIRFlowModFac));
                    ShowContinueError(state, format(" Negative value occurs using an air flow fraction of {:.3T}.", AirMassFlowRatio));
                    ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
                    if (Mode > 1) {
                        ShowContinueError(state, format(" Negative output results from stage {} compressor operation.", Mode));
                    }
                }
                ShowRecurringWarningErrorAtEnd(
                    state,
                    std::string{RoutineName} + thisDXCoil.DXCoilType + "=\"" + thisDXCoil.Name +
                        "\": Energy Input Ratio Modifier curve (function of flow fraction) output is negative warning continues...",
                    thisDXCoil.EIRFFlowErrorIndex,
                    EIRFlowModFac,
                    EIRFlowModFac);
                EIRFlowModFac = 0.0;
            }
        }

        EIR = thisDXCoil.RatedEIR(Mode) * EIRFlowModFac * EIRTempModFac;

        // For multimode coil, if stage-2 operation (Modes 2 or 4), return "full load" power adjusted for PLF
        if (Mode == 1 || Mode == 3) {
            thisDXCoil.ElecCoolingPower = TotCap * EIR * thisDXCoil.CoolingCoilRuntimeFraction;
        } else {
            thisDXCoil.ElecCoolingPower = TotCap * EIR * thisDXCoil.CoolingCoilRuntimeFraction / PartLoadRatio;
        }

        // Reset AirMassFlow to inlet node air mass flow for final total, sensible and latent calculations
        // since AirMassFlow might have been modified above (in this subroutine):
        //     IF (FanOpMode .EQ. FanOp::Cycling) AirMassFlow = AirMassFlow / PartLoadRatio
        // For multimode coil, this should be full flow including bypassed fraction
        AirMassFlow = thisDXCoil.InletAirMassFlowRate;
        CalcComponentSensibleLatentOutput(AirMassFlow,
                                          InletAirDryBulbTemp,
                                          InletAirHumRat,
                                          OutletAirTemp,
                                          OutletAirHumRat,
                                          thisDXCoil.SensCoolingEnergyRate,
                                          thisDXCoil.LatCoolingEnergyRate,
                                          thisDXCoil.TotalCoolingEnergyRate);

        // Set DataHeatGlobal heat reclaim variable for use by heat reclaim coil (part load ratio is accounted for)
        // Calculation for heat reclaim needs to be corrected to use compressor power (not including condenser fan power)
        state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = thisDXCoil.TotalCoolingEnergyRate + thisDXCoil.ElecCoolingPower;

        // Calculate crankcase heater power using the runtime fraction for this DX cooling coil only if there is no companion DX coil.
        // Else use the largest runtime fraction of this DX cooling coil and the companion DX heating coil.
        if (thisDXCoil.CompanionUpstreamDXCoil == 0) {
            thisDXCoil.CrankcaseHeaterPower = CrankcaseHeatingPower * (1.0 - thisDXCoil.CoolingCoilRuntimeFraction);
        } else {
            thisDXCoil.CrankcaseHeaterPower =
                CrankcaseHeatingPower * (1.0 - max(thisDXCoil.CoolingCoilRuntimeFraction,
                                                   state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).HeatingCoilRuntimeFraction));
        }

        if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Evap) {
            //******************
            //             WATER CONSUMPTION IN m3 OF WATER FOR DIRECT
            //             H2O [m3/s] = Delta W[kgWater/kgDryAir]*Mass Flow Air[kgDryAir/s]
            //                                /RhoWater [kgWater/m3]
            //******************
            RhoWater = RhoH2O(OutdoorDryBulb);
            thisDXCoil.EvapWaterConsumpRate = (CondInletHumRat - OutdoorHumRat) * CondAirMassFlow / RhoWater * thisDXCoil.CoolingCoilRuntimeFraction;
            thisDXCoil.EvapCondPumpElecPower = thisDXCoil.EvapCondPumpElecNomPower(Mode) * thisDXCoil.CoolingCoilRuntimeFraction;
            // Calculate basin heater power
            CalcBasinHeaterPower(state,
                                 thisDXCoil.BasinHeaterPowerFTempDiff,
                                 thisDXCoil.BasinHeaterSchedulePtr,
                                 thisDXCoil.BasinHeaterSetPointTemp,
                                 thisDXCoil.BasinHeaterPower);
            if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingSingleSpeed) {
                thisDXCoil.BasinHeaterPower *= (1.0 - thisDXCoil.CoolingCoilRuntimeFraction);
            }
        }

        thisDXCoil.OutletAirTemp = OutletAirTemp;
        thisDXCoil.OutletAirHumRat = OutletAirHumRat;
        thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;

    } else {

        // DX coil is off; just pass through conditions
        thisDXCoil.OutletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
        thisDXCoil.OutletAirHumRat = thisDXCoil.InletAirHumRat;
        thisDXCoil.OutletAirTemp = thisDXCoil.InletAirTemp;

        thisDXCoil.ElecCoolingPower = 0.0;
        thisDXCoil.TotalCoolingEnergyRate = 0.0;
        thisDXCoil.SensCoolingEnergyRate = 0.0;
        thisDXCoil.LatCoolingEnergyRate = 0.0;
        thisDXCoil.EvapCondPumpElecPower = 0.0;
        thisDXCoil.EvapWaterConsumpRate = 0.0;

        // Reset globals when DX coil is OFF for use in heat recovery module
        state.dataDXCoils->DXCoilFullLoadOutAirTemp(DXCoilNum) = 0.0;
        state.dataDXCoils->DXCoilFullLoadOutAirHumRat(DXCoilNum) = 0.0;

        // Calculate crankcase heater power using the runtime fraction for this DX cooling coil (here DXCoolingCoilRTF=0) if
        // there is no companion DX coil, or the runtime fraction of the companion DX heating coil (here DXHeatingCoilRTF>=0).
        if (thisDXCoil.CompanionUpstreamDXCoil == 0) {
            thisDXCoil.CrankcaseHeaterPower = CrankcaseHeatingPower;
        } else {
            thisDXCoil.CrankcaseHeaterPower =
                CrankcaseHeatingPower * (1.0 - state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).HeatingCoilRuntimeFraction);
        }

        // Calculate basin heater power
        if (thisDXCoil.DXCoilType_Num == HVAC::CoilDX_CoolingTwoStageWHumControl) {
            if (any_eq(thisDXCoil.CondenserType, DataHeatBalance::RefrigCondenserType::Evap)) {
                CalcBasinHeaterPower(state,
                                     thisDXCoil.BasinHeaterPowerFTempDiff,
                                     thisDXCoil.BasinHeaterSchedulePtr,
                                     thisDXCoil.BasinHeaterSetPointTemp,
                                     thisDXCoil.BasinHeaterPower);
            }
        } else {
            if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Evap) {
                CalcBasinHeaterPower(state,
                                     thisDXCoil.BasinHeaterPowerFTempDiff,
                                     thisDXCoil.BasinHeaterSchedulePtr,
                                     thisDXCoil.BasinHeaterSetPointTemp,
                                     thisDXCoil.BasinHeaterPower);
            }
        }

    } // end of on/off if - else

    // set water system demand request (if needed)
    if (thisDXCoil.EvapWaterSupplyMode == EvapWaterSupply::FromTank) {
        state.dataWaterData->WaterStorage(thisDXCoil.EvapWaterSupTankID).VdotRequestDemand(thisDXCoil.EvapWaterTankDemandARRID) =
            thisDXCoil.EvapWaterConsumpRate;
    }

    state.dataDXCoils->DXCoilOutletTemp(DXCoilNum) = thisDXCoil.OutletAirTemp;
    state.dataDXCoils->DXCoilOutletHumRat(DXCoilNum) = thisDXCoil.OutletAirHumRat;
    state.dataDXCoils->DXCoilPartLoadRatio(DXCoilNum) = thisDXCoil.PartLoadRatio;
    state.dataDXCoils->DXCoilFanOp(DXCoilNum) = fanOp;
    thisDXCoil.CondInletTemp = CondInletTemp;

    // set outlet node conditions
    int airOutletNode = thisDXCoil.AirOutNode;
    state.dataLoopNodes->Node(airOutletNode).Temp = thisDXCoil.OutletAirTemp;
    state.dataLoopNodes->Node(airOutletNode).HumRat = thisDXCoil.OutletAirHumRat;

    // calc secondary coil if specified
    if (thisDXCoil.IsSecondaryDXCoilInZone) {
        CalcSecondaryDXCoils(state, DXCoilNum);
    }
}

void CalcVRFCoolingCoil(EnergyPlusData &state,
                        int const DXCoilNum,                                 // the number of the DX coil to be simulated
                        HVAC::CompressorOp const compressorOp,               // compressor operation; 1=on, 0=off
                        bool const FirstHVACIteration,                       // true if this is the first iteration of HVAC
                        Real64 const PartLoadRatio,                          // sensible cooling load / full load sensible cooling capacity
                        HVAC::FanOp const fanOp,                             // Allows parent object to control fan operation
                        Real64 const CompCycRatio,                           // cycling ratio of VRF condenser
                        ObjexxFCL::Optional_int_const PerfMode,              // Performance mode for MultiMode DX coil; Always 1 for other coil types
                        ObjexxFCL::Optional<Real64 const> OnOffAirFlowRatio, // ratio of compressor on airflow to compressor off airflow
                        ObjexxFCL::Optional<Real64 const> MaxCoolCap         // maximum capacity of DX coil
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Richard Raustad
    //       DATE WRITTEN   August 2010

    // PURPOSE OF THIS SUBROUTINE:
    // Calculates the air-side performance of a direct-expansion, air-cooled
    // VRF terminal unit cooling coil.
    // A new subroutine was created in case this DX coil model is significantly
    // different from the existing CalcDoe2DXCoil subroutine. The VRF heating coil
    // uses the existing DX heating coil subroutine (CalcDXHeatingCoil).

    // METHODOLOGY EMPLOYED:
    // This routine simulates the performance of a variable refrigerant flow cooling coil.
    // The routine requires the user to enter the total cooling capacity and sensible heat ratio.
    // Since different manufacturer's rate their equipment at different air flow rates,
    // the supply air flow rate corresponding to the rated capacities must also be
    // entered (should be between 300 cfm/ton and 450 cfm/ton). The rated information entered by
    // the user should NOT include the thermal or electrical impacts of the supply air fan, as
    // this is addressed by another module.

    // With the rated performance data entered by the user, the model employs some of the
    // DOE-2.1E curve fits to adjust the capacity and efficiency of the unit as a function
    // of entering air temperatures and supply air flow rate (actual vs rated flow). The model
    // does NOT employ the exact same methodology to calculate performance as DOE-2.
    // This VRF cooling coil model adjusts the rated total cooling capacity by the CAPFT
    // and CAP function of flow curve/model currently used by the existing DX coil model.
    // The part-load ratio is then applied to the total operating capacity to find the capacity
    // required to meet the load. This VRF model then uses the ADP/bypass method to find the
    // SHR and resulting outlet conditions given that total capacity (or delta H).

    // The model checks for coil dryout conditions, and adjusts the calculated performance
    // appropriately.

    // Using/Aliasing
    using Curve::CurveValue;
    Real64 SysTimeElapsed = state.dataHVACGlobal->SysTimeElapsed;
    Real64 TimeStepSys = state.dataHVACGlobal->TimeStepSys;
    using General::CreateSysTimeIntervalString;

    // SUBROUTINE ARGUMENT DEFINITIONS:
    //  REAL(r64), INTENT(IN), OPTIONAL :: CoolingHeatingPLR   ! used for cycling fan RH control

    // SUBROUTINE PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineName("CalcVRFCoolingCoil");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 AirMassFlow;       // dry air mass flow rate through coil [kg/s] (adjusted for bypass if any)
    Real64 AirMassFlowRatio;  // Ratio of actual air mass flow to rated air mass flow (adjusted for bypass if any)
    Real64 AirVolumeFlowRate; // Air volume flow rate across the cooling coil [m3/s] (adjusted for bypass if any)
    // (average flow if cycling fan, full flow if constant fan)
    Real64 VolFlowperRatedTotCap; // Air volume flow rate divided by rated total cooling capacity [m3/s-W] (adjusted for bypass)
    Real64 TotCap;                // gross total cooling capacity at off-rated conditions [W]
    Real64 TotCapTempModFac;      // Total capacity modifier (function of entering wetbulb, outside drybulb)
    Real64 TotCapFlowModFac;      // Total capacity modifier (function of actual supply air flow vs rated flow)
    Real64 InletAirWetBulbC;      // wetbulb temperature of inlet air [C]
    Real64 InletAirDryBulbTemp;   // inlet air dry bulb temperature [C]
    Real64 InletAirEnthalpy;      // inlet air enthalpy [J/kg]
    Real64 InletAirHumRat;        // inlet air humidity ratio [kg/kg]
    Real64 InletAirHumRatTemp;    // inlet air humidity ratio used in ADP/BF loop [kg/kg]
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // REAL(r64) :: InletAirPressure      ! inlet air pressure [Pa]
    Real64 RatedCBF;             // coil bypass factor at rated conditions
    Real64 SHR;                  // Sensible Heat Ratio (sensible/total) of the cooling coil
    Real64 CBF;                  // coil bypass factor at off rated conditions
    Real64 A0;                   // NTU * air mass flow rate, used in CBF calculation
    Real64 hDelta;               // Change in air enthalpy across the cooling coil [J/kg]
    Real64 hADP;                 // Apparatus dew point enthalpy [J/kg]
    Real64 hTinwADP;             // Enthalpy at inlet dry-bulb and wADP [J/kg]
    Real64 hTinwout;             // Enthalpy at inlet dry-bulb and outlet humidity ratio [J/kg]
    Real64 tADP;                 // Apparatus dew point temperature [C]
    Real64 wADP;                 // Apparatus dew point humidity ratio [kg/kg]
    Real64 FullLoadOutAirEnth;   // outlet full load enthalpy [J/kg]
    Real64 FullLoadOutAirHumRat; // outlet humidity ratio at full load
    Real64 FullLoadOutAirTemp;   // outlet air temperature at full load [C]
    Real64 PLF;                  // Part load factor, accounts for thermal lag at compressor startup, used in power calculation
    Real64 QLatActual;           // operating latent capacity of DX coil
    Real64 QLatRated;            // Rated latent capacity of DX coil
    Real64 SHRUnadjusted;        // SHR prior to latent degradation effective SHR calculation
    int Counter;                 // Counter for dry evaporator iterations
    int MaxIter;                 // Maximum number of iterations for dry evaporator calculations
    Real64 RF;                   // Relaxation factor for dry evaporator iterations
    Real64 Tolerance;            // Error tolerance for dry evaporator iterations
    Real64 werror;               // Deviation of humidity ratio in dry evaporator iteration loop
    Real64 CondInletTemp;        // Condenser inlet temperature (C). Outdoor dry-bulb temp for air-cooled condenser.
    // Outdoor Wetbulb +(1 - effectiveness)*(outdoor drybulb - outdoor wetbulb) for evap condenser.
    Real64 CondInletHumRat; // Condenser inlet humidity ratio (kg/kg). Zero for air-cooled condenser.
    // For evap condenser, its the humidity ratio of the air leaving the evap cooling pads.
    Real64 CondAirMassFlow;       // Condenser air mass flow rate [kg/s]
    Real64 RhoAir;                // Density of air [kg/m3]
    Real64 CrankcaseHeatingPower; // power due to crankcase heater
    Real64 CompAmbTemp(0.0);      // Ambient temperature at compressor
    Real64 AirFlowRatio;          // ratio of compressor on airflow to average timestep airflow
    // used when constant fan mode yields different air flow rates when compressor is ON and OFF
    // (e.g. Packaged Terminal Heat Pump)
    Real64 OutdoorDryBulb;  // Outdoor dry-bulb temperature at condenser (C)
    Real64 OutdoorWetBulb;  // Outdoor wet-bulb temperature at condenser (C)
    Real64 OutdoorHumRat;   // Outdoor humidity ratio at condenser (kg/kg)
    Real64 OutdoorPressure; // Outdoor barometric pressure at condenser (Pa)

    int Mode;                 // Performance mode for Multimode DX coil; Always 1 for other coil types
    Real64 OutletAirTemp;     // Supply air temperature (average value if constant fan, full output if cycling fan)
    Real64 OutletAirHumRat;   // Supply air humidity ratio (average value if constant fan, full output if cycling fan)
    Real64 OutletAirEnthalpy; // Supply air enthalpy (average value if constant fan, full output if cycling fan)
    Real64 ADiff;             // Used for exponential

    // If Performance mode not present, then set to 1.  Used only by Multimode/Multispeed DX coil (otherwise mode = 1)
    if (present(PerfMode)) {
        Mode = PerfMode;
    } else {
        Mode = 1;
    }

    // If AirFlowRatio not present, then set to 1. Used only by DX coils with different air flow
    // during cooling and when no cooling is required (constant fan, fan speed changes)
    if (present(OnOffAirFlowRatio)) {
        AirFlowRatio = OnOffAirFlowRatio;
    } else {
        AirFlowRatio = 1.0;
    }

    MaxIter = 30;
    RF = 0.4;
    Counter = 0;
    Tolerance = 0.01;
    CondInletTemp = 0.0;
    CondInletHumRat = 0.0;

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    AirMassFlow = thisDXCoil.InletAirMassFlowRate;
    InletAirDryBulbTemp = thisDXCoil.InletAirTemp;
    InletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
    InletAirHumRat = thisDXCoil.InletAirHumRat;
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // InletAirPressure    = DXCoil(DXCoilNum)%InletAirPressure
    state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = 0.0;
    thisDXCoil.CoolingCoilRuntimeFraction = 0.0;
    thisDXCoil.PartLoadRatio = 0.0;
    thisDXCoil.BasinHeaterPower = 0.0;

    if (thisDXCoil.CondenserInletNodeNum(Mode) != 0) {
        OutdoorDryBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).Temp;
        if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Water) {
            OutdoorHumRat = state.dataEnvrn->OutHumRat;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
            OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
        } else {
            OutdoorPressure = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).Press;
            // If node is not connected to anything, pressure = default, use weather data
            if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press) {
                OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
                OutdoorHumRat = state.dataEnvrn->OutHumRat;
                OutdoorPressure = state.dataEnvrn->OutBaroPress;
                OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
            } else {
                OutdoorHumRat = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).HumRat;
                // this should use Node%WetBulbTemp or a PSYC function, not OAWB
                OutdoorWetBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).OutAirWetBulb;
            }
        }
    } else {
        OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
        OutdoorHumRat = state.dataEnvrn->OutHumRat;
        OutdoorPressure = state.dataEnvrn->OutBaroPress;
        OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
    }

    if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Evap) {
        RhoAir = PsyRhoAirFnPbTdbW(state, OutdoorPressure, OutdoorDryBulb, OutdoorHumRat);
        CondAirMassFlow = RhoAir * thisDXCoil.EvapCondAirFlow(Mode);
        // (Outdoor wet-bulb temp from DataEnvironment) + (1.0-EvapCondEffectiveness) * (drybulb - wetbulb)
        CondInletTemp = OutdoorWetBulb + (OutdoorDryBulb - OutdoorWetBulb) * (1.0 - thisDXCoil.EvapCondEffect(Mode));
        CondInletHumRat = PsyWFnTdbTwbPb(state, CondInletTemp, OutdoorWetBulb, OutdoorPressure);
        CompAmbTemp = OutdoorDryBulb;
    } else {                            // for air or water-cooled, inlet temp is stored in OutdoorDryBulb temp
        CondInletTemp = OutdoorDryBulb; // Outdoor dry-bulb temp or water inlet temp
        if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Water) {
            CompAmbTemp = state.dataEnvrn->OutDryBulbTemp; // for crankcase heater use actual outdoor temp for water-cooled
        } else {
            CompAmbTemp = OutdoorDryBulb;
        }
    }

    // Initialize crankcase heater, operates below OAT defined in input deck for HP DX cooling coil
    // If used in a heat pump, the value of MaxOAT in the heating coil overrides that in the cooling coil (in GetInput)
    if (CompAmbTemp < thisDXCoil.MaxOATCrankcaseHeater) {
        CrankcaseHeatingPower = thisDXCoil.CrankcaseHeaterCapacity;
        if (thisDXCoil.CrankcaseHeaterCapacityCurveIndex > 0) {
            CrankcaseHeatingPower *= Curve::CurveValue(state, thisDXCoil.CrankcaseHeaterCapacityCurveIndex, CompAmbTemp);
        }
    } else {
        CrankcaseHeatingPower = 0.0;
    }

    // calculate end time of current time step to determine if error messages should be printed
    state.dataDXCoils->CalcVRFCoolingCoilCurrentEndTime = state.dataGlobal->CurrentTime + SysTimeElapsed;

    //   Print warning messages only when valid and only for the first occurrence. Let summary provide statistics.
    //   Wait for next time step to print warnings. If simulation iterates, print out
    //   the warning for the last iteration only. Must wait for next time step to accomplish this.
    //   If a warning occurs and the simulation down shifts, the warning is not valid.
    if (thisDXCoil.PrintLowAmbMessage) { // .AND. &
        if (state.dataDXCoils->CalcVRFCoolingCoilCurrentEndTime > thisDXCoil.CurrentEndTimeLast && TimeStepSys >= thisDXCoil.TimeStepSysLast) {
            if (thisDXCoil.LowAmbErrIndex == 0) {
                ShowWarningMessage(state, thisDXCoil.LowAmbBuffer1);
                ShowContinueError(state, thisDXCoil.LowAmbBuffer2);
                ShowContinueError(state, "... Operation at low inlet temperatures may require special performance curves.");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                                               "\" - Low condenser inlet temperature error continues...",
                                           thisDXCoil.LowAmbErrIndex,
                                           thisDXCoil.LowTempLast,
                                           thisDXCoil.LowTempLast,
                                           _,
                                           "[C]",
                                           "[C]");
        }
    }

    if (thisDXCoil.PrintHighAmbMessage) { // .AND. &
        if (state.dataDXCoils->CalcVRFCoolingCoilCurrentEndTime > thisDXCoil.CurrentEndTimeLast && TimeStepSys >= thisDXCoil.TimeStepSysLast) {
            if (thisDXCoil.HighAmbErrIndex == 0) {
                ShowWarningMessage(state, thisDXCoil.HighAmbBuffer1);
                ShowContinueError(state, thisDXCoil.HighAmbBuffer2);
                ShowContinueError(state, "... Operation at high inlet temperatures may require special performance curves.");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                                               "\" - High condenser inlet temperature error continues...",
                                           thisDXCoil.HighAmbErrIndex,
                                           thisDXCoil.HighTempLast,
                                           thisDXCoil.HighTempLast,
                                           _,
                                           "[C]",
                                           "[C]");
        }
    }

    if (thisDXCoil.PrintLowOutTempMessage) {
        if (state.dataDXCoils->CalcVRFCoolingCoilCurrentEndTime > thisDXCoil.CurrentEndTimeLast && TimeStepSys >= thisDXCoil.TimeStepSysLast) {
            if (thisDXCoil.LowOutletTempIndex == 0) {
                ShowWarningMessage(state, thisDXCoil.LowOutTempBuffer1);
                ShowContinueError(state, thisDXCoil.LowOutTempBuffer2);
                ShowContinueError(state, "... Possible reasons for low outlet air dry-bulb temperatures are: This DX coil");
                ShowContinueError(state,
                                  format("   1) may have a low inlet air dry-bulb temperature. Inlet air temperature = {:.3T} C.",
                                         thisDXCoil.FullLoadInletAirTempLast));
                ShowContinueError(state, "   2) may have a low air flow rate per watt of cooling capacity. Check inputs.");
                ShowContinueError(state,
                                  "   3) is used as part of a HX assisted cooling coil which uses a high sensible effectiveness. Check inputs.");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                                               "\" - Full load outlet temperature indicates a possibility of frost/freeze error continues. "
                                               "Outlet air temperature statistics follow:",
                                           thisDXCoil.LowOutletTempIndex,
                                           thisDXCoil.FullLoadOutAirTempLast,
                                           thisDXCoil.FullLoadOutAirTempLast);
        }
    }

    // save last system time step and last end time of current time step (used to determine if warning is valid)
    thisDXCoil.TimeStepSysLast = TimeStepSys;
    thisDXCoil.CurrentEndTimeLast = state.dataDXCoils->CalcVRFCoolingCoilCurrentEndTime;
    thisDXCoil.PrintLowAmbMessage = false;
    thisDXCoil.PrintLowOutTempMessage = false;

    if ((AirMassFlow > 0.0) && (GetCurrentScheduleValue(state, thisDXCoil.SchedPtr) > 0.0) && (PartLoadRatio > 0.0) &&
        (compressorOp == HVAC::CompressorOp::On)) { // for cycling fan, reset mass flow to full on rate
        if (fanOp == HVAC::FanOp::Cycling) {
            AirMassFlow /= PartLoadRatio;
        } else if (fanOp == HVAC::FanOp::Continuous) {
            AirMassFlow *= AirFlowRatio;
        } else {
            AirMassFlow = thisDXCoil.RatedAirMassFlowRate(Mode);
        }

        // Check for valid air volume flow per rated total cooling capacity (200 - 500 cfm/ton)

        // for some reason there are diff's when using coil inlet air pressure
        // these lines (more to follow) are commented out for the time being

        InletAirWetBulbC = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRat, OutdoorPressure);
        AirVolumeFlowRate = AirMassFlow / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat);
        VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.RatedTotCap(Mode);

        if (thisDXCoil.RatedTotCap(Mode) <= 0.0) {
            ShowFatalError(state, format("{} \"{}\" - Rated total cooling capacity is zero or less.", thisDXCoil.DXCoilType, thisDXCoil.Name));
        }

        if (!FirstHVACIteration && !state.dataGlobal->WarmupFlag &&
            ((VolFlowperRatedTotCap < HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) ||
             (VolFlowperRatedTotCap > HVAC::MaxCoolVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]))) {
            if (thisDXCoil.ErrIndex1 == 0) {
                ShowWarningMessage(
                    state,
                    format("{} \"{}\" - Air volume flow rate per watt of rated total cooling capacity is out of range at {:.3R} m3/s/W.",
                           thisDXCoil.DXCoilType,
                           thisDXCoil.Name,
                           VolFlowperRatedTotCap));
                ShowContinueErrorTimeStamp(state, "");
                ShowContinueError(state,
                                  format("...Expected range for VolumeFlowPerRatedTotalCapacity=[{:.3R}--{:.3R}]",
                                         HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                         HVAC::MaxCoolVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
                ShowContinueError(state, "...Possible causes include inconsistent air flow rates in system components,");
                ShowContinueError(state, "...or mixing manual inputs with autosize inputs. Also check the following values and calculations.");
                ShowContinueError(state, "...Volume Flow Rate per Rated Total Capacity = Volume Flow Rate / Rated Total Capacity");
                ShowContinueError(state, "...Volume Flow Rate = Air Mass Flow Rate / Air Density");
                ShowContinueError(state, "...Data used for calculations:");
                ShowContinueError(state, format("...Rated Total Capacity = {:.2R} W.", thisDXCoil.RatedTotCap(Mode)));
                ShowContinueError(state, "...Volume Flow Rate = Air Mass Flow Rate / Air Density");
                ShowContinueError(state, format("...Volume Flow Rate   = {:.8R} m3/s.", AirVolumeFlowRate));
                ShowContinueError(state, format("...Air Mass Flow Rate = {:.8R} kg/s.", AirMassFlow));
                ShowContinueError(
                    state,
                    format("...Air Density        = {:.8R} kg/m3.", PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat)));
                ShowContinueError(state, "...Data used for air density calculation:");
                ShowContinueError(state, format("...Outdoor Air Pressure     = {:.3R} Pa.", OutdoorPressure));
                ShowContinueError(state, format("...Inlet Air Dry-Bulb Temp  = {:.3R} C.", InletAirDryBulbTemp));
                ShowContinueError(state, format("...Inlet Air Humidity Ratio = {:.8R} kgWater/kgDryAir.", InletAirHumRat));
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                    "\" - Air volume flow rate per watt of rated total cooling capacity is out of range error continues...",
                thisDXCoil.ErrIndex1,
                VolFlowperRatedTotCap,
                VolFlowperRatedTotCap);
        }
        //    Adjust coil bypass factor for actual air flow rate. Use relation CBF = exp(-NTU) where
        //    NTU = A0/(m*cp). Relationship models the cooling coil as a heat exchanger with Cmin/Cmax = 0.

        RatedCBF = thisDXCoil.RatedCBF(Mode);
        if (RatedCBF > 0.0) {
            A0 = -std::log(RatedCBF) * thisDXCoil.RatedAirMassFlowRate(Mode);
        } else {
            A0 = 0.0;
        }
        ADiff = -A0 / AirMassFlow;
        if (ADiff >= DataPrecisionGlobals::EXP_LowerLimit) {
            CBF = std::exp(ADiff);
        } else {
            CBF = 0.0;
        }

        // check boundary for low ambient temperature and post warnings to individual DX coil buffers to print at end of time step
        if (OutdoorDryBulb < thisDXCoil.MinOATCompressor && !state.dataGlobal->WarmupFlag) {
            thisDXCoil.PrintLowAmbMessage = true;
            thisDXCoil.LowTempLast = OutdoorDryBulb;
            if (thisDXCoil.LowAmbErrIndex == 0) {
                thisDXCoil.LowAmbBuffer1 = format("{} \"{}\" - Condenser inlet temperature below {:.2R} C. Condenser inlet temperature = {:.2R}",
                                                  thisDXCoil.DXCoilType,
                                                  thisDXCoil.Name,
                                                  thisDXCoil.MinOATCompressor,
                                                  OutdoorDryBulb);
                thisDXCoil.LowAmbBuffer2 = " ... Occurrence info = " + state.dataEnvrn->EnvironmentName + ", " + state.dataEnvrn->CurMnDy + ' ' +
                                           CreateSysTimeIntervalString(state);
            }
        }

        // check boundary for high ambient temperature and post warnings to individual DX coil buffers to print at end of time step
        if (OutdoorDryBulb > thisDXCoil.MaxOATCompressor && !state.dataGlobal->WarmupFlag) {
            thisDXCoil.PrintHighAmbMessage = true;
            thisDXCoil.HighTempLast = OutdoorDryBulb;
            if (thisDXCoil.HighAmbErrIndex == 0) {
                thisDXCoil.HighAmbBuffer1 = format("{} \"{}\" - Condenser inlet temperature above {:.2R} C. Condenser temperature = {:.2R}",
                                                   thisDXCoil.DXCoilType,
                                                   thisDXCoil.Name,
                                                   thisDXCoil.MaxOATCompressor,
                                                   OutdoorDryBulb);
                thisDXCoil.HighAmbBuffer2 = " ... Occurrence info = " + state.dataEnvrn->EnvironmentName + ", " + state.dataEnvrn->CurMnDy + ' ' +
                                            CreateSysTimeIntervalString(state);
            }
        }

        //  Get total capacity modifying factor (function of temperature) for off-rated conditions
        //  InletAirHumRat may be modified in this ADP/BF loop, use temporary variable for calculations
        InletAirHumRatTemp = InletAirHumRat;

    Label50:;
        switch (state.dataCurveManager->PerfCurve(thisDXCoil.CCapFTemp(Mode))->numDims) {
        case 1:
            TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(Mode), InletAirWetBulbC);
            break;
        case 2:
        default: // this default allows the simulation to continue, but will issue a warning, should be removed eventually
            TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(Mode), InletAirWetBulbC, CondInletTemp);
            break;
        }

        //  Warn user if curve output goes negative
        if (TotCapTempModFac < 0.0) {
            if (thisDXCoil.CCapFTempErrorIndex == 0) {
                ShowWarningMessage(state, format("{} \"{}\":", thisDXCoil.DXCoilType, thisDXCoil.Name));
                ShowContinueError(
                    state, format(" Total Cooling Capacity Modifier curve (function of temperature) output is negative ({:.3T}).", TotCapTempModFac));
                ShowContinueError(
                    state,
                    format(" Negative value occurs using a condenser inlet temperature of {:.1T} and an inlet air wet-bulb temperature of {:.1T}.",
                           CondInletTemp,
                           InletAirWetBulbC));
                if (Mode > 1) {
                    ShowContinueError(state, format(" Negative output results from stage {} compressor operation.", Mode));
                }
                ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                    "\": Total Cooling Capacity Modifier curve (function of temperature) output is negative warning continues...",
                thisDXCoil.CCapFTempErrorIndex,
                TotCapTempModFac,
                TotCapTempModFac);
            TotCapTempModFac = 0.0;
        }

        //  Get total capacity modifying factor (function of mass flow) for off-rated conditions
        AirMassFlowRatio = AirMassFlow / thisDXCoil.RatedAirMassFlowRate(Mode);
        TotCapFlowModFac = CurveValue(state, thisDXCoil.CCapFFlow(Mode), AirMassFlowRatio);

        //  Warn user if curve output goes negative
        if (TotCapFlowModFac < 0.0) {
            if (thisDXCoil.CCapFFlowErrorIndex == 0) {
                ShowWarningMessage(state, format("{} \"{}\":", thisDXCoil.DXCoilType, thisDXCoil.Name));
                ShowContinueError(
                    state,
                    format(" Total Cooling Capacity Modifier curve (function of flow fraction) output is negative ({:.3T}).", TotCapFlowModFac));
                ShowContinueError(state, format(" Negative value occurs using an air flow fraction of {:.3T}.", AirMassFlowRatio));
                ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
                if (Mode > 1) {
                    ShowContinueError(state, format(" Negative output results from stage {} compressor operation.", Mode));
                }
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                    "\": Total Cooling Capacity Modifier curve (function of flow fraction) output is negative warning continues...",
                thisDXCoil.CCapFFlowErrorIndex,
                TotCapFlowModFac,
                TotCapFlowModFac);
            TotCapFlowModFac = 0.0;
        }

        if (present(MaxCoolCap)) {
            TotCap = min(MaxCoolCap, thisDXCoil.RatedTotCap(Mode) * TotCapFlowModFac * TotCapTempModFac);
        } else {
            TotCap = thisDXCoil.RatedTotCap(Mode) * TotCapFlowModFac * TotCapTempModFac;
        }

        TotCap *= PartLoadRatio;

        // Calculate apparatus dew point conditions using TotCap and CBF
        hDelta = TotCap / AirMassFlow;
        // there is an issue here with using CBF to calculate the ADP enthalpy.
        // at low loads the bypass factor increases significantly.
        hADP = InletAirEnthalpy - hDelta / (1.0 - CBF);
        tADP = PsyTsatFnHPb(state, hADP, OutdoorPressure, RoutineName);
        //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
        //  tADP = PsyTsatFnHPb(hADP,InletAirPressure)
        wADP = min(InletAirHumRat, PsyWFnTdbH(state, tADP, hADP, RoutineName));
        hTinwADP = PsyHFnTdbW(InletAirDryBulbTemp, wADP);
        if ((InletAirEnthalpy - hADP) > 1.e-10) {
            SHR = min((hTinwADP - hADP) / (InletAirEnthalpy - hADP), 1.0);
        } else {
            SHR = 1.0;
        }
        // Check for dry evaporator conditions (win < wadp)
        if (wADP > InletAirHumRatTemp || (Counter >= 1 && Counter < MaxIter)) {
            if (InletAirHumRatTemp == 0.0) InletAirHumRatTemp = 0.00001;
            werror = (InletAirHumRatTemp - wADP) / InletAirHumRatTemp;
            // Increase InletAirHumRatTemp at constant InletAirTemp to find coil dry-out point. Then use the
            // capacity at the dry-out point to determine exiting conditions from coil. This is required
            // since the TotCapTempModFac doesn't work properly with dry-coil conditions.
            InletAirHumRatTemp = RF * wADP + (1.0 - RF) * InletAirHumRatTemp;
            InletAirWetBulbC = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRatTemp, OutdoorPressure);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //     InletAirWetBulbC = PsyTwbFnTdbWPb(InletAirDryBulbTemp,InletAirHumRatTemp,InletAirPressure)
            ++Counter;
            if (std::abs(werror) > Tolerance) goto Label50; // Recalculate with modified inlet conditions
        }

        if (thisDXCoil.PLFFPLR(Mode) > 0 && CompCycRatio < 1.0) {
            PLF = CurveValue(state, thisDXCoil.PLFFPLR(Mode), CompCycRatio); // Calculate part-load factor
        } else {
            PLF = 1.0;
        }

        if (PLF < 0.7) {
            if (thisDXCoil.ErrIndex2 == 0) {
                ShowWarningMessage(
                    state,
                    format(
                        "The PLF curve value for the DX cooling coil {} ={:.3R} for part-load ratio ={:.3R}", thisDXCoil.Name, PLF, PartLoadRatio));
                ShowContinueErrorTimeStamp(state, "PLF curve values must be >= 0.7. PLF has been reset to 0.7 and simulation is continuing.");
                ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Cooling:DX:SingleSpeed].");
            }
            ShowRecurringWarningErrorAtEnd(
                state, thisDXCoil.Name + ", DX cooling coil PLF curve < 0.7 warning continues...", thisDXCoil.ErrIndex2, PLF, PLF);
            PLF = 0.7;
        }

        thisDXCoil.PartLoadRatio = PartLoadRatio;
        thisDXCoil.CoolingCoilRuntimeFraction = CompCycRatio / PLF;
        if (thisDXCoil.CoolingCoilRuntimeFraction > 1.0 && std::abs(thisDXCoil.CoolingCoilRuntimeFraction - 1.0) > 0.001) {
            if (thisDXCoil.ErrIndex3 == 0) {
                ShowWarningMessage(state,
                                   format("The runtime fraction for DX cooling coil {} exceeded 1.0. [{:.4R}].",
                                          thisDXCoil.Name,
                                          thisDXCoil.CoolingCoilRuntimeFraction));
                ShowContinueError(state, "Runtime fraction reset to 1 and the simulation will continue.");
                ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Cooling:DX:SingleSpeed].");
                ShowContinueErrorTimeStamp(state, "");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           thisDXCoil.Name + ", DX cooling coil runtime fraction > 1.0 warning continues...",
                                           thisDXCoil.ErrIndex3,
                                           thisDXCoil.CoolingCoilRuntimeFraction,
                                           thisDXCoil.CoolingCoilRuntimeFraction);
            thisDXCoil.CoolingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
        } else if (thisDXCoil.CoolingCoilRuntimeFraction > 1.0) {
            thisDXCoil.CoolingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
        }

        // If cycling fan, send coil part-load fraction to on/off fan via HVACDataGlobals
        if (fanOp == HVAC::FanOp::Cycling) state.dataHVACGlobal->OnOffFanPartLoadFraction = PLF;

        //  Calculate full load output conditions
        //            if ( SHR > 1.0 || Counter > 0 ) SHR = 1.0;
        if (SHR > 1.0) SHR = 1.0;
        FullLoadOutAirEnth = InletAirEnthalpy - TotCap / AirMassFlow;
        hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
        if (SHR < 1.0) {
            FullLoadOutAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
        } else {
            FullLoadOutAirHumRat = InletAirHumRat;
        }
        FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, FullLoadOutAirHumRat);

        // Check for saturation error and modify temperature at constant enthalpy
        if (FullLoadOutAirTemp < PsyTsatFnHPb(state, FullLoadOutAirEnth, OutdoorPressure)) {
            FullLoadOutAirTemp = PsyTsatFnHPb(state, FullLoadOutAirEnth, OutdoorPressure);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //   IF(FullLoadOutAirTemp .LT. PsyTsatFnHPb(FullLoadOutAirEnth,InletAirPressure)) THEN
            //    FullLoadOutAirTemp = PsyTsatFnHPb(FullLoadOutAirEnth,InletAirPressure)
            FullLoadOutAirHumRat = PsyWFnTdbH(state, FullLoadOutAirTemp, FullLoadOutAirEnth);
        }

        // Store actual outlet conditions when DX coil is ON for use in heat recovery module
        state.dataDXCoils->DXCoilFullLoadOutAirTemp(DXCoilNum) = FullLoadOutAirTemp;
        state.dataDXCoils->DXCoilFullLoadOutAirHumRat(DXCoilNum) = FullLoadOutAirHumRat;

        // Add warning message for cold cooling coil (FullLoadOutAirTemp < 2 C)
        if (FullLoadOutAirTemp < 2.0 && !FirstHVACIteration && !state.dataGlobal->WarmupFlag) {
            thisDXCoil.PrintLowOutTempMessage = true;
            thisDXCoil.FullLoadOutAirTempLast = FullLoadOutAirTemp;
            if (thisDXCoil.LowOutletTempIndex == 0) {
                thisDXCoil.FullLoadInletAirTempLast = InletAirDryBulbTemp;
                thisDXCoil.LowOutTempBuffer1 = format("{} \"{}\" - Full load outlet air dry-bulb temperature < 2C. This indicates the "
                                                      "possibility of coil frost/freeze. Outlet temperature = {:.2R} C.",
                                                      thisDXCoil.DXCoilType,
                                                      thisDXCoil.Name,
                                                      FullLoadOutAirTemp);
                thisDXCoil.LowOutTempBuffer2 = " ...Occurrence info = " + state.dataEnvrn->EnvironmentName + ", " + state.dataEnvrn->CurMnDy + ' ' +
                                               CreateSysTimeIntervalString(state);
            }
        }

        //  If constant fan with cycling compressor, call function to determine "effective SHR"
        //  which includes the part-load degradation on latent capacity
        if (fanOp == HVAC::FanOp::Continuous && CompCycRatio < 1.0) {
            QLatRated = thisDXCoil.RatedTotCap(Mode) * (1.0 - thisDXCoil.RatedSHR(Mode)); // always the same number
            QLatActual = TotCap * (1.0 - SHR);
            SHRUnadjusted = SHR;
            SHR = CalcEffectiveSHR(
                state, DXCoilNum, SHR, thisDXCoil.CoolingCoilRuntimeFraction, QLatRated, QLatActual, InletAirDryBulbTemp, InletAirWetBulbC, Mode);

            //  Calculate full load output conditions
            //                if ( SHR > 1.0 || Counter > 0 ) SHR = 1.0;
            if (SHR > 1.0) SHR = 1.0;
            FullLoadOutAirEnth = InletAirEnthalpy - TotCap / AirMassFlow;
            hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
            if (SHR < 1.0) {
                FullLoadOutAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
            } else {
                FullLoadOutAirHumRat = InletAirHumRat;
            }
            FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, FullLoadOutAirHumRat);
        }

        //  Calculate actual outlet conditions for the input part load ratio
        //  Actual outlet conditions are "average" for time step when compressor cycles

        if (fanOp == HVAC::FanOp::Continuous && CompCycRatio < 1.0) {
            // Continuous fan, cycling compressor
            // hmmm ... this seems wrong. PLR * AirFlowRatio = 1. So we get FullLoadOutAirEnth all this time. This is OK since above TotCap *=
            // PLR.
            OutletAirEnthalpy = ((PartLoadRatio * AirFlowRatio) * FullLoadOutAirEnth + (1.0 - (PartLoadRatio * AirFlowRatio)) * InletAirEnthalpy);
            OutletAirHumRat = ((PartLoadRatio * AirFlowRatio) * FullLoadOutAirHumRat + (1.0 - (PartLoadRatio * AirFlowRatio)) * InletAirHumRat);
            OutletAirTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
        } else {
            // Default to cycling fan, cycling compressor
            OutletAirEnthalpy = FullLoadOutAirEnth;
            OutletAirHumRat = FullLoadOutAirHumRat;
            OutletAirTemp = FullLoadOutAirTemp;
        }

        // Check for saturation error and modify temperature at constant enthalpy
        if (OutletAirTemp < PsyTsatFnHPb(state, OutletAirEnthalpy, OutdoorPressure, RoutineName)) {
            OutletAirTemp = PsyTsatFnHPb(state, OutletAirEnthalpy, OutdoorPressure);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //   IF(OutletAirTemp .LT. PsyTsatFnHPb(OutletAirEnthalpy,InletAirPressure)) THEN
            //    OutletAirTemp = PsyTsatFnHPb(OutletAirEnthalpy,InletAirPressure)
            OutletAirHumRat = PsyWFnTdbH(state, OutletAirTemp, OutletAirEnthalpy);
        }

        // Reset AirMassFlow to inlet node air mass flow for final total, sensible and latent calculations
        // since AirMassFlow might have been modified above (in this subroutine):
        //     IF (FanOpMode .EQ. FanOp::Cycling) AirMassFlow = AirMassFlow / PartLoadRatio
        // For multimode coil, this should be full flow including bypassed fraction
        AirMassFlow = thisDXCoil.InletAirMassFlowRate;

        // Coil total/sensible/latent cooling rates
        CalcComponentSensibleLatentOutput(AirMassFlow,
                                          InletAirDryBulbTemp,
                                          InletAirHumRat,
                                          OutletAirTemp,
                                          OutletAirHumRat,
                                          thisDXCoil.SensCoolingEnergyRate,
                                          thisDXCoil.LatCoolingEnergyRate,
                                          thisDXCoil.TotalCoolingEnergyRate);

        thisDXCoil.OutletAirTemp = OutletAirTemp;
        thisDXCoil.OutletAirHumRat = OutletAirHumRat;
        thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;

    } else {

        // DX coil is off; just pass through conditions
        thisDXCoil.OutletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
        thisDXCoil.OutletAirHumRat = thisDXCoil.InletAirHumRat;
        thisDXCoil.OutletAirTemp = thisDXCoil.InletAirTemp;

        thisDXCoil.ElecCoolingPower = 0.0;
        thisDXCoil.TotalCoolingEnergyRate = 0.0;
        thisDXCoil.SensCoolingEnergyRate = 0.0;
        thisDXCoil.LatCoolingEnergyRate = 0.0;
        thisDXCoil.EvapCondPumpElecPower = 0.0;
        thisDXCoil.EvapWaterConsumpRate = 0.0;

        // Reset globals when DX coil is OFF for use in heat recovery module
        state.dataDXCoils->DXCoilFullLoadOutAirTemp(DXCoilNum) = 0.0;
        state.dataDXCoils->DXCoilFullLoadOutAirHumRat(DXCoilNum) = 0.0;

    } // end of on/off if - else

    // set water system demand request (if needed)
    if (thisDXCoil.EvapWaterSupplyMode == EvapWaterSupply::FromTank) {
        state.dataWaterData->WaterStorage(thisDXCoil.EvapWaterSupTankID).VdotRequestDemand(thisDXCoil.EvapWaterTankDemandARRID) =
            thisDXCoil.EvapWaterConsumpRate;
    }

    state.dataDXCoils->DXCoilOutletTemp(DXCoilNum) = thisDXCoil.OutletAirTemp;
    state.dataDXCoils->DXCoilOutletHumRat(DXCoilNum) = thisDXCoil.OutletAirHumRat;
    state.dataDXCoils->DXCoilPartLoadRatio(DXCoilNum) = thisDXCoil.PartLoadRatio;
    state.dataDXCoils->DXCoilFanOp(DXCoilNum) = fanOp;
    thisDXCoil.CondInletTemp = CondInletTemp;
    state.dataDXCoils->DXCoilTotalCooling(DXCoilNum) = thisDXCoil.TotalCoolingEnergyRate;
    state.dataDXCoils->DXCoilCoolInletAirWBTemp(DXCoilNum) = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRat, OutdoorPressure);

    // set outlet node conditions
    int airOutletNode = thisDXCoil.AirOutNode;
    state.dataLoopNodes->Node(airOutletNode).Temp = thisDXCoil.OutletAirTemp;
    state.dataLoopNodes->Node(airOutletNode).HumRat = thisDXCoil.OutletAirHumRat;
}

void CalcDXHeatingCoil(EnergyPlusData &state,
                       int const DXCoilNum,                                 // the number of the DX heating coil to be simulated
                       Real64 const PartLoadRatio,                          // sensible cooling load / full load sensible cooling capacity
                       HVAC::FanOp const fanOp,                             // Allows parent object to control fan mode
                       ObjexxFCL::Optional<Real64 const> OnOffAirFlowRatio, // ratio of compressor on airflow to compressor off airflow
                       ObjexxFCL::Optional<Real64 const> MaxHeatCap         // maximum allowed heating capacity
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Richard Raustad
    //       DATE WRITTEN   October 2001
    //       MODIFIED       Raustad/Shirey Mar 2004
    //                      Kenneth Tang 2004 (Sensitivity of TotCapTempModFac & EIRTempModFac  to indoor dry bulb temp)
    //                      Feb 2005 M. J. Witte, GARD Analytics, Inc.
    //                        Add new coil type COIL:DX:MultiMode:CoolingEmpirical:

    // PURPOSE OF THIS SUBROUTINE:
    // Calculates the air-side heating performance and electrical heating energy
    // use of a direct-expansion, air-cooled heat pump unit.

    // METHODOLOGY EMPLOYED:
    // This routine simulates the performance of air-cooled DX heating equipment.
    // The routine requires the user to enter the total heating capacity
    // and COP for the unit at ARI 210/240 rating conditions (21.11C [70F] dry-bulb,
    // 15.55C [60F] wet-bulb air entering the heating coil, 8.33C [47F] dry-bulb,
    // 6.11C [43F] wet-bulb air entering the outdoor condenser. Since different
    // manufacturer's rate their equipment at different air flow rates, the supply
    // air flow rate corresponding to the rated capacities and rated COP must also
    // be entered (should be between 300 cfm/ton and 450 cfm/ton). The rated information
    // entered by the user should NOT include the thermal or electrical impacts of the
    // supply air fan, as this is addressed by another module.

    // With the rated performance data entered by the user, the model employs some of the
    // DOE-2.1E curve fits to adjust the capacity and efficiency of the unit as a function
    // of outdoor air temperatures and supply air flow rate (actual vs rated flow). The
    // model does NOT employ the exact same methodology to calculate performance as DOE-2,
    // although some of the DOE-2 curve fits are employed by this model.

    // REFERENCES:
    // Winkelmann, F.C., Birdsall, B.E., Buhl W.F., Ellington, K.L., Erdem, A.E. 1993.
    // DOE-2 Supplement Version 2.1E.  Energy and Environment Division, Lawrence Berkeley
    // Laboratory.
    // Henderson, H.I. Jr., Y.J. Huang and Danny Parker. 1999. Residential Equipment Part
    // Load Curves for Use in DOE-2.  Environmental Energy Technologies Division, Ernest
    // Orlando Lawrence Berkeley National Laboratory.

    // Using/Aliasing
    using Curve::CurveValue;

    // SUBROUTINE PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineNameFullLoad("CalcDXHeatingCoil:fullload");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 AirMassFlow;           // dry air mass flow rate through coil [kg/s]
    Real64 AirMassFlowRatio;      // Ratio of actual air mass flow to rated air mass flow
    Real64 AirVolumeFlowRate;     // Air volume flow rate across the cooling coil [m3/s]
    Real64 VolFlowperRatedTotCap; // Air volume flow rate divided by rated total cooling capacity [m3/s-W]
    Real64 TotCap;                // gross total cooling capacity at off-rated conditions [W]
    Real64 TotCapAdj;             // adjusted total cooling capacity at off-rated conditions [W]
    Real64 TotCapTempModFac;      // Total capacity modifier (function of entering drybulb, outside drybulb) depending
    // on the type of curve
    Real64 TotCapFlowModFac;    // Total capacity modifier (function of actual supply air flow vs rated flow)
    Real64 InletAirDryBulbTemp; // inlet air dry bulb temperature [C]
    Real64 InletAirWetBulbC;    // wetbulb temperature of inlet air [C]
    Real64 InletAirEnthalpy;    // inlet air enthalpy [J/kg]
    Real64 InletAirHumRat;      // inlet air humidity ratio [kg/kg]
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // REAL(r64)     :: InletAirPressure            ! inlet air pressure [Pa]
    Real64 FullLoadOutAirEnth;   // outlet full load enthalpy [J/kg]
    Real64 FullLoadOutAirHumRat; // outlet humidity ratio at full load
    Real64 FullLoadOutAirTemp;   // outlet air temperature at full load [C]
    Real64 FullLoadOutAirRH;     // outlet air relative humidity at full load
    Real64 EIRTempModFac(0.0);   // EIR modifier (function of entering drybulb, outside drybulb) depending on the
    // type of curve
    Real64 DefrostEIRTempModFac;      // EIR modifier for defrost (function of entering wetbulb, outside drybulb)
    Real64 EIRFlowModFac;             // EIR modifier (function of actual supply air flow vs rated flow)
    Real64 EIR;                       // EIR at part load and off rated conditions
    Real64 PLF;                       // Part load factor, accounts for thermal lag at compressor startup
    Real64 PLRHeating;                // PartLoadRatio in heating
    Real64 OutdoorCoilT;              // Outdoor coil temperature (C)
    Real64 OutdoorCoildw;             // Outdoor coil delta w assuming coil temp of OutdoorCoilT (kg/kg)
    Real64 FractionalDefrostTime;     // Fraction of time step system is in defrost
    Real64 HeatingCapacityMultiplier; // Multiplier for heating capacity when system is in defrost
    Real64 InputPowerMultiplier;      // Multiplier for power when system is in defrost
    Real64 LoadDueToDefrost;          // Additional load due to defrost
    Real64 CrankcaseHeatingPower;     // power due to crankcase heater
    Real64 OutdoorDryBulb;            // Outdoor dry-bulb temperature at condenser (C)
    Real64 OutdoorWetBulb;            // Outdoor wet-bulb temperature at condenser (C)
    Real64 OutdoorHumRat;             // Outdoor humidity ratio at condenser (kg/kg)
    Real64 OutdoorPressure;           // Outdoor barometric pressure at condenser (Pa)
    constexpr int Mode(1);            // Performance mode for MultiMode DX coil; Always 1 for other coil types
    Real64 AirFlowRatio;              // Ratio of compressor on airflow to average timestep airflow
    Real64 OutletAirTemp;             // Supply air temperature (average value if constant fan, full output if cycling fan)
    Real64 OutletAirHumRat;           // Supply air humidity ratio (average value if constant fan, full output if cycling fan)
    Real64 OutletAirEnthalpy;         // Supply air enthalpy (average value if constant fan, full output if cycling fan)
    Real64 CompAmbTemp(0.0);          // Ambient temperature at compressor

    if (present(OnOffAirFlowRatio)) {
        AirFlowRatio = OnOffAirFlowRatio;
    } else {
        AirFlowRatio = 1.0;
    }

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
    // Get condenser outdoor node info from DX Heating Coil
    if (thisDXCoil.CondenserInletNodeNum(1) != 0) {
        OutdoorDryBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).Temp;
        CompAmbTemp = OutdoorDryBulb;
        if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Water) {
            OutdoorHumRat = state.dataEnvrn->OutHumRat;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
            OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
            CompAmbTemp = state.dataEnvrn->OutDryBulbTemp;
        } else {
            OutdoorPressure = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).Press;
            // If node is not connected to anything, pressure = default, use weather data
            if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press) {
                OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
                OutdoorHumRat = state.dataEnvrn->OutHumRat;
                OutdoorPressure = state.dataEnvrn->OutBaroPress;
                OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
            } else {
                OutdoorHumRat = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).HumRat;
                // this should use Node%WetBulbTemp or a PSYC function, not OAWB
                OutdoorWetBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).OutAirWetBulb;
            }
            if (thisDXCoil.IsSecondaryDXCoilInZone) {
                auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
                OutdoorDryBulb = secZoneHB.ZT;
                OutdoorHumRat = secZoneHB.airHumRat;
                OutdoorWetBulb = thisDXCoil.EvapInletWetBulb;
                OutdoorPressure = state.dataEnvrn->OutBaroPress;
                CompAmbTemp = OutdoorDryBulb;
            }
        }
    } else if (thisDXCoil.IsSecondaryDXCoilInZone) {
        auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
        OutdoorDryBulb = secZoneHB.ZT;
        OutdoorHumRat = secZoneHB.airHumRat;
        OutdoorWetBulb = thisDXCoil.EvapInletWetBulb;
        OutdoorPressure = state.dataEnvrn->OutBaroPress;
        CompAmbTemp = OutdoorDryBulb;
    } else {
        OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
        OutdoorHumRat = state.dataEnvrn->OutHumRat;
        OutdoorPressure = state.dataEnvrn->OutBaroPress;
        OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
        CompAmbTemp = OutdoorDryBulb;
    }

    AirMassFlow = thisDXCoil.InletAirMassFlowRate;
    InletAirDryBulbTemp = thisDXCoil.InletAirTemp;
    InletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
    InletAirHumRat = thisDXCoil.InletAirHumRat;
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // InletAirPressure = DXCoil(DXCoilNum)%InletAirPressure
    // InletAirWetBulbC = PsyTwbFnTdbWPb(InletAirDryBulbTemp,InletAirHumRat,InletAirPressure)
    InletAirWetBulbC = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRat, OutdoorPressure);
    PLRHeating = 0.0;
    thisDXCoil.HeatingCoilRuntimeFraction = 0.0;
    // Initialize crankcase heater, operates below OAT defined in input deck for HP DX heating coil
    if (CompAmbTemp < thisDXCoil.MaxOATCrankcaseHeater) {
        CrankcaseHeatingPower = thisDXCoil.CrankcaseHeaterCapacity;
        if (thisDXCoil.CrankcaseHeaterCapacityCurveIndex > 0) {
            CrankcaseHeatingPower *= Curve::CurveValue(state, thisDXCoil.CrankcaseHeaterCapacityCurveIndex, CompAmbTemp);
        }
    } else {
        CrankcaseHeatingPower = 0.0;
    }

    if ((AirMassFlow > 0.0) && (GetCurrentScheduleValue(state, thisDXCoil.SchedPtr) > 0.0) && (PartLoadRatio > 0.0) &&
        OutdoorDryBulb > thisDXCoil.MinOATCompressor) {
        // for cycling fan, reset mass flow to full on rate
        if (fanOp == HVAC::FanOp::Cycling) AirMassFlow /= PartLoadRatio;
        if (fanOp == HVAC::FanOp::Continuous) AirMassFlow *= AirFlowRatio;
        // Check for valid air volume flow per rated total cooling capacity (200 - 600 cfm/ton)
        AirVolumeFlowRate = AirMassFlow / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat);
        //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
        //  AirVolumeFlowRate = AirMassFlow/PsyRhoAirFnPbTdbW(InletAirPressure,InletAirDryBulbTemp, InletAirHumRat)
        VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.RatedTotCap(Mode);

        if ((VolFlowperRatedTotCap < HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) ||
            (VolFlowperRatedTotCap > HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT])) {
            if (thisDXCoil.ErrIndex1 == 0) {
                ShowWarningMessage(
                    state,
                    format("{} \"{}\" - Air volume flow rate per watt of rated total heating capacity is out of range at {:.3R} m3/s/W.",
                           thisDXCoil.DXCoilType,
                           thisDXCoil.Name,
                           VolFlowperRatedTotCap));
                ShowContinueErrorTimeStamp(state, "");
                ShowContinueError(state,
                                  format("Expected range for VolumeFlowPerRatedTotalCapacity=[{:.3R}--{:.3R}]",
                                         HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                         HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]));
                ShowContinueError(state, "Possible causes include inconsistent air flow rates in system components or");
                ShowContinueError(state, "inconsistent supply air fan operation modes in coil and unitary system objects.");
            }
            ShowRecurringWarningErrorAtEnd(
                state,
                thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                    "\" - Air volume flow rate per watt of rated total heating capacity is out of range error continues...",
                thisDXCoil.ErrIndex1,
                VolFlowperRatedTotCap,
                VolFlowperRatedTotCap);
        }

        // Get total capacity modifying factor (function of temperature) for off-rated conditions
        // Model was extended to accept bi-quadratic curves. This allows sensitivity of the heating capacity
        // to the entering dry-bulb temperature as well as the outside dry-bulb temperature. User is
        // advised to use the bi-quadratic curve if sufficient manufacturer data is available.
        if (state.dataCurveManager->PerfCurve(thisDXCoil.CCapFTemp(Mode))->numDims == 2) {
            switch (thisDXCoil.HeatingPerformanceOATType) {
            case HVAC::OATType::DryBulb: {
                TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(Mode), InletAirDryBulbTemp, OutdoorDryBulb);
            } break;
            case HVAC::OATType::WetBulb: {
                TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(Mode), InletAirDryBulbTemp, OutdoorWetBulb);
            } break;
            default: {
                TotCapTempModFac = 1.0;
            } break;
            }
        } else {
            switch (thisDXCoil.HeatingPerformanceOATType) {
            case HVAC::OATType::DryBulb: {
                if (thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_Heating && thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_FluidTCtrl_Heating) {
                    TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(Mode), OutdoorDryBulb);
                } else {
                    TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(Mode), InletAirDryBulbTemp);
                }
            } break;
            case HVAC::OATType::WetBulb: {
                if (thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_Heating && thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_FluidTCtrl_Heating) {
                    TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(Mode), OutdoorWetBulb);
                } else {
                    TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(Mode), InletAirDryBulbTemp);
                }
            } break;
            default: {
                TotCapTempModFac = 1.0;
            } break;
            }
        }

        if (TotCapTempModFac < 0.0) {
            if (thisDXCoil.CAPFTErrIndex == 0) {
                ShowWarningMessage(state,
                                   format("The TotCapTempModFac curve value for DX heating coil {} ={:.2R}", thisDXCoil.Name, TotCapTempModFac));
                ShowContinueError(state,
                                  "TotCapTempModFac curve value must be > 0. TotCapTempModFac curve value has been reset to 0.0 and "
                                  "simulation is continuing.");
                ShowContinueError(state, format("Check the IO reference manual for TotCapTempModFac curve guidance [ {} ].", thisDXCoil.DXCoilType));
                ShowContinueErrorTimeStamp(state, "");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           "DX heating coil TotCapTempModFac curve value < 0 warning continues... ",
                                           thisDXCoil.CAPFTErrIndex,
                                           TotCapTempModFac,
                                           TotCapTempModFac);
            TotCapTempModFac = 0.0;
        }

        //  Get total capacity modifying factor (function of mass flow) for off-rated conditions
        AirMassFlowRatio = AirMassFlow / thisDXCoil.RatedAirMassFlowRate(Mode);
        TotCapFlowModFac = CurveValue(state, thisDXCoil.CCapFFlow(Mode), AirMassFlowRatio);

        // Calculate total heating capacity for off-rated conditions
        TotCap = thisDXCoil.RatedTotCap(Mode) * TotCapFlowModFac * TotCapTempModFac;

        // Calculating adjustment factors for defrost
        // Calculate delta w through outdoor coil by assuming a coil temp of 0.82*DBT-9.7(F) per DOE2.1E
        OutdoorCoilT = 0.82 * OutdoorDryBulb - 8.589;
        OutdoorCoildw = max(1.0e-6, (OutdoorHumRat - PsyWFnTdpPb(state, OutdoorCoilT, OutdoorPressure)));

        // Initializing defrost adjustment factors
        LoadDueToDefrost = 0.0;
        HeatingCapacityMultiplier = 1.0;
        FractionalDefrostTime = 0.0;
        InputPowerMultiplier = 1.0;

        // Check outdoor temperature to determine of defrost is active
        if (OutdoorDryBulb <= thisDXCoil.MaxOATDefrost && thisDXCoil.CondenserType(Mode) != DataHeatBalance::RefrigCondenserType::Water) {
            // Calculate defrost adjustment factors depending on defrost control type
            if (thisDXCoil.DefrostControl == StandardRatings::HPdefrostControl::Timed) {
                FractionalDefrostTime = thisDXCoil.DefrostTime;
                if (FractionalDefrostTime > 0.0) {
                    HeatingCapacityMultiplier = 0.909 - 107.33 * OutdoorCoildw;
                    InputPowerMultiplier = 0.90 - 36.45 * OutdoorCoildw;
                }
            } else { // else defrost control is on-demand
                FractionalDefrostTime = 1.0 / (1.0 + 0.01446 / OutdoorCoildw);
                HeatingCapacityMultiplier = 0.875 * (1.0 - FractionalDefrostTime);
                InputPowerMultiplier = 0.954 * (1.0 - FractionalDefrostTime);
            }

            if (FractionalDefrostTime > 0.0) {
                // Calculate defrost adjustment factors depending on defrost control strategy
                if (thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::ReverseCycle) {
                    LoadDueToDefrost = (0.01 * FractionalDefrostTime) * (7.222 - OutdoorDryBulb) * (thisDXCoil.RatedTotCap(Mode) / 1.01667);
                    DefrostEIRTempModFac = CurveValue(state, thisDXCoil.DefrostEIRFT, max(15.555, InletAirWetBulbC), max(15.555, OutdoorDryBulb));
                    thisDXCoil.DefrostPower = DefrostEIRTempModFac * (thisDXCoil.RatedTotCap(Mode) / 1.01667) * FractionalDefrostTime;
                } else { // Defrost strategy is resistive
                    thisDXCoil.DefrostPower = thisDXCoil.DefrostCapacity * FractionalDefrostTime;
                }
            } else { // Defrost is not active because (FractionalDefrostTime .EQ. 0.0)
                thisDXCoil.DefrostPower = 0.0;
            }
        }

        // Modify total heating capacity based on defrost heating capacity multiplier
        // MaxHeatCap passed from parent object VRF Condenser and is used to limit capacity of TU's to that available from condenser
        if (present(MaxHeatCap)) {
            TotCapAdj = min(MaxHeatCap, TotCap * HeatingCapacityMultiplier);
            TotCap = min(MaxHeatCap, TotCap);
        } else {
            TotCapAdj = TotCap * HeatingCapacityMultiplier;
        }

        // Calculate full load outlet conditions
        FullLoadOutAirEnth = InletAirEnthalpy + TotCapAdj / AirMassFlow;
        FullLoadOutAirHumRat = InletAirHumRat;
        FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, FullLoadOutAirHumRat);
        FullLoadOutAirRH = PsyRhFnTdbWPb(state, FullLoadOutAirTemp, FullLoadOutAirHumRat, OutdoorPressure, RoutineNameFullLoad);
        //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
        //  FullLoadOutAirRH = PsyRhFnTdbWPb(FullLoadOutAirTemp,FullLoadOutAirHumRat,InletAirPressure)
        if (FullLoadOutAirRH > 1.0) { // Limit to saturated conditions at FullLoadOutAirEnth
            FullLoadOutAirTemp = PsyTsatFnHPb(state, FullLoadOutAirEnth, OutdoorPressure);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //    FullLoadOutAirTemp = PsyTsatFnHPb(FullLoadOutAirEnth,InletAirPressure)
            FullLoadOutAirHumRat = PsyWFnTdbH(state, FullLoadOutAirTemp, FullLoadOutAirEnth);
        }

        // Calculate actual outlet conditions for the input part load ratio
        // Actual outlet conditions are "average" for time step
        if (fanOp == HVAC::FanOp::Continuous) {
            // continuous fan, cycling compressor
            OutletAirEnthalpy = ((PartLoadRatio * AirFlowRatio) * FullLoadOutAirEnth + (1.0 - (PartLoadRatio * AirFlowRatio)) * InletAirEnthalpy);
            OutletAirHumRat = (PartLoadRatio * FullLoadOutAirHumRat + (1.0 - PartLoadRatio) * InletAirHumRat);
            OutletAirTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
        } else {
            // default to cycling fan, cycling compressor
            OutletAirEnthalpy = FullLoadOutAirEnth;
            OutletAirHumRat = FullLoadOutAirHumRat;
            OutletAirTemp = FullLoadOutAirTemp;
        }
        // Calculate electricity consumed. First, get EIR modifying factors for off-rated conditions
        // Model was extended to accept bi-quadratic curves. This allows sensitivity of the EIR
        // to the entering dry-bulb temperature as well as the outside dry-bulb temperature. User is
        // advised to use the bi-quadratic curve if sufficient manufacturer data is available.
        if (thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_Heating && thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_FluidTCtrl_Heating) {
            if (state.dataCurveManager->PerfCurve(thisDXCoil.EIRFTemp(Mode))->numDims == 1) {
                EIRTempModFac = CurveValue(state, thisDXCoil.EIRFTemp(Mode), OutdoorDryBulb);
            } else {
                EIRTempModFac = CurveValue(state, thisDXCoil.EIRFTemp(Mode), InletAirDryBulbTemp, OutdoorDryBulb);
            }
            EIRFlowModFac = CurveValue(state, thisDXCoil.EIRFFlow(Mode), AirMassFlowRatio);
        } else {
            EIRTempModFac = 1.0;
            EIRFlowModFac = 1.0;
        }

        if (EIRTempModFac < 0.0) {
            if (thisDXCoil.EIRFTErrIndex == 0) {
                ShowWarningMessage(state, format("The EIRTempModFac curve value for DX heating coil {} ={:.2R}", thisDXCoil.Name, EIRTempModFac));
                ShowContinueError(
                    state, "EIRTempModFac curve value must be > 0.  EIRTempModFac curve value has been reset to 0.0 and simulation is continuing.");
                ShowContinueError(state, format("Check the IO reference manual for EIRTempModFac curve guidance [ {} ].", thisDXCoil.DXCoilType));
                ShowContinueErrorTimeStamp(state, "");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           "DX heating coil EIRTempModFac curve value < 0.0 warning continues... ",
                                           thisDXCoil.EIRFTErrIndex,
                                           EIRTempModFac,
                                           EIRTempModFac);
            EIRTempModFac = 0.0;
        }

        EIR = thisDXCoil.RatedEIR(Mode) * EIRTempModFac * EIRFlowModFac;
        // Calculate modified PartLoadRatio due to defrost (reverse-cycle defrost only)
        if (TotCapAdj > 0.0) {
            PLRHeating = min(1.0, (PartLoadRatio + (LoadDueToDefrost * PartLoadRatio) / TotCapAdj));
        } else {
            PLRHeating = 0.0;
        }
        if (thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_Heating) {
            PLF = CurveValue(state, thisDXCoil.PLFFPLR(Mode), PLRHeating); // Calculate part-load factor
        } else {
            PLF = 1.0;
        }

        if (PLF < 0.7) {
            if (thisDXCoil.PLRErrIndex == 0) {
                ShowWarningMessage(
                    state,
                    format("The PLF curve value for DX heating coil {} ={:.2R} for part-load ratio ={:.2R}", thisDXCoil.Name, PLF, PLRHeating));
                ShowContinueError(state, "PLF curve values must be >= 0.7. PLF has been reset to 0.7 and simulation is continuing.");
                ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Heating:DX:SingleSpeed].");
                ShowContinueErrorTimeStamp(state, "");
            }
            ShowRecurringWarningErrorAtEnd(state, "DX heating coil PLF curve < 0.7 warning continues... ", thisDXCoil.PLRErrIndex, PLF, PLF);
            PLF = 0.7;
        }

        thisDXCoil.HeatingCoilRuntimeFraction = (PLRHeating / PLF);
        if (thisDXCoil.HeatingCoilRuntimeFraction > 1.0 && std::abs(thisDXCoil.HeatingCoilRuntimeFraction - 1.0) > 0.001) {
            if (thisDXCoil.ErrIndex4 == 0) {
                ShowWarningMessage(state,
                                   format("The runtime fraction for DX heating coil {} exceeded 1.0. [{:.4R}].",
                                          thisDXCoil.Name,
                                          thisDXCoil.HeatingCoilRuntimeFraction));
                ShowContinueError(state, "Runtime fraction is set to 1.0 and the simulation continues...");
                ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Heating:DX:SingleSpeed].");
                ShowContinueErrorTimeStamp(state, "");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           thisDXCoil.Name + ", DX heating coil runtime fraction > 1.0 warning continues...",
                                           thisDXCoil.ErrIndex4,
                                           thisDXCoil.HeatingCoilRuntimeFraction,
                                           thisDXCoil.HeatingCoilRuntimeFraction);
            thisDXCoil.HeatingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
        } else if (thisDXCoil.HeatingCoilRuntimeFraction > 1.0) {
            thisDXCoil.HeatingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
        }
        // if cycling fan, send coil part-load fraction to on/off fan via HVACDataGlobals
        if (fanOp == HVAC::FanOp::Cycling) state.dataHVACGlobal->OnOffFanPartLoadFraction = PLF;
        thisDXCoil.ElecHeatingPower = TotCap * EIR * thisDXCoil.HeatingCoilRuntimeFraction * InputPowerMultiplier;

        // Calculate crankcase heater power using the runtime fraction for this DX heating coil only if there is no companion DX coil.
        // Else use the largest runtime fraction of this DX heating coil and the companion DX cooling coil.

        if (thisDXCoil.CompanionUpstreamDXCoil == 0) {
            thisDXCoil.CrankcaseHeaterPower = CrankcaseHeatingPower * (1.0 - thisDXCoil.HeatingCoilRuntimeFraction);
        } else {
            thisDXCoil.CrankcaseHeaterPower =
                CrankcaseHeatingPower * (1.0 - max(thisDXCoil.HeatingCoilRuntimeFraction,
                                                   state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).CoolingCoilRuntimeFraction));
        }

        AirMassFlow = thisDXCoil.InletAirMassFlowRate;
        thisDXCoil.TotalHeatingEnergyRate = AirMassFlow * (OutletAirEnthalpy - InletAirEnthalpy);
        // Adjust defrost power to correct for DOE-2 bug where defrost power is constant regardless of compressor runtime fraction
        // Defrosts happen based on compressor run time (frost buildup on outdoor coil), not total elapsed time.
        thisDXCoil.DefrostPower *= thisDXCoil.HeatingCoilRuntimeFraction;

        thisDXCoil.OutletAirTemp = OutletAirTemp;
        thisDXCoil.OutletAirHumRat = OutletAirHumRat;
        thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;
        thisDXCoil.CompressorPartLoadRatio = PartLoadRatio;

    } else {

        // DX coil is off; just pass through conditions
        thisDXCoil.OutletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
        thisDXCoil.OutletAirHumRat = thisDXCoil.InletAirHumRat;
        thisDXCoil.OutletAirTemp = thisDXCoil.InletAirTemp;

        thisDXCoil.ElecHeatingPower = 0.0;
        thisDXCoil.TotalHeatingEnergyRate = 0.0;
        thisDXCoil.DefrostPower = 0.0;

        // Calculate crankcase heater power using the runtime fraction for this DX heating coil (here DXHeatingCoilRTF=0) if
        // there is no companion DX coil, or the runtime fraction of the companion DX cooling coil (here DXCoolingCoilRTF>=0).
        if (thisDXCoil.CompanionUpstreamDXCoil == 0) {
            thisDXCoil.CrankcaseHeaterPower = CrankcaseHeatingPower;
        } else {
            thisDXCoil.CrankcaseHeaterPower =
                CrankcaseHeatingPower * (1.0 - state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).CoolingCoilRuntimeFraction);
        }
        thisDXCoil.CompressorPartLoadRatio = 0.0;

    } // end of on/off if - else

    state.dataDXCoils->DXCoilOutletTemp(DXCoilNum) = thisDXCoil.OutletAirTemp;
    state.dataDXCoils->DXCoilOutletHumRat(DXCoilNum) = thisDXCoil.OutletAirHumRat;
    state.dataDXCoils->DXCoilFanOp(DXCoilNum) = fanOp;
    state.dataDXCoils->DXCoilPartLoadRatio(DXCoilNum) = PLRHeating;
    state.dataDXCoils->DXCoilTotalHeating(DXCoilNum) = thisDXCoil.TotalHeatingEnergyRate;
    state.dataDXCoils->DXCoilHeatInletAirDBTemp(DXCoilNum) = InletAirDryBulbTemp;
    state.dataDXCoils->DXCoilHeatInletAirWBTemp(DXCoilNum) = InletAirWetBulbC;

    // set outlet node conditions
    int airOutletNode = thisDXCoil.AirOutNode;
    state.dataLoopNodes->Node(airOutletNode).Temp = thisDXCoil.OutletAirTemp;
    state.dataLoopNodes->Node(airOutletNode).HumRat = thisDXCoil.OutletAirHumRat;

    // calc secondary coil if specified
    if (thisDXCoil.IsSecondaryDXCoilInZone) {
        CalcSecondaryDXCoils(state, DXCoilNum);
    }
}

void CalcMultiSpeedDXCoil(EnergyPlusData &state,
                          int const DXCoilNum,     // the number of the DX heating coil to be simulated
                          Real64 const SpeedRatio, // = (CompressorSpeed - CompressorSpeedMin) / (CompressorSpeedMax - CompressorSpeedMin)
                          Real64 const CycRatio,   // cycling part load ratio
                          ObjexxFCL::Optional_bool_const ForceOn)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Fred Buhl
    //       DATE WRITTEN   September 2002
    //       MODIFIED       Raustad/Shirey, Feb 2004
    //                      Feb 2005 M. J. Witte, GARD Analytics, Inc.
    //                        Add new coil type COIL:DX:MultiMode:CoolingEmpirical:
    //                      April 2010, Chandan sharma, FSEC, added basin heater

    // PURPOSE OF THIS SUBROUTINE:
    // Calculates the air-side performance and electrical energy use of a direct-
    // expansion, air-cooled cooling unit with a 2 speed or variable speed compressor.

    // METHODOLOGY EMPLOYED:
    // Uses the same methodology as the single speed DX unit model (SUBROUTINE CalcDoe2DXCoil).
    // In addition it assumes that the unit performance is obtained by interpolating between
    // the performance at high speed and that at low speed. If the output needed is below
    // that produced at low speed, the compressor cycles between off and low speed.

    // Using/Aliasing
    using Curve::CurveValue;

    // SUBROUTINE ARGUMENT DEFINITIONS:
    // SpeedRatio varies between 1.0 (maximum speed) and 0.0 (minimum speed)

    // SUBROUTINE PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineNameHighSpeedOutlet("CalcMultiSpeedDXCoil:highspeedoutlet");
    static constexpr std::string_view RoutineNameLowSpeedOutlet("CalcMultiSpeedDXCoil:lowspeedoutlet");
    static constexpr std::string_view RoutineNameNewDewPointConditions("CalcMultiSpeedDXCoil:newdewpointconditions");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 AirMassFlow;         // dry air mass flow rate through coil [kg/s]
    Real64 AirMassFlowRatio;    // Ratio of max air mass flow to rated air mass flow
    Real64 InletAirWetBulbC;    // wetbulb temperature of inlet air [C]
    Real64 InletAirDryBulbTemp; // inlet air dry bulb temperature [C]
    Real64 InletAirEnthalpy;    // inlet air enthalpy [J/kg]
    Real64 InletAirHumRat;      // inlet air humidity ratio [kg/kg]
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // REAL(r64) :: InletAirPressure    ! inlet air pressure [Pa]
    Real64 OutletAirDryBulbTemp;    // outlet air dry bulb temperature [C]
    Real64 OutletAirEnthalpy;       // outlet air enthalpy [J/kg]
    Real64 OutletAirHumRat;         // outlet air humidity ratio [kg/kg]
    Real64 OutletAirDryBulbTempSat; // outlet air dry bulb temp at saturation at the outlet enthalpy [C]
    Real64 LSOutletAirDryBulbTemp;  // low speed outlet air dry bulb temperature [C]
    Real64 LSOutletAirEnthalpy;     // low speed outlet air enthalpy [J/kg]
    Real64 LSOutletAirHumRat;       // low speed outlet air humidity ratio [kg/kg]
    Real64 hDelta;                  // Change in air enthalpy across the cooling coil [J/kg]
    Real64 hTinwout;                // Enthalpy at inlet dry-bulb and outlet humidity ratio [J/kg]
    Real64 hADP;                    // Apparatus dew point enthalpy [J/kg]
    Real64 tADP;                    // Apparatus dew point temperature [C]
    Real64 wADP;                    // Apparatus dew point humidity ratio [kg/kg]
    Real64 hTinwADP;                // Enthalpy at inlet dry-bulb and wADP [J/kg]
    Real64 RatedCBFHS;              // coil bypass factor at rated conditions (high speed)
    Real64 CBFHS;                   // coil bypass factor at max flow (high speed)
    Real64 TotCapHS;                // total capacity at high speed [W]
    Real64 SHRHS;                   // sensible heat ratio at high speed
    Real64 TotCapLS;                // total capacity at low speed [W]
    Real64 SHRLS;                   // sensible heat ratio at low speed
    Real64 EIRTempModFacHS;         // EIR modifier (function of entering wetbulb, outside drybulb) (high speed)
    Real64 EIRFlowModFacHS;         // EIR modifier (function of actual supply air flow vs rated flow) (high speed)
    Real64 EIRHS;                   // EIR at off rated conditions (high speed)
    Real64 EIRTempModFacLS;         // EIR modifier (function of entering wetbulb, outside drybulb) (low speed)
    Real64 EIRLS;                   // EIR at off rated conditions (low speed)
    Real64 TotCap;                  // total capacity at current speed [W]
    Real64 SHR;                     // sensible heat ratio at current speed
    Real64 EIR;                     // EIR at current speed
    Real64 AirMassFlowNom;          // speed ratio weighted average of high and low speed air mass flow rates [kg/s]
    Real64 CBFNom;                  // coil bypass factor corresponding to AirMassFlowNom and SpeedRatio
    Real64 CBF;                     // CBFNom adjusted for actual air mass flow rate
    Real64 PLF;                     // Part load factor, accounts for thermal lag at compressor startup, used in
    // power calculation
    Real64 CondInletTemp; // Condenser inlet temperature (C). Outdoor dry-bulb temp for air-cooled condenser.
    // Outdoor Wetbulb +(1 - effectiveness)*(outdoor drybulb - outdoor wetbulb) for evap condenser.
    Real64 CondInletHumRat; // Condenser inlet humidity ratio (kg/kg). Zero for air-cooled condenser.
    // For evap condenser, its the humidity ratio of the air leaving the evap cooling pads.
    Real64 RhoAir;                // Density of air [kg/m3]
    Real64 RhoWater;              // Density of water [kg/m3]
    Real64 CondAirMassFlow;       // Condenser air mass flow rate [kg/s]
    Real64 EvapCondPumpElecPower; // Evaporative condenser electric pump power [W]
    constexpr int Mode(1);        // Performance mode for MultiMode DX coil; Always 1 for other coil types
    Real64 OutdoorDryBulb;        // Outdoor dry-bulb temperature at condenser (C)
    Real64 OutdoorWetBulb;        // Outdoor wet-bulb temperature at condenser (C)
    Real64 OutdoorHumRat;         // Outdoor humidity ratio at condenser (kg/kg)
    Real64 OutdoorPressure;       // Outdoor barometric pressure at condenser (Pa)
    bool LocalForceOn;
    Real64 AirMassFlowRatio2; // Ratio of low speed air mass flow to rated air mass flow
    Real64 CompAmbTemp(0.0);  // Ambient temperature at compressor

    if (present(ForceOn)) {
        LocalForceOn = true;
    } else {
        LocalForceOn = false;
    }

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    if (thisDXCoil.CondenserInletNodeNum(Mode) != 0) {
        OutdoorPressure = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).Press;
        // If node is not connected to anything, pressure = default, use weather data
        if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press) {
            OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
            OutdoorHumRat = state.dataEnvrn->OutHumRat;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
            OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
        } else {
            OutdoorDryBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).Temp;
            OutdoorHumRat = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).HumRat;
            OutdoorWetBulb = PsyTwbFnTdbWPb(state, OutdoorDryBulb, OutdoorHumRat, OutdoorPressure);
        }
        CompAmbTemp = OutdoorDryBulb;
        if (thisDXCoil.IsSecondaryDXCoilInZone) {
            auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
            OutdoorDryBulb = secZoneHB.ZT;
            OutdoorHumRat = secZoneHB.airHumRat;
            OutdoorWetBulb = thisDXCoil.EvapInletWetBulb;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
            CompAmbTemp = OutdoorDryBulb;
        }
    } else if (thisDXCoil.IsSecondaryDXCoilInZone) {
        auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
        OutdoorDryBulb = secZoneHB.ZT;
        OutdoorHumRat = secZoneHB.airHumRat;
        OutdoorWetBulb = thisDXCoil.EvapInletWetBulb;
        OutdoorPressure = state.dataEnvrn->OutBaroPress;
        CompAmbTemp = OutdoorDryBulb;
    } else {
        OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
        OutdoorHumRat = state.dataEnvrn->OutHumRat;
        OutdoorPressure = state.dataEnvrn->OutBaroPress;
        OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
        CompAmbTemp = OutdoorDryBulb;
    }

    AirMassFlow = thisDXCoil.InletAirMassFlowRate;
    AirMassFlowRatio = thisDXCoil.InletAirMassFlowRateMax / thisDXCoil.RatedAirMassFlowRate(Mode);
    thisDXCoil.CoolingCoilRuntimeFraction = 0.0;
    InletAirDryBulbTemp = thisDXCoil.InletAirTemp;
    InletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
    InletAirHumRat = thisDXCoil.InletAirHumRat;
    AirMassFlowRatio2 = 1.0; // DXCoil(DXCoilNum)%RatedAirMassFlowRate2 / DXCoil(DXCoilNum)%RatedAirMassFlowRate(Mode)
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // InletAirPressure = DXCoil(DXCoilNum)%InletAirPressure
    // InletAirWetBulbC = PsyTwbFnTdbWPb(InletAirDryBulbTemp,InletAirHumRat,InletAirPressure)
    InletAirWetBulbC = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRat, OutdoorPressure);
    if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Air) {
        CondInletTemp = OutdoorDryBulb; // Outdoor dry-bulb temp
    } else if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Evap) {
        // Outdoor wet-bulb temp from DataEnvironment + (1.0-EvapCondEffectiveness) * (drybulb - wetbulb)
        CondInletTemp = OutdoorWetBulb + (OutdoorDryBulb - OutdoorWetBulb) * (1.0 - thisDXCoil.EvapCondEffect(Mode));
        CondInletHumRat = PsyWFnTdbTwbPb(state, CondInletTemp, OutdoorWetBulb, OutdoorPressure);
    }

    if ((AirMassFlow > 0.0 && CompAmbTemp >= thisDXCoil.MinOATCompressor) &&
        ((GetCurrentScheduleValue(state, thisDXCoil.SchedPtr) > 0.0) || (LocalForceOn)) && (SpeedRatio > 0.0 || CycRatio > 0.0)) {

        RhoAir = PsyRhoAirFnPbTdbW(state, OutdoorPressure, OutdoorDryBulb, OutdoorHumRat);
        if (SpeedRatio > 0.0) {
            // Adjust high speed coil bypass factor for actual maximum air flow rate.
            RatedCBFHS = thisDXCoil.RatedCBF(Mode);
            CBFHS = AdjustCBF(RatedCBFHS, thisDXCoil.RatedAirMassFlowRate(Mode), thisDXCoil.InletAirMassFlowRateMax);
            // get high speed total capacity and SHR at current conditions
            CalcTotCapSHR(state,
                          InletAirDryBulbTemp,
                          InletAirHumRat,
                          InletAirEnthalpy,
                          InletAirWetBulbC,
                          AirMassFlowRatio,
                          thisDXCoil.InletAirMassFlowRateMax,
                          thisDXCoil.RatedTotCap(Mode),
                          CBFHS,
                          thisDXCoil.CCapFTemp(Mode),
                          thisDXCoil.CCapFFlow(Mode),
                          TotCapHS,
                          SHRHS,
                          CondInletTemp,
                          OutdoorPressure,
                          thisDXCoil.capModFacTotal);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //                       CondInletTemp, Node(DXCoil(DXCoilNum)%AirInNode)%Press)
            // get the high speed SHR from user specified SHR modifier curves
            if (thisDXCoil.UserSHRCurveExists) {
                SHRHS = CalcSHRUserDefinedCurves(state,
                                                 InletAirDryBulbTemp,
                                                 InletAirWetBulbC,
                                                 AirMassFlowRatio,
                                                 thisDXCoil.SHRFTemp(Mode),
                                                 thisDXCoil.SHRFFlow(Mode),
                                                 thisDXCoil.RatedSHR(Mode));
            }
            // get low speed total capacity and SHR at current conditions
            CalcTotCapSHR(state,
                          InletAirDryBulbTemp,
                          InletAirHumRat,
                          InletAirEnthalpy,
                          InletAirWetBulbC,
                          1.0,
                          thisDXCoil.RatedAirMassFlowRate2,
                          thisDXCoil.RatedTotCap2,
                          thisDXCoil.RatedCBF2,
                          thisDXCoil.CCapFTemp2,
                          thisDXCoil.CCapFFlow(Mode),
                          TotCapLS,
                          SHRLS,
                          CondInletTemp,
                          OutdoorPressure,
                          thisDXCoil.capModFacTotal);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //                       Node(DXCoil(DXCoilNum)%AirInNode)%Press)
            // get the low speed SHR from user specified SHR modifier curves
            if (thisDXCoil.UserSHRCurveExists) {
                SHRLS = CalcSHRUserDefinedCurves(state,
                                                 InletAirDryBulbTemp,
                                                 InletAirWetBulbC,
                                                 AirMassFlowRatio2,
                                                 thisDXCoil.SHRFTemp2,
                                                 thisDXCoil.SHRFFlow2,
                                                 thisDXCoil.RatedSHR2);
            }
            // get high speed EIR at current conditions
            EIRTempModFacHS = CurveValue(state, thisDXCoil.EIRFTemp(Mode), InletAirWetBulbC, CondInletTemp);
            EIRFlowModFacHS = CurveValue(state, thisDXCoil.EIRFFlow(Mode), AirMassFlowRatio);
            EIRHS = thisDXCoil.RatedEIR(Mode) * EIRFlowModFacHS * EIRTempModFacHS;
            // get low speed EIR at current conditions
            //    EIRTempModFacLS = CurveValue(state, DXCoil(DXCoilNum)%EIRFTemp(Mode),InletAirWetBulbC,CondInletTemp)
            //    CR7307 changed EIRTempModFacLS calculation to that shown below.
            EIRTempModFacLS = CurveValue(state, thisDXCoil.EIRFTemp2, InletAirWetBulbC, CondInletTemp);
            EIRLS = thisDXCoil.RatedEIR2 * EIRTempModFacLS;

            // get current total capacity, SHR, EIR
            if (SpeedRatio >= 1.0) {
                TotCap = TotCapHS;
                SHR = SHRHS;
                EIR = EIRHS;
                CBFNom = CBFHS;
                AirMassFlowNom = thisDXCoil.InletAirMassFlowRateMax;
                CondAirMassFlow = RhoAir * thisDXCoil.EvapCondAirFlow(Mode);
                EvapCondPumpElecPower = thisDXCoil.EvapCondPumpElecNomPower(Mode);
            } else {
                TotCap = SpeedRatio * TotCapHS + (1.0 - SpeedRatio) * TotCapLS;
                EIR = SpeedRatio * EIRHS + (1.0 - SpeedRatio) * EIRLS;
                CBFNom = SpeedRatio * CBFHS + (1.0 - SpeedRatio) * thisDXCoil.RatedCBF2;
                AirMassFlowNom = SpeedRatio * thisDXCoil.InletAirMassFlowRateMax + (1.0 - SpeedRatio) * thisDXCoil.RatedAirMassFlowRate2;
                CondAirMassFlow = RhoAir * (SpeedRatio * thisDXCoil.EvapCondAirFlow(Mode) + (1.0 - SpeedRatio) * thisDXCoil.EvapCondAirFlow2);
                EvapCondPumpElecPower =
                    SpeedRatio * thisDXCoil.EvapCondPumpElecNomPower(Mode) + (1.0 - SpeedRatio) * thisDXCoil.EvapCondPumpElecNomPower2;
            }
            hDelta = TotCap / AirMassFlow;
            if (thisDXCoil.UserSHRCurveExists) {
                if (SpeedRatio >= 1.0) {
                    SHR = SHRHS;
                } else {
                    SHR = min(SpeedRatio * SHRHS + (1.0 - SpeedRatio) * SHRLS, 1.0);
                }
                OutletAirEnthalpy = InletAirEnthalpy - hDelta;
                if (SHR < 1.0) {
                    hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                    OutletAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
                    if (OutletAirHumRat <= 0.0) {
                        OutletAirHumRat = min(DryCoilOutletHumRatioMin, InletAirHumRat);
                    }
                } else {
                    SHR = 1.0;
                    OutletAirHumRat = InletAirHumRat;
                }
                OutletAirDryBulbTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
                OutletAirDryBulbTempSat = PsyTdpFnWPb(state, OutletAirHumRat, OutdoorPressure, RoutineNameHighSpeedOutlet);
                if (OutletAirDryBulbTempSat > OutletAirDryBulbTemp) {
                    OutletAirDryBulbTemp = OutletAirDryBulbTempSat;
                    OutletAirHumRat = PsyWFnTdbH(state, OutletAirDryBulbTemp, OutletAirEnthalpy, RoutineNameHighSpeedOutlet);
                }

            } else {
                // Adjust CBF for off-nominal flow
                CBF = AdjustCBF(CBFNom, AirMassFlowNom, AirMassFlow);
                // Calculate new apparatus dew point conditions
                hADP = InletAirEnthalpy - hDelta / (1.0 - CBF);
                tADP = PsyTsatFnHPb(state, hADP, OutdoorPressure);
                //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
                //    tADP = PsyTsatFnHPb(hADP,InletAirPressure)
                wADP = PsyWFnTdbH(state, tADP, hADP);
                hTinwADP = PsyHFnTdbW(InletAirDryBulbTemp, wADP);
                // get corresponding SHR
                if ((InletAirEnthalpy - hADP) > 1.e-10) {
                    SHR = min((hTinwADP - hADP) / (InletAirEnthalpy - hADP), 1.0);
                } else {
                    SHR = 1.0;
                }

                // cr8918    SHR = MIN((hTinwADP-hADP)/(InletAirEnthalpy-hADP),1.0d0)
                OutletAirEnthalpy = InletAirEnthalpy - hDelta;
                // get outlet conditions
                hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                OutletAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);

                OutletAirDryBulbTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
                OutletAirDryBulbTempSat = PsyTsatFnHPb(state, OutletAirEnthalpy, OutdoorPressure);
                if (OutletAirDryBulbTemp < OutletAirDryBulbTempSat) { // Limit to saturated conditions at OutletAirEnthalpy
                    OutletAirDryBulbTemp = OutletAirDryBulbTempSat;
                    OutletAirHumRat = PsyWFnTdbH(state, OutletAirDryBulbTemp, OutletAirEnthalpy);
                }
            }
            // Coil total/sensible/latent cooling rates and electrical power
            CalcComponentSensibleLatentOutput(AirMassFlow,
                                              InletAirDryBulbTemp,
                                              InletAirHumRat,
                                              OutletAirDryBulbTemp,
                                              OutletAirHumRat,
                                              thisDXCoil.SensCoolingEnergyRate,
                                              thisDXCoil.LatCoolingEnergyRate,
                                              thisDXCoil.TotalCoolingEnergyRate);
            thisDXCoil.ElecCoolingPower = TotCap * EIR;
            //   Calculation for heat reclaim needs to be corrected to use compressor power (not including condenser fan power)
            state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = thisDXCoil.TotalCoolingEnergyRate + thisDXCoil.ElecCoolingPower;
            thisDXCoil.PartLoadRatio = 1.0;
            thisDXCoil.CoolingCoilRuntimeFraction = 1.0;

            thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;
            thisDXCoil.OutletAirHumRat = OutletAirHumRat;
            thisDXCoil.OutletAirTemp = OutletAirDryBulbTemp;

        } else if (CycRatio > 0.0) {

            if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Evap) {
                // Outdoor wet-bulb temp from DataEnvironment + (1.0-EvapCondEffectiveness) * (drybulb - wetbulb)
                CondInletTemp = OutdoorWetBulb + (OutdoorDryBulb - OutdoorWetBulb) * (1.0 - thisDXCoil.EvapCondEffect2);
                CondInletHumRat = PsyWFnTdbTwbPb(state, CondInletTemp, OutdoorWetBulb, OutdoorPressure);
            }

            // Adjust low speed coil bypass factor for actual flow rate.
            // CBF = AdjustCBF(DXCoil(DXCoilNum)%RatedCBF2,DXCoil(DXCoilNum)%RatedAirMassFlowRate2,AirMassFlow)
            // get low speed total capacity and SHR at current conditions
            CalcTotCapSHR(state,
                          InletAirDryBulbTemp,
                          InletAirHumRat,
                          InletAirEnthalpy,
                          InletAirWetBulbC,
                          1.0,
                          thisDXCoil.RatedAirMassFlowRate2,
                          thisDXCoil.RatedTotCap2,
                          thisDXCoil.RatedCBF2,
                          thisDXCoil.CCapFTemp2,
                          thisDXCoil.CCapFFlow(Mode),
                          TotCapLS,
                          SHRLS,
                          CondInletTemp,
                          OutdoorPressure,
                          thisDXCoil.capModFacTotal);
            // get the low speed SHR from user specified SHR modifier curves
            if (thisDXCoil.UserSHRCurveExists) {
                SHRLS = CalcSHRUserDefinedCurves(
                    state, InletAirDryBulbTemp, InletAirWetBulbC, 1.0, thisDXCoil.SHRFTemp2, thisDXCoil.SHRFFlow2, thisDXCoil.RatedSHR2);
            }
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //                       Node(DXCoil(DXCoilNum)%AirInNode)%Press)
            hDelta = TotCapLS / AirMassFlow;
            if (thisDXCoil.UserSHRCurveExists) {
                SHR = SHRLS;
                LSOutletAirEnthalpy = InletAirEnthalpy - hDelta;
                if (SHR < 1.0) {
                    hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                    LSOutletAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
                    if (LSOutletAirHumRat <= 0.0) {
                        LSOutletAirHumRat = min(DryCoilOutletHumRatioMin, InletAirHumRat);
                    }
                } else {
                    SHR = 1.0;
                    LSOutletAirHumRat = InletAirHumRat;
                }
                LSOutletAirDryBulbTemp = PsyTdbFnHW(LSOutletAirEnthalpy, LSOutletAirHumRat);
                OutletAirDryBulbTempSat = PsyTdpFnWPb(state, LSOutletAirHumRat, OutdoorPressure, RoutineNameLowSpeedOutlet);
                if (OutletAirDryBulbTempSat > LSOutletAirDryBulbTemp) {
                    LSOutletAirDryBulbTemp = OutletAirDryBulbTempSat;
                    LSOutletAirHumRat = PsyWFnTdbH(state, LSOutletAirDryBulbTemp, LSOutletAirEnthalpy, RoutineNameLowSpeedOutlet);
                }

            } else {
                // Adjust CBF for off-nominal flow
                CBF = AdjustCBF(thisDXCoil.RatedCBF2, thisDXCoil.RatedAirMassFlowRate2, AirMassFlow);
                // Calculate new apparatus dew point conditions
                hADP = InletAirEnthalpy - hDelta / (1.0 - CBF);
                tADP = PsyTsatFnHPb(state, hADP, OutdoorPressure, RoutineNameNewDewPointConditions);
                //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
                //    tADP = PsyTsatFnHPb(hADP,InletAirPressure)
                wADP = PsyWFnTdbH(state, tADP, hADP, RoutineNameNewDewPointConditions);
                hTinwADP = PsyHFnTdbW(InletAirDryBulbTemp, wADP);
                // get corresponding SHR
                if ((InletAirEnthalpy - hADP) > 1.e-10) {
                    SHR = min((hTinwADP - hADP) / (InletAirEnthalpy - hADP), 1.0);
                } else {
                    SHR = 1.0;
                }
                // cr8918    SHR = MIN((hTinwADP-hADP)/(InletAirEnthalpy-hADP),1.0d0)
                // get low speed outlet conditions
                LSOutletAirEnthalpy = InletAirEnthalpy - hDelta;
                hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                LSOutletAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout);
                LSOutletAirDryBulbTemp = PsyTdbFnHW(LSOutletAirEnthalpy, LSOutletAirHumRat);
                OutletAirDryBulbTempSat = PsyTsatFnHPb(state, LSOutletAirEnthalpy, OutdoorPressure, RoutineNameLowSpeedOutlet);
                if (LSOutletAirDryBulbTemp < OutletAirDryBulbTempSat) { // Limit to saturated conditions at OutletAirEnthalpy
                    LSOutletAirDryBulbTemp = OutletAirDryBulbTempSat;
                    LSOutletAirHumRat = PsyWFnTdbH(state, LSOutletAirDryBulbTemp, LSOutletAirEnthalpy, RoutineNameLowSpeedOutlet);
                }
            }
            // outlet conditions are average of inlet and low speed weighted by CycRatio
            OutletAirEnthalpy = CycRatio * LSOutletAirEnthalpy + (1.0 - CycRatio) * InletAirEnthalpy;
            OutletAirHumRat = CycRatio * LSOutletAirHumRat + (1.0 - CycRatio) * InletAirHumRat;
            OutletAirDryBulbTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
            // get low speed EIR at current conditions
            //    EIRTempModFacLS = CurveValue(state, DXCoil(DXCoilNum)%EIRFTemp(Mode),InletAirWetBulbC,CondInletTemp)
            //    CR7307 changed EIRTempModFacLS calculation to that shown below.
            EIRTempModFacLS = CurveValue(state, thisDXCoil.EIRFTemp2, InletAirWetBulbC, CondInletTemp);
            EIRLS = thisDXCoil.RatedEIR2 * EIRTempModFacLS;
            // get the part load factor that will account for cycling losses
            PLF = CurveValue(state, thisDXCoil.PLFFPLR(Mode), CycRatio);
            if (PLF < 0.7) {
                PLF = 0.7;
            }
            // calculate the run time fraction
            thisDXCoil.CoolingCoilRuntimeFraction = CycRatio / PLF;
            thisDXCoil.PartLoadRatio = CycRatio;
            if (thisDXCoil.CoolingCoilRuntimeFraction > 1.0) {
                thisDXCoil.CoolingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
            }
            // get the electrical power consumption
            thisDXCoil.ElecCoolingPower = TotCapLS * EIRLS * thisDXCoil.CoolingCoilRuntimeFraction;

            // Coil total/sensible/latent cooling rates and electrical power
            CalcComponentSensibleLatentOutput(AirMassFlow,
                                              InletAirDryBulbTemp,
                                              InletAirHumRat,
                                              OutletAirDryBulbTemp,
                                              OutletAirHumRat,
                                              thisDXCoil.SensCoolingEnergyRate,
                                              thisDXCoil.LatCoolingEnergyRate,
                                              thisDXCoil.TotalCoolingEnergyRate);
            state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = thisDXCoil.TotalCoolingEnergyRate + thisDXCoil.ElecCoolingPower;
            thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;
            thisDXCoil.OutletAirHumRat = OutletAirHumRat;
            thisDXCoil.OutletAirTemp = OutletAirDryBulbTemp;
            CondAirMassFlow = RhoAir * thisDXCoil.EvapCondAirFlow2 * thisDXCoil.CoolingCoilRuntimeFraction;
            EvapCondPumpElecPower = thisDXCoil.EvapCondPumpElecNomPower2 * thisDXCoil.CoolingCoilRuntimeFraction;
        }

        if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Evap) {
            //******************
            //             WATER CONSUMPTION IN m3 OF WATER FOR DIRECT
            //             H2O [m3/s] = Delta W[kgWater/kgDryAir]*Mass Flow Air[kgDryAir/s]
            //                                /RhoWater [kgWater/m3]
            //******************
            RhoWater = RhoH2O(OutdoorDryBulb);
            thisDXCoil.EvapWaterConsumpRate = (CondInletHumRat - OutdoorHumRat) * CondAirMassFlow / RhoWater;
            thisDXCoil.EvapCondPumpElecPower = EvapCondPumpElecPower;
            // set water system demand request (if needed)
            if (thisDXCoil.EvapWaterSupplyMode == EvapWaterSupply::FromTank) {

                state.dataWaterData->WaterStorage(thisDXCoil.EvapWaterSupTankID).VdotRequestDemand(thisDXCoil.EvapWaterTankDemandARRID) =
                    thisDXCoil.EvapWaterConsumpRate;
            }

            // Calculate basin heater power
            CalcBasinHeaterPower(state,
                                 thisDXCoil.BasinHeaterPowerFTempDiff,
                                 thisDXCoil.BasinHeaterSchedulePtr,
                                 thisDXCoil.BasinHeaterSetPointTemp,
                                 thisDXCoil.BasinHeaterPower);
            thisDXCoil.BasinHeaterPower *= (1.0 - thisDXCoil.CoolingCoilRuntimeFraction);
        }

    } else {

        // DX coil is off; just pass through conditions
        thisDXCoil.OutletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
        thisDXCoil.OutletAirHumRat = thisDXCoil.InletAirHumRat;
        thisDXCoil.OutletAirTemp = thisDXCoil.InletAirTemp;

        thisDXCoil.ElecCoolingPower = 0.0;
        thisDXCoil.TotalCoolingEnergyRate = 0.0;
        thisDXCoil.SensCoolingEnergyRate = 0.0;
        thisDXCoil.LatCoolingEnergyRate = 0.0;
        thisDXCoil.EvapCondPumpElecPower = 0.0;
        thisDXCoil.EvapWaterConsumpRate = 0.0;

        // Calculate basin heater power
        if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Evap) {
            CalcBasinHeaterPower(state,
                                 thisDXCoil.BasinHeaterPowerFTempDiff,
                                 thisDXCoil.BasinHeaterSchedulePtr,
                                 thisDXCoil.BasinHeaterSetPointTemp,
                                 thisDXCoil.BasinHeaterPower);
        }
    }

    state.dataDXCoils->DXCoilOutletTemp(DXCoilNum) = thisDXCoil.OutletAirTemp;
    state.dataDXCoils->DXCoilOutletHumRat(DXCoilNum) = thisDXCoil.OutletAirHumRat;
    thisDXCoil.CondInletTemp = CondInletTemp; // Save condenser inlet temp in the data structure

    // set outlet node conditions
    int airOutletNode = thisDXCoil.AirOutNode;
    state.dataLoopNodes->Node(airOutletNode).Temp = thisDXCoil.OutletAirTemp;
    state.dataLoopNodes->Node(airOutletNode).HumRat = thisDXCoil.OutletAirHumRat;

    // calc secondary coil if specified
    if (thisDXCoil.IsSecondaryDXCoilInZone) {
        CalcSecondaryDXCoils(state, DXCoilNum);
    }
}

void CalcBasinHeaterPowerForMultiModeDXCoil(EnergyPlusData &state,
                                            int const DXCoilNum,             // Index of coil being simulated
                                            HVAC::CoilMode const DehumidMode // Dehumidification mode (0=normal, 1=enhanced)
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Chandan Sharma, FSEC
    //       DATE WRITTEN   May 2010

    // PURPOSE OF THIS SUBROUTINE:
    // To calculate the basin heater power for multi mode DX cooling coil

    // METHODOLOGY EMPLOYED:
    // The methodology employed is as follows:
    // 1) If the number of capacity stages is equal to 1 and the CondenserType for stage 1
    //    is EvapCooled, then the basin heater power is calculated for (1-runtimefractionstage1) of DX coil
    // 2) If the number of capacity stages is greater than 1, then
    //    a) If the CondenserType for stage 1 is EvapCooled, then the basin heater power is calculated for
    //       (1-runtimefractionofstage1) of DX coil
    //    b) Elseif the CondenserType for stage 2 is EvapCooled, then the basin heater power is calculated for
    //       (1-runtimefractionofstage2) of DX coil

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int PerfMode; // Performance mode for MultiMode DX coil; Always 1 for other coil types
    // 1-2=normal mode: 1=stage 1 only, 2=stage 1&2
    // 3-4=enhanced dehumidification mode: 3=stage 1 only, 4=stage 1&2

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    if (thisDXCoil.NumCapacityStages == 1) {
        thisDXCoil.BasinHeaterPower *= (1.0 - thisDXCoil.CoolingCoilRuntimeFraction);
    } else {
        PerfMode = (int)DehumidMode * 2 + 1;
        if (thisDXCoil.CondenserType(PerfMode) == DataHeatBalance::RefrigCondenserType::Evap) {
            thisDXCoil.BasinHeaterPower *= (1.0 - thisDXCoil.CoolingCoilRuntimeFraction);
        } else if (thisDXCoil.CondenserType(PerfMode + 1) == DataHeatBalance::RefrigCondenserType::Evap) {
            CalcBasinHeaterPower(state,
                                 thisDXCoil.BasinHeaterPowerFTempDiff,
                                 thisDXCoil.BasinHeaterSchedulePtr,
                                 thisDXCoil.BasinHeaterSetPointTemp,
                                 thisDXCoil.BasinHeaterPower);
            thisDXCoil.BasinHeaterPower *= (1.0 - thisDXCoil.CoolingCoilStg2RuntimeFrac);
        }
    }
}

Real64 AdjustCBF(Real64 const CBFNom,             // nominal coil bypass factor
                 Real64 const AirMassFlowRateNom, // nominal air mass flow rate [kg/s]
                 Real64 const AirMassFlowRate     // actual air mass flow rate [kg/s]
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         Fred Buhl using Don Shirey's code
    //       DATE WRITTEN   September 2002

    // PURPOSE OF THIS FUNCTION:
    //    Adjust coil bypass factor for actual air flow rate.

    // METHODOLOGY EMPLOYED:
    // Uses relation CBF = exp(-NTU) whereNTU = A0/(m*cp). Relationship models the cooling coil
    // as a heat exchanger with Cmin/Cmax = 0.

    // Return value
    Real64 CBFAdj; // the result - the adjusted coil bypass factor

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    Real64 A0;    // intermediate variable
    Real64 ADiff; // intermediate variable

    if (CBFNom > 0.0) {
        A0 = -std::log(CBFNom) * AirMassFlowRateNom;
    } else {
        A0 = 0.0;
    }
    ADiff = -A0 / AirMassFlowRate;
    if (ADiff >= DataPrecisionGlobals::EXP_LowerLimit) {
        CBFAdj = std::exp(ADiff);
    } else {
        CBFAdj = 1.0e-6;
    }

    return CBFAdj;
}

Real64 CalcCBF(EnergyPlusData &state,
               std::string const &UnitType,
               std::string const &UnitName,
               Real64 const InletAirTemp,   // inlet air temperature [C]
               Real64 const InletAirHumRat, // inlet air humidity ratio [kg water / kg dry air]
               Real64 const TotCap,         // total cooling  capacity [Watts]
               Real64 const AirVolFlowRate, // the air volume flow rate at the given capacity [m3/s]
               Real64 const SHR,            // sensible heat ratio at the given capacity and flow rate
               bool const PrintFlag         // flag used to print warnings if desired
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         Fred Buhl using Don Shirey's code
    //       DATE WRITTEN   September 2002

    // PURPOSE OF THIS FUNCTION:
    // Calculate the coil bypass factor for a coil given the total capacity at the entering conditions,
    // air mass flow rate at the entering conditions, and the sensible heat ratio (SHR) at the
    // entering conditions. Standard barometric pressure is used for this model parameter.

    // METHODOLOGY EMPLOYED:
    // calculate SlopeRated (deltahumrat/deltaT) using rated unit information provided by
    // user. Then hunt along saturation curve of psychrometric chart until the slope of the line
    // between the saturation point and rated inlet air humidity ratio and T is the same as SlopeRated.
    // When the slopes are equal, then we have located the apparatus dewpoint of the coil at rated
    // conditions. From this information, coil bypass factor is calculated.

    // Using/Aliasing

    // Return value
    Real64 CBF(0.0); // the result - the coil bypass factor

    // FUNCTION PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineName("CalcCBF");
    constexpr Real64 SmallDifferenceTest(0.00000001);

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    Real64 InletAirEnthalpy;                // Enthalpy of inlet air to evaporator at given conditions [J/kg]
    Real64 DeltaH(0.0);                     // Enthalpy drop across evaporator at given conditions [J/kg]
    Real64 DeltaT(0.0);                     // Temperature drop across evaporator at given conditions [C]
    Real64 DeltaHumRat(0.0);                // Humidity ratio drop across evaporator at given conditions [kg/kg]
    Real64 OutletAirTemp(InletAirTemp);     // Outlet dry-bulb temperature from evaporator at given conditions [C]
    Real64 OutletAirTempSat(InletAirTemp);  // Saturation dry-bulb temperature from evaporator at outlet air enthalpy [C]
    Real64 OutletAirEnthalpy;               // Enthalpy of outlet air at given conditions [J/kg]
    Real64 OutletAirHumRat(InletAirHumRat); // Outlet humidity ratio from evaporator at given conditions [kg/kg]
    Real64 OutletAirRH;                     // relative humidity of the outlet air
    Real64 Error;                           // Error term used in given coil bypass factor (CBF) calculations
    Real64 ErrorLast;                       // Error term, from previous iteration
    int Iter;                               // Iteration loop counter in CBF calculations
    int IterMax(50);                        // Maximum number of iterations in CBF calculations
    Real64 ADPTemp;                         // Apparatus dewpoint temperature used in CBF calculations [C]
    Real64 ADPHumRat;                       // Apparatus dewpoint humidity used in CBF calculations [kg/kg]
    Real64 ADPEnthalpy;                     // Air enthalpy at apparatus dew point [J/kg]
    Real64 DeltaADPTemp;                    // Change in Apparatus Dew Point used in CBF calculations [C]
    Real64 SlopeAtConds(0.0);               // Slope (DeltaHumRat/DeltaT) at given conditions
    Real64 Slope(0.0);                      // Calculated Slope used while hunting for Tadp
    Real64 Tolerance;                       // Convergence tolerance for CBF calculations
    Real64 HTinHumRatOut;                   // Air enthalpy at inlet air temp and outlet air humidity ratio [J/kg]
    Real64 AirMassFlowRate;                 // the standard air mass flow rate at the given capacity [kg/s]
    Real64 adjustedSHR;                     // SHR calculated using adjusted outlet air properties []
    bool CBFErrors(false);                  // Set to true if errors in CBF calculation, fatal at end of routine

    if (AirVolFlowRate <= 0.0 || TotCap <= 0.0) { // Coil not running or has no capacity, don't calculate CBF
        return CBF;
    }

    AirMassFlowRate = AirVolFlowRate * PsyRhoAirFnPbTdbW(state, DataEnvironment::StdPressureSeaLevel, InletAirTemp, InletAirHumRat, RoutineName);
    DeltaH = TotCap / AirMassFlowRate;
    InletAirEnthalpy = PsyHFnTdbW(InletAirTemp, InletAirHumRat);
    HTinHumRatOut = InletAirEnthalpy - (1.0 - SHR) * DeltaH;
    OutletAirHumRat = PsyWFnTdbH(state, InletAirTemp, HTinHumRatOut);
    DeltaHumRat = InletAirHumRat - OutletAirHumRat;
    OutletAirEnthalpy = InletAirEnthalpy - DeltaH;
    OutletAirTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    //  Pressure will have to be pass into this subroutine to fix this one
    OutletAirRH = PsyRhFnTdbWPb(state, OutletAirTemp, OutletAirHumRat, DataEnvironment::StdPressureSeaLevel, RoutineName);
    if (OutletAirRH >= 1.0 && PrintFlag) {
        ShowWarningError(state, format("For object = {}, name = \"{}\"", UnitType, UnitName));
        ShowContinueError(state, "Calculated outlet air relative humidity greater than 1. The combination of");
        ShowContinueError(state, "rated air volume flow rate, total cooling capacity and sensible heat ratio yields coil exiting");
        ShowContinueError(state, "air conditions above the saturation curve. Possible fixes are to reduce the rated total cooling");
        ShowContinueError(state, "capacity, increase the rated air volume flow rate, or reduce the rated sensible heat ratio for this coil.");
        ShowContinueError(state, "If autosizing, it is recommended that all three of these values be autosized.");
        ShowContinueError(state, "...Inputs used for calculating cooling coil bypass factor.");
        ShowContinueError(state, format("...Inlet Air Temperature     = {:.2R} C", InletAirTemp));
        ShowContinueError(state, format("...Outlet Air Temperature    = {:.2R} C", OutletAirTemp));
        ShowContinueError(state, format("...Inlet Air Humidity Ratio  = {:.6R} kgWater/kgDryAir", InletAirHumRat));
        ShowContinueError(state, format("...Outlet Air Humidity Ratio = {:.6R} kgWater/kgDryAir", OutletAirHumRat));
        ShowContinueError(state, format("...Total Cooling Capacity used in calculation = {:.2R} W", TotCap));
        ShowContinueError(state, format("...Air Mass Flow Rate used in calculation     = {:.6R} kg/s", AirMassFlowRate));
        ShowContinueError(state, format("...Air Volume Flow Rate used in calculation   = {:.6R} m3/s", AirVolFlowRate));
        if (TotCap > 0.0) {
            if (((HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT] - AirVolFlowRate / TotCap) > SmallDifferenceTest) ||
                ((AirVolFlowRate / TotCap - HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) > SmallDifferenceTest)) {
                ShowContinueError(state,
                                  format("...Air Volume Flow Rate per Watt of Rated Cooling Capacity is also out of bounds at = {:.7R} m3/s/W",
                                         AirVolFlowRate / TotCap));
            }
        }
        ShowContinueErrorTimeStamp(state, "");
        OutletAirTempSat = PsyTsatFnHPb(state, OutletAirEnthalpy, DataEnvironment::StdPressureSeaLevel, RoutineName);
        if (OutletAirTemp < OutletAirTempSat) { // Limit to saturated conditions at OutletAirEnthalpy
            OutletAirTemp = OutletAirTempSat + 0.005;
            OutletAirHumRat = PsyWFnTdbH(state, OutletAirTemp, OutletAirEnthalpy, RoutineName);
            DeltaHumRat = InletAirHumRat - OutletAirHumRat;
            HTinHumRatOut = PsyHFnTdbW(InletAirTemp, OutletAirHumRat);
            adjustedSHR = (HTinHumRatOut - OutletAirEnthalpy) / DeltaH;
            ShowContinueError(state, "CalcCBF: SHR adjusted to achieve valid outlet air properties and the simulation continues.");
            ShowContinueError(state, format("CalcCBF: initial SHR = {:.5R}", SHR));
            ShowContinueError(state, format("CalcCBF: adjusted SHR = {:.5R}", adjustedSHR));
        }
    }
    DeltaT = InletAirTemp - OutletAirTemp;
    if (DeltaT <= 0.0) {
        ShowSevereError(state, format("For object = {}, name = \"{}\"", UnitType, UnitName));
        ShowContinueError(state, "Calculated coil delta T is less than or equal to 0. The combination of");
        ShowContinueError(state, "rated air volume flow rate, total cooling capacity and sensible heat ratio yields coil exiting");
        ShowContinueError(state, "air conditions that are not reasonable. Possible fixes are to adjust the rated total cooling");
        ShowContinueError(state, "capacity, rated air volume flow rate, or rated sensible heat ratio for this coil.");
        ShowContinueError(state, "If autosizing, it is recommended that all three of these values be autosized.");
        ShowContinueError(state, "...Inputs used for calculating cooling coil bypass factor.");
        ShowContinueError(state, format("...Inlet Air Temperature     = {:.2R} C", InletAirTemp));
        ShowContinueError(state, format("...Outlet Air Temperature    = {:.2R} C", OutletAirTemp));
        ShowContinueError(state, format("...Inlet Air Humidity Ratio  = {:.6R} kgWater/kgDryAir", InletAirHumRat));
        ShowContinueError(state, format("...Outlet Air Humidity Ratio = {:.6R} kgWater/kgDryAir", OutletAirHumRat));
        ShowContinueError(state, format("...Total Cooling Capacity used in calculation = {:.2R} W", TotCap));
        ShowContinueError(state, format("...Air Mass Flow Rate used in calculation     = {:.6R} kg/s", AirMassFlowRate));
        ShowContinueError(state, format("...Air Volume Flow Rate used in calculation   = {:.6R} m3/s", AirVolFlowRate));
        if (TotCap > 0.0) {
            if (((HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT] - AirVolFlowRate / TotCap) > SmallDifferenceTest) ||
                ((AirVolFlowRate / TotCap - HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) > SmallDifferenceTest)) {
                ShowContinueError(state,
                                  format("...Air Volume Flow Rate per Watt of Rated Cooling Capacity is also out of bounds at = {:.7R} m3/s/W",
                                         AirVolFlowRate / TotCap));
            }
        }
        ShowContinueErrorTimeStamp(state, "");
        ShowFatalError(state, "Check and revise the input data for this coil before rerunning the simulation.");
    }
    // Calculate slope at given conditions
    if (DeltaT > 0.0) SlopeAtConds = DeltaHumRat / DeltaT;

    //  IF (SlopeAtConds .le. .0000001d0 .or. OutletAirHumRat .le. 0.0d0) THEN
    if (SlopeAtConds < 0.0 || OutletAirHumRat <= 0.0) {
        //   Invalid conditions, slope can't be less than zero (SHR > 1) or
        //   outlet air humidity ratio can't be less than zero.
        ShowSevereError(state, format("{} \"{}\"", UnitType, UnitName));
        ShowContinueError(state, "...Invalid slope or outlet air condition when calculating cooling coil bypass factor.");
        ShowContinueError(state, format("...Slope = {:.8R}", SlopeAtConds));
        ShowContinueError(state, format("...Inlet Air Temperature     = {:.2R} C", InletAirTemp));
        ShowContinueError(state, format("...Outlet Air Temperature    = {:.2R} C", OutletAirTemp));
        ShowContinueError(state, format("...Inlet Air Humidity Ratio  = {:.6R} kgWater/kgDryAir", InletAirHumRat));
        ShowContinueError(state, format("...Outlet Air Humidity Ratio = {:.6R} kgWater/kgDryAir", OutletAirHumRat));
        ShowContinueError(state, format("...Total Cooling Capacity used in calculation = {:.2R} W", TotCap));
        ShowContinueError(state, format("...Air Mass Flow Rate used in calculation     = {:.6R} kg/s", AirMassFlowRate));
        ShowContinueError(state, format("...Air Volume Flow Rate used in calculation   = {:.6R} m3/s", AirVolFlowRate));
        if (TotCap > 0.0) {
            if (((HVAC::MinRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT] - AirVolFlowRate / TotCap) > SmallDifferenceTest) ||
                ((AirVolFlowRate / TotCap - HVAC::MaxRatedVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) > SmallDifferenceTest)) {
                ShowContinueError(state,
                                  format("...Air Volume Flow Rate per Watt of Rated Cooling Capacity is also out of bounds at = {:.7R} m3/s/W",
                                         AirVolFlowRate / TotCap));
            }
        }
        ShowContinueErrorTimeStamp(state, "");
        CBFErrors = true;
        CBF = 0.0; //? Added: Is this what should be returned
    } else {

        //   First guess for Tadp is outlet air dew point
        //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
        //  Pressure will have to be pass into this subroutine to fix this one
        ADPTemp = PsyTdpFnWPb(state, OutletAirHumRat, DataEnvironment::StdPressureSeaLevel);

        Tolerance = 1.0; // initial conditions for iteration
        ErrorLast = 100.0;
        Iter = 0;
        DeltaADPTemp = 5.0;
        while ((Iter <= IterMax) && (Tolerance > 0.001)) {
            //     Do for IterMax iterations or until the error gets below .1%
            if (Iter > 0) ADPTemp += DeltaADPTemp;
            ++Iter;

            //     Find new slope using guessed Tadp

            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  Pressure will have to be pass into this subroutine to fix this one
            ADPHumRat = min(OutletAirHumRat, PsyWFnTdpPb(state, ADPTemp, DataEnvironment::StdPressureSeaLevel));
            Slope = (InletAirHumRat - ADPHumRat) / max(0.001, (InletAirTemp - ADPTemp));

            //     check for convergence (slopes are equal to within error tolerance)

            Error = (Slope - SlopeAtConds) / SlopeAtConds;
            if ((Error > 0.0) && (ErrorLast < 0.0)) {
                DeltaADPTemp = -DeltaADPTemp / 2.0;
            } else if ((Error < 0.0) && (ErrorLast > 0.0)) {
                DeltaADPTemp = -DeltaADPTemp / 2.0;
            } else if (std::abs(Error) > std::abs(ErrorLast)) {
                DeltaADPTemp = -DeltaADPTemp / 2.0;
            }
            ErrorLast = Error;

            Tolerance = std::abs(Error);
        }

        //   Calculate Bypass Factor from Enthalpies

        InletAirEnthalpy = PsyHFnTdbW(InletAirTemp, InletAirHumRat);
        OutletAirEnthalpy = PsyHFnTdbW(OutletAirTemp, OutletAirHumRat);
        ADPEnthalpy = PsyHFnTdbW(ADPTemp, ADPHumRat);
        CBF = min(1.0, (OutletAirEnthalpy - ADPEnthalpy) / (InletAirEnthalpy - ADPEnthalpy));
        if (Iter > IterMax && PrintFlag) {
            ShowSevereError(state, format("{} \"{}\" -- coil bypass factor calculation did not converge after max iterations.", UnitType, UnitName));
            ShowContinueError(state, format("The RatedSHR of [{:.3R}], entered by the user or autosized (see *.eio file),", SHR));
            ShowContinueError(state, "may be causing this. The line defined by the coil rated inlet air conditions");
            ShowContinueError(state, "(26.7C drybulb and 19.4C wetbulb) and the RatedSHR (i.e., slope of the line) must intersect");
            ShowContinueError(state, "the saturation curve of the psychrometric chart. If the RatedSHR is too low, then this");
            ShowContinueError(state, "intersection may not occur and the coil bypass factor calculation will not converge.");
            ShowContinueError(state, "If autosizing the SHR, recheck the design supply air humidity ratio and design supply air");
            ShowContinueError(state, "temperature values in the Sizing:System and Sizing:Zone objects. In general, the temperatures");
            ShowContinueError(state, "and humidity ratios specified in these two objects should be the same for each system");
            ShowContinueError(state, "and the zones that it serves.");
            ShowContinueErrorTimeStamp(state, "");
            CBFErrors = true; // Didn't converge within MaxIter iterations
        }
        if (CBF < 0.0 && PrintFlag) {
            ShowSevereError(state, format("{} \"{}\" -- negative coil bypass factor calculated.", UnitType, UnitName));
            ShowContinueErrorTimeStamp(state, "");
            CBFErrors = true; // Negative CBF not valid
        }
    }

    // Show fatal error for specific coil that caused a CBF error
    if (CBFErrors) {
        ShowFatalError(state, format("{} \"{}\" Errors found in calculating coil bypass factors", UnitType, UnitName));
    }

    return CBF;
}

Real64 ValidateADP(EnergyPlusData &state,
                   std::string const &UnitType,      // component name
                   std::string const &UnitName,      // component type
                   Real64 const RatedInletAirTemp,   // coil inlet air temperature [C]
                   Real64 const RatedInletAirHumRat, // coil inlet air humidity ratio [kg/kg]
                   Real64 const TotCap,              // coil total capacity [W]
                   Real64 const AirVolFlowRate,      // coil air volume flow rate [m3/s]
                   Real64 const InitialSHR,          // coil sensible heat ratio []
                   std::string const &CallingRoutine // function name calling this routine
)
{

    // FUNCTION INFORMATION:
    //    AUTHOR         Richard Raustad, FSEC
    //    DATE WRITTEN   December 2015

    // PURPOSE OF THIS FUNCTION:
    //    Validates that the calculated bypass factor represents valid SHR based on total capacity and air mass flow rate.

    // METHODOLOGY EMPLOYED:
    //    With model parameters autosized by the user, the SHR is selected based on an empirical model.
    //    This can sometimes lead to an SHR that does not cross the saturation curve, or one that crosses excessively where
    //    the coil outlet air conditions exceed the saturation curve (i.e., RH > 1).
    //    This function checks to see if the ADP based on coil delta T and calculated bypass factor and the ADP based
    //    on coil delta W and calculated bypass factor land on the saturation curve at the same place within a tolerance.
    //    The result is passed back to the sizing routine as the new value for SHR.
    //    If the SHR is not autosized, this routine will still adjust the design SHR appropriately, however, the hard-sized SHR will not
    //    change.

    // Return value
    Real64 SHR(0.0); // the result - the adjusted design SHR

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    Real64 CBF_calculated(0.0);    // coil bypass factor based on TotCap, AirFlow, SHR, and BaroPress
    Real64 InletAirEnthalpy(0.0);  // Enthalpy of inlet air to evaporator at given conditions [J/kg]
    Real64 DeltaH(0.0);            // Enthalpy drop across evaporator at given conditions [J/kg]
    Real64 HTinHumRatOut(0.0);     // Air enthalpy at inlet air temp and outlet air humidity ratio [J/kg]
    Real64 DeltaHumRat(0.0);       // Humidity ratio drop across evaporator at given conditions [kg/kg]
    Real64 OutletAirTemp(0.0);     // Outlet dry-bulb temperature from evaporator at given conditions [C]
    Real64 OutletAirEnthalpy(0.0); // Enthalpy of outlet air at given conditions [J/kg]
    Real64 OutletAirHumRat(0.0);   // Outlet humidity ratio from evaporator at given conditions [kg/kg]
    Real64 OutletAirRH(0.0);       // relative humidity of the outlet air
    Real64 CalcADPTemp(0.0);       // actual ADP temperature based on bypass factor [C]
    Real64 CalcADPHumRat(0.0);     // actual ADP humidity ratio based on bypass factor [kg/kg]
    Real64 CalcADPTempFnHR(0.0);   // actual ADP temperature as a function of humidity ratio based on bypass factor [C]
    Real64 ADPerror(0.0);          // difference between ADP function of temperature and humidity ratio [deltaC]
    Real64 AirMassFlow(0.0);       // air mass flow rate based on standard barometric pressure [kg/s]
    bool bStillValidating(true);   // while loop flag
    bool bNoReporting(false);      // don't report specific warnings in calcCBF while iterating on result
    bool bReversePerturb(false);   // identifies when SHR is being lowered based on outlet air RH

    SHR = InitialSHR;
    AirMassFlow =
        AirVolFlowRate * PsyRhoAirFnPbTdbW(state, DataEnvironment::StdPressureSeaLevel, RatedInletAirTemp, RatedInletAirHumRat, CallingRoutine);
    while (bStillValidating) {
        CBF_calculated = max(0.0, CalcCBF(state, UnitType, UnitName, RatedInletAirTemp, RatedInletAirHumRat, TotCap, AirMassFlow, SHR, bNoReporting));
        DeltaH = TotCap / AirMassFlow;
        InletAirEnthalpy = PsyHFnTdbW(RatedInletAirTemp, RatedInletAirHumRat);
        HTinHumRatOut = InletAirEnthalpy - (1.0 - SHR) * DeltaH;
        OutletAirHumRat = PsyWFnTdbH(state, RatedInletAirTemp, HTinHumRatOut, CallingRoutine);
        DeltaHumRat = RatedInletAirHumRat - OutletAirHumRat;
        OutletAirEnthalpy = InletAirEnthalpy - DeltaH;
        OutletAirTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
        OutletAirRH = PsyRhFnTdbWPb(state, OutletAirTemp, OutletAirHumRat, DataEnvironment::StdPressureSeaLevel, CallingRoutine);
        if (CBF_calculated < 1) {
            CalcADPTemp = RatedInletAirTemp - ((RatedInletAirTemp - OutletAirTemp) / (1 - CBF_calculated));
            CalcADPHumRat = RatedInletAirHumRat - ((DeltaHumRat) / (1 - CBF_calculated));
            CalcADPTempFnHR = PsyTdpFnWPb(state, CalcADPHumRat, DataEnvironment::StdPressureSeaLevel, CallingRoutine);
            ADPerror = CalcADPTemp - CalcADPTempFnHR;
        } else {
            ADPerror = 0; // might be able to check for RH >= 1 and reduce SHR, need defect file for that since can't create one
        }

        if (std::abs(ADPerror) > 0.012) {
            if (OutletAirRH >= 1.0) { // if RH > 1, reduce SHR until it crosses the saturation curve
                SHR -= 0.001;
                bReversePerturb = true;
                if (SHR < 0.5)
                    bStillValidating = false; // have to stop somewhere, this is lower than the lower limit of SHR empirical model (see
                                              // Autosizing/CoolingSHRSizing)
            } else {
                if (bReversePerturb) {
                    bStillValidating = false; // stop iterating once SHR causes ADP to cross back under saturation curve, take what you get
                } else {
                    SHR += 0.001; // increase SHR slowly until ADP temps are resolved
                }
            }
            if (SHR > 0.8)
                bStillValidating = false; // have to stop somewhere, this is the upper limit of SHR empirical model (see Autosizing/CoolingSHRSizing)
        } else {
            bStillValidating = false; // ADP temps are close enough. Normal input files hit this on first pass
        }
    }

    return SHR;
}

Real64 CalcEffectiveSHR(EnergyPlusData &state,
                        int const DXCoilNum,                         // Index number for cooling coil
                        Real64 const SHRss,                          // Steady-state sensible heat ratio
                        Real64 const RTF,                            // Compressor run-time fraction
                        Real64 const QLatRated,                      // Rated latent capacity
                        Real64 const QLatActual,                     // Actual latent capacity
                        Real64 const EnteringDB,                     // Entering air dry-bulb temperature
                        Real64 const EnteringWB,                     // Entering air wet-bulb temperature
                        ObjexxFCL::Optional_int_const Mode,          // Performance mode for MultiMode DX coil; Always 1 for other coil types
                        ObjexxFCL::Optional<Real64 const> HeatingRTF // Used to recalculate Toff for cycling fan systems
)
{

    // FUNCTION INFORMATION:
    //    AUTHOR         Richard Raustad, FSEC
    //    DATE WRITTEN   September 2003
    //                   Feb 2005 M. J. Witte, GARD Analytics, Inc.
    //                    Add new coil type COIL:DX:MultiMode:CoolingEmpirical:
    //                   Nov 2008 R. Raustad, FSEC
    //                    Modified to allow latent degradation with cycling fan

    // PURPOSE OF THIS FUNCTION:
    //    Adjust sensible heat ratio to account for degradation of DX coil latent
    //    capacity at part-load (cycling) conditions.

    // METHODOLOGY EMPLOYED:
    //    With model parameters entered by the user, the part-load latent performance
    //    of a DX cooling coil is determined for a constant air flow system with
    //    a cooling coil that cycles on/off. The model calculates the time
    //    required for condensate to begin falling from the cooling coil.
    //    Runtimes greater than this are integrated to a "part-load" latent
    //    capacity which is used to determine the "part-load" sensible heat ratio.
    //    See reference below for additional details (linear decay model, Eq. 8b).
    // REFERENCES:
    //   "A Model to Predict the Latent Capacity of Air Conditioners and
    //    Heat Pumps at Part-Load Conditions with Constant Fan Operation"
    //    1996 ASHRAE Transactions, Volume 102, Part 1, Pp. 266 - 274,
    //    Hugh I. Henderson, Jr., P.E., Kannan Rengarajan, P.E.

    // Return value
    Real64 SHReff; // Effective sensible heat ratio, includes degradation due to cycling effects

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    Real64 Twet; // Nominal time for condensate to begin leaving the coil's condensate drain line
    //   at the current operating conditions (sec)
    Real64 Gamma; // Initial moisture evaporation rate divided by steady-state AC latent capacity
    //   at the current operating conditions
    Real64 Twet_Rated;  // Twet at rated conditions (coil air flow rate and air temperatures), sec
    Real64 Gamma_Rated; // Gamma at rated conditions (coil air flow rate and air temperatures)
    Real64 Twet_max;    // Maximum allowed value for Twet
    Real64 Nmax;        // Maximum ON/OFF cycles per hour for the compressor (cycles/hr)
    Real64 Tcl;         // Time constant for latent capacity to reach steady state after startup (sec)
    Real64 Ton;         // Coil on time (sec)
    Real64 Toff;        // Coil off time (sec)
    Real64 Toffa;       // Actual coil off time (sec). Equations valid for Toff <= (2.0 * Twet/Gamma)
    Real64 aa;          // Intermediate variable
    Real64 To1;         // Intermediate variable (first guess at To). To = time to the start of moisture removal
    Real64 To2;         // Intermediate variable (second guess at To). To = time to the start of moisture removal
    Real64 Error;       // Error for iteration (DO) loop
    Real64 LHRmult;     // Latent Heat Ratio (LHR) multiplier. The effective latent heat ratio LHR = (1-SHRss)*LHRmult
    Real64 Ton_heating;
    Real64 Toff_heating;

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    if (thisDXCoil.DXCoilType_Num != HVAC::CoilDX_MultiSpeedCooling) {
        Twet_Rated = thisDXCoil.Twet_Rated(Mode);
        Gamma_Rated = thisDXCoil.Gamma_Rated(Mode);
        Nmax = thisDXCoil.MaxONOFFCyclesperHour(Mode);
        Tcl = thisDXCoil.LatentCapacityTimeConstant(Mode);
    } else {
        Twet_Rated = thisDXCoil.MSTwet_Rated(Mode);
        Gamma_Rated = thisDXCoil.MSGamma_Rated(Mode);
        Nmax = thisDXCoil.MSMaxONOFFCyclesperHour(Mode);
        Tcl = thisDXCoil.MSLatentCapacityTimeConstant(Mode);
    }

    //  No moisture evaporation (latent degradation) occurs for runtime fraction of 1.0
    //  All latent degradation model parameters cause divide by 0.0 if not greater than 0.0
    //  Latent degradation model parameters initialize to 0.0 meaning no evaporation model used.
    if (RTF >= 1.0 || Twet_Rated <= 0.0 || Gamma_Rated <= 0.0 || Nmax <= 0.0 || Tcl <= 0.0) {
        SHReff = SHRss;
        return SHReff;
    }

    Twet_max = 9999.0; // high limit for Twet

    //  Calculate the model parameters at the actual operating conditions
    Twet = min(Twet_Rated * QLatRated / (QLatActual + 1.e-10), Twet_max);
    Gamma = Gamma_Rated * QLatRated * (EnteringDB - EnteringWB) / ((26.7 - 19.4) * QLatActual + 1.e-10);

    //  Calculate the compressor on and off times using a conventional thermostat curve
    Ton = 3600.0 / (4.0 * Nmax * (1.0 - RTF)); // duration of cooling coil on-cycle (sec)
    Toff = 3600.0 / (4.0 * Nmax * RTF);        // duration of cooling coil off-cycle (sec)

    //  Cap Toff to meet the equation restriction
    if (Gamma > 0.0) {
        Toffa = min(Toff, 2.0 * Twet / Gamma);
    } else {
        Toffa = Toff;
    }

    //  Need to include the reheat coil operation to account for actual fan run time. E+ uses a
    //  separate heating coil for heating and reheat (to separate the heating and reheat loads)
    //  and real world applications would use a single heating coil for both purposes, the actual
    //  fan operation is based on HeatingPLR + ReheatPLR. For cycling fan RH control, latent
    //  degradation only occurs when a heating load exists, in this case the reheat load is
    //  equal to and opposite in magnitude to the cooling coil sensible output but the reheat
    //  coil is not always active. This additional fan run time has not been accounted for at this time.
    //  Recalculate Toff for cycling fan systems when heating is active
    if (present(HeatingRTF)) {
        if (HeatingRTF < 1.0 && HeatingRTF > RTF) {
            Ton_heating = 3600.0 / (4.0 * Nmax * (1.0 - HeatingRTF));
            Toff_heating = 3600.0 / (4.0 * Nmax * HeatingRTF);
            //    add additional heating coil operation during cooling coil off cycle (due to cycling rate difference of coils)
            Ton_heating += max(0.0, min(Ton_heating, (Ton + Toffa) - (Ton_heating + Toff_heating)));
            Toffa = min(Toffa, Ton_heating - Ton);
        }
    }

    //  Use successive substitution to solve for To
    aa = (Gamma * Toffa) - (0.25 / Twet) * pow_2(Gamma) * pow_2(Toffa);
    To1 = aa + Tcl;
    Error = 1.0;
    while (Error > 0.001) {
        To2 = aa - Tcl * (std::exp(-To1 / Tcl) - 1.0);
        Error = std::abs((To2 - To1) / To1);
        To1 = To2;
    }

    //  Adjust Sensible Heat Ratio (SHR) using Latent Heat Ratio (LHR) multiplier
    //  Floating underflow errors occur when -Ton/Tcl is a large negative number.
    //  Cap lower limit at -700 to avoid the underflow errors.
    aa = std::exp(max(-700.0, -Ton / Tcl));
    //  Calculate latent heat ratio multiplier
    LHRmult = max(((Ton - To2) / (Ton + Tcl * (aa - 1.0))), 0.0);

    //  Calculate part-load or "effective" sensible heat ratio
    SHReff = 1.0 - (1.0 - SHRss) * LHRmult;

    if (SHReff < SHRss) SHReff = SHRss; // Effective SHR can be less than the steady-state SHR
    if (SHReff > 1.0) SHReff = 1.0;     // Effective sensible heat ratio can't be greater than 1.0

    return SHReff;
}

void CalcTotCapSHR(EnergyPlusData &state,
                   Real64 const InletDryBulb,     // inlet air dry bulb temperature [C]
                   Real64 const InletHumRat,      // inlet air humidity ratio [kg water / kg dry air]
                   Real64 const InletEnthalpy,    // inlet air specific enthalpy [J/kg]
                   Real64 const InletWetBulb,     // inlet air wet bulb temperature [C]
                   Real64 const AirMassFlowRatio, // Ratio of actual air mass flow to nominal air mass flow
                   Real64 const AirMassFlow,      // actual mass flow for capacity and SHR calculation
                   Real64 const TotCapNom,        // nominal total capacity [W]
                   Real64 const CBF,              // coil bypass factor
                   int const CCapFTemp,           // capacity modifier curve index, function of entering wetbulb
                   int const CCapFFlow,           // capacity modifier curve, function of actual flow vs rated flow
                   Real64 &TotCap,                // total capacity at the given conditions [W]
                   Real64 &SHR,                   // sensible heat ratio at the given conditions
                   Real64 const CondInletTemp,    // Condenser inlet temperature [C]
                   Real64 const Pressure,         // air pressure [Pa]
                   Real64 &TotCapModFac           // capacity modification factor, func of temp and func of flow
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Fred Buhl using Don Shirey's code
    //       DATE WRITTEN   September 2002

    // PURPOSE OF THIS SUBROUTINE:
    // Calculates total capacity and sensible heat ratio of a DX coil at the specified conditions

    // METHODOLOGY EMPLOYED:
    // With the rated performance data entered by the user, the model employs some of the
    // DOE-2.1E curve fits to adjust the capacity and SHR of the unit as a function
    // of entering air temperatures and supply air flow rate (actual vs rated flow). The model
    // does NOT employ the exact same methodology to calculate performance as DOE-2, although
    // some of the DOE-2 curve fits are employed by this model.

    // The model checks for coil dryout conditions, and adjusts the calculated performance
    // appropriately.

    // REFERENCES:
    // ASHRAE HVAC 2 Toolkit page 4-81.
    // Henderson, H.I. Jr., K. Rengarajan and D.B. Shirey, III. 1992.The impact of comfort
    // control on air conditioner energy use in humid climates. ASHRAE Transactions 98(2):
    // 104-113.
    // Henderson, H.I. Jr., Danny Parker and Y.J. Huang. 2000.Improving DOE-2's RESYS routine:
    // User Defined Functions to Provide More Accurate Part Load Energy Use and Humidity
    // Predictions. Proceedings of ACEEE Conference.

    // Using/Aliasing
    using Curve::CurveValue;

    // Locals
    // SUBROUTINE ARGUMENT DEFINITIONS:
    // and outside drybulb

    // SUBROUTINE PARAMETER DEFINITIONS:
    constexpr int MaxIter(30);               // Maximum number of iterations for dry evaporator calculations
    constexpr Real64 RF(0.4);                // Relaxation factor for dry evaporator iterations
    constexpr Real64 Tolerance(0.01);        // Error tolerance for dry evaporator iterations
    constexpr Real64 MinHumRatCalc(0.00001); // Error tolerance for dry evaporator iterations

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 InletWetBulbCalc; // calculated inlet wetbulb temperature used for finding dry coil point [C]
    Real64 InletHumRatCalc;  // calculated inlet humidity ratio used for finding dry coil point [kg water / kg dry air]
    Real64 TotCapTempModFac; // Total capacity modifier (function of entering wetbulb, outside drybulb)
    Real64 TotCapFlowModFac; // Total capacity modifier (function of actual supply air flow vs nominal flow)
    Real64 hDelta;           // Change in air enthalpy across the cooling coil [J/kg]
    Real64 hADP;             // Apparatus dew point enthalpy [J/kg]
    Real64 tADP;             // Apparatus dew point temperature [C]
    Real64 wADP;             // Apparatus dew point humidity ratio [kg/kg]
    Real64 hTinwADP;         // Enthalpy at inlet dry-bulb and wADP [J/kg]
    Real64 SHRCalc;          // temporary calculated value of SHR
    Real64 TotCapCalc;       // temporary calculated value of total capacity [W]
    int Counter;             // Counter for dry evaporator iterations
    Real64 werror;           // Deviation of humidity ratio in dry evaporator iteration loop

    //  MaxIter = 30
    //  RF = 0.4d0
    Counter = 0;
    //  Tolerance = 0.01d0
    werror = 0.0;

    InletWetBulbCalc = InletWetBulb;
    InletHumRatCalc = InletHumRat;

    if (AirMassFlow <= 0.00001) {
        TotCap = 0.0;
        SHR = 0.0;
        return;
    }

    //  DO WHILE (ABS(werror) .gt. Tolerance .OR. Counter == 0)
    //   Get capacity modifying factor (function of inlet wetbulb & outside drybulb) for off-rated conditions
    while (true) {
        TotCapTempModFac = CurveValue(state, CCapFTemp, InletWetBulbCalc, CondInletTemp);
        //   Get capacity modifying factor (function of mass flow) for off-rated conditions
        TotCapFlowModFac = CurveValue(state, CCapFFlow, AirMassFlowRatio);
        //   Get total capacity
        TotCapCalc = TotCapNom * TotCapFlowModFac * TotCapTempModFac;

        //   Calculate apparatus dew point conditions using TotCap and CBF
        hDelta = TotCapCalc / AirMassFlow;
        hADP = InletEnthalpy - hDelta / (1.0 - CBF);
        tADP = PsyTsatFnHPb(state, hADP, Pressure);
        wADP = PsyWFnTdbH(state, tADP, hADP);
        hTinwADP = PsyHFnTdbW(InletDryBulb, wADP);
        if ((InletEnthalpy - hADP) > 1.e-10) {
            SHRCalc = min((hTinwADP - hADP) / (InletEnthalpy - hADP), 1.0);
        } else {
            SHRCalc = 1.0;
        }
        //   Check for dry evaporator conditions (win < wadp)
        if (wADP > InletHumRatCalc || (Counter >= 1 && Counter < MaxIter)) {
            if (InletHumRatCalc == 0.0) InletHumRatCalc = MinHumRatCalc;
            //      InletHumRatCalc=MAX(InletHumRatCalc,MinHumRatCalc)  ! proposed.

            werror = (InletHumRatCalc - wADP) / InletHumRatCalc;
            //     Increase InletHumRatCalc at constant inlet air temp to find coil dry-out point. Then use the
            //     capacity at the dry-out point to determine exiting conditions from coil. This is required
            //     since the TotCapTempModFac doesn't work properly with dry-coil conditions.
            InletHumRatCalc = RF * wADP + (1.0 - RF) * InletHumRatCalc;
            InletWetBulbCalc = PsyTwbFnTdbWPb(state, InletDryBulb, InletHumRatCalc, Pressure);
            ++Counter;
            if (std::abs(werror) > Tolerance) continue; // Recalculate with modified inlet conditions
            break;                                      // conditions are satisfied
        } else {
            break; // conditions are satisfied
        }
    }

    // END DO

    //  Calculate full load output conditions
    if (SHRCalc > 1.0 || Counter > 0) SHRCalc = 1.0;

    SHR = SHRCalc;
    TotCap = TotCapCalc;
    TotCapModFac = TotCapTempModFac * TotCapFlowModFac;
}

void CalcMultiSpeedDXCoilCooling(EnergyPlusData &state,
                                 int const DXCoilNum,     // the number of the DX heating coil to be simulated
                                 Real64 const SpeedRatio, // = (CompressorSpeed - CompressorSpeedMin) / (CompressorSpeedMax - CompressorSpeedMin)
                                 Real64 const CycRatio,   // cycling part load ratio
                                 int const SpeedNum,      // Speed number
                                 HVAC::FanOp const fanOp, // Sets fan control to FanOp::Cycling or FanOp::Continuous
                                 HVAC::CompressorOp const compressorOp, // Compressor on/off; 1=on, 0=off
                                 int const SingleMode                   // Single mode operation Yes/No; 1=Yes, 0=No
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Lixing Gu, FSEC
    //       DATE WRITTEN   June 2007
    //       MODIFIED       April 2010, Chandan sharma, FSEC, added basin heater
    //       RE-ENGINEERED  Revised based on CalcMultiSpeedDXCoil

    // PURPOSE OF THIS SUBROUTINE:
    // Calculates the air-side performance and electrical energy use of a direct-
    // expansion, air-cooled cooling unit with a multispeed compressor.

    // METHODOLOGY EMPLOYED:
    // Uses the same methodology as the single speed DX unit model (SUBROUTINE CalcDoe2DXCoil).
    // In addition it assumes that the unit performance is obtained by interpolating between
    // the performance at high speed and that at low speed. If the output needed is below
    // that produced at low speed, the compressor cycles between off and low speed.

    // Using/Aliasing
    using Curve::CurveValue;
    Real64 MSHPMassFlowRateHigh = state.dataHVACGlobal->MSHPMassFlowRateHigh;
    Real64 MSHPMassFlowRateLow = state.dataHVACGlobal->MSHPMassFlowRateLow;
    auto &MSHPWasteHeat = state.dataHVACGlobal->MSHPWasteHeat;

    // Locals
    // SUBROUTINE ARGUMENT DEFINITIONS:
    // SpeedRatio varies between 1.0 (maximum speed) and 0.0 (minimum speed)

    // SUBROUTINE PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineName("CalcMultiSpeedDXCoilCooling");
    static constexpr std::string_view RoutineNameHighSpeedAlt("CalcMultiSpeedDXCoilCooling highspeed");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 AirMassFlow;         // dry air mass flow rate through coil [kg/s]
    Real64 InletAirWetBulbC;    // wetbulb temperature of inlet air [C]
    Real64 InletAirDryBulbTemp; // inlet air dry bulb temperature [C]
    Real64 InletAirEnthalpy;    // inlet air enthalpy [J/kg]
    Real64 InletAirHumRat;      // inlet air humidity ratio [kg/kg]
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // REAL(r64)   :: InletAirPressure    ! inlet air pressure [Pa]
    Real64 OutletAirDryBulbTemp;    // outlet air dry bulb temperature [C]
    Real64 OutletAirEnthalpy;       // outlet air enthalpy [J/kg]
    Real64 OutletAirHumRat;         // outlet air humidity ratio [kg/kg]
    Real64 OutletAirDryBulbTempSat; // outlet air dry bulb temp at saturation at the outlet enthalpy [C]
    Real64 LSOutletAirDryBulbTemp;  // low speed outlet air dry bulb temperature [C]
    Real64 LSOutletAirEnthalpy;     // low speed outlet air enthalpy [J/kg]
    Real64 LSOutletAirHumRat;       // low speed outlet air humidity ratio [kg/kg]
    Real64 HSOutletAirDryBulbTemp;  // high speed outlet air dry bulb temperature [C]
    Real64 HSOutletAirEnthalpy;     // high speed outlet air enthalpy [J/kg]
    Real64 HSOutletAirHumRat;       // high speed outlet air humidity ratio [kg/kg]
    Real64 hDelta;                  // Change in air enthalpy across the cooling coil [J/kg]
    Real64 hTinwout;                // Enthalpy at inlet dry-bulb and outlet humidity ratio [J/kg]
    Real64 hADP;                    // Apparatus dew point enthalpy [J/kg]
    Real64 tADP;                    // Apparatus dew point temperature [C]
    Real64 wADP;                    // Apparatus dew point humidity ratio [kg/kg]
    Real64 hTinwADP;                // Enthalpy at inlet dry-bulb and wADP [J/kg]
    Real64 RatedCBFHS;              // coil bypass factor at rated conditions (high speed)
    Real64 CBFHS;                   // coil bypass factor at max flow (high speed)
    Real64 RatedCBFLS;              // coil bypass factor at rated conditions (low speed)
    Real64 CBFLS;                   // coil bypass factor at max flow (low speed)
    Real64 TotCapHS;                // total capacity at high speed [W]
    Real64 SHRHS;                   // sensible heat ratio at high speed
    Real64 TotCapLS;                // total capacity at low speed [W]
    Real64 SHRLS;                   // sensible heat ratio at low speed
    Real64 EIRTempModFacHS;         // EIR modifier (function of entering wetbulb, outside drybulb) (high speed)
    Real64 EIRFlowModFacHS;         // EIR modifier (function of actual supply air flow vs rated flow) (high speed)
    Real64 EIRHS;                   // EIR at off rated conditions (high speed)
    Real64 EIRTempModFacLS;         // EIR modifier (function of entering wetbulb, outside drybulb) (low speed)
    Real64 EIRFlowModFacLS;         // EIR modifier (function of actual supply air flow vs rated flow) (low speed)
    Real64 EIRLS;                   // EIR at off rated conditions (low speed)
    Real64 SHR;                     // sensible heat ratio at current speed
    Real64 EIR;                     // EIR at current speed
    Real64 CBF;                     // CBFNom adjusted for actual air mass flow rate
    Real64 PLF;                     // Part load factor, accounts for thermal lag at compressor startup, used in
    // power calculation
    Real64 CondInletTemp; // Condenser inlet temperature (C). Outdoor dry-bulb temp for air-cooled condenser.
    // Outdoor Wetbulb +(1 - effectiveness)*(outdoor drybulb - outdoor wetbulb) for evap condenser.
    Real64 CondInletHumRat; // Condenser inlet humidity ratio (kg/kg). Zero for air-cooled condenser.
    // For evap condenser, its the humidity ratio of the air leaving the evap cooling pads.
    Real64 RhoAir;                // Density of air [kg/m3]
    Real64 RhoWater;              // Density of water [kg/m3]
    Real64 CondAirMassFlow;       // Condenser air mass flow rate [kg/s]
    Real64 EvapCondPumpElecPower; // Evaporative condenser electric pump power [W]
    constexpr int DXMode(1);      // Performance mode for MultiMode DX coil; Always 1 for other coil types
    Real64 OutdoorDryBulb;        // Outdoor dry-bulb temperature at condenser (C)
    Real64 OutdoorWetBulb;        // Outdoor wet-bulb temperature at condenser (C)
    Real64 OutdoorHumRat;         // Outdoor humidity ratio at condenser (kg/kg)
    Real64 OutdoorPressure;       // Outdoor barometric pressure at condenser (Pa)
    int SpeedNumHS;               // High speed number
    int SpeedNumLS;               // Low speed number
    Real64 SHRUnadjusted;         // Temp SHR
    Real64 QLatRated;             // Qlatent at rated conditions of indoor(TDB,TWB)=(26.7C,19.4C)
    Real64 QLatActual;            // Qlatent at actual operating conditions
    Real64 AirMassFlowRatioLS;    // airflow ratio at low speed
    Real64 AirMassFlowRatioHS;    // airflow ratio at high speed
    Real64 WasteHeatLS;           // Waste heat at low speed
    Real64 WasteHeatHS;           // Waste heat at high speed
    Real64 LSElecCoolingPower;    // low speed power [W]
    Real64 HSElecCoolingPower;    // high speed power [W]
    Real64 CrankcaseHeatingPower; // Power due to crank case heater
    Real64 AirVolumeFlowRate;     // Air volume flow rate across the heating coil
    Real64 VolFlowperRatedTotCap; // Air volume flow rate divided by rated total heating capacity

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    if (thisDXCoil.CondenserInletNodeNum(DXMode) != 0) {
        OutdoorPressure = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(DXMode)).Press;
        // If node is not connected to anything, pressure = default, use weather data
        if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press) {
            OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
            OutdoorHumRat = state.dataEnvrn->OutHumRat;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
            OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
        } else {
            OutdoorDryBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(DXMode)).Temp;
            OutdoorHumRat = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(DXMode)).HumRat;
            OutdoorWetBulb = PsyTwbFnTdbWPb(state, OutdoorDryBulb, OutdoorHumRat, OutdoorPressure, RoutineName);
        }
        if (thisDXCoil.IsSecondaryDXCoilInZone) {
            auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
            OutdoorDryBulb = secZoneHB.ZT;
            OutdoorHumRat = secZoneHB.airHumRat;
            OutdoorWetBulb = thisDXCoil.EvapInletWetBulb;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
        }
    } else if (thisDXCoil.IsSecondaryDXCoilInZone) {
        auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
        OutdoorDryBulb = secZoneHB.ZT;
        OutdoorHumRat = secZoneHB.airHumRat;
        OutdoorWetBulb = thisDXCoil.EvapInletWetBulb;
        OutdoorPressure = state.dataEnvrn->OutBaroPress;
    } else {
        OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
        OutdoorHumRat = state.dataEnvrn->OutHumRat;
        OutdoorPressure = state.dataEnvrn->OutBaroPress;
        OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
    }

    if (SpeedNum > 1) {
        SpeedNumLS = SpeedNum - 1;
        SpeedNumHS = SpeedNum;
        if (SpeedNum > thisDXCoil.NumOfSpeeds) {
            SpeedNumLS = thisDXCoil.NumOfSpeeds - 1;
            SpeedNumHS = thisDXCoil.NumOfSpeeds;
        }
    } else {
        SpeedNumLS = 1;
        SpeedNumHS = 1;
    }

    MSHPWasteHeat = 0.0;
    AirMassFlow = thisDXCoil.InletAirMassFlowRate;
    AirMassFlowRatioLS = MSHPMassFlowRateLow / thisDXCoil.MSRatedAirMassFlowRate(SpeedNumLS);
    AirMassFlowRatioHS = MSHPMassFlowRateHigh / thisDXCoil.MSRatedAirMassFlowRate(SpeedNumHS);
    if ((AirMassFlow > 0.0) && (CycRatio > 0.0) && (MSHPMassFlowRateHigh == 0.0)) {
        ShowSevereError(
            state,
            format("CalcMultiSpeedDXCoilCooling: {} \"{} Developer error - inconsistent airflow rates.", thisDXCoil.DXCoilType, thisDXCoil.Name));
        if (MSHPMassFlowRateLow == 0.0 && SpeedNum > 1) {
            ShowContinueError(state,
                              "When AirMassFlow > 0.0 and CycRatio > 0.0 and SpeedNum > 1, then MSHPMassFlowRateLow and MSHPMassFlowRateHigh "
                              "must also be > 0.0");
            ShowContinueErrorTimeStamp(state, "");
            ShowContinueError(state,
                              format("AirMassFlow={:.3R},CycRatio={:.3R},SpeedNum={:.0R}, MSHPMassFlowRateLow={:.3R}, MSHPMassFlowRateHigh={:.3R}",
                                     AirMassFlow,
                                     double(SpeedNum),
                                     CycRatio,
                                     MSHPMassFlowRateLow,
                                     MSHPMassFlowRateHigh));
            ShowFatalError(state, "Preceding condition(s) causes termination.");
        } else {
            ShowContinueError(state, "When AirMassFlow > 0.0 and CycRatio > 0.0, then MSHPMassFlowRateHigh must also be > 0.0");
            ShowContinueErrorTimeStamp(state, "");
            ShowContinueError(state,
                              format("AirMassFlow={:.3R},CycRatio={:.3R}, MSHPMassFlowRateHigh={:.3R}", AirMassFlow, CycRatio, MSHPMassFlowRateHigh));
            ShowFatalError(state, "Preceding condition(s) causes termination.");
        }
    } else if (CycRatio > 1.0 || SpeedRatio > 1.0) {
        ShowSevereError(
            state,
            format("CalcMultiSpeedDXCoilCooling: {} \"{} Developer error - inconsistent speed ratios.", thisDXCoil.DXCoilType, thisDXCoil.Name));
        ShowContinueError(state, "CycRatio and SpeedRatio must be between 0.0 and 1.0");
        ShowContinueErrorTimeStamp(state, "");
        ShowContinueError(state, format("CycRatio={:.1R}, SpeedRatio = {:.1R}", CycRatio, SpeedRatio));
        ShowFatalError(state, "Preceding condition(s) causes termination.");
    }

    thisDXCoil.PartLoadRatio = 0.0;
    state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = 0.0;
    thisDXCoil.CoolingCoilRuntimeFraction = 0.0;
    InletAirDryBulbTemp = thisDXCoil.InletAirTemp;
    InletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
    InletAirHumRat = thisDXCoil.InletAirHumRat;
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // InletAirPressure = DXCoil(DXCoilNum)%InletAirPressure
    // InletAirWetBulbC = PsyTwbFnTdbWPb(InletAirDryBulbTemp,InletAirHumRat,InletAirPressure)
    InletAirWetBulbC = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRat, OutdoorPressure, RoutineName);
    if (thisDXCoil.CondenserType(DXMode) == DataHeatBalance::RefrigCondenserType::Air) {
        CondInletTemp = OutdoorDryBulb; // Outdoor dry-bulb temp
    } else if (thisDXCoil.CondenserType(DXMode) == DataHeatBalance::RefrigCondenserType::Evap) {
        // Outdoor wet-bulb temp from DataEnvironment + (1.0-EvapCondEffectiveness) * (drybulb - wetbulb)
        CondInletTemp = OutdoorWetBulb + (OutdoorDryBulb - OutdoorWetBulb) * (1.0 - thisDXCoil.MSEvapCondEffect(SpeedNumHS));
        CondInletHumRat = PsyWFnTdbTwbPb(state, CondInletTemp, OutdoorWetBulb, OutdoorPressure, RoutineName);
    }
    if (OutdoorDryBulb < thisDXCoil.MaxOATCrankcaseHeater) {
        CrankcaseHeatingPower = thisDXCoil.CrankcaseHeaterCapacity;
        if (thisDXCoil.CrankcaseHeaterCapacityCurveIndex > 0) {
            CrankcaseHeatingPower *= Curve::CurveValue(state, thisDXCoil.CrankcaseHeaterCapacityCurveIndex, OutdoorDryBulb);
        }
    } else {
        CrankcaseHeatingPower = 0.0;
    }

    if ((AirMassFlow > 0.0 && CondInletTemp >= thisDXCoil.MinOATCompressor) && (GetCurrentScheduleValue(state, thisDXCoil.SchedPtr) > 0.0) &&
        ((SpeedRatio > 0.0 && SingleMode == 0) || CycRatio > 0.0) && (compressorOp == HVAC::CompressorOp::On)) {

        RhoAir = PsyRhoAirFnPbTdbW(state, OutdoorPressure, OutdoorDryBulb, OutdoorHumRat, RoutineName);
        if (SpeedNum > 1 && SingleMode == 0) {

            // Check for valid air volume flow per rated total cooling capacity (200 - 500 cfm/ton) at low speed
            AirVolumeFlowRate = MSHPMassFlowRateLow / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat, RoutineName);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  AirVolumeFlowRate = AirMassFlow/PsyRhoAirFnPbTdbW(InletAirPressure,InletAirDryBulbTemp, InletAirHumRat)
            VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.MSRatedTotCap(SpeedNumLS);
            if (((VolFlowperRatedTotCap < HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) ||
                 (VolFlowperRatedTotCap > HVAC::MaxCoolVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT])) &&
                state.dataHVACGlobal->MSUSEconoSpeedNum == 0) {
                if (thisDXCoil.MSErrIndex(SpeedNumLS) == 0) {
                    ShowWarningMessage(
                        state,
                        format("{} \"{}\" - Air volume flow rate per watt of rated total cooling capacity is out of range at speed {}.",
                               thisDXCoil.DXCoilType,
                               thisDXCoil.Name,
                               SpeedNumLS));
                    ShowContinueErrorTimeStamp(state, "");
                    ShowContinueError(state,
                                      format("Expected range for VolumeFlowPerRatedTotalCapacity=[{:.3R}--{:.3R}] Current value is {:.3R} m3/s/W",
                                             HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             HVAC::MaxCoolVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             VolFlowperRatedTotCap));
                    ShowContinueError(state, "Possible causes include inconsistent air flow rates in system components or");
                    ShowContinueError(state, "inconsistent supply air fan operation modes in coil and unitary system objects.");
                }
                ShowRecurringWarningErrorAtEnd(state,
                                               format("{} \"{}\" - Air volume flow rate per watt of rated total cooling capacity is out of range "
                                                      "at speed {} error continues...",
                                                      thisDXCoil.DXCoilType,
                                                      thisDXCoil.Name,
                                                      SpeedNumLS),
                                               thisDXCoil.MSErrIndex(SpeedNumLS),
                                               VolFlowperRatedTotCap,
                                               VolFlowperRatedTotCap);
            }

            // Check for valid air volume flow per rated total cooling capacity (200 - 500 cfm/ton) at high speed
            AirVolumeFlowRate = MSHPMassFlowRateHigh / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat, RoutineName);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  AirVolumeFlowRate = AirMassFlow/PsyRhoAirFnPbTdbW(InletAirPressure,InletAirDryBulbTemp, InletAirHumRat)
            VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.MSRatedTotCap(SpeedNumHS);
            if (((VolFlowperRatedTotCap < HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) ||
                 (VolFlowperRatedTotCap > HVAC::MaxCoolVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT])) &&
                state.dataHVACGlobal->MSUSEconoSpeedNum == 0) {
                if (thisDXCoil.MSErrIndex(SpeedNumHS) == 0) {
                    ShowWarningMessage(
                        state,
                        format("{} \"{}\" - Air volume flow rate per watt of rated total cooling capacity is out of range at speed {}.",
                               thisDXCoil.DXCoilType,
                               thisDXCoil.Name,
                               SpeedNumHS));
                    ShowContinueErrorTimeStamp(state, "");
                    ShowContinueError(state,
                                      format("Expected range for VolumeFlowPerRatedTotalCapacity=[{:.3R}--{:.3R}] Current value is {:.3R} m3/s/W",
                                             HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             HVAC::MaxCoolVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             VolFlowperRatedTotCap));
                    ShowContinueError(state, "Possible causes include inconsistent air flow rates in system components or");
                    ShowContinueError(state, "inconsistent supply air fan operation modes in coil and unitary system objects.");
                }
                ShowRecurringWarningErrorAtEnd(state,
                                               format("{} \"{}\" - Air volume flow rate per watt of rated total cooling capacity is out of range "
                                                      "at speed {} error continues...",
                                                      thisDXCoil.DXCoilType,
                                                      thisDXCoil.Name,
                                                      SpeedNumHS),
                                               thisDXCoil.MSErrIndex(SpeedNumHS),
                                               VolFlowperRatedTotCap,
                                               VolFlowperRatedTotCap);
            }

            // Adjust high speed coil bypass factor for actual maximum air flow rate.
            RatedCBFHS = thisDXCoil.MSRatedCBF(SpeedNumHS);
            CBFHS = AdjustCBF(RatedCBFHS, thisDXCoil.MSRatedAirMassFlowRate(SpeedNumHS), MSHPMassFlowRateHigh);
            RatedCBFLS = thisDXCoil.MSRatedCBF(SpeedNumLS);
            CBFLS = AdjustCBF(RatedCBFLS, thisDXCoil.MSRatedAirMassFlowRate(SpeedNumLS), MSHPMassFlowRateLow);
            // get low speed total capacity and SHR at current conditions
            CalcTotCapSHR(state,
                          InletAirDryBulbTemp,
                          InletAirHumRat,
                          InletAirEnthalpy,
                          InletAirWetBulbC,
                          AirMassFlowRatioLS,
                          MSHPMassFlowRateLow,
                          thisDXCoil.MSRatedTotCap(SpeedNumLS),
                          CBFLS,
                          thisDXCoil.MSCCapFTemp(SpeedNumLS),
                          thisDXCoil.MSCCapFFlow(SpeedNumLS),
                          TotCapLS,
                          SHRLS,
                          CondInletTemp,
                          OutdoorPressure,
                          thisDXCoil.capModFacTotal);
            // get low speed outlet conditions
            hDelta = TotCapLS / MSHPMassFlowRateLow;
            // Calculate new apparatus dew point conditions
            hADP = InletAirEnthalpy - hDelta / (1.0 - CBFLS);
            tADP = PsyTsatFnHPb(state, hADP, OutdoorPressure, RoutineNameHighSpeedAlt);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  tADP = PsyTsatFnHPb(hADP,InletAirPressure)
            wADP = PsyWFnTdbH(state, tADP, hADP, RoutineName);
            hTinwADP = PsyHFnTdbW(InletAirDryBulbTemp, wADP);
            // get corresponding SHR
            if ((InletAirEnthalpy - hADP) > 1.e-10) {
                SHRLS = min((hTinwADP - hADP) / (InletAirEnthalpy - hADP), 1.0);
            } else {
                SHRLS = 1.0;
            }
            // cr8918    SHRLS = MIN((hTinwADP-hADP)/(InletAirEnthalpy-hADP),1.0d0)
            // get low speed outlet conditions
            LSOutletAirEnthalpy = InletAirEnthalpy - hDelta;
            hTinwout = InletAirEnthalpy - (1.0 - SHRLS) * hDelta;
            LSOutletAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout, RoutineName);
            LSOutletAirDryBulbTemp = PsyTdbFnHW(LSOutletAirEnthalpy, LSOutletAirHumRat);
            OutletAirDryBulbTempSat = PsyTsatFnHPb(state, LSOutletAirEnthalpy, OutdoorPressure, RoutineName);
            if (LSOutletAirDryBulbTemp < OutletAirDryBulbTempSat) { // Limit to saturated conditions at OutletAirEnthalpy
                LSOutletAirDryBulbTemp = OutletAirDryBulbTempSat;
                LSOutletAirHumRat = PsyWFnTdbH(state, LSOutletAirDryBulbTemp, LSOutletAirEnthalpy, RoutineName);
            }

            // get high speed total capacity and SHR at current conditions

            CalcTotCapSHR(state,
                          InletAirDryBulbTemp,
                          InletAirHumRat,
                          InletAirEnthalpy,
                          InletAirWetBulbC,
                          AirMassFlowRatioHS,
                          MSHPMassFlowRateHigh,
                          thisDXCoil.MSRatedTotCap(SpeedNumHS),
                          CBFHS,
                          thisDXCoil.MSCCapFTemp(SpeedNumHS),
                          thisDXCoil.MSCCapFFlow(SpeedNumHS),
                          TotCapHS,
                          SHRHS,
                          CondInletTemp,
                          OutdoorPressure,
                          thisDXCoil.capModFacTotal);
            hDelta = TotCapHS / MSHPMassFlowRateHigh;
            // Calculate new apparatus dew point conditions
            hADP = InletAirEnthalpy - hDelta / (1.0 - CBFHS);
            tADP = PsyTsatFnHPb(state, hADP, OutdoorPressure, RoutineName);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  tADP = PsyTsatFnHPb(hADP,InletAirPressure)
            wADP = PsyWFnTdbH(state, tADP, hADP, RoutineName);
            hTinwADP = PsyHFnTdbW(InletAirDryBulbTemp, wADP);
            // get corresponding SHR
            if ((InletAirEnthalpy - hADP) > 1.e-10) {
                SHRHS = min((hTinwADP - hADP) / (InletAirEnthalpy - hADP), 1.0);
            } else {
                SHRHS = 1.0;
            }
            // cr8918    SHRHS = MIN((hTinwADP-hADP)/(InletAirEnthalpy-hADP),1.0d0)
            // get the part load factor that will account for cycling losses
            PLF = CurveValue(state, thisDXCoil.MSPLFFPLR(SpeedNumHS), SpeedRatio);
            if (PLF < 0.7) {
                PLF = 0.7;
            }
            // calculate the run time fraction
            thisDXCoil.CoolingCoilRuntimeFraction = SpeedRatio / PLF;
            thisDXCoil.PartLoadRatio = SpeedRatio;

            if (thisDXCoil.CoolingCoilRuntimeFraction > 1.0) {
                thisDXCoil.CoolingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
            }

            // get high speed outlet conditions
            HSOutletAirEnthalpy = InletAirEnthalpy - hDelta;
            hTinwout = InletAirEnthalpy - (1.0 - SHRHS) * hDelta;
            HSOutletAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout, RoutineName);
            HSOutletAirDryBulbTemp = PsyTdbFnHW(HSOutletAirEnthalpy, HSOutletAirHumRat);
            OutletAirDryBulbTempSat = PsyTsatFnHPb(state, HSOutletAirEnthalpy, OutdoorPressure, RoutineName);
            if (HSOutletAirDryBulbTemp < OutletAirDryBulbTempSat) { // Limit to saturated conditions at OutletAirEnthalpy
                HSOutletAirDryBulbTemp = OutletAirDryBulbTempSat;
                HSOutletAirHumRat = PsyWFnTdbH(state, HSOutletAirDryBulbTemp, HSOutletAirEnthalpy, RoutineName);
            }

            //  If constant fan with cycling compressor, call function to determine "effective SHR"
            //  which includes the part-load degradation on latent capacity
            if (thisDXCoil.LatentImpact && fanOp == HVAC::FanOp::Continuous && SpeedRatio > 0.0) {
                QLatRated = thisDXCoil.MSRatedTotCap(SpeedNumHS) * (1.0 - thisDXCoil.MSRatedSHR(SpeedNumHS));
                QLatActual = TotCapHS * (1.0 - SHRHS);
                SHRUnadjusted = SHRHS;
                SHR = CalcEffectiveSHR(state,
                                       DXCoilNum,
                                       SHRHS,
                                       thisDXCoil.CoolingCoilRuntimeFraction,
                                       QLatRated,
                                       QLatActual,
                                       InletAirDryBulbTemp,
                                       InletAirWetBulbC,
                                       SpeedNumHS);
                // Calculate full load output conditions
                if (SHR > 1.0) SHR = 1.0;
                hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                if (SHR < 1.0) {
                    HSOutletAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout, RoutineName);
                } else {
                    HSOutletAirHumRat = InletAirHumRat;
                }
                HSOutletAirDryBulbTemp = PsyTdbFnHW(HSOutletAirEnthalpy, HSOutletAirHumRat);
            }

            // get high speed EIR at current conditions
            EIRTempModFacHS = CurveValue(state, thisDXCoil.MSEIRFTemp(SpeedNumHS), InletAirWetBulbC, CondInletTemp);
            EIRFlowModFacHS = CurveValue(state, thisDXCoil.MSEIRFFlow(SpeedNumHS), AirMassFlowRatioHS);
            EIRHS = 1.0 / thisDXCoil.MSRatedCOP(SpeedNumHS) * EIRFlowModFacHS * EIRTempModFacHS;
            // get low speed EIR at current conditions
            EIRTempModFacLS = CurveValue(state, thisDXCoil.MSEIRFTemp(SpeedNumLS), InletAirWetBulbC, CondInletTemp);
            EIRFlowModFacLS = CurveValue(state, thisDXCoil.MSEIRFFlow(SpeedNumLS), AirMassFlowRatioLS);
            EIRLS = 1.0 / thisDXCoil.MSRatedCOP(SpeedNumLS) * EIRTempModFacLS * EIRFlowModFacLS;

            // get current total capacity, SHR, EIR
            if (SpeedRatio >= 1.0) {
                SHR = SHRHS;
                EIR = EIRHS;
                CondAirMassFlow = RhoAir * thisDXCoil.MSEvapCondAirFlow(SpeedNumHS);
                EvapCondPumpElecPower = thisDXCoil.MSEvapCondPumpElecNomPower(SpeedNumHS);
            } else {
                EIR = SpeedRatio * EIRHS + (1.0 - SpeedRatio) * EIRLS;
                SHR = SpeedRatio * SHRHS + (1.0 - SpeedRatio) * SHRLS;
                CondAirMassFlow =
                    RhoAir * (SpeedRatio * thisDXCoil.MSEvapCondAirFlow(SpeedNumHS) + (1.0 - SpeedRatio) * thisDXCoil.MSEvapCondAirFlow(SpeedNumLS));
                EvapCondPumpElecPower = SpeedRatio * thisDXCoil.MSEvapCondPumpElecNomPower(SpeedNumHS) +
                                        (1.0 - SpeedRatio) * thisDXCoil.MSEvapCondPumpElecNomPower(SpeedNumLS);
            }

            // Outlet calculation
            Real64 SensibleOutputLS(0.0); // low speed sensible output rate
            Real64 LatentOutputLS(0.0);   // low speed latent output rate
            Real64 TotalOutputLS(0.0);    // low speed total output rate
            Real64 SensibleOutputHS(0.0); // high speed sensible output rate
            Real64 LatentOutputHS(0.0);   // high speed latent output rate
            Real64 TotalOutputHS(0.0);    // high speed total output rate
            CalcComponentSensibleLatentOutput(MSHPMassFlowRateLow,
                                              InletAirDryBulbTemp,
                                              InletAirHumRat,
                                              LSOutletAirDryBulbTemp,
                                              LSOutletAirHumRat,
                                              SensibleOutputLS,
                                              LatentOutputLS,
                                              TotalOutputLS);
            CalcComponentSensibleLatentOutput(MSHPMassFlowRateHigh,
                                              InletAirDryBulbTemp,
                                              InletAirHumRat,
                                              HSOutletAirDryBulbTemp,
                                              HSOutletAirHumRat,
                                              SensibleOutputHS,
                                              LatentOutputHS,
                                              TotalOutputHS);
            thisDXCoil.TotalCoolingEnergyRate = TotalOutputHS * SpeedRatio + TotalOutputLS * (1.0 - SpeedRatio);
            thisDXCoil.SensCoolingEnergyRate = SensibleOutputHS * SpeedRatio + SensibleOutputLS * (1.0 - SpeedRatio);
            thisDXCoil.LatCoolingEnergyRate = LatentOutputHS * SpeedRatio + LatentOutputLS * (1.0 - SpeedRatio);
            // Average outlet enthalpy
            OutletAirEnthalpy = InletAirEnthalpy - thisDXCoil.TotalCoolingEnergyRate / thisDXCoil.InletAirMassFlowRate;

            if (fanOp == HVAC::FanOp::Cycling) state.dataHVACGlobal->OnOffFanPartLoadFraction = 1.0;
            // Update outlet conditions
            if (SpeedRatio == 0.0 && fanOp == HVAC::FanOp::Cycling) {
                OutletAirEnthalpy = LSOutletAirEnthalpy;
                OutletAirHumRat = LSOutletAirHumRat;
                OutletAirDryBulbTemp = LSOutletAirDryBulbTemp;
            } else if (SpeedRatio >= 1.0 && fanOp == HVAC::FanOp::Cycling) {
                OutletAirEnthalpy = HSOutletAirEnthalpy;
                OutletAirHumRat = HSOutletAirHumRat;
                OutletAirDryBulbTemp = HSOutletAirDryBulbTemp;
            } else {
                OutletAirHumRat =
                    ((HSOutletAirHumRat * SpeedRatio * MSHPMassFlowRateHigh) + (LSOutletAirHumRat * (1.0 - SpeedRatio) * MSHPMassFlowRateLow)) /
                    thisDXCoil.InletAirMassFlowRate;
                OutletAirDryBulbTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
                if (OutletAirDryBulbTemp < OutletAirDryBulbTempSat) { // Limit to saturated conditions at OutletAirEnthalpy
                    OutletAirDryBulbTemp = OutletAirDryBulbTempSat;
                    OutletAirHumRat = PsyWFnTdbH(state, OutletAirDryBulbTemp, OutletAirEnthalpy, RoutineName);
                    CalcComponentSensibleLatentOutput(AirMassFlow,
                                                      InletAirDryBulbTemp,
                                                      InletAirHumRat,
                                                      OutletAirDryBulbTemp,
                                                      OutletAirHumRat,
                                                      thisDXCoil.SensCoolingEnergyRate,
                                                      thisDXCoil.LatCoolingEnergyRate,
                                                      thisDXCoil.TotalCoolingEnergyRate);
                }
            }

            LSElecCoolingPower = TotCapLS * EIRLS;
            HSElecCoolingPower = TotCapHS * EIRHS;

            // Power calculation
            if (!thisDXCoil.PLRImpact) {
                thisDXCoil.ElecCoolingPower = SpeedRatio * HSElecCoolingPower + (1.0 - SpeedRatio) * LSElecCoolingPower;
            } else {
                thisDXCoil.ElecCoolingPower =
                    thisDXCoil.CoolingCoilRuntimeFraction * HSElecCoolingPower + (1.0 - thisDXCoil.CoolingCoilRuntimeFraction) * LSElecCoolingPower;
            }
            // Now reset runtime fraction to 1.0 (because LS is running the full timestep)
            thisDXCoil.CoolingCoilRuntimeFraction = 1.0;

            //   Calculation for heat reclaim needs to be corrected to use compressor power (not including condenser fan power)
            state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = thisDXCoil.TotalCoolingEnergyRate + thisDXCoil.ElecCoolingPower;

            // Waste heat calculation
            // TODO: waste heat not considered even if defined in Cooling:DX:MultiSpeed, N16, \field Speed 1 Rated Waste Heat Fraction of
            // Power Input
            if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {
                if (thisDXCoil.MSWasteHeat(SpeedNumLS) == 0) {
                    WasteHeatLS = thisDXCoil.MSWasteHeatFrac(SpeedNumLS);
                } else {
                    WasteHeatLS = CurveValue(state, thisDXCoil.MSWasteHeat(SpeedNumLS), OutdoorDryBulb, InletAirDryBulbTemp) *
                                  thisDXCoil.MSWasteHeatFrac(SpeedNumLS);
                }
                if (thisDXCoil.MSWasteHeat(SpeedNumHS) == 0) {
                    WasteHeatHS = thisDXCoil.MSWasteHeatFrac(SpeedNumHS);
                } else {
                    WasteHeatHS = CurveValue(state, thisDXCoil.MSWasteHeat(SpeedNumHS), OutdoorDryBulb, InletAirDryBulbTemp) *
                                  thisDXCoil.MSWasteHeatFrac(SpeedNumHS);
                }
                thisDXCoil.MSFuelWasteHeat = (SpeedRatio * WasteHeatHS + (1.0 - SpeedRatio) * WasteHeatLS) * thisDXCoil.ElecCoolingPower;
                if (thisDXCoil.MSHPHeatRecActive) {
                    MSHPWasteHeat = thisDXCoil.MSFuelWasteHeat;
                }
            }

            // Energy use for other fuel types
            if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {
                thisDXCoil.FuelUsed = thisDXCoil.ElecCoolingPower;
                thisDXCoil.ElecCoolingPower = 0.0;
            }

            thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;
            thisDXCoil.OutletAirHumRat = OutletAirHumRat;
            thisDXCoil.OutletAirTemp = OutletAirDryBulbTemp;
            thisDXCoil.CrankcaseHeaterPower = 0.0;

        } else if (CycRatio > 0.0) {

            if (fanOp == HVAC::FanOp::Cycling) AirMassFlow /= CycRatio;
            if (fanOp == HVAC::FanOp::Continuous) AirMassFlow = MSHPMassFlowRateHigh;

            // Check for valid air volume flow per rated total cooling capacity (200 - 500 cfm/ton) at low speed
            AirVolumeFlowRate = MSHPMassFlowRateHigh / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat, RoutineName);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  AirVolumeFlowRate = AirMassFlow/PsyRhoAirFnPbTdbW(InletAirPressure,InletAirDryBulbTemp, InletAirHumRat)
            VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.MSRatedTotCap(SpeedNum);
            if (((VolFlowperRatedTotCap < HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) ||
                 (VolFlowperRatedTotCap > HVAC::MaxCoolVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT])) &&
                state.dataHVACGlobal->MSUSEconoSpeedNum == 0) {
                if (thisDXCoil.MSErrIndex(SpeedNum) == 0) {
                    ShowWarningMessage(
                        state,
                        format("{} \"{}\" - Air volume flow rate per watt of rated total cooling capacity is out of range at speed {}.",
                               thisDXCoil.DXCoilType,
                               thisDXCoil.Name,
                               SpeedNum));
                    ShowContinueErrorTimeStamp(state, "");
                    ShowContinueError(state,
                                      format("Expected range for VolumeFlowPerRatedTotalCapacity=[{:.3R}--{:.3R}] Current value is {:.3R} m3/s/W",
                                             HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             HVAC::MaxCoolVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             VolFlowperRatedTotCap));
                    ShowContinueError(state, "Possible causes include inconsistent air flow rates in system components or");
                    ShowContinueError(state, "inconsistent supply air fan operation modes in coil and unitary system objects.");
                }
                ShowRecurringWarningErrorAtEnd(state,
                                               format("{} \"{}\" - Air volume flow rate per watt of rated total cooling capacity is out of range "
                                                      "at speed {} error continues...",
                                                      thisDXCoil.DXCoilType,
                                                      thisDXCoil.Name,
                                                      SpeedNumHS),
                                               thisDXCoil.MSErrIndex(SpeedNumHS),
                                               VolFlowperRatedTotCap,
                                               VolFlowperRatedTotCap);
            }

            if (thisDXCoil.CondenserType(SpeedNum) == DataHeatBalance::RefrigCondenserType::Evap) {
                // Outdoor wet-bulb temp from DataEnvironment + (1.0-EvapCondEffectiveness) * (drybulb - wetbulb)
                CondInletTemp = OutdoorWetBulb + (OutdoorDryBulb - OutdoorWetBulb) * (1.0 - thisDXCoil.MSEvapCondEffect(SpeedNum));
                CondInletHumRat = PsyWFnTdbTwbPb(state, CondInletTemp, OutdoorWetBulb, OutdoorPressure, RoutineName);
            }

            RatedCBFLS = thisDXCoil.MSRatedCBF(SpeedNum);
            CBFLS = AdjustCBF(RatedCBFLS, thisDXCoil.MSRatedAirMassFlowRate(SpeedNum), MSHPMassFlowRateHigh);

            // Adjust low speed coil bypass factor for actual flow rate.
            // CBF = AdjustCBF(DXCoil(DXCoilNum)%RatedCBF2,DXCoil(DXCoilNum)%RatedAirMassFlowRate2,AirMassFlow)
            // get low speed total capacity and SHR at current conditions
            CalcTotCapSHR(state,
                          InletAirDryBulbTemp,
                          InletAirHumRat,
                          InletAirEnthalpy,
                          InletAirWetBulbC,
                          AirMassFlowRatioLS,
                          MSHPMassFlowRateHigh,
                          thisDXCoil.MSRatedTotCap(SpeedNum),
                          CBFLS,
                          thisDXCoil.MSCCapFTemp(SpeedNum),
                          thisDXCoil.MSCCapFFlow(SpeedNum),
                          TotCapLS,
                          SHRLS,
                          CondInletTemp,
                          OutdoorPressure,
                          thisDXCoil.capModFacTotal);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  Node(DXCoil(DXCoilNum)%AirInNode)%Press)
            hDelta = TotCapLS / AirMassFlow;
            // Adjust CBF for off-nominal flow
            CBF = AdjustCBF(thisDXCoil.MSRatedCBF(SpeedNum), thisDXCoil.MSRatedAirMassFlowRate(SpeedNum), AirMassFlow);
            // Calculate new apparatus dew point conditions
            hADP = InletAirEnthalpy - hDelta / (1.0 - CBF);
            tADP = PsyTsatFnHPb(state, hADP, OutdoorPressure, RoutineName);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  tADP = PsyTsatFnHPb(hADP,InletAirPressure)
            wADP = PsyWFnTdbH(state, tADP, hADP, RoutineName);
            hTinwADP = PsyHFnTdbW(InletAirDryBulbTemp, wADP);
            // get corresponding SHR
            if ((InletAirEnthalpy - hADP) > 1.e-10) {
                SHR = min((hTinwADP - hADP) / (InletAirEnthalpy - hADP), 1.0);
            } else {
                SHR = 1.0;
            }
            // cr8918    SHR = MIN((hTinwADP-hADP)/(InletAirEnthalpy-hADP),1.0d0)

            // get the part load factor that will account for cycling losses
            PLF = CurveValue(state, thisDXCoil.MSPLFFPLR(SpeedNum), CycRatio);
            if (fanOp == HVAC::FanOp::Cycling && CycRatio == 1.0 && PLF != 1.0) {
                if (thisDXCoil.PLFErrIndex == 0) {
                    ShowWarningMessage(state,
                                       format("The PLF curve value for DX cooling coil {} ={:.2R} for part-load ratio = 1", thisDXCoil.Name, PLF));
                    ShowContinueError(state, "PLF curve value must be = 1.0 and has been reset to 1.0. Simulation is continuing.");
                    ShowContinueErrorTimeStamp(state, "");
                }
                ShowRecurringWarningErrorAtEnd(
                    state, thisDXCoil.Name + "\": DX cooling coil PLF curve value <> 1.0 warning continues...", thisDXCoil.PLFErrIndex, PLF, PLF);
                PLF = 1.0;
            }

            if (PLF < 0.7) {
                PLF = 0.7;
            }
            // calculate the run time fraction
            thisDXCoil.CoolingCoilRuntimeFraction = CycRatio / PLF;
            thisDXCoil.PartLoadRatio = CycRatio;

            if (thisDXCoil.CoolingCoilRuntimeFraction > 1.0) {
                thisDXCoil.CoolingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
            }

            // get low speed outlet conditions
            LSOutletAirEnthalpy = InletAirEnthalpy - hDelta;
            hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
            LSOutletAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout, RoutineName);
            LSOutletAirDryBulbTemp = PsyTdbFnHW(LSOutletAirEnthalpy, LSOutletAirHumRat);
            OutletAirDryBulbTempSat = PsyTsatFnHPb(state, LSOutletAirEnthalpy, OutdoorPressure, RoutineName);
            if (LSOutletAirDryBulbTemp < OutletAirDryBulbTempSat) { // Limit to saturated conditions at OutletAirEnthalpy
                LSOutletAirDryBulbTemp = OutletAirDryBulbTempSat;
                LSOutletAirHumRat = PsyWFnTdbH(state, LSOutletAirDryBulbTemp, LSOutletAirEnthalpy, RoutineName);
            }

            //  If constant fan with cycling compressor, call function to determine "effective SHR"
            //  which includes the part-load degradation on latent capacity
            if (fanOp == HVAC::FanOp::Continuous) {
                QLatRated = thisDXCoil.MSRatedTotCap(SpeedNum) * (1.0 - thisDXCoil.MSRatedSHR(SpeedNum));
                QLatActual = TotCapLS * (1.0 - SHR);
                SHRUnadjusted = SHR;
                SHR = CalcEffectiveSHR(state,
                                       DXCoilNum,
                                       SHR,
                                       thisDXCoil.CoolingCoilRuntimeFraction,
                                       QLatRated,
                                       QLatActual,
                                       InletAirDryBulbTemp,
                                       InletAirWetBulbC,
                                       SpeedNum);
                // Calculate full load output conditions
                if (SHR > 1.0) SHR = 1.0;
                hTinwout = InletAirEnthalpy - (1.0 - SHR) * hDelta;
                if (SHR < 1.0) {
                    LSOutletAirHumRat = PsyWFnTdbH(state, InletAirDryBulbTemp, hTinwout, RoutineName);
                } else {
                    LSOutletAirHumRat = InletAirHumRat;
                }
                LSOutletAirDryBulbTemp = PsyTdbFnHW(LSOutletAirEnthalpy, LSOutletAirHumRat);
            }

            if (fanOp == HVAC::FanOp::Cycling) state.dataHVACGlobal->OnOffFanPartLoadFraction = PLF;
            if (fanOp == HVAC::FanOp::Continuous) {
                // outlet conditions are average of inlet and low speed weighted by CycRatio
                // Continuous fan, cycling compressor
                Real64 CycAirFlowRatio =
                    CycRatio * AirMassFlow / thisDXCoil.InletAirMassFlowRate; // ratio of compressor on airflow to average timestep airflow
                OutletAirEnthalpy = CycAirFlowRatio * LSOutletAirEnthalpy + (1.0 - CycAirFlowRatio) * InletAirEnthalpy;
                OutletAirHumRat = CycAirFlowRatio * LSOutletAirHumRat + (1.0 - CycAirFlowRatio) * InletAirHumRat;
                OutletAirDryBulbTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
            } else {
                OutletAirHumRat = LSOutletAirHumRat;
                OutletAirDryBulbTemp = LSOutletAirDryBulbTemp;
                OutletAirEnthalpy = LSOutletAirEnthalpy;
            }

            // get low speed EIR at current conditions
            EIRTempModFacLS = CurveValue(state, thisDXCoil.MSEIRFTemp(SpeedNum), InletAirWetBulbC, CondInletTemp);
            EIRFlowModFacLS = CurveValue(state, thisDXCoil.MSEIRFFlow(SpeedNum), AirMassFlowRatioLS);
            EIRLS = 1.0 / thisDXCoil.MSRatedCOP(SpeedNum) * EIRTempModFacLS * EIRFlowModFacLS;

            // get the electrical power consumption
            thisDXCoil.ElecCoolingPower = TotCapLS * EIRLS * thisDXCoil.CoolingCoilRuntimeFraction;
            // calculate cooling output power
            //    AirMassFlow = DXCoil(DXCoilNum)%InletAirMassFlowRate
            CalcComponentSensibleLatentOutput(AirMassFlow,
                                              InletAirDryBulbTemp,
                                              InletAirHumRat,
                                              LSOutletAirDryBulbTemp,
                                              LSOutletAirHumRat,
                                              thisDXCoil.SensCoolingEnergyRate,
                                              thisDXCoil.LatCoolingEnergyRate,
                                              thisDXCoil.TotalCoolingEnergyRate);
            thisDXCoil.TotalCoolingEnergyRate = thisDXCoil.TotalCoolingEnergyRate * CycRatio;
            thisDXCoil.SensCoolingEnergyRate = thisDXCoil.SensCoolingEnergyRate * CycRatio;
            thisDXCoil.LatCoolingEnergyRate = thisDXCoil.LatCoolingEnergyRate * CycRatio;

            //   Calculation for heat reclaim needs to be corrected to use compressor power (not including condenser fan power)
            state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = thisDXCoil.TotalCoolingEnergyRate + thisDXCoil.ElecCoolingPower;
            thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;
            thisDXCoil.OutletAirHumRat = OutletAirHumRat;
            thisDXCoil.OutletAirTemp = OutletAirDryBulbTemp;
            CondAirMassFlow = RhoAir * thisDXCoil.MSEvapCondAirFlow(SpeedNum) * thisDXCoil.CoolingCoilRuntimeFraction;
            EvapCondPumpElecPower = thisDXCoil.MSEvapCondPumpElecNomPower(SpeedNum) * thisDXCoil.CoolingCoilRuntimeFraction;

            // Waste heat
            if (thisDXCoil.MSHPHeatRecActive) {
                if (thisDXCoil.MSWasteHeat(SpeedNum) == 0) {
                    thisDXCoil.MSFuelWasteHeat = thisDXCoil.MSWasteHeatFrac(SpeedNum) * thisDXCoil.ElecCoolingPower;
                } else {
                    thisDXCoil.MSFuelWasteHeat = CurveValue(state, thisDXCoil.MSWasteHeat(SpeedNum), OutdoorDryBulb, InletAirDryBulbTemp) *
                                                 thisDXCoil.MSWasteHeatFrac(SpeedNum) * thisDXCoil.ElecCoolingPower;
                }
                if (thisDXCoil.MSHPHeatRecActive) {
                    MSHPWasteHeat = thisDXCoil.MSFuelWasteHeat;
                }
            }
            // Energy use for other fuel types
            if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {
                thisDXCoil.FuelUsed = thisDXCoil.ElecCoolingPower;
                thisDXCoil.ElecCoolingPower = 0.0;
            }

            if (thisDXCoil.CompanionUpstreamDXCoil == 0) {
                thisDXCoil.CrankcaseHeaterPower = CrankcaseHeatingPower * (1.0 - thisDXCoil.CoolingCoilRuntimeFraction);
            } else {
                thisDXCoil.CrankcaseHeaterPower =
                    CrankcaseHeatingPower * (1.0 - max(thisDXCoil.CoolingCoilRuntimeFraction,
                                                       state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).HeatingCoilRuntimeFraction));
            }
        }

        if (thisDXCoil.CondenserType(DXMode) == DataHeatBalance::RefrigCondenserType::Evap) {
            //******************
            //             WATER CONSUMPTION IN m3 OF WATER FOR DIRECT
            //             H2O [m3/s] = Delta W[kgWater/kgDryAir]*Mass Flow Air[kgDryAir/s]
            //                                /RhoWater [kgWater/m3]
            //******************
            RhoWater = RhoH2O(OutdoorDryBulb);
            thisDXCoil.EvapWaterConsumpRate = (CondInletHumRat - OutdoorHumRat) * CondAirMassFlow / RhoWater;
            thisDXCoil.EvapCondPumpElecPower = EvapCondPumpElecPower;
            // set water system demand request (if needed)
            if (thisDXCoil.EvapWaterSupplyMode == EvapWaterSupply::FromTank) {
                state.dataWaterData->WaterStorage(thisDXCoil.EvapWaterSupTankID).VdotRequestDemand(thisDXCoil.EvapWaterTankDemandARRID) =
                    thisDXCoil.EvapWaterConsumpRate;
            }

            // Calculate basin heater power
            CalcBasinHeaterPower(state,
                                 thisDXCoil.BasinHeaterPowerFTempDiff,
                                 thisDXCoil.BasinHeaterSchedulePtr,
                                 thisDXCoil.BasinHeaterSetPointTemp,
                                 thisDXCoil.BasinHeaterPower);
            thisDXCoil.BasinHeaterPower *= (1.0 - thisDXCoil.CoolingCoilRuntimeFraction);
        }

    } else {

        // DX coil is off; just pass through conditions
        thisDXCoil.OutletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
        thisDXCoil.OutletAirHumRat = thisDXCoil.InletAirHumRat;
        thisDXCoil.OutletAirTemp = thisDXCoil.InletAirTemp;

        thisDXCoil.FuelUsed = 0.0;
        thisDXCoil.ElecCoolingPower = 0.0;
        thisDXCoil.TotalCoolingEnergyRate = 0.0;
        thisDXCoil.SensCoolingEnergyRate = 0.0;
        thisDXCoil.LatCoolingEnergyRate = 0.0;
        thisDXCoil.EvapCondPumpElecPower = 0.0;
        thisDXCoil.EvapWaterConsumpRate = 0.0;

        if (thisDXCoil.CompanionUpstreamDXCoil == 0) {
            thisDXCoil.CrankcaseHeaterPower = CrankcaseHeatingPower;
        } else {
            thisDXCoil.CrankcaseHeaterPower =
                CrankcaseHeatingPower * (1.0 - state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).HeatingCoilRuntimeFraction);
        }

        // Calculate basin heater power
        if (thisDXCoil.CondenserType(DXMode) == DataHeatBalance::RefrigCondenserType::Evap) {
            CalcBasinHeaterPower(state,
                                 thisDXCoil.BasinHeaterPowerFTempDiff,
                                 thisDXCoil.BasinHeaterSchedulePtr,
                                 thisDXCoil.BasinHeaterSetPointTemp,
                                 thisDXCoil.BasinHeaterPower);
        }
    }

    state.dataDXCoils->DXCoilOutletTemp(DXCoilNum) = thisDXCoil.OutletAirTemp;
    state.dataDXCoils->DXCoilOutletHumRat(DXCoilNum) = thisDXCoil.OutletAirHumRat;
    state.dataDXCoils->DXCoilPartLoadRatio(DXCoilNum) = thisDXCoil.PartLoadRatio;
    state.dataDXCoils->DXCoilFanOp(DXCoilNum) = fanOp;
    thisDXCoil.CondInletTemp = CondInletTemp; // Save condenser inlet temp in the data structure

    // set outlet node conditions
    int airOutletNode = thisDXCoil.AirOutNode;
    state.dataLoopNodes->Node(airOutletNode).Temp = thisDXCoil.OutletAirTemp;
    state.dataLoopNodes->Node(airOutletNode).HumRat = thisDXCoil.OutletAirHumRat;

    // calc secondary coil if specified
    if (thisDXCoil.IsSecondaryDXCoilInZone) {
        CalcSecondaryDXCoils(state, DXCoilNum);
    }
}

void CalcMultiSpeedDXCoilHeating(EnergyPlusData &state,
                                 int const DXCoilNum,     // the number of the DX heating coil to be simulated
                                 Real64 const SpeedRatio, // = (CompressorSpeed - CompressorSpeedMin) / (CompressorSpeedMax - CompressorSpeedMin)
                                 Real64 const CycRatio,   // cycling part load ratio
                                 int const SpeedNum,      // Speed number
                                 HVAC::FanOp const fanOp, // Fan operation mode
                                 int const SingleMode     // Single mode operation Yes/No; 1=Yes, 0=No
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Lixing Gu, FSEC
    //       DATE WRITTEN   June 2007
    //       RE-ENGINEERED  Revised based on CalcDXHeatingCoil

    // PURPOSE OF THIS SUBROUTINE:
    // Calculates the air-side performance and electrical energy use of a direct-
    // expansion, air-cooled cooling unit with a multispeed compressor.

    // METHODOLOGY EMPLOYED:
    // Uses the same methodology as the single speed DX heating unit model (SUBROUTINE CalcDXHeatingCoil).
    // In addition it assumes that the unit performance is obtained by interpolating between
    // the performance at high speed and that at low speed. If the output needed is below
    // that produced at low speed, the compressor cycles between off and low speed.

    // Using/Aliasing
    using Curve::CurveValue;
    Real64 MSHPMassFlowRateHigh = state.dataHVACGlobal->MSHPMassFlowRateHigh;
    Real64 MSHPMassFlowRateLow = state.dataHVACGlobal->MSHPMassFlowRateLow;
    auto &MSHPWasteHeat = state.dataHVACGlobal->MSHPWasteHeat;

    // SUBROUTINE ARGUMENT DEFINITIONS:
    // SpeedRatio varies between 1.0 (maximum speed) and 0.0 (minimum speed)

    // SUBROUTINE PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineName("CalcMultiSpeedDXCoilHeating");
    static constexpr std::string_view RoutineNameAverageLoad("CalcMultiSpeedDXCoilHeating:Averageload");
    static constexpr std::string_view RoutineNameFullLoad("CalcMultiSpeedDXCoilHeating:fullload");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 AirMassFlow;         // dry air mass flow rate through coil [kg/s]
    Real64 InletAirWetBulbC;    // wetbulb temperature of inlet air [C]
    Real64 InletAirDryBulbTemp; // inlet air dry bulb temperature [C]
    Real64 InletAirEnthalpy;    // inlet air enthalpy [J/kg]
    Real64 InletAirHumRat;      // inlet air humidity ratio [kg/kg]
    Real64 OutletAirEnthalpy;   // outlet air enthalpy [J/kg]
    Real64 OutletAirHumRat;     // outlet air humidity ratio [kg/kg]
    Real64 TotCapHS;            // total capacity at high speed [W]
    Real64 TotCapLS;            // total capacity at low speed [W]
    Real64 TotCapHSAdj;         // total adjusted capacity at high speed [W]
    Real64 TotCapLSAdj;         // total adjusted capacity at low speed [W]
    Real64 EIRHS;               // EIR at off rated conditions (high speed)
    Real64 EIRLS;               // EIR at off rated conditions (low speed)
    Real64 TotCap;              // total capacity at current speed [W]
    Real64 TotCapAdj;           // total adjusted capacity at current speed [W]
    Real64 EIR;                 // EIR at current speed
    Real64 PLF;                 // Part load factor, accounts for thermal lag at compressor startup, used in
    // power calculation
    Real64 OutdoorDryBulb;            // Outdoor dry-bulb temperature at condenser (C)
    Real64 OutdoorHumRat;             // Outdoor humidity ratio at condenser (kg/kg)
    Real64 OutdoorPressure;           // Outdoor barometric pressure at condenser (Pa)
    int SpeedNumHS;                   // High speed number
    int SpeedNumLS;                   // Low speed number
    Real64 AirMassFlowRatioLS;        // airflow ratio at low speed
    Real64 AirMassFlowRatioHS;        // airflow ratio at high speed
    Real64 AirFlowRatio;              // Airflow ratio
    Real64 PLRHeating;                // Part load ratio in heating
    Real64 CrankcaseHeatingPower;     // Power due to crank case heater
    Real64 AirVolumeFlowRate;         // Air volume flow rate across the heating coil
    Real64 VolFlowperRatedTotCap;     // Air volume flow rate divided by rated total heating capacity
    Real64 TotCapTempModFac(0.0);     // Total capacity modifier as a function of temperature
    Real64 TotCapFlowModFac;          // Total capacity modifier as a function of flow ratio
    Real64 OutdoorCoilT;              // Outdoor coil temperature
    Real64 OutdoorCoildw;             // Outdoor coil delta w assuming coil temperature of OutdoorCoilT
    Real64 LoadDueToDefrost;          // Additional load due to defrost
    Real64 LoadDueToDefrostLS;        // Additional load due to defrost at low speed
    Real64 LoadDueToDefrostHS;        // Additional load due to defrost at high speed
    Real64 HeatingCapacityMultiplier; // Multiplier for heating capacity when system is in defrost
    Real64 FractionalDefrostTime;     // Fraction of time step when system is in defrost
    Real64 InputPowerMultiplier;      // Multiplier for power when system is in defrost
    Real64 DefrostEIRTempModFac;      // EIR modifier for defrost
    Real64 FullLoadOutAirEnth;        // Outlet full load enthalpy
    Real64 FullLoadOutAirHumRat;      // Outlet humidity ratio at full load
    Real64 FullLoadOutAirTemp;        // Outlet temperature at full load
    Real64 FullLoadOutAirRH;          // Outlet relative humidity at full load
    Real64 OutletAirTemp;             // Supply air temperature
    Real64 EIRTempModFac(0.0);        // EIR modifier as a function of temperature
    Real64 EIRFlowModFac;             // EIR modifier as a function of airflow ratio
    Real64 WasteHeatLS;               // Waste heat at low speed
    Real64 WasteHeatHS;               // Waste heat at high speed
    Real64 LSFullLoadOutAirEnth;      // Outlet full load enthalpy at low speed
    Real64 HSFullLoadOutAirEnth;      // Outlet full load enthalpy at high speed
    Real64 LSElecHeatingPower;        // Full load power at low speed
    Real64 HSElecHeatingPower;        // Full load power at high speed
    Real64 DefrostPowerLS;            // Defrost power at low speed [W]
    Real64 DefrostPowerHS;            // Defrost power at high speed [W]

    // Autodesk:Uninit Initialize variables used uninitialized
    FullLoadOutAirEnth = 0.0; // Autodesk:Uninit Force default initialization

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    if (SpeedNum > 1) {
        SpeedNumLS = SpeedNum - 1;
        SpeedNumHS = SpeedNum;
        if (SpeedNum > thisDXCoil.NumOfSpeeds) {
            SpeedNumLS = thisDXCoil.NumOfSpeeds - 1;
            SpeedNumHS = thisDXCoil.NumOfSpeeds;
        }
    } else {
        SpeedNumLS = 1;
        SpeedNumHS = 1;
    }

    AirMassFlow = thisDXCoil.InletAirMassFlowRate;
    AirMassFlowRatioLS = MSHPMassFlowRateLow / thisDXCoil.MSRatedAirMassFlowRate(SpeedNumLS);
    AirMassFlowRatioHS = MSHPMassFlowRateHigh / thisDXCoil.MSRatedAirMassFlowRate(SpeedNumHS);
    if ((AirMassFlow > 0.0) && (CycRatio > 0.0) && (MSHPMassFlowRateHigh == 0.0)) {
        ShowSevereError(
            state,
            format("CalcMultiSpeedDXCoilHeating: {} \"{} Developer error - inconsistent airflow rates.", thisDXCoil.DXCoilType, thisDXCoil.Name));
        if (MSHPMassFlowRateLow == 0.0 && SpeedNum > 1) {
            ShowContinueError(state,
                              "When AirMassFlow > 0.0 and CycRatio > 0.0 and SpeedNum > 1, then MSHPMassFlowRateLow and MSHPMassFlowRateHigh "
                              "must also be > 0.0");
            ShowContinueErrorTimeStamp(state, "");
            ShowContinueError(state,
                              format("AirMassFlow={:.3R},CycRatio={:.3R},SpeedNum={:.0R}, MSHPMassFlowRateLow={:.3R}, MSHPMassFlowRateHigh={:.3R}",
                                     AirMassFlow,
                                     double(SpeedNum),
                                     CycRatio,
                                     MSHPMassFlowRateLow,
                                     MSHPMassFlowRateHigh));
            ShowFatalError(state, "Preceding condition(s) causes termination.");
        } else {
            ShowContinueError(state, "When AirMassFlow > 0.0 and CycRatio > 0.0, then MSHPMassFlowRateHigh must also be > 0.0");
            ShowContinueErrorTimeStamp(state, "");
            ShowContinueError(state,
                              format("AirMassFlow={:.3R},CycRatio={:.3R}, MSHPMassFlowRateHigh={:.3R}", AirMassFlow, CycRatio, MSHPMassFlowRateHigh));
            ShowFatalError(state, "Preceding condition(s) causes termination.");
        }
    } else if (CycRatio > 1.0 || SpeedRatio > 1.0) {
        ShowSevereError(
            state,
            format("CalcMultiSpeedDXCoilHeating: {} \"{} Developer error - inconsistent speed ratios.", thisDXCoil.DXCoilType, thisDXCoil.Name));
        ShowContinueError(state, "CycRatio and SpeedRatio must be between 0.0 and 1.0");
        ShowContinueErrorTimeStamp(state, "");
        ShowContinueError(state, format("CycRatio={:.1R}, SpeedRatio = {:.1R}", CycRatio, SpeedRatio));
        ShowFatalError(state, "Preceding condition(s) causes termination.");
    }

    AirFlowRatio = 1.0;
    if (thisDXCoil.CompanionUpstreamDXCoil == 0) MSHPWasteHeat = 0.0;

    // Get condenser outdoor node info from DX Heating Coil
    if (thisDXCoil.CondenserInletNodeNum(1) != 0) {
        OutdoorPressure = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).Press;
        // If node is not connected to anything, pressure = default, use weather data
        if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press) {
            OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
            OutdoorHumRat = state.dataEnvrn->OutHumRat;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
        } else {
            OutdoorDryBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).Temp;
            OutdoorHumRat = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).HumRat;
        }
        if (thisDXCoil.IsSecondaryDXCoilInZone) {
            auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
            OutdoorDryBulb = secZoneHB.ZT;
            OutdoorHumRat = secZoneHB.airHumRat;
            // OutdoorWetBulb = DXCoil( DXCoilNum ).EvapInletWetBulb;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
        }
    } else if (thisDXCoil.IsSecondaryDXCoilInZone) {
        auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
        OutdoorDryBulb = secZoneHB.ZT;
        OutdoorHumRat = secZoneHB.airHumRat;
        // OutdoorWetBulb = DXCoil( DXCoilNum ).EvapInletWetBulb;
        OutdoorPressure = state.dataEnvrn->OutBaroPress;
    } else {
        OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
        OutdoorHumRat = state.dataEnvrn->OutHumRat;
        OutdoorPressure = state.dataEnvrn->OutBaroPress;
    }

    InletAirDryBulbTemp = thisDXCoil.InletAirTemp;
    InletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
    InletAirHumRat = thisDXCoil.InletAirHumRat;
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // InletAirPressure = DXCoil(DXCoilNum)%InletAirPressure
    // InletAirWetBulbC = PsyTwbFnTdbWPb(InletAirDryBulbTemp,InletAirHumRat,InletAirPressure)
    InletAirWetBulbC = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRat, OutdoorPressure, RoutineName);
    PLRHeating = 0.0;
    thisDXCoil.HeatingCoilRuntimeFraction = 0.0;
    // Initialize crankcase heater, operates below OAT defined in input deck for HP DX heating coil
    if (OutdoorDryBulb < thisDXCoil.MaxOATCrankcaseHeater) {
        CrankcaseHeatingPower = thisDXCoil.CrankcaseHeaterCapacity;
        if (thisDXCoil.CrankcaseHeaterCapacityCurveIndex > 0) {
            CrankcaseHeatingPower *= Curve::CurveValue(state, thisDXCoil.CrankcaseHeaterCapacityCurveIndex, OutdoorDryBulb);
        }
    } else {
        CrankcaseHeatingPower = 0.0;
    }
    thisDXCoil.PartLoadRatio = 0.0;
    state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = 0.0;

    if ((AirMassFlow > 0.0) && (GetCurrentScheduleValue(state, thisDXCoil.SchedPtr) > 0.0) &&
        ((CycRatio > 0.0) || (SpeedRatio > 0.0 && SingleMode == 0)) && OutdoorDryBulb > thisDXCoil.MinOATCompressor) {

        if (SpeedNum > 1 && SingleMode == 0) {

            // Check for valid air volume flow per rated total cooling capacity (200 - 600 cfm/ton) at low speed
            AirVolumeFlowRate = MSHPMassFlowRateLow / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat, RoutineName);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  AirVolumeFlowRate = AirMassFlow/PsyRhoAirFnPbTdbW(InletAirPressure,InletAirDryBulbTemp, InletAirHumRat)
            VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.MSRatedTotCap(SpeedNumLS);
            if ((VolFlowperRatedTotCap < HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) ||
                (VolFlowperRatedTotCap > HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT])) {
                if (thisDXCoil.MSErrIndex(SpeedNumLS) == 0) {
                    ShowWarningMessage(
                        state,
                        format("{} \"{}\" - Air volume flow rate per watt of rated total heating capacity is out of range at speed {}.",
                               thisDXCoil.DXCoilType,
                               thisDXCoil.Name,
                               SpeedNumLS));
                    ShowContinueErrorTimeStamp(state, "");
                    ShowContinueError(state,
                                      format("Expected range for VolumeFlowPerRatedTotalCapacity=[{:.3R}--{:.3R}] Current value is {:.3R} m3/s/W",
                                             HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             VolFlowperRatedTotCap));
                    ShowContinueError(state, "Possible causes include inconsistent air flow rates in system components or");
                    ShowContinueError(state, "inconsistent supply air fan operation modes in coil and unitary system objects.");
                }
                ShowRecurringWarningErrorAtEnd(state,
                                               format("{} \"{}\" - Air volume flow rate per watt of rated total heating capacity is out of range "
                                                      "at speed {} error continues...",
                                                      thisDXCoil.DXCoilType,
                                                      thisDXCoil.Name,
                                                      SpeedNumLS),
                                               thisDXCoil.MSErrIndex(SpeedNumLS),
                                               VolFlowperRatedTotCap,
                                               VolFlowperRatedTotCap);
            }

            // Check for valid air volume flow per rated total cooling capacity (200 - 600 cfm/ton) at high speed
            AirVolumeFlowRate = MSHPMassFlowRateHigh / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat, RoutineName);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  AirVolumeFlowRate = AirMassFlow/PsyRhoAirFnPbTdbW(InletAirPressure,InletAirDryBulbTemp, InletAirHumRat)
            VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.MSRatedTotCap(SpeedNumHS);
            if ((VolFlowperRatedTotCap < HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) ||
                (VolFlowperRatedTotCap > HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT])) {
                if (thisDXCoil.MSErrIndex(SpeedNumHS) == 0) {
                    ShowWarningMessage(
                        state,
                        format("{} \"{}\" - Air volume flow rate per watt of rated total heating capacity is out of range at speed {}.",
                               thisDXCoil.DXCoilType,
                               thisDXCoil.Name,
                               SpeedNumHS));
                    ShowContinueErrorTimeStamp(state, "");
                    ShowContinueError(state,
                                      format("Expected range for VolumeFlowPerRatedTotalCapacity=[{:.3R}--{:.3R}] Current value is {:.3R} m3/s/W",
                                             HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             VolFlowperRatedTotCap));
                    ShowContinueError(state, "Possible causes include inconsistent air flow rates in system components or");
                    ShowContinueError(state, "inconsistent supply air fan operation modes in coil and unitary system objects.");
                }
                ShowRecurringWarningErrorAtEnd(state,
                                               format("{} \"{}\" - Air volume flow rate per watt of rated total heating capacity is out of range "
                                                      "at speed {} error continues...",
                                                      thisDXCoil.DXCoilType,
                                                      thisDXCoil.Name,
                                                      SpeedNumHS),
                                               thisDXCoil.MSErrIndex(SpeedNumHS),
                                               VolFlowperRatedTotCap,
                                               VolFlowperRatedTotCap);
            }

            // Get total capacity modifying factor (function of temperature) for off-rated conditions
            // Model was extended to accept bi-quadratic curves. This allows sensitivity of the heating capacity
            // to the entering dry-bulb temperature as well as the outside dry-bulb temperature. User is
            // advised to use the bi-quadratic curve if sufficient manufacturer data is available.
            // Low speed
            if (state.dataCurveManager->PerfCurve(thisDXCoil.MSCCapFTemp(SpeedNumLS))->numDims == 1) {
                TotCapTempModFac = CurveValue(state, thisDXCoil.MSCCapFTemp(SpeedNumLS), OutdoorDryBulb);
            } else {
                TotCapTempModFac = CurveValue(state, thisDXCoil.MSCCapFTemp(SpeedNumLS), InletAirDryBulbTemp, OutdoorDryBulb);
            }
            //  Get total capacity modifying factor (function of mass flow) for off-rated conditions
            TotCapFlowModFac = CurveValue(state, thisDXCoil.MSCCapFFlow(SpeedNumLS), AirMassFlowRatioLS);
            // Calculate total heating capacity for off-rated conditions
            TotCapLS = thisDXCoil.MSRatedTotCap(SpeedNumLS) * TotCapFlowModFac * TotCapTempModFac;
            // High speed
            if (state.dataCurveManager->PerfCurve(thisDXCoil.MSCCapFTemp(SpeedNumHS))->numDims == 1) {
                TotCapTempModFac = CurveValue(state, thisDXCoil.MSCCapFTemp(SpeedNumHS), OutdoorDryBulb);
            } else {
                TotCapTempModFac = CurveValue(state, thisDXCoil.MSCCapFTemp(SpeedNumHS), InletAirDryBulbTemp, OutdoorDryBulb);
            }
            //  Get total capacity modifying factor (function of mass flow) for off-rated conditions
            TotCapFlowModFac = CurveValue(state, thisDXCoil.MSCCapFFlow(SpeedNumHS), AirMassFlowRatioHS);
            // Calculate total heating capacity for off-rated conditions
            TotCapHS = thisDXCoil.MSRatedTotCap(SpeedNumHS) * TotCapFlowModFac * TotCapTempModFac;
            // Calculate electricity consumed. First, get EIR modifying factors for off-rated conditions
            // Model was extended to accept bi-quadratic curves. This allows sensitivity of the EIR
            // to the entering dry-bulb temperature as well as the outside dry-bulb temperature. User is
            // advised to use the bi-quadratic curve if sufficient manufacturer data is available.
            // Low Speed
            if (state.dataCurveManager->PerfCurve(thisDXCoil.MSEIRFTemp(SpeedNumLS))->numDims == 1) {
                EIRTempModFac = CurveValue(state, thisDXCoil.MSEIRFTemp(SpeedNumLS), OutdoorDryBulb);
            } else {
                EIRTempModFac = CurveValue(state, thisDXCoil.MSEIRFTemp(SpeedNumLS), InletAirDryBulbTemp, OutdoorDryBulb);
            }
            EIRFlowModFac = CurveValue(state, thisDXCoil.MSEIRFFlow(SpeedNumLS), AirMassFlowRatioLS);
            EIRLS = 1.0 / thisDXCoil.MSRatedCOP(SpeedNumLS) * EIRTempModFac * EIRFlowModFac;
            // High Speed
            if (state.dataCurveManager->PerfCurve(thisDXCoil.MSEIRFTemp(SpeedNumHS))->numDims == 1) {
                EIRTempModFac = CurveValue(state, thisDXCoil.MSEIRFTemp(SpeedNumHS), OutdoorDryBulb);
            } else {
                EIRTempModFac = CurveValue(state, thisDXCoil.MSEIRFTemp(SpeedNumHS), InletAirDryBulbTemp, OutdoorDryBulb);
            }
            EIRFlowModFac = CurveValue(state, thisDXCoil.MSEIRFFlow(SpeedNumHS), AirMassFlowRatioHS);
            EIRHS = 1.0 / thisDXCoil.MSRatedCOP(SpeedNumHS) * EIRTempModFac * EIRFlowModFac;

            // Calculating adjustment factors for defrost
            // Calculate delta w through outdoor coil by assuming a coil temp of 0.82*DBT-9.7(F) per DOE2.1E
            OutdoorCoilT = 0.82 * OutdoorDryBulb - 8.589;
            OutdoorCoildw = max(1.0e-6, (OutdoorHumRat - PsyWFnTdpPb(state, OutdoorCoilT, OutdoorPressure, RoutineName)));

            // Initializing defrost adjustment factors
            LoadDueToDefrostLS = 0.0;
            LoadDueToDefrostHS = 0.0;
            HeatingCapacityMultiplier = 1.0;
            FractionalDefrostTime = 0.0;
            InputPowerMultiplier = 1.0;
            DefrostPowerLS = 0.0;
            DefrostPowerHS = 0.0;

            // Check outdoor temperature to determine if defrost is active
            if (OutdoorDryBulb <= thisDXCoil.MaxOATDefrost) {
                // Calculate defrost adjustment factors depending on defrost control type
                if (thisDXCoil.DefrostControl == StandardRatings::HPdefrostControl::Timed) {
                    FractionalDefrostTime = thisDXCoil.DefrostTime;
                    if (FractionalDefrostTime > 0.0) {
                        HeatingCapacityMultiplier = 0.909 - 107.33 * OutdoorCoildw;
                        InputPowerMultiplier = 0.90 - 36.45 * OutdoorCoildw;
                    }
                } else { // else defrost control is on-demand
                    FractionalDefrostTime = 1.0 / (1.0 + 0.01446 / OutdoorCoildw);
                    HeatingCapacityMultiplier = 0.875 * (1.0 - FractionalDefrostTime);
                    InputPowerMultiplier = 0.954 * (1.0 - FractionalDefrostTime);
                }

                if (FractionalDefrostTime > 0.0) {
                    // Calculate defrost adjustment factors depending on defrost control strategy
                    if (thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::ReverseCycle) {
                        DefrostEIRTempModFac = CurveValue(state, thisDXCoil.DefrostEIRFT, max(15.555, InletAirWetBulbC), max(15.555, OutdoorDryBulb));
                        LoadDueToDefrostLS =
                            (0.01 * FractionalDefrostTime) * (7.222 - OutdoorDryBulb) * (thisDXCoil.MSRatedTotCap(SpeedNumLS) / 1.01667);
                        DefrostPowerLS = DefrostEIRTempModFac * (thisDXCoil.MSRatedTotCap(SpeedNumLS) / 1.01667) * FractionalDefrostTime;
                        LoadDueToDefrostHS =
                            (0.01 * FractionalDefrostTime) * (7.222 - OutdoorDryBulb) * (thisDXCoil.MSRatedTotCap(SpeedNumHS) / 1.01667);
                        DefrostPowerHS = DefrostEIRTempModFac * (thisDXCoil.MSRatedTotCap(SpeedNumHS) / 1.01667) * FractionalDefrostTime;
                    } else { // Defrost strategy is resistive
                        thisDXCoil.DefrostPower = thisDXCoil.DefrostCapacity * FractionalDefrostTime;
                    }
                } else { // Defrost is not active because (OutDryBulbTemp .GT. DXCoil(DXCoilNum)%MaxOATDefrost)
                    thisDXCoil.DefrostPower = 0.0;
                }
            }

            TotCapLSAdj = TotCapLS * HeatingCapacityMultiplier;
            TotCapHSAdj = TotCapHS * HeatingCapacityMultiplier;

            // Calculate modified PartLoadRatio due to defrost (reverse-cycle defrost only)
            PLRHeating = min(1.0, (SpeedRatio + LoadDueToDefrostHS / TotCapHSAdj));
            PLF = CurveValue(state, thisDXCoil.MSPLFFPLR(SpeedNumHS), PLRHeating); // Calculate part-load factor

            if (PLF < 0.7) {
                if (thisDXCoil.PLRErrIndex == 0) {
                    ShowWarningMessage(
                        state,
                        format("The PLF curve value at high speed for DX multispeed heating coil {} ={:.2R} for part-load ratio ={:.2R}",
                               thisDXCoil.Name,
                               PLF,
                               PLRHeating));
                    ShowContinueError(state, "PLF curve values must be >= 0.7. PLF has been reset to 0.7 and simulation is continuing.");
                    ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Heating:DX:MultiSpeed].");
                    ShowContinueErrorTimeStamp(state, "");
                }
                ShowRecurringWarningErrorAtEnd(state, "DX heating coil PLF curve < 0.7 warning continues... ", thisDXCoil.PLRErrIndex, PLF, PLF);
                PLF = 0.7;
            }

            thisDXCoil.HeatingCoilRuntimeFraction = (PLRHeating / PLF);
            if (thisDXCoil.HeatingCoilRuntimeFraction > 1.0 && std::abs(thisDXCoil.HeatingCoilRuntimeFraction - 1.0) > 0.001) {
                if (thisDXCoil.ErrIndex4 == 0) {
                    ShowWarningMessage(state,
                                       format("The runtime fraction at high speed for DX multispeed heating coil {} exceeded 1.0. [{:.4R}].",
                                              thisDXCoil.Name,
                                              thisDXCoil.HeatingCoilRuntimeFraction));
                    ShowContinueError(state, "Runtime fraction is set to 1.0 and the simulation continues...");
                    ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Heating:DX:SingleSpeed].");
                    ShowContinueErrorTimeStamp(state, "");
                }
                ShowRecurringWarningErrorAtEnd(state,
                                               thisDXCoil.Name + ", DX heating coil runtime fraction > 1.0 warning continues...",
                                               thisDXCoil.ErrIndex4,
                                               thisDXCoil.HeatingCoilRuntimeFraction,
                                               thisDXCoil.HeatingCoilRuntimeFraction);
                thisDXCoil.HeatingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
            } else if (thisDXCoil.HeatingCoilRuntimeFraction > 1.0) {
                thisDXCoil.HeatingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
            }

            // Get full load output and power
            LSFullLoadOutAirEnth = InletAirEnthalpy + TotCapLSAdj / MSHPMassFlowRateLow;
            HSFullLoadOutAirEnth = InletAirEnthalpy + TotCapHSAdj / MSHPMassFlowRateHigh;
            LSElecHeatingPower = TotCapLS * EIRLS * InputPowerMultiplier;
            HSElecHeatingPower = TotCapHS * EIRHS * InputPowerMultiplier;
            OutletAirHumRat = InletAirHumRat;

            // if cycling fan, send coil part-load fraction to on/off fan via HVACDataGlobals
            if (fanOp == HVAC::FanOp::Cycling) state.dataHVACGlobal->OnOffFanPartLoadFraction = 1.0;

            // Power calculation
            if (!thisDXCoil.PLRImpact) {
                thisDXCoil.ElecHeatingPower = SpeedRatio * HSElecHeatingPower + (1.0 - SpeedRatio) * LSElecHeatingPower;
            } else {
                thisDXCoil.ElecHeatingPower =
                    thisDXCoil.HeatingCoilRuntimeFraction * HSElecHeatingPower + (1.0 - thisDXCoil.HeatingCoilRuntimeFraction) * LSElecHeatingPower;
            }

            thisDXCoil.TotalHeatingEnergyRate = MSHPMassFlowRateHigh * (HSFullLoadOutAirEnth - InletAirEnthalpy) * SpeedRatio +
                                                MSHPMassFlowRateLow * (LSFullLoadOutAirEnth - InletAirEnthalpy) * (1.0 - SpeedRatio);
            OutletAirEnthalpy = InletAirEnthalpy + thisDXCoil.TotalHeatingEnergyRate / thisDXCoil.InletAirMassFlowRate;
            OutletAirTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
            FullLoadOutAirRH = PsyRhFnTdbWPb(state, OutletAirTemp, OutletAirHumRat, OutdoorPressure, RoutineNameAverageLoad);
            if (FullLoadOutAirRH > 1.0) { // Limit to saturated conditions at FullLoadOutAirEnth
                OutletAirTemp = PsyTsatFnHPb(state,
                                             FullLoadOutAirEnth,
                                             OutdoorPressure,
                                             RoutineName); // Autodesk:Uninit FullLoadOutAirEnth was possibly uninitialized
                OutletAirHumRat = PsyWFnTdbH(
                    state, OutletAirTemp, FullLoadOutAirEnth, RoutineName); // Autodesk:Uninit FullLoadOutAirEnth was possibly uninitialized
            }

            // Waste heat calculation
            if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {
                if (thisDXCoil.MSWasteHeat(SpeedNumLS) == 0) {
                    WasteHeatLS = thisDXCoil.MSWasteHeatFrac(SpeedNumLS);
                } else {
                    WasteHeatLS = CurveValue(state, thisDXCoil.MSWasteHeat(SpeedNumLS), OutdoorDryBulb, InletAirDryBulbTemp) *
                                  thisDXCoil.MSWasteHeatFrac(SpeedNumLS);
                }
                if (thisDXCoil.MSWasteHeat(SpeedNumHS) == 0) {
                    WasteHeatHS = thisDXCoil.MSWasteHeatFrac(SpeedNumHS);
                } else {
                    WasteHeatHS = CurveValue(state, thisDXCoil.MSWasteHeat(SpeedNumHS), OutdoorDryBulb, InletAirDryBulbTemp) *
                                  thisDXCoil.MSWasteHeatFrac(SpeedNumHS);
                }
                thisDXCoil.MSFuelWasteHeat = (SpeedRatio * WasteHeatHS + (1.0 - SpeedRatio) * WasteHeatLS) * thisDXCoil.ElecCoolingPower;
                if (thisDXCoil.MSHPHeatRecActive) {
                    MSHPWasteHeat = thisDXCoil.MSFuelWasteHeat;
                }
            }
            if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {

                thisDXCoil.FuelUsed = thisDXCoil.ElecHeatingPower;
                thisDXCoil.ElecHeatingPower = 0.0;
            }

            // Adjust defrost power to correct for DOE-2 bug where defrost power is constant regardless of compressor runtime fraction
            // Defrosts happen based on compressor run time (frost buildup on outdoor coil), not total elapsed time.
            if (thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::ReverseCycle) {
                if (!thisDXCoil.PLRImpact) {
                    thisDXCoil.DefrostPower = DefrostPowerHS * SpeedRatio + DefrostPowerLS * (1.0 - SpeedRatio);
                } else {
                    thisDXCoil.DefrostPower =
                        DefrostPowerHS * thisDXCoil.HeatingCoilRuntimeFraction + DefrostPowerLS * (1.0 - thisDXCoil.HeatingCoilRuntimeFraction);
                }
            }
            thisDXCoil.OutletAirTemp = OutletAirTemp;
            thisDXCoil.OutletAirHumRat = OutletAirHumRat;
            thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;
            thisDXCoil.CrankcaseHeaterPower = 0.0;

            // Stage 1
        } else if (CycRatio > 0.0 || (CycRatio > 0.0 && SingleMode == 1)) {

            // for cycling fan, reset mass flow to full on rate
            if (fanOp == HVAC::FanOp::Cycling) AirMassFlow /= CycRatio;
            if (fanOp == HVAC::FanOp::Continuous) AirMassFlow = MSHPMassFlowRateHigh;
            // Check for valid air volume flow per rated total cooling capacity (200 - 600 cfm/ton)
            AirVolumeFlowRate = AirMassFlow / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat, RoutineName);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  AirVolumeFlowRate = AirMassFlow/PsyRhoAirFnPbTdbW(InletAirPressure,InletAirDryBulbTemp, InletAirHumRat)
            VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.MSRatedTotCap(SpeedNum);

            if ((VolFlowperRatedTotCap < HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT]) ||
                (VolFlowperRatedTotCap > HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT])) {
                if (thisDXCoil.ErrIndex1 == 0) {
                    ShowWarningMessage(state,
                                       format("{} \"{}\" - Air volume flow rate per watt of rated total heating capacity is out of range at speed 1.",
                                              thisDXCoil.DXCoilType,
                                              thisDXCoil.Name));
                    ShowContinueErrorTimeStamp(state, "");
                    ShowContinueError(state,
                                      format("Expected range for VolumeFlowPerRatedTotalCapacity=[{:.3R}--{:.3R}] Current value is {:.3R} m3/s/W",
                                             HVAC::MinOperVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             HVAC::MaxHeatVolFlowPerRatedTotCap[(int)state.dataHVACGlobal->DXCT],
                                             VolFlowperRatedTotCap));
                    ShowContinueError(state, "Possible causes include inconsistent air flow rates in system components or");
                    ShowContinueError(state, "inconsistent supply air fan operation modes in coil and unitary system objects.");
                }
                ShowRecurringWarningErrorAtEnd(
                    state,
                    thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                        "\" - Air volume flow rate per watt of rated total heating capacity is out of range error continues at speed 1...",
                    thisDXCoil.ErrIndex1,
                    VolFlowperRatedTotCap,
                    VolFlowperRatedTotCap);
            }

            // Get total capacity modifying factor (function of temperature) for off-rated conditions
            // Model was extended to accept bi-quadratic curves. This allows sensitivity of the heating capacity
            // to the entering dry-bulb temperature as well as the outside dry-bulb temperature. User is
            // advised to use the bi-quadratic curve if sufficient manufacturer data is available.
            if (state.dataCurveManager->PerfCurve(thisDXCoil.MSCCapFTemp(SpeedNum))->numDims == 1) {
                TotCapTempModFac = CurveValue(state, thisDXCoil.MSCCapFTemp(SpeedNum), OutdoorDryBulb);
            } else {
                TotCapTempModFac = CurveValue(state, thisDXCoil.MSCCapFTemp(SpeedNum), InletAirDryBulbTemp, OutdoorDryBulb);
            }

            //  Get total capacity modifying factor (function of mass flow) for off-rated conditions
            //    AirMassFlowRatio = AirMassFlow/DXCoil(DXCoilNum)%MSRatedAirMassFlowRate(SpeedNumLS)
            //    TotCapFlowModFac = CurveValue(state, DXCoil(DXCoilNum)%MSCCapFFlow(SpeedNumLS),AirMassFlowRatio)
            TotCapFlowModFac = CurveValue(state, thisDXCoil.MSCCapFFlow(SpeedNum), AirMassFlowRatioLS);
            // Calculate total heating capacity for off-rated conditions
            TotCap = thisDXCoil.MSRatedTotCap(SpeedNum) * TotCapFlowModFac * TotCapTempModFac;

            // Calculating adjustment factors for defrost
            // Calculate delta w through outdoor coil by assuming a coil temp of 0.82*DBT-9.7(F) per DOE2.1E
            OutdoorCoilT = 0.82 * OutdoorDryBulb - 8.589;
            OutdoorCoildw = max(1.0e-6, (OutdoorHumRat - PsyWFnTdpPb(state, OutdoorCoilT, OutdoorPressure, RoutineName)));

            // Initializing defrost adjustment factors
            LoadDueToDefrost = 0.0;
            HeatingCapacityMultiplier = 1.0;
            FractionalDefrostTime = 0.0;
            InputPowerMultiplier = 1.0;

            // Check outdoor temperature to determine of defrost is active
            if (OutdoorDryBulb <= thisDXCoil.MaxOATDefrost) {
                // Calculate defrost adjustment factors depending on defrost control type
                if (thisDXCoil.DefrostControl == StandardRatings::HPdefrostControl::Timed) {
                    FractionalDefrostTime = thisDXCoil.DefrostTime;
                    if (FractionalDefrostTime > 0.0) {
                        HeatingCapacityMultiplier = 0.909 - 107.33 * OutdoorCoildw;
                        InputPowerMultiplier = 0.90 - 36.45 * OutdoorCoildw;
                    }
                } else { // else defrost control is on-demand
                    FractionalDefrostTime = 1.0 / (1.0 + 0.01446 / OutdoorCoildw);
                    HeatingCapacityMultiplier = 0.875 * (1.0 - FractionalDefrostTime);
                    InputPowerMultiplier = 0.954 * (1.0 - FractionalDefrostTime);
                }

                if (FractionalDefrostTime > 0.0) {
                    // Calculate defrost adjustment factors depending on defrost control strategy
                    if (thisDXCoil.DefrostStrategy == StandardRatings::DefrostStrat::ReverseCycle) {
                        LoadDueToDefrost = (0.01 * FractionalDefrostTime) * (7.222 - OutdoorDryBulb) * (thisDXCoil.MSRatedTotCap(1) / 1.01667);
                        DefrostEIRTempModFac = CurveValue(state, thisDXCoil.DefrostEIRFT, max(15.555, InletAirWetBulbC), max(15.555, OutdoorDryBulb));
                        thisDXCoil.DefrostPower = DefrostEIRTempModFac * (thisDXCoil.MSRatedTotCap(1) / 1.01667) * FractionalDefrostTime;
                    } else { // Defrost strategy is resistive
                        thisDXCoil.DefrostPower = thisDXCoil.DefrostCapacity * FractionalDefrostTime;
                    }
                } else { // Defrost is not active because (OutDryBulbTemp .GT. DXCoil(DXCoilNum)%MaxOATDefrost)
                    thisDXCoil.DefrostPower = 0.0;
                }
            }

            // Modify total heating capacity based on defrost heating capacity multiplier
            TotCapAdj = TotCap * HeatingCapacityMultiplier;

            // Calculate full load outlet conditions
            FullLoadOutAirEnth = InletAirEnthalpy + TotCapAdj / AirMassFlow;
            FullLoadOutAirHumRat = InletAirHumRat;
            FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, FullLoadOutAirHumRat);
            FullLoadOutAirRH = PsyRhFnTdbWPb(state, FullLoadOutAirTemp, FullLoadOutAirHumRat, OutdoorPressure, RoutineNameFullLoad);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //  FullLoadOutAirRH = PsyRhFnTdbWPb(FullLoadOutAirTemp,FullLoadOutAirHumRat,InletAirPressure)
            if (FullLoadOutAirRH > 1.0) { // Limit to saturated conditions at FullLoadOutAirEnth
                FullLoadOutAirTemp = PsyTsatFnHPb(state, FullLoadOutAirEnth, OutdoorPressure, RoutineName);
                //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
                //  FullLoadOutAirTemp = PsyTsatFnHPb(FullLoadOutAirEnth,InletAirPressure)
                FullLoadOutAirHumRat = PsyWFnTdbH(state, FullLoadOutAirTemp, FullLoadOutAirEnth, RoutineName);
            }

            // Set outlet conditions from the full load calculation
            OutletAirEnthalpy = FullLoadOutAirEnth;
            OutletAirHumRat = FullLoadOutAirHumRat;
            OutletAirTemp = FullLoadOutAirTemp;
            // Calculate electricity consumed. First, get EIR modifying factors for off-rated conditions
            // Model was extended to accept bi-quadratic curves. This allows sensitivity of the EIR
            // to the entering dry-bulb temperature as well as the outside dry-bulb temperature. User is
            // advised to use the bi-quadratic curve if sufficient manufacturer data is available.
            if (state.dataCurveManager->PerfCurve(thisDXCoil.MSEIRFTemp(1))->numDims == 1) {
                EIRTempModFac = CurveValue(state, thisDXCoil.MSEIRFTemp(1), OutdoorDryBulb);
            } else {
                EIRTempModFac = CurveValue(state, thisDXCoil.MSEIRFTemp(1), InletAirDryBulbTemp, OutdoorDryBulb);
            }
            EIRFlowModFac = CurveValue(state, thisDXCoil.MSEIRFFlow(1), AirMassFlowRatioLS);
            EIR = 1.0 / thisDXCoil.MSRatedCOP(1) * EIRTempModFac * EIRFlowModFac;
            // Calculate modified PartLoadRatio due to defrost (reverse-cycle defrost only)
            PLRHeating = min(1.0, (CycRatio + LoadDueToDefrost / TotCapAdj));
            PLF = CurveValue(state, thisDXCoil.MSPLFFPLR(1), PLRHeating); // Calculate part-load factor
            if (fanOp == HVAC::FanOp::Cycling && CycRatio == 1.0 && PLF != 1.0) {
                if (thisDXCoil.PLFErrIndex == 0) {
                    ShowWarningMessage(state,
                                       format("The PLF curve value for DX heating coil {} ={:.2R} for part-load ratio = 1", thisDXCoil.Name, PLF));
                    ShowContinueError(state, "PLF curve value must be = 1.0 and has been reset to 1.0. Simulation is continuing.");
                    ShowContinueErrorTimeStamp(state, "");
                }
                ShowRecurringWarningErrorAtEnd(
                    state, thisDXCoil.Name + "\": DX heating coil PLF curve value <> 1.0 warning continues...", thisDXCoil.PLFErrIndex, PLF, PLF);
                PLF = 1.0;
            }

            if (PLF < 0.7) {
                if (thisDXCoil.PLRErrIndex == 0) {
                    ShowWarningMessage(
                        state,
                        format("The PLF curve value for DX heating coil {} ={:.2R} for part-load ratio ={:.2R}", thisDXCoil.Name, PLF, PLRHeating));
                    ShowContinueError(state, "PLF curve values must be >= 0.7. PLF has been reset to 0.7 and simulation is continuing.");
                    ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Heating:DX:SingleSpeed].");
                    ShowContinueErrorTimeStamp(state, "");
                }
                ShowRecurringWarningErrorAtEnd(state, "DX heating coil PLF curve < 0.7 warning continues... ", thisDXCoil.PLRErrIndex, PLF, PLF);
                PLF = 0.7;
            }

            thisDXCoil.HeatingCoilRuntimeFraction = (PLRHeating / PLF);
            if (thisDXCoil.HeatingCoilRuntimeFraction > 1.0 && std::abs(thisDXCoil.HeatingCoilRuntimeFraction - 1.0) > 0.001) {
                if (thisDXCoil.ErrIndex4 == 0) {
                    ShowWarningMessage(state,
                                       format("The runtime fraction for DX heating coil {} exceeded 1.0. [{:.4R}].",
                                              thisDXCoil.Name,
                                              thisDXCoil.HeatingCoilRuntimeFraction));
                    ShowContinueError(state, "Runtime fraction is set to 1.0 and the simulation continues...");
                    ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Heating:DX:SingleSpeed].");
                    ShowContinueErrorTimeStamp(state, "");
                }
                ShowRecurringWarningErrorAtEnd(state,
                                               thisDXCoil.Name + ", DX heating coil runtime fraction > 1.0 warning continues...",
                                               thisDXCoil.ErrIndex4,
                                               thisDXCoil.HeatingCoilRuntimeFraction,
                                               thisDXCoil.HeatingCoilRuntimeFraction);
                thisDXCoil.HeatingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
            } else if (thisDXCoil.HeatingCoilRuntimeFraction > 1.0) {
                thisDXCoil.HeatingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
            }
            // if cycling fan, send coil part-load fraction to on/off fan via HVACDataGlobals
            if (fanOp == HVAC::FanOp::Cycling) state.dataHVACGlobal->OnOffFanPartLoadFraction = PLF;
            thisDXCoil.ElecHeatingPower = TotCap * EIR * thisDXCoil.HeatingCoilRuntimeFraction * InputPowerMultiplier;

            // Calculate crankcase heater power using the runtime fraction for this DX heating coil only if there is no companion DX coil.
            // Else use the largest runtime fraction of this DX heating coil and the companion DX cooling coil.

            if (thisDXCoil.CompanionUpstreamDXCoil == 0) {
                thisDXCoil.CrankcaseHeaterPower = CrankcaseHeatingPower * (1.0 - thisDXCoil.HeatingCoilRuntimeFraction);
            } else {
                thisDXCoil.CrankcaseHeaterPower =
                    CrankcaseHeatingPower * (1.0 - max(thisDXCoil.HeatingCoilRuntimeFraction,
                                                       state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).CoolingCoilRuntimeFraction));
            }

            thisDXCoil.TotalHeatingEnergyRate = AirMassFlow * (FullLoadOutAirEnth - InletAirEnthalpy) * CycRatio;
            if (fanOp == HVAC::FanOp::Continuous) {
                OutletAirEnthalpy = InletAirEnthalpy + thisDXCoil.TotalHeatingEnergyRate / thisDXCoil.InletAirMassFlowRate;
                OutletAirTemp = PsyTdbFnHW(OutletAirEnthalpy, OutletAirHumRat);
            }
            if (thisDXCoil.MSHPHeatRecActive || thisDXCoil.FuelType != Constant::eFuel::Electricity) {
                if (thisDXCoil.MSWasteHeat(SpeedNum) == 0) {
                    thisDXCoil.MSFuelWasteHeat = thisDXCoil.MSWasteHeatFrac(SpeedNum) * thisDXCoil.ElecHeatingPower;
                } else {
                    thisDXCoil.MSFuelWasteHeat = CurveValue(state, thisDXCoil.MSWasteHeat(SpeedNum), OutdoorDryBulb, InletAirDryBulbTemp) *
                                                 thisDXCoil.MSWasteHeatFrac(SpeedNum) * thisDXCoil.ElecHeatingPower;
                }
                if (thisDXCoil.MSHPHeatRecActive) {
                    MSHPWasteHeat = thisDXCoil.MSFuelWasteHeat;
                }
            }
            if (thisDXCoil.FuelType != Constant::eFuel::Electricity) {

                thisDXCoil.FuelUsed = thisDXCoil.ElecHeatingPower;
                thisDXCoil.ElecHeatingPower = 0.0;
            }
            // Adjust defrost power to correct for DOE-2 bug where defrost power is constant regardless of compressor runtime fraction
            // Defrosts happen based on compressor run time (frost buildup on outdoor coil), not total elapsed time.
            thisDXCoil.DefrostPower *= thisDXCoil.HeatingCoilRuntimeFraction;

            thisDXCoil.OutletAirTemp = OutletAirTemp;
            thisDXCoil.OutletAirHumRat = OutletAirHumRat;
            thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;
        }

    } else {

        // DX coil is off; just pass through conditions
        thisDXCoil.OutletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
        thisDXCoil.OutletAirHumRat = thisDXCoil.InletAirHumRat;
        thisDXCoil.OutletAirTemp = thisDXCoil.InletAirTemp;

        thisDXCoil.ElecHeatingPower = 0.0;
        thisDXCoil.FuelUsed = 0.0;
        thisDXCoil.TotalHeatingEnergyRate = 0.0;
        thisDXCoil.DefrostPower = 0.0;

        // Calculate crankcase heater power using the runtime fraction for this DX heating coil (here DXHeatingCoilRTF=0) if
        // there is no companion DX coil, or the runtime fraction of the companion DX cooling coil (here DXCoolingCoilRTF>=0).
        if (thisDXCoil.CompanionUpstreamDXCoil == 0) {
            thisDXCoil.CrankcaseHeaterPower = CrankcaseHeatingPower;
        } else {
            thisDXCoil.CrankcaseHeaterPower =
                CrankcaseHeatingPower * (1.0 - state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).CoolingCoilRuntimeFraction);
        }

    } // end of on/off if - else

    state.dataDXCoils->DXCoilOutletTemp(DXCoilNum) = thisDXCoil.OutletAirTemp;
    state.dataDXCoils->DXCoilOutletHumRat(DXCoilNum) = thisDXCoil.OutletAirHumRat;
    thisDXCoil.PartLoadRatio = PLRHeating;
    state.dataDXCoils->DXCoilFanOp(DXCoilNum) = fanOp;
    state.dataDXCoils->DXCoilPartLoadRatio(DXCoilNum) = PLRHeating;
    thisDXCoil.MSSpeedNumLS = SpeedNumLS;
    thisDXCoil.MSSpeedNumHS = SpeedNumHS;
    thisDXCoil.MSSpeedRatio = SpeedRatio;
    thisDXCoil.MSCycRatio = CycRatio;

    // set outlet node conditions
    int airOutletNode = thisDXCoil.AirOutNode;
    state.dataLoopNodes->Node(airOutletNode).Temp = thisDXCoil.OutletAirTemp;
    state.dataLoopNodes->Node(airOutletNode).HumRat = thisDXCoil.OutletAirHumRat;

    // calc secondary coil if specified
    if (thisDXCoil.IsSecondaryDXCoilInZone) {
        CalcSecondaryDXCoils(state, DXCoilNum);
    }
}

void UpdateDXCoil(EnergyPlusData &state, int const DXCoilNum) // number of the current fan coil unit being simulated
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Fred Buhl
    //       DATE WRITTEN   May 2000

    // PURPOSE OF THIS SUBROUTINE:
    // This subroutine is for passing results to the outlet air node.

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int AirOutletNode; // air outlet node number
    int AirInletNode;  // air inlet node number

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    AirOutletNode = thisDXCoil.AirOutNode;
    AirInletNode = thisDXCoil.AirInNode;
    // changed outputs
    state.dataLoopNodes->Node(AirOutletNode).Enthalpy = thisDXCoil.OutletAirEnthalpy;
    state.dataLoopNodes->Node(AirOutletNode).Temp = thisDXCoil.OutletAirTemp;
    state.dataLoopNodes->Node(AirOutletNode).HumRat = thisDXCoil.OutletAirHumRat;
    state.dataLoopNodes->Node(AirOutletNode).MassFlowRate = thisDXCoil.InletAirMassFlowRate;
    // pass through outputs
    state.dataLoopNodes->Node(AirOutletNode).Quality = state.dataLoopNodes->Node(AirInletNode).Quality;
    state.dataLoopNodes->Node(AirOutletNode).Press = state.dataLoopNodes->Node(AirInletNode).Press;
    state.dataLoopNodes->Node(AirOutletNode).MassFlowRateMin = state.dataLoopNodes->Node(AirInletNode).MassFlowRateMin;
    state.dataLoopNodes->Node(AirOutletNode).MassFlowRateMax = state.dataLoopNodes->Node(AirInletNode).MassFlowRateMax;
    state.dataLoopNodes->Node(AirOutletNode).MassFlowRateMinAvail = state.dataLoopNodes->Node(AirInletNode).MassFlowRateMinAvail;
    state.dataLoopNodes->Node(AirOutletNode).MassFlowRateMaxAvail = state.dataLoopNodes->Node(AirInletNode).MassFlowRateMaxAvail;

    if (state.dataContaminantBalance->Contaminant.CO2Simulation) {
        state.dataLoopNodes->Node(AirOutletNode).CO2 = state.dataLoopNodes->Node(AirInletNode).CO2;
    }
    if (state.dataContaminantBalance->Contaminant.GenericContamSimulation) {
        state.dataLoopNodes->Node(AirOutletNode).GenContam = state.dataLoopNodes->Node(AirInletNode).GenContam;
    }
}

void ReportDXCoil(EnergyPlusData &state, int const DXCoilNum) // number of the current fan coil unit being simulated
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Fred Buhl
    //       DATE WRITTEN   May 2000
    //       MODIFIED       Richard Raustad/Don Shirey Oct 2001, Feb 2004
    //                      Feb 2005 M. J. Witte, GARD Analytics, Inc.
    //                        Always update evap value to support new coil type COIL:DX:MultiMode:CoolingEmpirical:
    //                      Lixing Gu. Jan. 5, 2007, pass information to the AirflowNetwork model

    // PURPOSE OF THIS SUBROUTINE:
    // Fills some of the report variables for the DX coils

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    if (thisDXCoil.reportCoilFinalSizes) {
        if (!state.dataGlobal->WarmupFlag && !state.dataGlobal->DoingHVACSizingSimulations && !state.dataGlobal->DoingSizing) {
            Real64 ratedSensCap(0.0);
            ratedSensCap = thisDXCoil.RatedTotCap(1) * thisDXCoil.RatedSHR(1);
            state.dataRptCoilSelection->coilSelectionReportObj->setCoilFinalSizes(
                state, thisDXCoil.Name, thisDXCoil.DXCoilType, thisDXCoil.RatedTotCap(1), ratedSensCap, thisDXCoil.RatedAirVolFlowRate(1), -999.0);
            thisDXCoil.reportCoilFinalSizes = false;
        }
    }

    Real64 ReportingConstant = state.dataHVACGlobal->TimeStepSysSec;

    switch (thisDXCoil.DXCoilType_Num) {
    case HVAC::CoilDX_HeatingEmpirical:
    case HVAC::CoilVRF_Heating:
    case HVAC::CoilVRF_FluidTCtrl_Heating: {
        thisDXCoil.TotalHeatingEnergy = thisDXCoil.TotalHeatingEnergyRate * ReportingConstant;
        thisDXCoil.ElecHeatingConsumption = thisDXCoil.ElecHeatingPower * ReportingConstant;
        thisDXCoil.DefrostConsumption = thisDXCoil.DefrostPower * ReportingConstant;
        thisDXCoil.CrankcaseHeaterConsumption = thisDXCoil.CrankcaseHeaterPower * ReportingConstant;
        state.dataHVACGlobal->DXElecHeatingPower = thisDXCoil.ElecHeatingPower + thisDXCoil.CrankcaseHeaterPower;
        state.dataHVACGlobal->DefrostElecPower = thisDXCoil.DefrostPower;
    } break;
    case HVAC::CoilDX_MultiSpeedHeating: {
        thisDXCoil.TotalHeatingEnergy = thisDXCoil.TotalHeatingEnergyRate * ReportingConstant;
        if (thisDXCoil.FuelType == Constant::eFuel::Electricity) {
            thisDXCoil.ElecHeatingConsumption = thisDXCoil.ElecHeatingPower * ReportingConstant;
        } else {
            thisDXCoil.FuelConsumed = thisDXCoil.FuelUsed * ReportingConstant;
        }
        thisDXCoil.DefrostConsumption = thisDXCoil.DefrostPower * ReportingConstant;
        thisDXCoil.CrankcaseHeaterConsumption = thisDXCoil.CrankcaseHeaterPower * ReportingConstant;
        state.dataHVACGlobal->DXElecHeatingPower = thisDXCoil.ElecHeatingPower + thisDXCoil.CrankcaseHeaterPower;
        state.dataHVACGlobal->DefrostElecPower = thisDXCoil.DefrostPower;
    } break;
    case HVAC::CoilDX_MultiSpeedCooling: {
        thisDXCoil.TotalCoolingEnergy = thisDXCoil.TotalCoolingEnergyRate * ReportingConstant;
        thisDXCoil.SensCoolingEnergy = thisDXCoil.SensCoolingEnergyRate * ReportingConstant;
        thisDXCoil.LatCoolingEnergy = thisDXCoil.TotalCoolingEnergy - thisDXCoil.SensCoolingEnergy;
        thisDXCoil.CrankcaseHeaterConsumption = thisDXCoil.CrankcaseHeaterPower * ReportingConstant;
        state.dataHVACGlobal->DXElecCoolingPower = thisDXCoil.ElecCoolingPower;
        thisDXCoil.EvapCondPumpElecConsumption = thisDXCoil.EvapCondPumpElecPower * ReportingConstant;
        thisDXCoil.EvapWaterConsump = thisDXCoil.EvapWaterConsumpRate * ReportingConstant;
        if (thisDXCoil.FuelType == Constant::eFuel::Electricity) {
            thisDXCoil.ElecCoolingConsumption = thisDXCoil.ElecCoolingPower * ReportingConstant;
        } else {
            thisDXCoil.FuelConsumed = thisDXCoil.FuelUsed * ReportingConstant;
        }
        if (any_eq(thisDXCoil.CondenserType, DataHeatBalance::RefrigCondenserType::Evap)) {
            thisDXCoil.BasinHeaterConsumption = thisDXCoil.BasinHeaterPower * ReportingConstant;
        }
    } break;
    case HVAC::CoilDX_HeatPumpWaterHeaterPumped:
    case HVAC::CoilDX_HeatPumpWaterHeaterWrapped: {
        // water heating energy for HP water heater DX Coil condenser
        thisDXCoil.TotalHeatingEnergy = thisDXCoil.TotalHeatingEnergyRate * ReportingConstant;
        // water heating power for HP water heater
        thisDXCoil.ElecWaterHeatingConsumption = thisDXCoil.ElecWaterHeatingPower * ReportingConstant;
        // other usual DX cooling coil outputs
        thisDXCoil.TotalCoolingEnergy = thisDXCoil.TotalCoolingEnergyRate * ReportingConstant;
        thisDXCoil.SensCoolingEnergy = thisDXCoil.SensCoolingEnergyRate * ReportingConstant;
        thisDXCoil.LatCoolingEnergy = thisDXCoil.TotalCoolingEnergy - thisDXCoil.SensCoolingEnergy;
        thisDXCoil.ElecCoolingConsumption = thisDXCoil.ElecCoolingPower * ReportingConstant;
        thisDXCoil.CrankcaseHeaterConsumption = thisDXCoil.CrankcaseHeaterPower * ReportingConstant;
        // DXElecCoolingPower global is only used for air-to-air cooling and heating coils
        state.dataHVACGlobal->DXElecCoolingPower = 0.0;
    } break;
    default: {
        thisDXCoil.TotalCoolingEnergy = thisDXCoil.TotalCoolingEnergyRate * ReportingConstant;
        thisDXCoil.SensCoolingEnergy = thisDXCoil.SensCoolingEnergyRate * ReportingConstant;
        thisDXCoil.LatCoolingEnergy = thisDXCoil.TotalCoolingEnergy - thisDXCoil.SensCoolingEnergy;
        thisDXCoil.ElecCoolingConsumption = thisDXCoil.ElecCoolingPower * ReportingConstant;
        thisDXCoil.CrankcaseHeaterConsumption = thisDXCoil.CrankcaseHeaterPower * ReportingConstant;
        state.dataHVACGlobal->DXElecCoolingPower = thisDXCoil.ElecCoolingPower;
        thisDXCoil.EvapCondPumpElecConsumption = thisDXCoil.EvapCondPumpElecPower * ReportingConstant;
        thisDXCoil.EvapWaterConsump = thisDXCoil.EvapWaterConsumpRate * ReportingConstant;
        if (any_eq(thisDXCoil.CondenserType, DataHeatBalance::RefrigCondenserType::Evap)) {
            thisDXCoil.BasinHeaterConsumption = thisDXCoil.BasinHeaterPower * ReportingConstant;
        }
    } break;
    }

    if (thisDXCoil.CondensateCollectMode == CondensateCollectAction::ToTank) {
        // calculate and report condensation rates  (how much water extracted from the air stream)
        // water flow of water in m3/s for water system interactions
        //  put here to catch all types of DX coils
        Real64 Tavg = (thisDXCoil.InletAirTemp + thisDXCoil.OutletAirTemp) / 2.0;
        // CR9155 Remove specific humidity calculations
        //  mdot * del HumRat / rho water
        thisDXCoil.CondensateVdot =
            max(0.0, (thisDXCoil.InletAirMassFlowRate * (thisDXCoil.InletAirHumRat - thisDXCoil.OutletAirHumRat) / Psychrometrics::RhoH2O(Tavg)));
        thisDXCoil.CondensateVol = thisDXCoil.CondensateVdot * ReportingConstant;

        state.dataWaterData->WaterStorage(thisDXCoil.CondensateTankID).VdotAvailSupply(thisDXCoil.CondensateTankSupplyARRID) =
            thisDXCoil.CondensateVdot;
        state.dataWaterData->WaterStorage(thisDXCoil.CondensateTankID).TwaterSupply(thisDXCoil.CondensateTankSupplyARRID) = thisDXCoil.OutletAirTemp;
    }

    state.dataAirLoop->LoopDXCoilRTF = max(thisDXCoil.CoolingCoilRuntimeFraction, thisDXCoil.HeatingCoilRuntimeFraction);
    if (thisDXCoil.AirLoopNum > 0) {
        state.dataAirLoop->AirLoopAFNInfo(thisDXCoil.AirLoopNum).AFNLoopDXCoilRTF =
            max(thisDXCoil.CoolingCoilRuntimeFraction, thisDXCoil.HeatingCoilRuntimeFraction);
    }
}

void CalcTwoSpeedDXCoilStandardRating(EnergyPlusData &state, int const DXCoilNum)
{
    // SUBROUTINE INFORMATION:
    //       AUTHOR         B. Griffith, (Derived from CalcDXCoilStandardRating by Bereket Nigusse & Chandan Sharma)
    //       DATE WRITTEN   July 2012

    // PURPOSE OF THIS SUBROUTINE:
    // Calculate the following
    //                 (1) Standard Rated (net) Cooling Capacity
    //                 (2) Energy Efficiency Ratio (EER),
    //                 (3) Integrated Energy Efficiency Ratio (IEER)

    // REFERENCES:
    // ANSI/AHRI Standard 340/360-2007, Performance Rating of Commercial and Industrial Unitary Air-Conditioning and
    //  Heat Pump Equipment, Air-Conditioning, Heating, and Refrigeration Institute, Arlington VA.

    // Using/Aliasing
    using Curve::CurveValue;
    using namespace OutputReportPredefined;

    // SUBROUTINE PARAMETER DEFINITIONS:
    // AHRI Standard 340/360-2007 Performance Rating of Commercial and Industrial Unitary Air-Conditioning and Heat Pump Equipment
    Real64 constexpr CoolingCoilInletAirWetBulbTempRated(19.4); // 19.44C (67F)
    Real64 constexpr CoolingCoilInletAirDryBulbTempRated(26.7);
    Real64 constexpr OutdoorUnitInletAirDryBulbTempRated(35.0); // 35.00C (95F)
    static Array1D<Real64> const OutdoorUnitInletAirDryBulbTempPLTestPoint(3, {27.5, 20.0, 18.3});
    static Array1D<Real64> const NetCapacityFactorPLTestPoint(3, {0.75, 0.50, 0.25});
    Real64 constexpr ConvFromSIToIP(3.412141633); // Conversion from SI to IP [3.412 Btu/hr-W]

    Real64 constexpr AirMassFlowRatioRated(1.0); // AHRI test is at the design flow rate
    // and hence AirMassFlowRatio is 1.0

    Real64 constexpr DefaultFanPowerPerEvapAirFlowRate(773.3);      // 365 W/1000 scfm or 773.3 W/(m3/s). The AHRI standard
    Real64 constexpr DefaultFanPowerPerEvapAirFlowRateSEER2(934.4); // 441 W/1000 scfm or 934.4 W/(m3/s). The AHRI standard
    // specifies a nominal/default fan electric power consumption per rated air
    // volume flow rate to account for indoor fan electric power consumption
    // when the standard tests are conducted on units that do not have an
    // indoor air circulating fan. Used if user doesn't enter a specific value.

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    static constexpr std::string_view RoutineName("CalcTwoSpeedDXCoilStandardRating");

    auto &NetCoolingCapRated = state.dataDXCoils->NetCoolingCapRated;
    auto &EER = state.dataDXCoils->EER;
    auto &IEER = state.dataDXCoils->IEER;
    auto &TotCapTempModFac = state.dataDXCoils->TotCapTempModFac;
    auto &TotCapFlowModFac = state.dataDXCoils->TotCapFlowModFac;
    auto &EIRTempModFac = state.dataDXCoils->EIRTempModFac;
    auto &EIRFlowModFac = state.dataDXCoils->EIRFlowModFac;
    auto &TempDryBulb_Leaving_Apoint = state.dataDXCoils->TempDryBulb_Leaving_Apoint;

    constexpr Real64 AccuracyTolerance(0.2); // tolerance in AHRI 340/360 Table 6 note 1
    constexpr int MaximumIterations(1000);
    Real64 EIR;
    Real64 TotalElecPowerRated;
    Array1D<Real64> EER_TestPoint_SI(4);      // 1 = A, 2 = B, 3= C, 4= D
    Array1D<Real64> EER_TestPoint_IP(4);      // 1 = A, 2 = B, 3= C, 4= D
    Array1D<Real64> NetCapacity_TestPoint(4); // 1 = A, 2 = B, 3= C, 4= D
    Array1D<Real64> NetPower_TestPoint(4);    // 1 = A, 2 = B, 3= C, 4= D
    Array1D<Real64> SupAirMdot_TestPoint(4);  // 1 = A, 2 = B, 3= C, 4= D

    Real64 HighSpeedNetCoolingCap;
    Real64 LowSpeedNetCoolingCap;

    Real64 PartLoadAirMassFlowRate;
    Real64 AirMassFlowRatio;
    int SolverFlag;
    Real64 EIR_HighSpeed;
    Real64 EIR_LowSpeed;
    int FanInletNode;
    int FanOutletNode;
    int Iter;
    Real64 ExternalStatic;
    Real64 FanStaticPressureRise;
    Real64 FanHeatCorrection;
    Real64 FanPowerCorrection;
    Real64 FanPowerPerEvapAirFlowRate = 0.0;
    Real64 FanPowerPerEvapAirFlowRateSEER2;
    Real64 SpeedRatio;
    Real64 CycRatio;
    Real64 TargetNetCapacity;
    Real64 SupplyAirHumRat;
    Real64 SupplyAirRho;
    Real64 SupplyAirVolFlowRate;
    Real64 HighSpeedTotCoolingCap;
    Real64 LowSpeedTotCoolingCap;
    Real64 TotCoolingCap;
    Real64 NetCoolingCap;
    Real64 PLF;
    Real64 RunTimeFraction;
    Real64 LowerBoundMassFlowRate;
    int PartLoadTestPoint;
    int countStaticInputs;
    int index;

    // Formats
    static constexpr std::string_view Header(
        "! <VAV DX Cooling Coil Standard Rating Information>, DX Coil Type, DX Coil Name, Fan Type, Fan Name, Standard Net Cooling Capacity "
        "{{W}}, Standard Net Cooling Capacity {{Btu/h}}, IEER {{Btu/W-h}}, COP 100% Capacity {{W/W}}, COP 75% Capacity {{W/W}}, COP 50% Capacity "
        "{{W/W}}, COP 25% Capacity {{W/W}}, EER 100% Capacity {{Btu/W-h}}, EER 75% Capacity {{Btu/W-h}}, EER 50% Capacity {{Btu/W-h}}, EER 25% "
        "Capacity {{Btu/W-h}}, Supply Air Flow 100% {{kg/s}}, Supply Air Flow 75% {{kg/s}},Supply Air Flow 50% {{kg/s}},Supply Air Flow 25% "
        "{{kg/s}}\n");

    static constexpr std::string_view Format_891{
        " VAV DX Cooling Coil Standard Rating Information, "
        "{},{},{},{},{:.2R},{:.2R},{:.2R},{:.2R},{:.2R},{:.2R},{:.2R},{:.2R},{:.2R},{:.2R},{:.2R},{:.4R},{:.4R},{:.4R},{:.4R},\n"};

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    // Get fan index and name if not already available
    if (thisDXCoil.SupplyFanIndex == 0)
        GetFanIndexForTwoSpeedCoil(state, DXCoilNum, thisDXCoil.SupplyFanIndex, thisDXCoil.SupplyFanName, thisDXCoil.supplyFanType);
    if (thisDXCoil.SupplyFanIndex == 0) { // didn't find VAV fan, do not rate this coil
        thisDXCoil.RateWithInternalStaticAndFanObject = false;
        ShowWarningError(state,
                         format("CalcTwoSpeedDXCoilStandardRating: Did not find an appropriate fan associated with DX coil named = \"{}\". Standard "
                                "Ratings will not be calculated.",
                                thisDXCoil.Name));
        return;
    }
    bool saveTurnFansOn = state.dataHVACGlobal->TurnFansOn;
    bool saveTurnFansOff = state.dataHVACGlobal->TurnFansOff;
    state.dataHVACGlobal->TurnFansOn = true; // enable fans, will override fan availability schedule if needed
    state.dataHVACGlobal->TurnFansOff = false;

    // Calculate the Indoor fan electric power consumption.  The electric power consumption is estimated
    // using either user supplied or AHRI default value for fan power per air volume flow rate
    if (thisDXCoil.RateWithInternalStaticAndFanObject) {

        TotCapFlowModFac = CurveValue(state, thisDXCoil.CCapFFlow(1), AirMassFlowRatioRated);
        TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(1), CoolingCoilInletAirWetBulbTempRated, OutdoorUnitInletAirDryBulbTempRated);
        for (Iter = 1; Iter <= 4; ++Iter) { // iterative solution in the event that net capacity is near a threshold for external static
            // Obtain external static pressure from Table 5 in ANSI/AHRI Std. 340/360-2007
            if (NetCoolingCapRated <= 21000.0) {
                ExternalStatic = 50.0;
            } else if (21000.0 < NetCoolingCapRated && NetCoolingCapRated <= 30800.0) {
                ExternalStatic = 60.0;
            } else if (30800.0 < NetCoolingCapRated && NetCoolingCapRated <= 39300.0) {
                ExternalStatic = 70.0;
            } else if (39300.0 < NetCoolingCapRated && NetCoolingCapRated <= 61500.0) {
                ExternalStatic = 90.0;
            } else if (61500.0 < NetCoolingCapRated && NetCoolingCapRated <= 82100.0) {
                ExternalStatic = 100.0;
            } else if (82100.0 < NetCoolingCapRated && NetCoolingCapRated <= 103000.0) {
                ExternalStatic = 110.0;
            } else if (103000.0 < NetCoolingCapRated && NetCoolingCapRated <= 117000.0) {
                ExternalStatic = 140.0;
            } else if (117000.0 < NetCoolingCapRated && NetCoolingCapRated <= 147000.0) {
                ExternalStatic = 160.0;
            } else if (147000.0 < NetCoolingCapRated) {
                ExternalStatic = 190.0;
            }
            FanStaticPressureRise = ExternalStatic + thisDXCoil.InternalStaticPressureDrop;
            FanInletNode = state.dataFans->fans(thisDXCoil.SupplyFanIndex)->inletNodeNum;
            FanOutletNode = state.dataFans->fans(thisDXCoil.SupplyFanIndex)->outletNodeNum;

            // set node state variables in preparation for fan model.
            state.dataLoopNodes->Node(FanInletNode).MassFlowRate = thisDXCoil.RatedAirMassFlowRate(1);
            state.dataLoopNodes->Node(FanOutletNode).MassFlowRate = thisDXCoil.RatedAirMassFlowRate(1);
            state.dataLoopNodes->Node(FanInletNode).Temp = CoolingCoilInletAirDryBulbTempRated;
            state.dataLoopNodes->Node(FanInletNode).HumRat = PsyWFnTdbTwbPb(
                state, CoolingCoilInletAirDryBulbTempRated, CoolingCoilInletAirWetBulbTempRated, state.dataEnvrn->OutBaroPress, RoutineName);
            state.dataLoopNodes->Node(FanInletNode).Enthalpy =
                PsyHFnTdbW(CoolingCoilInletAirDryBulbTempRated, state.dataLoopNodes->Node(FanInletNode).HumRat);
            state.dataFans->fans(thisDXCoil.SupplyFanIndex)->simulate(state, true, _, FanStaticPressureRise);
            FanPowerCorrection = state.dataFans->fans(thisDXCoil.SupplyFanIndex)->totalPower;

            FanHeatCorrection = state.dataLoopNodes->Node(FanInletNode).MassFlowRate *
                                (state.dataLoopNodes->Node(FanOutletNode).Enthalpy - state.dataLoopNodes->Node(FanInletNode).Enthalpy);

            NetCoolingCapRated = thisDXCoil.RatedTotCap(1) * TotCapTempModFac * TotCapFlowModFac - FanHeatCorrection;
        }

    } else {
        FanPowerPerEvapAirFlowRate = DefaultFanPowerPerEvapAirFlowRate;
        FanPowerPerEvapAirFlowRateSEER2 = DefaultFanPowerPerEvapAirFlowRateSEER2;
        FanPowerCorrection = DefaultFanPowerPerEvapAirFlowRate * thisDXCoil.RatedAirVolFlowRate(1);
        FanHeatCorrection = DefaultFanPowerPerEvapAirFlowRate * thisDXCoil.RatedAirVolFlowRate(1);
        TotCapFlowModFac = CurveValue(state, thisDXCoil.CCapFFlow(1), AirMassFlowRatioRated);
        TotCapTempModFac = CurveValue(state, thisDXCoil.CCapFTemp(1), CoolingCoilInletAirWetBulbTempRated, OutdoorUnitInletAirDryBulbTempRated);
        NetCoolingCapRated = thisDXCoil.RatedTotCap(1) * TotCapTempModFac * TotCapFlowModFac - FanHeatCorrection;
    }

    SupAirMdot_TestPoint(1) = thisDXCoil.RatedAirMassFlowRate(1);

    // Calculate Energy Efficiency Ratio (EER) at (19.44C WB and 35.0C DB ), ANSI/AHRI Std. 340/360
    EIRTempModFac = CurveValue(state, thisDXCoil.EIRFTemp(1), CoolingCoilInletAirWetBulbTempRated, OutdoorUnitInletAirDryBulbTempRated);
    EIRFlowModFac = CurveValue(state, thisDXCoil.EIRFFlow(1), AirMassFlowRatioRated);
    if (thisDXCoil.RatedCOP(1) > 0.0) {
        // RatedCOP <= 0.0 is trapped in GetInput, but keep this as "safety"
        EIR = EIRTempModFac * EIRFlowModFac / thisDXCoil.RatedCOP(1);
    } else {
        EIR = 0.0;
    }
    TotalElecPowerRated = EIR * (thisDXCoil.RatedTotCap(1) * TotCapTempModFac * TotCapFlowModFac) + FanPowerCorrection;

    if (TotalElecPowerRated > 0.0) {
        EER = NetCoolingCapRated / TotalElecPowerRated;
    } else {
        EER = 0.0;
    }

    // IEER - A point 100 % net capacity
    EER_TestPoint_SI(1) = EER;
    EER_TestPoint_IP(1) = EER * ConvFromSIToIP;

    // find coil leaving drybulb at point A, with full rated air flow rate.
    // init coil
    thisDXCoil.InletAirMassFlowRate = thisDXCoil.RatedAirMassFlowRate(1);
    thisDXCoil.InletAirMassFlowRateMax = thisDXCoil.RatedAirMassFlowRate(1);
    thisDXCoil.InletAirTemp = 26.7;
    thisDXCoil.InletAirHumRat = PsyWFnTdbTwbPb(state, 26.7, 19.4, state.dataEnvrn->OutBaroPress, RoutineName);
    thisDXCoil.InletAirEnthalpy = PsyHFnTdbW(26.7, thisDXCoil.InletAirHumRat);

    Real64 const heldOutDryBulb = state.dataEnvrn->OutDryBulbTemp;
    if (thisDXCoil.CondenserInletNodeNum(1) != 0) {
        state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).Temp = OutdoorUnitInletAirDryBulbTempRated;
    } else {
        state.dataEnvrn->OutDryBulbTemp = OutdoorUnitInletAirDryBulbTempRated;
    }
    SpeedRatio = 1.0;
    CycRatio = 1.0;
    CalcMultiSpeedDXCoil(state, DXCoilNum, SpeedRatio, CycRatio, true);
    TempDryBulb_Leaving_Apoint = state.dataDXCoils->DXCoilOutletTemp(DXCoilNum); // store result

    // IEER - part load test points ***************************************************
    for (PartLoadTestPoint = 1; PartLoadTestPoint <= 3; ++PartLoadTestPoint) {
        // determine minimum unloading capacity fraction at point B conditions.
        if (thisDXCoil.CondenserInletNodeNum(1) != 0) {
            state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(1)).Temp = OutdoorUnitInletAirDryBulbTempPLTestPoint(PartLoadTestPoint);
        } else {
            state.dataEnvrn->OutDryBulbTemp = OutdoorUnitInletAirDryBulbTempPLTestPoint(PartLoadTestPoint);
        }

        TargetNetCapacity = NetCapacityFactorPLTestPoint(PartLoadTestPoint) * NetCoolingCapRated;

        // set up parameters for the solver here
        Real64 const par3 = OutdoorUnitInletAirDryBulbTempPLTestPoint(PartLoadTestPoint);
        Real64 par7 = FanPowerPerEvapAirFlowRate;
        int fanInNode = 0;
        int fanOutNode = 0;
        Real64 externalStatic = 0.0;
        int fanIndex = 0;
        if (thisDXCoil.RateWithInternalStaticAndFanObject) {
            par7 = 0.0;
            fanInNode = FanInletNode;
            fanOutNode = FanOutletNode;
            externalStatic = ExternalStatic;
            fanIndex = thisDXCoil.SupplyFanIndex;
        }

        LowerBoundMassFlowRate = 0.01 * thisDXCoil.RatedAirMassFlowRate(1);

        // OK, so there are two variables here which are const at compile time.  The question is whether compile time data needs to be
        // explicitly captured in the lambda capture block.
        // For GCC it currently doesn't mind whether they are captured or not, no warnings.
        // On Clang, if you list them, there is a compiler warning.
        // On our version of MSVC, if you take them out, the compiler will fail.  On newer versions, I think it's OK.  Should be soon anyway.
        // To avoid this, you could pragma away the Clang warning in this section, or tell Clang to hush via compiler flags.  However, to keep things
        // really simple, I'm just going to use two local variables and capture them instead of the original data.
        // I'm not sure if there are any more of these instances in the codebase.  If so I am going to tag all of them with CONST_LAMBDA_CAPTURE.
        Real64 dbRated = CoolingCoilInletAirDryBulbTempRated;
        Real64 wbRated = CoolingCoilInletAirWetBulbTempRated;
        auto f = // (AUTO_OK_LAMBDA)
            [&state, DXCoilNum, TempDryBulb_Leaving_Apoint, TargetNetCapacity, par3, par7, fanInNode, fanOutNode, externalStatic, dbRated, wbRated](
                Real64 SupplyAirMassFlowRate) {
                static constexpr std::string_view RoutineName("CalcTwoSpeedDXCoilIEERResidual");
                auto &coil = state.dataDXCoils->DXCoil(DXCoilNum);
                Real64 AirMassFlowRatio = 0.0;
                if (coil.RatedAirMassFlowRate(1) > 0.0) {
                    AirMassFlowRatio = SupplyAirMassFlowRate / coil.RatedAirMassFlowRate(1);
                }
                Real64 SupplyAirHumRat = PsyWFnTdbTwbPb(state, dbRated, wbRated, state.dataEnvrn->OutBaroPress, RoutineName);
                Real64 SupplyAirRho = PsyRhoAirFnPbTdbW(state, state.dataEnvrn->OutBaroPress, dbRated, SupplyAirHumRat, RoutineName);
                Real64 SupplyAirVolFlowRate = SupplyAirMassFlowRate / SupplyAirRho;

                Real64 FanHeatCorrection;
                if (coil.RateWithInternalStaticAndFanObject) {
                    // modify external static per AHRI 340/360, Table 6, note 1.
                    Real64 FanStaticPressureRise = coil.InternalStaticPressureDrop + (externalStatic * pow_2(AirMassFlowRatio));
                    auto &inletNode = state.dataLoopNodes->Node(fanInNode);
                    auto &outletNode = state.dataLoopNodes->Node(fanOutNode);
                    inletNode.MassFlowRate = SupplyAirMassFlowRate;
                    outletNode.MassFlowRate = SupplyAirMassFlowRate;
                    inletNode.Temp = dbRated;
                    inletNode.HumRat = PsyWFnTdbTwbPb(state, dbRated, wbRated, state.dataEnvrn->OutBaroPress, RoutineName);
                    inletNode.Enthalpy = PsyHFnTdbW(dbRated, inletNode.HumRat);
                    state.dataFans->fans(coil.SupplyFanIndex)->simulate(state, true, _, FanStaticPressureRise);
                    FanHeatCorrection = SupplyAirMassFlowRate * (outletNode.Enthalpy - inletNode.Enthalpy);
                } else {
                    FanHeatCorrection = par7 * SupplyAirVolFlowRate;
                }

                Real64 TotCapFlowModFac = Curve::CurveValue(state, coil.CCapFFlow(1), AirMassFlowRatio);
                Real64 TotCapTempModFac = Curve::CurveValue(state, coil.CCapFTemp(1), wbRated, par3);
                Real64 HighSpeedNetCoolingCap = coil.RatedTotCap(1) * TotCapTempModFac * TotCapFlowModFac - FanHeatCorrection;

                // TotCapFlowModFac = CurveManager::CurveValue(state, coil.CCapFFlow(1), AirMassFlowRatio);
                TotCapTempModFac = Curve::CurveValue(state, coil.CCapFTemp2, wbRated, par3);
                Real64 LowSpeedNetCoolingCap = coil.RatedTotCap2 * TotCapTempModFac * TotCapFlowModFac - FanHeatCorrection;

                Real64 SpeedRatio;
                Real64 CycRatio;
                if (LowSpeedNetCoolingCap <= TargetNetCapacity) {
                    CycRatio = 1.0;
                    SpeedRatio = (TargetNetCapacity - LowSpeedNetCoolingCap) / (HighSpeedNetCoolingCap - LowSpeedNetCoolingCap);
                } else { // minimum unloading limit exceeded for no cycling
                    SpeedRatio = 0.0;
                    CycRatio = TargetNetCapacity / LowSpeedNetCoolingCap;
                }

                coil.InletAirMassFlowRate = SupplyAirMassFlowRate;
                CalcMultiSpeedDXCoil(state, DXCoilNum, SpeedRatio, CycRatio, true);
                Real64 OutletAirTemp = state.dataDXCoils->DXCoilOutletTemp(DXCoilNum);
                return TempDryBulb_Leaving_Apoint - OutletAirTemp;
            };
        General::SolveRoot(state,
                           AccuracyTolerance,
                           MaximumIterations,
                           SolverFlag,
                           PartLoadAirMassFlowRate,
                           f,
                           LowerBoundMassFlowRate,
                           thisDXCoil.RatedAirMassFlowRate(1));

        if (SolverFlag == -1) {

            ShowWarningError(state, "CalcTwoSpeedDXCoilStandardRating: air flow rate solver failed. Iteration limit exceeded ");

            SupAirMdot_TestPoint(1 + PartLoadTestPoint) = -999.0;
            EER_TestPoint_SI(1 + PartLoadTestPoint) = -999.0;
            EER_TestPoint_IP(1 + PartLoadTestPoint) = -999.0;
            NetCapacity_TestPoint(1 + PartLoadTestPoint) = -999.0;
            NetPower_TestPoint(1 + PartLoadTestPoint) = -999.0;

        } else if (SolverFlag == -2) {
            ShowWarningError(state, "CalcTwoSpeedDXCoilStandardRating: air flow rate solver failed. root not bounded ");

            SupAirMdot_TestPoint(1 + PartLoadTestPoint) = -999.0;
            EER_TestPoint_SI(1 + PartLoadTestPoint) = -999.0;
            EER_TestPoint_IP(1 + PartLoadTestPoint) = -999.0;
            NetCapacity_TestPoint(1 + PartLoadTestPoint) = -999.0;
            NetPower_TestPoint(1 + PartLoadTestPoint) = -999.0;
        } else {
            // now we have the supply air flow rate
            SupAirMdot_TestPoint(1 + PartLoadTestPoint) = PartLoadAirMassFlowRate;
            AirMassFlowRatio = PartLoadAirMassFlowRate / thisDXCoil.RatedAirMassFlowRate(1);
            SupplyAirHumRat = PsyWFnTdbTwbPb(
                state, CoolingCoilInletAirDryBulbTempRated, CoolingCoilInletAirWetBulbTempRated, state.dataEnvrn->OutBaroPress, RoutineName);
            SupplyAirRho = PsyRhoAirFnPbTdbW(state, state.dataEnvrn->OutBaroPress, CoolingCoilInletAirDryBulbTempRated, SupplyAirHumRat, RoutineName);
            SupplyAirVolFlowRate = PartLoadAirMassFlowRate / SupplyAirRho;

            if (thisDXCoil.RateWithInternalStaticAndFanObject) {
                FanStaticPressureRise = thisDXCoil.InternalStaticPressureDrop + (ExternalStatic * pow_2(AirMassFlowRatio));
                state.dataLoopNodes->Node(FanInletNode).MassFlowRate = PartLoadAirMassFlowRate;
                state.dataLoopNodes->Node(FanInletNode).Temp = CoolingCoilInletAirDryBulbTempRated;
                state.dataLoopNodes->Node(FanInletNode).HumRat = SupplyAirHumRat;
                state.dataLoopNodes->Node(FanInletNode).Enthalpy = PsyHFnTdbW(CoolingCoilInletAirDryBulbTempRated, SupplyAirHumRat);

                state.dataFans->fans(thisDXCoil.SupplyFanIndex)->simulate(state, true, _, FanStaticPressureRise);
                FanPowerCorrection = state.dataFans->fans(thisDXCoil.SupplyFanIndex)->totalPower;

                FanHeatCorrection =
                    PartLoadAirMassFlowRate * (state.dataLoopNodes->Node(FanOutletNode).Enthalpy - state.dataLoopNodes->Node(FanInletNode).Enthalpy);

            } else {
                FanPowerCorrection = FanPowerPerEvapAirFlowRate * PartLoadAirMassFlowRate;
                FanHeatCorrection = FanPowerPerEvapAirFlowRate * PartLoadAirMassFlowRate;
            }

            TotCapFlowModFac = CurveValue(state, thisDXCoil.CCapFFlow(1), AirMassFlowRatio);
            //    Warn user if curve output goes negative
            if (TotCapFlowModFac < 0.0) {
                if (thisDXCoil.CCapFFlowErrorIndex == 0) {
                    ShowWarningMessage(state, format("{}{} \"{}\":", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                    ShowContinueError(
                        state,
                        format(" Total Cooling Capacity Modifier curve (function of flow fraction) output is negative ({:.3T}).", TotCapFlowModFac));
                    ShowContinueError(state, format(" Negative value occurs using an air flow fraction of {:.3T}.", AirMassFlowRatio));
                    ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
                }
                ShowRecurringWarningErrorAtEnd(
                    state,
                    format("{}{}\"{}\": Total Cooling Capacity Modifier curve (function of flow fraction) output is negative warning continues...",
                           RoutineName,
                           thisDXCoil.DXCoilType,
                           thisDXCoil.Name),
                    thisDXCoil.CCapFFlowErrorIndex,
                    TotCapFlowModFac,
                    TotCapFlowModFac);
                TotCapFlowModFac = 0.0;
            }

            TotCapTempModFac = CurveValue(
                state, thisDXCoil.CCapFTemp(1), CoolingCoilInletAirWetBulbTempRated, OutdoorUnitInletAirDryBulbTempPLTestPoint(PartLoadTestPoint));
            //    Warn user if curve output goes negative
            if (TotCapTempModFac < 0.0) {
                if (thisDXCoil.CCapFTempErrorIndex == 0) {
                    ShowWarningMessage(state, format("{}{} \"{}\":", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                    ShowContinueError(
                        state,
                        format(" Total Cooling Capacity Modifier curve (function of temperature) output is negative ({:.3T}).", TotCapTempModFac));
                    ShowContinueError(state,
                                      format(" Negative value occurs using a coil inlet wet-bulb temperature of {:.1T} and an outdoor unit inlet air "
                                             "dry-bulb temperature of {:.1T}.",
                                             CoolingCoilInletAirWetBulbTempRated,
                                             OutdoorUnitInletAirDryBulbTempPLTestPoint(PartLoadTestPoint)));
                    ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
                }
                ShowRecurringWarningErrorAtEnd(
                    state,
                    format("{}{} \"{}\": Total Cooling Capacity Modifier curve (function of temperature) output is negative warning continues...",
                           RoutineName,
                           thisDXCoil.DXCoilType,
                           thisDXCoil.Name),
                    thisDXCoil.CCapFTempErrorIndex,
                    TotCapTempModFac,
                    TotCapTempModFac);
                TotCapTempModFac = 0.0;
            }

            HighSpeedTotCoolingCap = thisDXCoil.RatedTotCap(1) * TotCapTempModFac * TotCapFlowModFac;
            HighSpeedNetCoolingCap = HighSpeedTotCoolingCap - FanHeatCorrection;

            EIRTempModFac = CurveValue(
                state, thisDXCoil.EIRFTemp(1), CoolingCoilInletAirWetBulbTempRated, OutdoorUnitInletAirDryBulbTempPLTestPoint(PartLoadTestPoint));
            EIRFlowModFac = CurveValue(state, thisDXCoil.EIRFFlow(1), AirMassFlowRatio);
            if (thisDXCoil.RatedCOP(1) > 0.0) {
                // RatedCOP <= 0.0 is trapped in GetInput, but keep this as "safety"
                EIR_HighSpeed = EIRTempModFac * EIRFlowModFac / thisDXCoil.RatedCOP(1);
            } else {
                EIR = 0.0;
            }

            // TotCapFlowModFac = CurveValue(state, thisDXCoil.CCapFFlow(1), AirMassFlowRatio);
            TotCapTempModFac = CurveValue(
                state, thisDXCoil.CCapFTemp2, CoolingCoilInletAirWetBulbTempRated, OutdoorUnitInletAirDryBulbTempPLTestPoint(PartLoadTestPoint));
            //    Warn user if curve output goes negative
            if (TotCapTempModFac < 0.0) {
                if (thisDXCoil.CCapFTempErrorIndex == 0) {
                    ShowWarningMessage(state, format("{}{} \"{}\":", RoutineName, thisDXCoil.DXCoilType, thisDXCoil.Name));
                    ShowContinueError(
                        state,
                        format(" Total Cooling Capacity Modifier curve (function of temperature) output is negative ({:.3T}).", TotCapTempModFac));
                    ShowContinueError(state,
                                      format(" Negative value occurs using a coil inlet wet-bulb temperature of {:.1T} and an outdoor unit inlet air "
                                             "dry-bulb temperature of {:.1T}.",
                                             CoolingCoilInletAirWetBulbTempRated,
                                             OutdoorUnitInletAirDryBulbTempPLTestPoint(PartLoadTestPoint)));
                    ShowContinueErrorTimeStamp(state, " Resetting curve output to zero and continuing simulation.");
                }
                ShowRecurringWarningErrorAtEnd(
                    state,
                    format("{}{} \"{}\": Total Cooling Capacity Modifier curve (function of temperature) output is negative warning continues...",
                           RoutineName,
                           thisDXCoil.DXCoilType,
                           thisDXCoil.Name),
                    thisDXCoil.CCapFTempErrorIndex,
                    TotCapTempModFac,
                    TotCapTempModFac);
                TotCapTempModFac = 0.0;
            }

            LowSpeedTotCoolingCap = thisDXCoil.RatedTotCap2 * TotCapTempModFac * TotCapFlowModFac;
            LowSpeedNetCoolingCap = LowSpeedTotCoolingCap - FanHeatCorrection;

            EIRTempModFac = CurveValue(
                state, thisDXCoil.EIRFTemp2, CoolingCoilInletAirWetBulbTempRated, OutdoorUnitInletAirDryBulbTempPLTestPoint(PartLoadTestPoint));
            EIRFlowModFac = CurveValue(state, thisDXCoil.EIRFFlow(1), AirMassFlowRatio);
            if (thisDXCoil.RatedCOP2 > 0.0) {
                // RatedCOP <= 0.0 is trapped in GetInput, but keep this as "safety"
                EIR_LowSpeed = EIRTempModFac * EIRFlowModFac / thisDXCoil.RatedCOP2;
            } else {
                EIR_LowSpeed = 0.0;
            }

            if (LowSpeedNetCoolingCap <= TargetNetCapacity) {
                CycRatio = 1.0;
                SpeedRatio = (TargetNetCapacity - LowSpeedNetCoolingCap) / (HighSpeedNetCoolingCap - LowSpeedNetCoolingCap);
                TotCoolingCap = HighSpeedTotCoolingCap * SpeedRatio + LowSpeedTotCoolingCap * (1.0 - SpeedRatio);
                NetCoolingCap = TotCoolingCap - FanHeatCorrection;
                EIR = EIR_HighSpeed * SpeedRatio + EIR_LowSpeed * (1.0 - SpeedRatio);
                TotalElecPowerRated = TotCoolingCap * EIR + FanPowerCorrection;
                EER_TestPoint_SI(1 + PartLoadTestPoint) = NetCoolingCap / TotalElecPowerRated;
                EER_TestPoint_IP(1 + PartLoadTestPoint) = EER_TestPoint_SI(1 + PartLoadTestPoint) * ConvFromSIToIP;
                NetCapacity_TestPoint(1 + PartLoadTestPoint) = NetCoolingCap;
                NetPower_TestPoint(1 + PartLoadTestPoint) = TotalElecPowerRated;
            } else { // minimum unloading limit exceeded without cycling, so cycle
                SpeedRatio = 0.0;
                CycRatio = TargetNetCapacity / LowSpeedNetCoolingCap;
                PLF = CurveValue(state, thisDXCoil.PLFFPLR(1), CycRatio);
                if (PLF < 0.7) {
                    PLF = 0.7;
                }
                RunTimeFraction = CycRatio / PLF;
                RunTimeFraction = min(RunTimeFraction, 1.0);
                TotCoolingCap = LowSpeedTotCoolingCap * RunTimeFraction;
                NetCoolingCap = TotCoolingCap - FanHeatCorrection;
                TotalElecPowerRated = LowSpeedTotCoolingCap * EIR_LowSpeed * RunTimeFraction + FanPowerCorrection;
                EER_TestPoint_SI(1 + PartLoadTestPoint) = NetCoolingCap / TotalElecPowerRated;
                EER_TestPoint_IP(1 + PartLoadTestPoint) = EER_TestPoint_SI(1 + PartLoadTestPoint) * ConvFromSIToIP;
                NetCapacity_TestPoint(1 + PartLoadTestPoint) = NetCoolingCap;
                NetPower_TestPoint(1 + PartLoadTestPoint) = TotalElecPowerRated;
            }
        }
    } // loop over 3 part load test points
    state.dataHVACGlobal->TurnFansOn = saveTurnFansOn;
    state.dataHVACGlobal->TurnFansOff = saveTurnFansOff;

    IEER = (0.02 * EER_TestPoint_IP(1)) + (0.617 * EER_TestPoint_IP(2)) + (0.238 * EER_TestPoint_IP(3)) + (0.125 * EER_TestPoint_IP(4));
    // CalcMultiSpeedDXCoilCooling() //??
    // begin output
    if (state.dataDXCoils->CalcTwoSpeedDXCoilStandardRatingOneTimeEIOHeaderWrite) {
        print(state.files.eio, Header);
        state.dataDXCoils->CalcTwoSpeedDXCoilStandardRatingOneTimeEIOHeaderWrite = false;
        state.dataOutRptPredefined->pdstVAVDXCoolCoil =
            newPreDefSubTable(state, state.dataOutRptPredefined->pdrEquip, "VAV DX Cooling Standard Rating Details");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilType =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "DX Cooling Coil Type");
        state.dataOutRptPredefined->pdchVAVDXFanName = newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "Associated Fan");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilNetCapSI =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "Net Cooling Capacity [W]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilCOP = newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "COP [W/W]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilEERIP = newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "EER [Btu/W-h]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilIEERIP = newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "IEER [Btu/W-h]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilMdotA =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "Supply Air Flow 100% [kg/s]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilCOP_B =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "COP 75% Capacity [W/W]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilEER_B_IP =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "EER 75% Capacity [Btu/W-h]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilMdotB =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "Supply Air Flow 75% [kg/s]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilCOP_C =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "COP 50% Capacity [W/W]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilEER_C_IP =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "EER 50% Capacity [Btu/W-h]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilMdotC =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "Supply Air Flow 50% [kg/s]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilCOP_D =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "COP 25% Capacity [W/W]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilEER_D_IP =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "EER 25% Capacity [Btu/W-h]");
        state.dataOutRptPredefined->pdchVAVDXCoolCoilMdotD =
            newPreDefColumn(state, state.dataOutRptPredefined->pdstVAVDXCoolCoil, "Supply Air Flow 25% [kg/s]");

        // determine footnote content
        countStaticInputs = 0;
        for (index = 1; index <= state.dataDXCoils->NumDXCoils; ++index) {

            if (state.dataDXCoils->DXCoil(index).RateWithInternalStaticAndFanObject &&
                state.dataDXCoils->DXCoil(index).DXCoilType_Num == HVAC::CoilDX_CoolingTwoSpeed) {
                ++countStaticInputs;
            }
        }

        if (countStaticInputs == state.dataDXCoils->NumDXMulSpeedCoils) {
            addFootNoteSubTable(state,
                                state.dataOutRptPredefined->pdstVAVDXCoolCoil,
                                "Packaged VAV unit ratings per ANSI/AHRI Standard 340/360-2007 with Addenda 1 and 2");
        } else if (countStaticInputs == 0) {
            addFootNoteSubTable(state,
                                state.dataOutRptPredefined->pdstVAVDXCoolCoil,
                                "Indoor-coil-only unit ratings per ANSI/AHRI Standard 340/360-2007 with Addenda 1 and 2, with "
                                "supply fan specific power at 365 {{W/1000cfm}} (773.3 {{W/(m3/s)}})");
        } else { // both
            addFootNoteSubTable(state,
                                state.dataOutRptPredefined->pdstVAVDXCoolCoil,
                                "Packaged VAV unit ratings per ANSI/AHRI Standard 340/360-2007 with Addenda 1 and 2, "
                                "indoor-coil-only units with supply fan specific power at 365 {{W/1000cfm}} (773.3 {{W/(m3/s)}})");
        }
    }

    const auto &fan_type_name = [&]() -> std::pair<const char *, std::string> {
        if (thisDXCoil.RateWithInternalStaticAndFanObject) {
            return {"Fan:VariableVolume", thisDXCoil.SupplyFanName};
        } else {
            return {"N/A", "N/A"};
        }
    }();

    print(state.files.eio,
          Format_891,
          "Coil:Cooling:DX:TwoSpeed",
          thisDXCoil.Name,
          fan_type_name.first,
          fan_type_name.second,
          NetCoolingCapRated,
          (NetCoolingCapRated * ConvFromSIToIP),
          IEER,
          EER_TestPoint_SI(1),
          EER_TestPoint_SI(2),
          EER_TestPoint_SI(3),
          EER_TestPoint_SI(4),
          EER_TestPoint_IP(1),
          EER_TestPoint_IP(2),
          EER_TestPoint_IP(3),
          EER_TestPoint_IP(4),
          SupAirMdot_TestPoint(1),
          SupAirMdot_TestPoint(2),
          SupAirMdot_TestPoint(3),
          SupAirMdot_TestPoint(4));

    if (state.dataHVACGlobal->StandardRatingsMyCoolOneTimeFlag) {
        static constexpr std::string_view Format_994(
            "! <DX Cooling Coil Standard Rating Information>, Component Type, Component Name, Standard Rating (Net) "
            "Cooling Capacity {W}, Standard Rating Net COP {W/W}, EER {Btu/W-h}, SEER User {Btu/W-h}, SEER Standard {Btu/W-h}, "
            "IEER "
            "{Btu/W-h}");
        print(state.files.eio, "{}\n", Format_994);
        state.dataHVACGlobal->StandardRatingsMyCoolOneTimeFlag = false;
    }
    static constexpr std::string_view Format_995(" DX Cooling Coil Standard Rating Information, {}, {}, {:.1R}, {}, {}, {}, {}, {}\n");
    print(state.files.eio,
          Format_995,
          "Coil:Cooling:DX:TwoSpeed",
          thisDXCoil.Name,
          NetCoolingCapRated,
          EER_TestPoint_SI(1),
          EER_TestPoint_IP(1),
          "N/A",
          "N/A",
          IEER);

    PreDefTableEntry(state, state.dataOutRptPredefined->pdchDXCoolCoilType, thisDXCoil.Name, "Coil:Cooling:DX:TwoSpeed");
    // W to tons
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchDXCoolCoilNetCapSI, thisDXCoil.Name, NetCoolingCapRated, 1);

    // TODO: Commercial and industrial unitary air-conditioning condensing units with a capacity greater than 135,000 Btu/h (39564.59445 Watts)
    // as defined in ANSI/AHRI Standard 365(I-P). | Scope 2.2.6 (ANSI/AHRI 340-360 2022)
    //
    // These will convert with a factor of 1 which is ok
    // SEER | Capacity less than 65K Btu/h (19050 W) - calculated as per AHRI Standard 210/240-2023.
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchDXCoolCoilCOP, thisDXCoil.Name, EER_TestPoint_SI(1), 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchDXCoolCoilEERIP, thisDXCoil.Name, EER_TestPoint_IP(1), 2);
    // These will convert with a factor of 1 which is ok
    // IEER | Capacity of 65K Btu/h (19050 W) to less than 135K Btu/h (39565 W) - calculated as per AHRI Standard 340/360-2022.
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchDXCoolCoilIEERIP, thisDXCoil.Name, IEER, 1);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchDXCoolCoilSEERUserIP, thisDXCoil.Name, "N/A");
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchDXCoolCoilSEERStandardIP, thisDXCoil.Name, "N/A");

    addFootNoteSubTable(
        state,
        state.dataOutRptPredefined->pdstDXCoolCoil,
        "ANSI/AHRI ratings account for supply air fan heat and electric power. <br/>"
        "1 - EnergyPlus object type. <br/>"
        "2 - Capacity less than 65K Btu/h (19050 W) - calculated as per AHRI Standard 210/240-2017. <br/>"
        "&emsp;&nbsp;Capacity of 65K Btu/h (19050 W) to less than 135K Btu/h (39565 W) - calculated as per AHRI Standard 340/360-2007. <br/>"
        "&emsp;&nbsp;Capacity from 135K (39565 W) to 250K Btu/hr (73268 W) - calculated as per AHRI Standard 365-2009 - Ratings not yet supported in "
        "EnergyPlus. <br/>"
        "3 - SEER (User) is calculated using user-input PLF curve and cooling coefficient of degradation. <br/>"
        "&emsp;&nbsp;SEER (Standard) is calculated using the default PLF curve and cooling coefficient of degradation"
        "from the appropriate AHRI standard.");

    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilType, thisDXCoil.Name, "Coil:Cooling:DX:TwoSpeed");
    if (thisDXCoil.RateWithInternalStaticAndFanObject) {
        PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXFanName, thisDXCoil.Name, thisDXCoil.SupplyFanName);
    } else {
        PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXFanName, thisDXCoil.Name, "None");
    }
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilNetCapSI, thisDXCoil.Name, NetCoolingCapRated, 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilCOP, thisDXCoil.Name, EER_TestPoint_SI(1), 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilIEERIP, thisDXCoil.Name, IEER, 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilEERIP, thisDXCoil.Name, EER_TestPoint_IP(1), 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilMdotA, thisDXCoil.Name, SupAirMdot_TestPoint(1), 4);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilCOP_B, thisDXCoil.Name, EER_TestPoint_SI(2), 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilEER_B_IP, thisDXCoil.Name, EER_TestPoint_IP(2), 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilMdotB, thisDXCoil.Name, SupAirMdot_TestPoint(2), 4);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilCOP_C, thisDXCoil.Name, EER_TestPoint_SI(3), 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilEER_C_IP, thisDXCoil.Name, EER_TestPoint_IP(3), 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilMdotC, thisDXCoil.Name, SupAirMdot_TestPoint(3), 4);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilCOP_D, thisDXCoil.Name, EER_TestPoint_SI(4), 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilEER_D_IP, thisDXCoil.Name, EER_TestPoint_IP(4), 2);
    PreDefTableEntry(state, state.dataOutRptPredefined->pdchVAVDXCoolCoilMdotD, thisDXCoil.Name, SupAirMdot_TestPoint(4), 4);

    state.dataEnvrn->OutDryBulbTemp = heldOutDryBulb; // reset the outdoor dry bulb when done with it
}

void GetFanIndexForTwoSpeedCoil(
    EnergyPlusData &state, int const CoolingCoilIndex, int &SupplyFanIndex, std::string &SupplyFanName, HVAC::FanType &supplyFanType)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         <author>
    //       DATE WRITTEN   <date_written>

    // PURPOSE OF THIS SUBROUTINE:
    // This routine looks up the given TwoSpeed DX coil and returns the companion supply fan index

    // Using/Aliasing
    int NumPrimaryAirSys = state.dataHVACGlobal->NumPrimaryAirSys;

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int FoundBranch;
    int FoundAirSysNum;
    int AirSysNum;
    int BranchNum;
    int CompNum;

    FoundBranch = 0;
    FoundAirSysNum = 0;
    SupplyFanIndex = 0;
    SupplyFanName = "n/a";
    for (AirSysNum = 1; AirSysNum <= NumPrimaryAirSys; ++AirSysNum) {

        for (BranchNum = 1; BranchNum <= state.dataAirSystemsData->PrimaryAirSystems(AirSysNum).NumBranches; ++BranchNum) {

            for (CompNum = 1; CompNum <= state.dataAirSystemsData->PrimaryAirSystems(AirSysNum).Branch(BranchNum).TotalComponents; ++CompNum) {

                if (state.dataAirSystemsData->PrimaryAirSystems(AirSysNum).Branch(BranchNum).Comp(CompNum).CompType_Num ==
                    SimAirServingZones::CompType::DXSystem) {

                    if (Util::SameString(state.dataAirSystemsData->PrimaryAirSystems(AirSysNum).Branch(BranchNum).Comp(CompNum).Name,
                                         state.dataDXCoils->DXCoil(CoolingCoilIndex).CoilSystemName)) {
                        FoundBranch = BranchNum;
                        FoundAirSysNum = AirSysNum;
                        break;
                    }
                    // these are specified in SimAirServingZones and need to be moved to a Data* file. UnitarySystem=19
                } else if (state.dataAirSystemsData->PrimaryAirSystems(AirSysNum).Branch(BranchNum).Comp(CompNum).CompType_Num ==
                           SimAirServingZones::CompType::UnitarySystemModel) {

                    if (Util::SameString(state.dataAirSystemsData->PrimaryAirSystems(AirSysNum).Branch(BranchNum).Comp(CompNum).Name,
                                         state.dataDXCoils->DXCoil(CoolingCoilIndex).CoilSystemName)) {
                        FoundBranch = BranchNum;
                        FoundAirSysNum = AirSysNum;
                        break;
                    }
                }
            }

            if (FoundBranch > 0 && FoundAirSysNum > 0) {
                for (CompNum = 1; CompNum <= state.dataAirSystemsData->PrimaryAirSystems(FoundAirSysNum).Branch(FoundBranch).TotalComponents;
                     ++CompNum) {
                    if (state.dataAirSystemsData->PrimaryAirSystems(FoundAirSysNum).Branch(FoundBranch).Comp(CompNum).CompType_Num ==
                        SimAirServingZones::CompType::Fan_Simple_VAV) {
                        SupplyFanName = state.dataAirSystemsData->PrimaryAirSystems(FoundAirSysNum).Branch(FoundBranch).Comp(CompNum).Name;
                        SupplyFanIndex = Fans::GetFanIndex(state, SupplyFanName);
                        supplyFanType = HVAC::FanType::VAV;
                        break;
                        // these are specified in SimAirServingZones and need to be moved to a Data* file. UnitarySystem=19
                    } else if (state.dataAirSystemsData->PrimaryAirSystems(FoundAirSysNum).Branch(FoundBranch).Comp(CompNum).CompType_Num ==
                               SimAirServingZones::CompType::Fan_System_Object) {
                        SupplyFanName = state.dataAirSystemsData->PrimaryAirSystems(FoundAirSysNum).Branch(FoundBranch).Comp(CompNum).Name;
                        SupplyFanIndex = Fans::GetFanIndex(state, SupplyFanName);
                        supplyFanType = HVAC::FanType::SystemModel;

                    } else if (state.dataAirSystemsData->PrimaryAirSystems(FoundAirSysNum).Branch(FoundBranch).Comp(CompNum).CompType_Num ==
                               SimAirServingZones::CompType::UnitarySystemModel) {
                        // fan may not be specified in a unitary system object, keep looking
                        // Unitary System will "set" the fan index to the DX coil if contained within the HVAC system
                        if (state.dataDXCoils->DXCoil(CoolingCoilIndex).SupplyFanIndex > 0) break;
                    }
                }
            }
        }
    }
}

void GetDXCoilIndex(EnergyPlusData &state,
                    std::string const &DXCoilName,
                    int &DXCoilIndex,
                    bool &ErrorsFound,
                    std::string_view const ThisObjectType,
                    bool const SuppressWarning)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Richard Raustad
    //       DATE WRITTEN   March 2005

    // PURPOSE OF THIS SUBROUTINE:
    // This subroutine sets an index for a given DX Coil -- issues error message if that
    // DX Coil is not a legal DX Coil.

    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    DXCoilIndex = Util::FindItemInList(DXCoilName, state.dataDXCoils->DXCoil);
    if (DXCoilIndex == 0) {
        if (!SuppressWarning) {
            //     No warning printed if only searching for the existence of a DX Coil
            if (!ThisObjectType.empty()) {
                ShowSevereError(state, fmt::format("{}, GetDXCoilIndex: DX Coil not found={}", ThisObjectType, DXCoilName));
            } else {
                ShowSevereError(state, format("GetDXCoilIndex: DX Coil not found={}", DXCoilName));
            }
        }
        ErrorsFound = true;
    }
}

std::string
GetDXCoilName(EnergyPlusData &state, int &DXCoilIndex, bool &ErrorsFound, std::string_view const ThisObjectType, bool const SuppressWarning)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Richard Raustad
    //       DATE WRITTEN   May 2017

    // PURPOSE OF THIS SUBROUTINE:
    // This subroutine gets a name for a given DX Coil -- issues error message if that
    // DX Coil is not a legal DX Coil.

    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    if (DXCoilIndex == 0) {
        if (!SuppressWarning) {
            //     No warning printed if only searching for the existence of a DX Coil
            if (!ThisObjectType.empty()) {
                ShowSevereError(state, fmt::format("{}, GetDXCoilIndex: DX Coil not found ", ThisObjectType));
            } else {
                ShowSevereError(state, "GetDXCoilIndex: DX Coil not found ");
            }
        }
        ErrorsFound = true;
        return " "; // This does not seem great

    } else {
        return state.dataDXCoils->DXCoil(DXCoilIndex).Name;
    }
}

Real64 GetCoilCapacity(EnergyPlusData &state,
                       std::string const &CoilType, // must match coil types in this module
                       std::string const &CoilName, // must match coil names for the coil type
                       bool &ErrorsFound            // set to true if problem
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         Linda Lawrie
    //       DATE WRITTEN   February 2006

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the coil capacity for the given coil and returns it.  If
    // incorrect coil type or name is given, ErrorsFound is returned as true and capacity is returned
    // as negative.

    // Return value
    Real64 CoilCapacity; // returned capacity of matched coil

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    if (Util::SameString(CoilType, "Coil:Heating:DX:SingleSpeed") || Util::SameString(CoilType, "Coil:Cooling:DX:SingleSpeed")) {
        WhichCoil = Util::FindItem(CoilName, state.dataDXCoils->DXCoil);
        if (WhichCoil != 0) {
            CoilCapacity = state.dataDXCoils->DXCoil(WhichCoil).RatedTotCap(1);
        }
    } else if (Util::SameString(CoilType, "Coil:Cooling:DX:TwoStageWithHumidityControlMode")) {
        WhichCoil = Util::FindItem(CoilName, state.dataDXCoils->DXCoil);
        if (WhichCoil != 0) {
            CoilCapacity = state.dataDXCoils->DXCoil(WhichCoil).RatedTotCap(state.dataDXCoils->DXCoil(WhichCoil).NumCapacityStages);
        }
    } else if (Util::SameString(CoilType, "Coil:Cooling:DX:TwoSpeed")) {
        WhichCoil = Util::FindItem(CoilName, state.dataDXCoils->DXCoil);
        if (WhichCoil != 0) {
            CoilCapacity = state.dataDXCoils->DXCoil(WhichCoil).RatedTotCap(1);
        }
    } else if (Util::SameString(CoilType, "Coil:Cooling:DX:MultiSpeed") || Util::SameString(CoilType, "Coil:Heating:DX:MultiSpeed")) {
        WhichCoil = Util::FindItem(CoilName, state.dataDXCoils->DXCoil);
        if (WhichCoil != 0) {
            CoilCapacity = state.dataDXCoils->DXCoil(WhichCoil).MSRatedTotCap(state.dataDXCoils->DXCoil(WhichCoil).NumOfSpeeds);
        }
    } else {
        WhichCoil = 0;
    }

    if (WhichCoil == 0) {
        ShowSevereError(state, format("GetCoilCapacity: Could not find Coil, Type=\"{}\" Name=\"{}\"", CoilType, CoilName));
        ShowContinueError(state, "... returning capacity as -1000.");
        ErrorsFound = true;
        CoilCapacity = -1000.0;
    }

    return CoilCapacity;
}

Real64 GetCoilCapacityByIndexType(EnergyPlusData &state,
                                  int const CoilIndex,    // must match coil index for the coil type
                                  int const CoilType_Num, // must match coil types in this module
                                  bool &ErrorsFound       // set to true if problem
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         Richard Raustad
    //       DATE WRITTEN   October 2010

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the coil capacity for the given coil and returns it.  If
    // incorrect coil index or type is given, ErrorsFound is returned as true and capacity is returned
    // as negative.

    // Return value
    Real64 CoilCapacity; // returned capacity of matched coil

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    if (CoilIndex == 0) {
        ShowSevereError(state, "GetCoilCapacityByIndexType: Invalid index passed = 0");
        ShowContinueError(state, "... returning capacity as -1000.");
        ErrorsFound = true;
        CoilCapacity = -1000.0;
        return CoilCapacity;
    }

    if (CoilType_Num != state.dataDXCoils->DXCoil(CoilIndex).DXCoilType_Num) {
        ShowSevereError(state, "GetCoilCapacityByIndexType: Index passed does not match DX Coil type passed.");
        ShowContinueError(state, "... returning capacity as -1000.");
        ErrorsFound = true;
        CoilCapacity = -1000.0;
    } else {
        switch (state.dataDXCoils->DXCoil(CoilIndex).DXCoilType_Num) {
        case HVAC::CoilDX_MultiSpeedCooling:
        case HVAC::CoilDX_MultiSpeedHeating: {
            CoilCapacity = state.dataDXCoils->DXCoil(CoilIndex).MSRatedTotCap(state.dataDXCoils->DXCoil(CoilIndex).NumOfSpeeds);
        } break;
        default: {
            CoilCapacity = state.dataDXCoils->DXCoil(CoilIndex).RatedTotCap(state.dataDXCoils->DXCoil(CoilIndex).NumCapacityStages);
        } break;
        }
    }

    return CoilCapacity;
}

int GetCoilTypeNum(EnergyPlusData &state,
                   std::string const &CoilType,                // must match coil types in this module
                   std::string const &CoilName,                // must match coil names for the coil type
                   bool &ErrorsFound,                          // set to true if problem
                   ObjexxFCL::Optional_bool_const PrintWarning // prints warning when true
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         R. Raustad - FSEC
    //       DATE WRITTEN   August 2008

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the integerized coil type for the given coil and returns it.  If
    // incorrect coil type or name is given, ErrorsFound is returned as true and capacity is returned
    // as negative.

    // Return value
    int TypeNum; // returned integerized type of matched coil

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;
    bool PrintMessage;

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    if (present(PrintWarning)) {
        PrintMessage = PrintWarning;
    } else {
        PrintMessage = true;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        TypeNum = state.dataDXCoils->DXCoil(WhichCoil).DXCoilType_Num;
    } else {
        if (PrintMessage) {
            ShowSevereError(state, format("GetCoilTypeNum: Could not find Coil, Type=\"{}\" Name=\"{}\"", CoilType, CoilName));
        }
        ErrorsFound = true;
        TypeNum = 0;
    }

    return TypeNum;
}

Real64 GetMinOATCompressor(EnergyPlusData &state,
                           int const CoilIndex, // index to cooling coil
                           bool &ErrorsFound    // set to true if problem
)
{

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    if (CoilIndex == 0) {
        ShowSevereError(state, "GetMinOATCompressor: Index passed = 0");
        ShowContinueError(state, "... returning Min OAT for compressor operation as -1000.");
        ErrorsFound = true;
        return -1000.0;
    } else {
        return state.dataDXCoils->DXCoil(CoilIndex).MinOATCompressor;
    }
}

int GetCoilInletNode(EnergyPlusData &state,
                     std::string const &CoilType, // must match coil types in this module
                     std::string const &CoilName, // must match coil names for the coil type
                     bool &ErrorsFound            // set to true if problem
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         Linda Lawrie
    //       DATE WRITTEN   February 2006

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the given coil and returns the inlet node number.  If
    // incorrect coil type or name is given, ErrorsFound is returned as true and node number is returned
    // as zero.

    // Return value
    int NodeNumber; // returned node number of matched coil

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        NodeNumber = state.dataDXCoils->DXCoil(WhichCoil).AirInNode;
    } else {
        ShowSevereError(state, format("GetCoilInletNode: Could not find Coil, Type=\"{}\" Name=\"{}\"", CoilType, CoilName));
        ErrorsFound = true;
        NodeNumber = 0;
    }

    return NodeNumber;
}

int getCoilInNodeIndex(EnergyPlusData &state,
                       int const CoilIndex, // coil index
                       bool &ErrorsFound    // set to true if problem
)
{

    int NodeNumber; // returned node number of matched coil

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    if (CoilIndex != 0) {
        NodeNumber = state.dataDXCoils->DXCoil(CoilIndex).AirInNode;
    } else {
        ShowSevereError(state, "GetCoilInletNode: Could not find Coil Type");
        ErrorsFound = true;
        NodeNumber = 0;
    }

    return NodeNumber;
}

int GetCoilOutletNode(EnergyPlusData &state,
                      std::string const &CoilType, // must match coil types in this module
                      std::string const &CoilName, // must match coil names for the coil type
                      bool &ErrorsFound            // set to true if problem
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         Linda Lawrie
    //       DATE WRITTEN   February 2006

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the given coil and returns the inlet node number.  If
    // incorrect coil type or name is given, ErrorsFound is returned as true and node number is returned
    // as zero.

    // Return value
    int NodeNumber; // returned node number of matched coil

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        NodeNumber = state.dataDXCoils->DXCoil(WhichCoil).AirOutNode;
    } else {
        ShowSevereError(
            state,
            format("GetCoilOutletNode: Could not find Coil, Type=\"{}\" Name=\"{}\" when accessing coil outlet node number.", CoilType, CoilName));
        ErrorsFound = true;
        NodeNumber = 0;
    }

    return NodeNumber;
}

int getCoilOutNodeIndex(EnergyPlusData &state,
                        int const CoilIndex, // must match coil types in this module
                        bool &ErrorsFound    // set to true if problem
)
{

    int NodeNumber; // returned node number of matched coil

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    if (CoilIndex != 0) {
        NodeNumber = state.dataDXCoils->DXCoil(CoilIndex).AirOutNode;
    } else {
        ShowSevereError(state, "GetCoilOutletNode: Could not find Coil Type");
        ErrorsFound = true;
        NodeNumber = 0;
    }

    return NodeNumber;
}

int GetCoilCondenserInletNode(EnergyPlusData &state,
                              std::string const &CoilType, // must match coil types in this module
                              std::string const &CoilName, // must match coil names for the coil type
                              bool &ErrorsFound            // set to true if problem
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         R. Raustad
    //       DATE WRITTEN   January 2007

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the given coil and returns the condenser inlet node.  If
    // incorrect coil type or name is given, ErrorsFound is returned as true.

    // Return value
    int CondNode; // returned condenser node number of matched coil

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        CondNode = state.dataDXCoils->DXCoil(WhichCoil).CondenserInletNodeNum(1);
    } else {
        ShowSevereError(state, format("GetCoilCondenserInletNode: Invalid DX Coil, Type= \"{}\" Name=\"{}\"", CoilType, CoilName));
        ErrorsFound = true;
        CondNode = 0;
    }

    return CondNode;
}

Real64 GetDXCoilBypassedFlowFrac(EnergyPlusData &state,
                                 std::string const &CoilType, // must match coil types in this module
                                 std::string const &CoilName, // must match coil names for the coil type
                                 bool &ErrorsFound            // set to true if problem
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         R. Raustad
    //       DATE WRITTEN   June 2007

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the given coil and returns the bypassed air flow fraction.
    // Bypassed air flow fraction can only be greater than 0 for multimode DX cooling coils and is typical for 1st stage
    // If incorrect coil type or name is given, ErrorsFound is returned as true.

    // Return value
    Real64 BypassFraction; // returned bypass air fraction of matched coil

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        BypassFraction = state.dataDXCoils->DXCoil(WhichCoil).BypassedFlowFrac(1);
    } else {
        ShowSevereError(state, format("GetDXCoilBypassedFlowFrac: Invalid DX Coil Type=\"{}\" Name=\"{}\"", CoilType, CoilName));
        ErrorsFound = true;
        BypassFraction = 0.0;
    }

    return BypassFraction;
}

int GetHPCoolingCoilIndex(EnergyPlusData &state,
                          std::string const &HeatingCoilType, // Type of DX heating coil used in HP
                          std::string const &HeatingCoilName, // Name of DX heating coil used in HP
                          int const HeatingCoilIndex          // Index of DX heating coil used in HP
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         R. Raustad
    //       DATE WRITTEN   February 2007

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the given DX heating coil and returns the companion DX cooling coil.

    // Return value
    int DXCoolingCoilIndex; // Index of HP DX cooling coil returned from this function

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    int WhichComp;           // DO loop counter to find correct comp set
    int WhichCompanionComp;  // DO loop counter to find companion coil comp set
    int WhichHXAssistedComp; // DO loop counter when DX coil is used in a HX assisted cooling coil

    DXCoolingCoilIndex = 0;

    DataLoopNode::ConnectionObjectType HeatingCoilTypeNum = static_cast<DataLoopNode::ConnectionObjectType>(
        getEnumValue(BranchNodeConnections::ConnectionObjectTypeNamesUC, Util::makeUPPER(HeatingCoilType)));

    DataLoopNode::ConnectionObjectType CompSetsParentType; // Parent object type which uses DX heating coil pass into this function
    std::string CompSetsParentName;
    for (WhichComp = 1; WhichComp <= state.dataBranchNodeConnections->NumCompSets; ++WhichComp) {

        if (HeatingCoilTypeNum != state.dataBranchNodeConnections->CompSets(WhichComp).ComponentObjectType ||
            !Util::SameString(HeatingCoilName, state.dataBranchNodeConnections->CompSets(WhichComp).CName))
            continue;
        CompSetsParentType = state.dataBranchNodeConnections->CompSets(WhichComp).ParentObjectType;
        CompSetsParentName = state.dataBranchNodeConnections->CompSets(WhichComp).ParentCName;
        if ((CompSetsParentType == DataLoopNode::ConnectionObjectType::AirLoopHVACUnitaryHeatPumpAirToAir) ||
            (CompSetsParentType == DataLoopNode::ConnectionObjectType::ZoneHVACPackagedTerminalHeatPump) ||
            (CompSetsParentType == DataLoopNode::ConnectionObjectType::AirLoopHVACUnitaryHeatPumpAirToAirMultiSpeed) ||
            (CompSetsParentType == DataLoopNode::ConnectionObjectType::AirLoopHVACUnitaryHeatCoolVAVChangeoverBypass) ||
            (CompSetsParentType == DataLoopNode::ConnectionObjectType::AirLoopHVACUnitarySystem)) {
            //       Search for DX cooling coils
            for (WhichCompanionComp = 1; WhichCompanionComp <= state.dataBranchNodeConnections->NumCompSets; ++WhichCompanionComp) {
                if (!Util::SameString(state.dataBranchNodeConnections->CompSets(WhichCompanionComp).ParentCName, CompSetsParentName) ||
                    (state.dataBranchNodeConnections->CompSets(WhichCompanionComp).ComponentObjectType !=
                     DataLoopNode::ConnectionObjectType::CoilCoolingDXSingleSpeed))
                    continue;
                DXCoolingCoilIndex =
                    Util::FindItemInList(state.dataBranchNodeConnections->CompSets(WhichCompanionComp).CName, state.dataDXCoils->DXCoil);
                break;
            }
            for (WhichCompanionComp = 1; WhichCompanionComp <= state.dataBranchNodeConnections->NumCompSets; ++WhichCompanionComp) {
                if (!Util::SameString(state.dataBranchNodeConnections->CompSets(WhichCompanionComp).ParentCName, CompSetsParentName) ||
                    (state.dataBranchNodeConnections->CompSets(WhichCompanionComp).ComponentObjectType !=
                     DataLoopNode::ConnectionObjectType::CoilCoolingDXMultiSpeed))
                    continue;
                DXCoolingCoilIndex =
                    Util::FindItemInList(state.dataBranchNodeConnections->CompSets(WhichCompanionComp).CName, state.dataDXCoils->DXCoil);
                break;
            }
            //       Search for Heat Exchanger Assisted DX cooling coils
            if (DXCoolingCoilIndex == 0) {
                for (WhichHXAssistedComp = 1; WhichHXAssistedComp <= state.dataBranchNodeConnections->NumCompSets; ++WhichHXAssistedComp) {
                    if (!Util::SameString(state.dataBranchNodeConnections->CompSets(WhichHXAssistedComp).ParentCName, CompSetsParentName) ||
                        (state.dataBranchNodeConnections->CompSets(WhichHXAssistedComp).ComponentObjectType !=
                         DataLoopNode::ConnectionObjectType::CoilSystemCoolingDXHeatExchangerAssisted))
                        continue;
                    DataLoopNode::ConnectionObjectType HXCompSetsParentType; // Used when DX cooling coil is a child of a HX assisted cooling coil
                    HXCompSetsParentType = state.dataBranchNodeConnections->CompSets(WhichHXAssistedComp).ComponentObjectType;
                    std::string const &HXCompSetsParentName = state.dataBranchNodeConnections->CompSets(WhichHXAssistedComp).CName;
                    for (WhichCompanionComp = 1; WhichCompanionComp <= state.dataBranchNodeConnections->NumCompSets; ++WhichCompanionComp) {
                        if (!Util::SameString(state.dataBranchNodeConnections->CompSets(WhichCompanionComp).ParentCName, HXCompSetsParentName) ||
                            (state.dataBranchNodeConnections->CompSets(WhichCompanionComp).ComponentObjectType !=
                             DataLoopNode::ConnectionObjectType::CoilCoolingDXSingleSpeed))
                            continue;
                        DXCoolingCoilIndex =
                            Util::FindItemInList(state.dataBranchNodeConnections->CompSets(WhichCompanionComp).CName, state.dataDXCoils->DXCoil);
                        break;
                    }
                    break;
                }
            }
        } else {
            //     ErrorFound, Coil:Heating:DX:SingleSpeed is used in wrong type of parent object (should never get here)
            ShowSevereError(state,
                            format("Configuration error in {}\"{}\"",
                                   BranchNodeConnections::ConnectionObjectTypeNames[static_cast<int>(CompSetsParentType)],
                                   CompSetsParentName));
            ShowContinueError(state, "DX heating coil not allowed in this configuration.");
            ShowFatalError(state, "Preceding condition(s) causes termination.");
        }
        break;
    }

    // Check and warn user is crankcase heater power or max OAT for crankcase heater differs in DX cooling and heating coils
    if (DXCoolingCoilIndex > 0) {
        if (state.dataDXCoils->DXCoil(DXCoolingCoilIndex).CrankcaseHeaterCapacity != 0.0) {
            if (state.dataDXCoils->DXCoil(DXCoolingCoilIndex).CrankcaseHeaterCapacity !=
                    state.dataDXCoils->DXCoil(HeatingCoilIndex).CrankcaseHeaterCapacity ||
                state.dataDXCoils->DXCoil(DXCoolingCoilIndex).MaxOATCrankcaseHeater !=
                    state.dataDXCoils->DXCoil(HeatingCoilIndex).MaxOATCrankcaseHeater) {
                ShowWarningError(state, "Crankcase heater capacity or max outdoor temp for crankcase heater operation specified in");
                ShowContinueError(state, format("Coil:Cooling:DX:SingleSpeed = {}", state.dataDXCoils->DXCoil(DXCoolingCoilIndex).Name));
                ShowContinueError(state, format("is different than that specified in Coil:Heating:DX:SingleSpeed = {}.", HeatingCoilName));
                ShowContinueError(state,
                                  format("Both of these DX coils are part of {}={}.",
                                         BranchNodeConnections::ConnectionObjectTypeNames[static_cast<int>(CompSetsParentType)],
                                         CompSetsParentName));
                ShowContinueError(state, "The value specified in the DX heating coil will be used and the simulation continues...");
            }
        }
    }

    return DXCoolingCoilIndex;
}

int GetDXCoilNumberOfSpeeds(EnergyPlusData &state,
                            std::string const &CoilType, // must match coil types in this module
                            std::string const &CoilName, // must match coil names for the coil type
                            bool &ErrorsFound            // set to true if problem
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         L. Gu
    //       DATE WRITTEN   July 2007

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the given coil and returns the number of speeds for multispeed coils.
    // If incorrect coil type or name is given, ErrorsFound is returned as true.

    // Return value
    int NumberOfSpeeds; // returned the number of speed of matched coil

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        NumberOfSpeeds = state.dataDXCoils->DXCoil(WhichCoil).NumOfSpeeds;
    } else {
        ShowSevereError(state, format("GetDXCoilNumberOfSpeeds: Invalid DX Coil Type=\"{}\" Name=\"{}\"", CoilType, CoilName));
        ErrorsFound = true;
        NumberOfSpeeds = 0;
    }

    return NumberOfSpeeds;
}

int GetDXCoilAvailSchPtr(EnergyPlusData &state,
                         std::string const &CoilType,            // must match coil types in this module
                         std::string const &CoilName,            // must match coil names for the coil type
                         bool &ErrorsFound,                      // set to true if problem
                         ObjexxFCL::Optional_int_const CoilIndex // Coil index number
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         Richard Raustad
    //       DATE WRITTEN   January 2013

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the given coil and returns the availability schedule index.  If
    // incorrect coil type or name is given, ErrorsFound is returned as true and schedule index is returned
    // as -1.

    // Return value
    int SchPtr; // returned availability schedule of matched coil

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    if (present(CoilIndex)) {
        if (CoilIndex == 0) {
            ShowSevereError(state, "GetDXCoilAvailSchPtr: Invalid index passed = 0");
            ShowContinueError(state, "... returning DXCoilAvailSchPtr as -1.");
            ErrorsFound = true;
            SchPtr = -1;
            return SchPtr;
        } else {
            WhichCoil = CoilIndex;
        }
    } else {
        WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    }
    if (WhichCoil != 0) {
        SchPtr = state.dataDXCoils->DXCoil(WhichCoil).SchedPtr;
    } else {
        if (!present(CoilIndex)) {
            ShowSevereError(state,
                            format("GetDXCoilAvailSch: Could not find Coil, Type=\"{}\" Name=\"{}\" when accessing coil availability schedule index.",
                                   CoilType,
                                   CoilName));
        }
        ErrorsFound = true;
        SchPtr = -1;
    }

    return SchPtr;
}

Real64 GetDXCoilAirFlow(EnergyPlusData &state,
                        std::string const &CoilType, // must match coil types in this module
                        std::string const &CoilName, // must match coil names for the coil type
                        bool &ErrorsFound            // set to true if problem
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         Richard Raustad
    //       DATE WRITTEN   January 2013

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the given coil and returns the availability schedule index.  If
    // incorrect coil type or name is given, ErrorsFound is returned as true and schedule index is returned
    // as -1.

    // Return value
    Real64 AirFlow; // returned coil air flow rate

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        switch (state.dataDXCoils->DXCoil(WhichCoil).DXCoilType_Num) {
        case HVAC::CoilDX_CoolingSingleSpeed:
        case HVAC::CoilDX_CoolingTwoSpeed:
        case HVAC::CoilDX_HeatingEmpirical:
        case HVAC::CoilDX_CoolingTwoStageWHumControl: {
            AirFlow = state.dataDXCoils->DXCoil(WhichCoil).RatedAirVolFlowRate(1);
        } break;
        case HVAC::CoilDX_MultiSpeedCooling:
        case HVAC::CoilDX_MultiSpeedHeating: {
            AirFlow = state.dataDXCoils->DXCoil(WhichCoil).MSRatedAirVolFlowRate(1);
        } break;
        default: {
            ShowSevereError(
                state,
                format("GetDXCoilAirFlow: Could not find Coil, Type=\"{}\" Name=\"{}\" when accessing coil air flow rate.", CoilType, CoilName));
            ErrorsFound = true;
            AirFlow = -1.0;
        } break;
        }
    } else {
        ShowSevereError(
            state, format("GetDXCoilAirFlow: Could not find Coil, Type=\"{}\" Name=\"{}\" when accessing coil air flow rate.", CoilType, CoilName));
        ErrorsFound = true;
        AirFlow = -1.0;
    }

    return AirFlow;
}

int GetDXCoilCapFTCurveIndex(EnergyPlusData &state,
                             int const CoilIndex, // coil index pointer
                             bool &ErrorsFound    // set to true if problem
)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         Richard Raustad
    //       DATE WRITTEN   August 2013

    // PURPOSE OF THIS FUNCTION:
    // This function looks up the given coil and returns the CapFT schedule index.  If
    // incorrect coil index is given, ErrorsFound is returned as true and schedule index is returned
    // as -1.

    // Return value
    int CapFTCurveIndex; // returned coil CapFT curve index

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    if (CoilIndex != 0) {
        switch (state.dataDXCoils->DXCoil(CoilIndex).DXCoilType_Num) {
        case HVAC::CoilDX_CoolingSingleSpeed:
        case HVAC::CoilDX_CoolingTwoSpeed:
        case HVAC::CoilDX_HeatingEmpirical:
        case HVAC::CoilDX_CoolingTwoStageWHumControl: {
            CapFTCurveIndex = state.dataDXCoils->DXCoil(CoilIndex).CCapFTemp(1);
        } break;
        case HVAC::CoilDX_MultiSpeedCooling:
        case HVAC::CoilDX_MultiSpeedHeating: {
            CapFTCurveIndex = state.dataDXCoils->DXCoil(CoilIndex).MSCCapFTemp(state.dataDXCoils->DXCoil(CoilIndex).NumOfSpeeds);
        } break;
        case HVAC::CoilVRF_Heating: {
            CapFTCurveIndex = state.dataDXCoils->DXCoil(CoilIndex).CCapFTemp(1);
        } break;
        default: {
            //        CALL ShowSevereError(state, 'GetDXCoilCapFTCurveIndex: Could not find Coil, Type="'// &
            //             TRIM(cAllCoilTypes(DXCoil(CoilIndex)%DXCoilType_Num))//'" Name="'//TRIM(DXCoil(CoilIndex)%Name)//  &
            //              '" when accessing coil capacity as a function of temperature curve.')
            ErrorsFound = true;
            CapFTCurveIndex = 0;
        } break;
        }
    } else {
        //    CALL ShowSevereError(state, 'GetDXCoilCapFTCurveIndex: Could not find Coil, Index = 0'// &
        //          ' when accessing coil air flow rate.')
        ErrorsFound = true;
        CapFTCurveIndex = 0;
    }

    return CapFTCurveIndex;
}

void SetDXCoolingCoilData(
    EnergyPlusData &state,
    int const DXCoilNum,                                                     // Number of DX Cooling Coil
    bool &ErrorsFound,                                                       // Set to true if certain errors found
    ObjexxFCL::Optional_int HeatingCoilPLFCurvePTR,                          // Parameter equivalent of heating coil PLR curve index
    ObjexxFCL::Optional<DataHeatBalance::RefrigCondenserType> CondenserType, // Parameter equivalent of condenser type parameter
    ObjexxFCL::Optional_int CondenserInletNodeNum,                           // Parameter equivalent of condenser inlet node number
    ObjexxFCL::Optional<Real64> MaxOATCrankcaseHeater,                       // Parameter equivalent of condenser Max OAT for Crank Case Heater temp
    ObjexxFCL::Optional<Real64> MinOATCooling,                    // Parameter equivalent of condenser Min OAT for compressor cooling operation
    ObjexxFCL::Optional<Real64> MaxOATCooling,                    // Parameter equivalent of condenser Max OAT for compressor cooling operation
    ObjexxFCL::Optional<Real64> MinOATHeating,                    // Parameter equivalent of condenser Min OAT for compressor heating operation
    ObjexxFCL::Optional<Real64> MaxOATHeating,                    // Parameter equivalent of condenser Max OAT for compressor heating operation
    ObjexxFCL::Optional<HVAC::OATType> HeatingPerformanceOATType, // Parameter equivalent to condenser entering air temp type (1-db, 2=wb)
    ObjexxFCL::Optional<StandardRatings::DefrostStrat> DefrostStrategy,
    ObjexxFCL::Optional<StandardRatings::HPdefrostControl> DefrostControl,
    ObjexxFCL::Optional_int DefrostEIRPtr,
    ObjexxFCL::Optional<Real64> DefrostFraction,
    ObjexxFCL::Optional<Real64> DefrostCapacity,
    ObjexxFCL::Optional<Real64> MaxOATDefrost,
    ObjexxFCL::Optional_bool CoolingCoilPresent,
    ObjexxFCL::Optional_bool HeatingCoilPresent,
    ObjexxFCL::Optional<Real64> HeatSizeRatio,
    ObjexxFCL::Optional<Real64> TotCap,
    ObjexxFCL::Optional_int SupplyFanIndex,
    ObjexxFCL::Optional_string SupplyFanName,
    ObjexxFCL::Optional<HVAC::FanType> supplyFanType)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Richard Raustad, FSEC
    //       DATE WRITTEN   December 2008

    // PURPOSE OF THIS SUBROUTINE:
    // This routine was designed to allow the DX coil to access information from a gas or
    // electric heating coil when these coils are each used in a parent object.
    // Also, this is an illustration of setting Data from an outside source.

    // Using/Aliasing

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    if (DXCoilNum <= 0 || DXCoilNum > state.dataDXCoils->NumDXCoils) {
        ShowSevereError(state,
                        format("SetDXCoolingCoilData: called with DX Cooling Coil Number out of range={} should be >0 and <{}",
                               DXCoilNum,
                               state.dataDXCoils->NumDXCoils));
        ErrorsFound = true;
        return;
    }

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);
    if (present(HeatingCoilPLFCurvePTR)) {
        thisDXCoil.HeatingCoilPLFCurvePTR = HeatingCoilPLFCurvePTR;
    }

    if (present(CondenserType)) {
        thisDXCoil.CondenserType = CondenserType;
    }

    if (present(CondenserInletNodeNum)) {
        thisDXCoil.CondenserInletNodeNum(1) = CondenserInletNodeNum;
    }

    if (present(MaxOATCrankcaseHeater)) {
        thisDXCoil.MaxOATCrankcaseHeater = MaxOATCrankcaseHeater;
    }

    if (present(MaxOATCooling)) {
        thisDXCoil.MaxOATCompressor = MaxOATCooling;
    }

    if (present(MaxOATHeating)) {
        thisDXCoil.MaxOATCompressor = MaxOATHeating;
    }

    if (present(MinOATCooling)) {
        thisDXCoil.MinOATCompressor = MinOATCooling;
    }

    if (present(MinOATHeating)) {
        thisDXCoil.MinOATCompressor = MinOATHeating;
    }

    if (present(HeatingPerformanceOATType)) {
        thisDXCoil.HeatingPerformanceOATType = HeatingPerformanceOATType;
    }

    if (present(DefrostStrategy)) {
        thisDXCoil.DefrostStrategy = DefrostStrategy;
    }

    if (present(DefrostControl)) {
        thisDXCoil.DefrostControl = DefrostControl;
    }

    if (present(DefrostEIRPtr)) {
        thisDXCoil.DefrostEIRFT = DefrostEIRPtr;
    }

    if (present(DefrostFraction)) {
        thisDXCoil.DefrostTime = DefrostFraction;
    }

    if (present(DefrostCapacity)) {
        thisDXCoil.DefrostCapacity = DefrostCapacity;
    }

    if (present(MaxOATDefrost)) {
        thisDXCoil.MaxOATDefrost = MaxOATDefrost;
    }

    if (present(CoolingCoilPresent)) {
        thisDXCoil.CoolingCoilPresent = CoolingCoilPresent;
    }

    if (present(HeatingCoilPresent)) {
        thisDXCoil.HeatingCoilPresent = HeatingCoilPresent;
    }

    if (present(HeatSizeRatio)) {
        thisDXCoil.HeatSizeRatio = HeatSizeRatio;
    }

    if (present(TotCap)) {
        thisDXCoil.RatedTotCap(1) = TotCap;
    }

    if (present(SupplyFanIndex)) {
        thisDXCoil.SupplyFanIndex = SupplyFanIndex;
    }

    if (present(SupplyFanName)) {
        thisDXCoil.SupplyFanName = SupplyFanName;
    }

    if (present(supplyFanType)) {
        thisDXCoil.supplyFanType = supplyFanType;
        if (thisDXCoil.SupplyFanIndex > 0) {
            state.dataRptCoilSelection->coilSelectionReportObj->setCoilSupplyFanInfo(state,
                                                                                     thisDXCoil.Name,
                                                                                     thisDXCoil.DXCoilType,
                                                                                     state.dataFans->fans(thisDXCoil.SupplyFanIndex)->Name,
                                                                                     state.dataFans->fans(thisDXCoil.SupplyFanIndex)->type,
                                                                                     thisDXCoil.SupplyFanIndex);
        }
    }
}

void SetCoilSystemHeatingDXFlag(EnergyPlusData &state,
                                std::string const &CoilType, // must match coil types in this module
                                std::string const &CoilName  // must match coil names for the coil type
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         B. Griffith
    //       DATE WRITTEN   Jan. 2012

    // PURPOSE OF THIS SUBROUTINE:
    // inform DX heating coil that is is part of a CoilSystem:Heating:DX
    // and therefore it need not find its companion cooling coil

    // METHODOLOGY EMPLOYED:
    // set value of logical flag FindCompanionUpStreamCoil to true

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    // Obtains and Allocates DXCoils
    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        state.dataDXCoils->DXCoil(WhichCoil).FindCompanionUpStreamCoil = false;
    } else {
        ShowSevereError(state, format("SetCoilSystemHeatingDXFlag: Could not find Coil, Type=\"{}\"Name=\"{}\"", CoilType, CoilName));
    }
}

void SetCoilSystemCoolingData(EnergyPlusData &state,
                              std::string const &CoilName, // must match coil names for the coil type
                              std::string const &CoilSystemName)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         B. Griffith
    //       DATE WRITTEN   July 2012

    // PURPOSE OF THIS SUBROUTINE:
    // inform the child DX coil what the name of its parent is.

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        state.dataDXCoils->DXCoil(WhichCoil).CoilSystemName = CoilSystemName;
    } else {
        ShowSevereError(state, format("SetCoilSystemCoolingData: Could not find Coil \"Name=\"{}\"", CoilName));
    }
}

Real64 CalcSHRUserDefinedCurves(EnergyPlusData &state,
                                Real64 const InletDryBulb,     // inlet air dry bulb temperature [C]
                                Real64 const InletWetBulb,     // inlet air wet bulb temperature [C]
                                Real64 const AirMassFlowRatio, // ratio of actual air mass flow to rated air mass flow
                                int const SHRFTempCurveIndex,  // SHR modifier curve index
                                int const SHRFFlowCurveIndex,  // SHR modifier curve index
                                Real64 const SHRRated          // rated sensible heat ratio, user input
)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         Bereket Nigusse, FSEC
    //       DATE WRITTEN   December 2012

    // PURPOSE OF THIS FUNCTION:
    //    Returns the operating sensible heat ratio for a given Rated SHR and coil entering
    //    air DBT and WBT, and supply air mass flow fraction.

    // METHODOLOGY EMPLOYED:
    //    Model uses user specified rated SHR, and SHR modifying curves for temperature and flow
    //    fraction.  The curves adjust the rated SHR based on biquadratic curve for temperatures
    //    and quadratic function for supply air mass flow ratio (actual vs rated).
    //    The biquadratic and quadratic curves are normalized curves generated from manufacturer's
    //    performance data

    // Using/Aliasing
    using Curve::CurveValue;

    // Return value
    Real64 SHRopr; // operating SHR, corrected for Temp and Flow Fraction

    // FUNCTION LOCAL VARIABLE DECLARATIONS:
    Real64 SHRTempModFac; // Sensible Heat Ratio modifier (function of entering wetbulb, entering drybulb)
    Real64 SHRFlowModFac; // Sensible Heat Ratio modifier (function of actual vs rated flow)

    //   Get SHR modifying factor (function of inlet wetbulb & drybulb) for off-rated conditions
    if (SHRFTempCurveIndex == 0) {
        SHRTempModFac = 1.0;
    } else {
        SHRTempModFac = CurveValue(state, SHRFTempCurveIndex, InletWetBulb, InletDryBulb);
        if (SHRTempModFac < 0.0) {
            SHRTempModFac = 0.0;
        }
    }
    //   Get SHR modifying factor (function of mass flow ratio) for off-rated conditions
    if (SHRFFlowCurveIndex == 0) {
        SHRFlowModFac = 1.0;
    } else {
        SHRFlowModFac = CurveValue(state, SHRFFlowCurveIndex, AirMassFlowRatio);
        if (SHRFlowModFac < 0.0) {
            SHRFlowModFac = 0.0;
        }
    }
    //  Calculate "operating" sensible heat ratio
    SHRopr = SHRRated * SHRTempModFac * SHRFlowModFac;

    if (SHRopr < 0.0) SHRopr = 0.0; // SHR cannot be less than zero
    if (SHRopr > 1.0) SHRopr = 1.0; // SHR cannot be greater than 1.0

    return SHRopr;
}

void SetDXCoilTypeData(EnergyPlusData &state, std::string const &CoilName) // must match coil names for the coil type
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         B. Nigusse
    //       DATE WRITTEN   January 2013

    // PURPOSE OF THIS SUBROUTINE:
    // inform the child DX coil if the DX cooling coil is for 100% DOAS application.

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        state.dataDXCoils->DXCoil(WhichCoil).ISHundredPercentDOASDXCoil = true;
    } else {
        // DXCoil(WhichCoil)%ISHundredPercentDOASDXCoil = .FALSE. //Autodesk:BoundsViolation DXCoil(0): DXCoil is not allocated with a 0
        // element: Commented out
        ShowSevereError(state, format("SetDXCoilTypeData: Could not find Coil \"Name=\"{}\"", CoilName));
    }
}

void CalcSecondaryDXCoils(EnergyPlusData &state, int const DXCoilNum)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         B. Nigusse
    //       DATE WRITTEN   February 2015

    // PURPOSE OF THIS SUBROUTINE:
    // Calculates secondary zone heat gain from secondary DX coils placed in a zone.

    // METHODOLOGY EMPLOYED:
    // Energy balance:
    //  (1) Condenser placed in a zone, the zone total (sensible) heat
    //      gain rate is given Qcond = QEvap + WcompPluscondFanPower
    //  (2) Evaporator placed in a zone, the zone total heat removal
    //      rate is given Qevap = Qcond - WcompPluscondFanPower
    //      Furthermore, the evaporator total heat removal is split into
    //      latent and sensible components using user specified SHR

    // Using/Aliasing
    using Curve::CurveValue;

    // SUBROUTINE PARAMETER DEFINITIONS:
    static constexpr std::string_view RoutineName("CalcSecondaryDXCoils");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 CondInletDryBulb;       // condenser entering air dry-bulb temperature (C)
    Real64 EvapAirMassFlow;        // Condenser air mass flow rate [kg/s]
    Real64 EvapInletDryBulb;       // evaporator inlet air drybulb [C]
    Real64 EvapInletHumRat;        // evaporator inlet air humidity ratio [kg/kg]
    Real64 EvapInletWetBulb;       // evaporator inlet air wetbulb [C]
    Real64 EvapInletEnthalpy;      // evaporator inlet air enthalpy [J/kg]
    Real64 FullLoadOutAirEnth;     // evaporator outlet full load enthalpy [J/kg]
    Real64 FullLoadOutAirHumRat;   // evaporator outlet humidity ratio at full load
    Real64 FullLoadOutAirTemp;     // evaporator outlet air temperature at full load [C]
    Real64 hTinwout;               // Enthalpy at inlet dry-bulb and outlet humidity ratio [J/kg]
    Real64 SHR(0);                 // sensible heat ratio
    Real64 RhoAir;                 // secondary coil entering air density [kg/m3]
    Real64 PartLoadRatio(0);       // primary coil part-load ratio [-]
    Real64 SecCoilRatedSHR;        // secondary DX coil nominal or rated sensible heat ratio
    Real64 SecCoilFlowFraction;    // secondary coil flow fraction, is 1.0 for single speed machine
    Real64 TotalHeatRemovalRate;   // secondary coil total heat removal rate
    Real64 TotalHeatRejectionRate; // secondary coil total heat rejection rate
    int SecCoilSHRFT;              // index of the SHR modifier curve for temperature of a secondary DX coil
    int SecCoilSHRFF;              // index of the sHR modifier curve for flow fraction of a secondary DX coil
    int MSSpeedNumLS;              // current low speed number of multispeed HP
    int MSSpeedNumHS;              // current high speed number of multispeed HP
    Real64 MSSpeedRatio;           // current speed ratio of multispeed HP
    Real64 MSCycRatio;             // current cycling ratio of multispeed HP
    Real64 SHRHighSpeed;           // sensible heat ratio at high speed
    Real64 SHRLowSpeed;            // sensible heat ratio at low speed

    EvapAirMassFlow = 0.0;

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    if (thisDXCoil.IsSecondaryDXCoilInZone) {
        auto &secZoneHB = state.dataZoneTempPredictorCorrector->zoneHeatBalance(thisDXCoil.SecZonePtr);
        // Select the correct unit type
        switch (thisDXCoil.DXCoilType_Num) {
        case HVAC::CoilDX_CoolingSingleSpeed:
        case HVAC::CoilDX_CoolingTwoSpeed:
        case HVAC::CoilDX_MultiSpeedCooling: {
            // total sensible heat gain of the secondary zone from the secondary coil (condenser)
            if (thisDXCoil.ElecCoolingPower > 0.0) {
                TotalHeatRejectionRate = thisDXCoil.TotalCoolingEnergyRate + thisDXCoil.ElecCoolingPower;
            } else {
                TotalHeatRejectionRate = 0.0;
                return;
            }
            thisDXCoil.SecCoilSensibleHeatGainRate = TotalHeatRejectionRate;
        } break;
        case HVAC::CoilDX_HeatingEmpirical: {
            // evaporator coil in the secondary zone
            if (thisDXCoil.ElecHeatingPower > 0.0) {
                TotalHeatRemovalRate = max(0.0, thisDXCoil.TotalHeatingEnergyRate - thisDXCoil.ElecHeatingPower);
            } else {
                TotalHeatRemovalRate = 0.0;
                thisDXCoil.SecCoilSHR = 0.0;
                return;
            }
            thisDXCoil.SecCoilTotalHeatRemovalRate = -TotalHeatRemovalRate; // +DXCoil( DXCoilNum ).DefrostPower;
            EvapInletDryBulb = secZoneHB.ZT;
            EvapInletHumRat = secZoneHB.airHumRat;
            RhoAir = PsyRhoAirFnPbTdbW(state, state.dataEnvrn->OutBaroPress, EvapInletDryBulb, EvapInletHumRat);
            EvapAirMassFlow = RhoAir * thisDXCoil.SecCoilAirFlow;
            ;
            PartLoadRatio = thisDXCoil.CompressorPartLoadRatio;
            SecCoilRatedSHR = thisDXCoil.SecCoilRatedSHR;
            if ((EvapAirMassFlow > HVAC::SmallMassFlow) && (PartLoadRatio > 0.0) &&
                (EvapInletDryBulb > thisDXCoil.MinOATCompressor)) { // coil is running
                SecCoilFlowFraction = 1.0;                          // for single speed DX coil the secondary coil (condenser) flow fraction is 1.0
                CondInletDryBulb = state.dataLoopNodes->Node(thisDXCoil.AirInNode).Temp;
                EvapInletWetBulb = PsyTwbFnTdbWPb(state, EvapInletDryBulb, EvapInletHumRat, state.dataEnvrn->OutBaroPress, RoutineName);
                EvapInletEnthalpy = PsyHFnTdbW(EvapInletDryBulb, EvapInletHumRat);
                SecCoilSHRFT = thisDXCoil.SecCoilSHRFT;
                SecCoilSHRFF = thisDXCoil.SecCoilSHRFF;
                // determine the current SHR
                SHR = CalcSecondaryDXCoilsSHR(state,
                                              DXCoilNum,
                                              EvapAirMassFlow,
                                              TotalHeatRemovalRate,
                                              PartLoadRatio,
                                              SecCoilRatedSHR,
                                              EvapInletDryBulb,
                                              EvapInletHumRat,
                                              EvapInletWetBulb,
                                              EvapInletEnthalpy,
                                              CondInletDryBulb,
                                              SecCoilFlowFraction,
                                              SecCoilSHRFT,
                                              SecCoilSHRFF);
                // Calculate full load output conditions
                FullLoadOutAirEnth = EvapInletEnthalpy - (TotalHeatRemovalRate / PartLoadRatio) / EvapAirMassFlow;
                hTinwout = EvapInletEnthalpy - (1.0 - SHR) * ((TotalHeatRemovalRate / PartLoadRatio) / EvapAirMassFlow);
                FullLoadOutAirHumRat = PsyWFnTdbH(state, EvapInletDryBulb, hTinwout, RoutineName, true);
                FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, FullLoadOutAirHumRat);
                // when the air outlet temperature falls below the saturation temperature, it is reset to saturation temperature
                if (FullLoadOutAirTemp < PsyTsatFnHPb(state, FullLoadOutAirEnth, state.dataEnvrn->OutBaroPress, RoutineName)) {
                    FullLoadOutAirTemp = PsyTsatFnHPb(state, FullLoadOutAirEnth, state.dataEnvrn->OutBaroPress, RoutineName);
                    FullLoadOutAirHumRat = PsyWFnTdbH(state, FullLoadOutAirTemp, FullLoadOutAirEnth, RoutineName);
                    // Adjust SHR for the new outlet condition that balances energy
                    hTinwout = PsyHFnTdbW(EvapInletDryBulb, FullLoadOutAirHumRat);
                    SHR = 1.0 - (EvapInletEnthalpy - hTinwout) / ((TotalHeatRemovalRate / PartLoadRatio) / EvapAirMassFlow);
                    SHR = min(SHR, 1.0);
                }
                // calculate the sensible and latent zone heat removal (extraction) rate by the secondary coil
                thisDXCoil.SecCoilSensibleHeatRemovalRate = thisDXCoil.SecCoilTotalHeatRemovalRate * SHR;
                thisDXCoil.SecCoilLatentHeatRemovalRate = thisDXCoil.SecCoilTotalHeatRemovalRate - thisDXCoil.SecCoilSensibleHeatRemovalRate;
            } else {
                // DX coil is off;
                thisDXCoil.SecCoilTotalHeatRemovalRate = 0.0;
                thisDXCoil.SecCoilSensibleHeatRemovalRate = 0.0;
                thisDXCoil.SecCoilLatentHeatRemovalRate = 0.0;
                SHR = 0.0; // SHR is set to zero if the coil is off
            }
            thisDXCoil.SecCoilSHR = SHR;
        } break;
        case HVAC::CoilDX_MultiSpeedHeating: {
            EvapInletDryBulb = secZoneHB.ZT;
            EvapInletHumRat = secZoneHB.airHumRat;
            RhoAir = PsyRhoAirFnPbTdbW(state, state.dataEnvrn->OutBaroPress, EvapInletDryBulb, EvapInletHumRat);
            MSSpeedRatio = thisDXCoil.MSSpeedRatio;
            MSCycRatio = thisDXCoil.MSCycRatio;
            MSSpeedNumHS = thisDXCoil.MSSpeedNumHS;
            MSSpeedNumLS = thisDXCoil.MSSpeedNumLS;
            if (MSSpeedRatio > 0.0) {
                EvapAirMassFlow = RhoAir * (thisDXCoil.MSSecCoilAirFlow(MSSpeedNumHS) * MSSpeedRatio +
                                            thisDXCoil.MSSecCoilAirFlow(MSSpeedNumLS) * (1.0 - MSSpeedRatio));
            } else if (MSCycRatio > 0.0) {
                EvapAirMassFlow = RhoAir * thisDXCoil.MSSecCoilAirFlow(MSSpeedNumLS);
            }
            if (thisDXCoil.ElecHeatingPower > 0.0) {
                TotalHeatRemovalRate = max(0.0, thisDXCoil.TotalHeatingEnergyRate - thisDXCoil.ElecHeatingPower);
            } else {
                TotalHeatRemovalRate = 0.0;
                return;
            }
            thisDXCoil.SecCoilTotalHeatRemovalRate = -TotalHeatRemovalRate; // +DXCoil( DXCoilNum ).DefrostPower;
            if ((EvapAirMassFlow > HVAC::SmallMassFlow) && (MSSpeedRatio > 0.0 || MSCycRatio > 0.0) &&
                (EvapInletDryBulb > thisDXCoil.MinOATCompressor)) { // coil is running
                SecCoilFlowFraction = 1.0;                          // for single speed DX coil the secondary coil (condenser) flow fraction is 1.0
                CondInletDryBulb = state.dataLoopNodes->Node(thisDXCoil.AirInNode).Temp;
                EvapInletWetBulb = PsyTwbFnTdbWPb(state, EvapInletDryBulb, EvapInletHumRat, state.dataEnvrn->OutBaroPress, RoutineName);
                EvapInletEnthalpy = PsyHFnTdbW(EvapInletDryBulb, EvapInletHumRat);
                // determine the current SHR
                if (MSSpeedRatio > 0.0) {
                    // calculate SHR for the higher speed
                    PartLoadRatio = 1.0;
                    SecCoilFlowFraction = 1.0;
                    SecCoilSHRFT = thisDXCoil.MSSecCoilSHRFT(MSSpeedNumHS);
                    SecCoilSHRFF = thisDXCoil.MSSecCoilSHRFF(MSSpeedNumHS);
                    SecCoilRatedSHR = thisDXCoil.MSSecCoilRatedSHR(MSSpeedNumHS);
                    SHRHighSpeed = CalcSecondaryDXCoilsSHR(state,
                                                           DXCoilNum,
                                                           EvapAirMassFlow,
                                                           TotalHeatRemovalRate,
                                                           PartLoadRatio,
                                                           SecCoilRatedSHR,
                                                           EvapInletDryBulb,
                                                           EvapInletHumRat,
                                                           EvapInletWetBulb,
                                                           EvapInletEnthalpy,
                                                           CondInletDryBulb,
                                                           SecCoilFlowFraction,
                                                           SecCoilSHRFT,
                                                           SecCoilSHRFF);
                    // calculate SHR for the lower speed
                    SecCoilSHRFT = thisDXCoil.MSSecCoilSHRFT(MSSpeedNumLS);
                    SecCoilSHRFF = thisDXCoil.MSSecCoilSHRFF(MSSpeedNumLS);
                    SecCoilRatedSHR = thisDXCoil.MSSecCoilRatedSHR(MSSpeedNumLS);
                    SHRLowSpeed = CalcSecondaryDXCoilsSHR(state,
                                                          DXCoilNum,
                                                          EvapAirMassFlow,
                                                          TotalHeatRemovalRate,
                                                          PartLoadRatio,
                                                          SecCoilRatedSHR,
                                                          EvapInletDryBulb,
                                                          EvapInletHumRat,
                                                          EvapInletWetBulb,
                                                          EvapInletEnthalpy,
                                                          CondInletDryBulb,
                                                          SecCoilFlowFraction,
                                                          SecCoilSHRFT,
                                                          SecCoilSHRFF);
                    SHR = SHRHighSpeed * MSSpeedRatio + SHRLowSpeed * (1.0 - MSSpeedRatio);

                } else if (MSCycRatio > 0.0) {
                    // calculate SHR for the lower speed
                    PartLoadRatio = MSCycRatio;
                    SecCoilSHRFT = thisDXCoil.MSSecCoilSHRFT(MSSpeedNumLS);
                    SecCoilSHRFF = thisDXCoil.MSSecCoilSHRFF(MSSpeedNumLS);
                    SecCoilRatedSHR = thisDXCoil.MSSecCoilRatedSHR(MSSpeedNumLS);
                    SecCoilFlowFraction = 1.0;
                    SHRLowSpeed = CalcSecondaryDXCoilsSHR(state,
                                                          DXCoilNum,
                                                          EvapAirMassFlow,
                                                          TotalHeatRemovalRate,
                                                          MSCycRatio,
                                                          SecCoilRatedSHR,
                                                          EvapInletDryBulb,
                                                          EvapInletHumRat,
                                                          EvapInletWetBulb,
                                                          EvapInletEnthalpy,
                                                          CondInletDryBulb,
                                                          SecCoilFlowFraction,
                                                          SecCoilSHRFT,
                                                          SecCoilSHRFF);
                    SHR = SHRLowSpeed;
                }
                // Calculate full load output conditions
                FullLoadOutAirEnth = EvapInletEnthalpy - (TotalHeatRemovalRate / PartLoadRatio) / EvapAirMassFlow;
                hTinwout = EvapInletEnthalpy - (1.0 - SHR) * ((TotalHeatRemovalRate / PartLoadRatio) / EvapAirMassFlow);
                FullLoadOutAirHumRat = PsyWFnTdbH(state, EvapInletDryBulb, hTinwout, RoutineName, true);
                FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, FullLoadOutAirHumRat);
                // when the air outlet temperature falls below the saturation temperature, it is reset to saturation temperature
                if (FullLoadOutAirTemp < PsyTsatFnHPb(state, FullLoadOutAirEnth, state.dataEnvrn->OutBaroPress, RoutineName)) {
                    FullLoadOutAirTemp = PsyTsatFnHPb(state, FullLoadOutAirEnth, state.dataEnvrn->OutBaroPress, RoutineName);
                    FullLoadOutAirHumRat = PsyWFnTdbH(state, FullLoadOutAirTemp, FullLoadOutAirEnth, RoutineName);
                    // Adjust SHR for the new outlet condition that balances energy
                    hTinwout = PsyHFnTdbW(EvapInletDryBulb, FullLoadOutAirHumRat);
                    SHR = 1.0 - (EvapInletEnthalpy - hTinwout) / (TotalHeatRemovalRate / PartLoadRatio) / EvapAirMassFlow;
                    SHR = min(SHR, 1.0);
                }
                // calculate the sensible and latent zone heat removal (extraction) rate by the secondary coil
                thisDXCoil.SecCoilSensibleHeatRemovalRate = thisDXCoil.SecCoilTotalHeatRemovalRate * SHR;
                thisDXCoil.SecCoilLatentHeatRemovalRate = thisDXCoil.SecCoilTotalHeatRemovalRate - thisDXCoil.SecCoilSensibleHeatRemovalRate;
            } else {
                // DX coil is off;
                thisDXCoil.SecCoilTotalHeatRemovalRate = 0.0;
                thisDXCoil.SecCoilSensibleHeatRemovalRate = 0.0;
                thisDXCoil.SecCoilLatentHeatRemovalRate = 0.0;
                SHR = 0.0; // SHR is set to rated value if the coil is off
            }
            thisDXCoil.SecCoilSHR = SHR;
        } break;
        default:
            break;
        }

    } else {
        thisDXCoil.SecCoilSensibleHeatGainRate = 0.0;
        thisDXCoil.SecCoilTotalHeatRemovalRate = 0.0;
        thisDXCoil.SecCoilSensibleHeatRemovalRate = 0.0;
        thisDXCoil.SecCoilLatentHeatRemovalRate = 0.0;
    }
}

Real64 CalcSecondaryDXCoilsSHR(EnergyPlusData &state,
                               [[maybe_unused]] int const DXCoilNum,
                               Real64 const EvapAirMassFlow,
                               Real64 const TotalHeatRemovalRate,
                               Real64 const PartLoadRatio,
                               Real64 const SecCoilRatedSHR,
                               Real64 const EvapInletDryBulb,
                               Real64 const EvapInletHumRat,
                               Real64 const EvapInletWetBulb,
                               Real64 const EvapInletEnthalpy,
                               Real64 const CondInletDryBulb,
                               Real64 const SecCoilFlowFraction,
                               int const SecCoilSHRFT,
                               int const SecCoilSHRFF)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         B. Nigusse
    //       DATE WRITTEN   February 2015

    // PURPOSE OF THIS SUBROUTINE:
    // Calculates secondary coil (evaporator) sensible heat ratio.

    // METHODOLOGY EMPLOYED:
    // Energy balance:
    //  (1) checks if the secondary coil operation is dry and calculates applicable SHR.
    //  (2) determines SHR from user specified rated SHR values and SHR modifier curves for
    //      temperature and flow fraction.
    //  (3) if secondary coil operates dry then the larger of the user SHR value and dry
    //      coil operation SHR is selected.

    // Using/Aliasing
    using Curve::CurveValue;

    // SUBROUTINE PARAMETER DEFINITIONS:
    int constexpr MaxIter(30);
    Real64 constexpr RelaxationFactor(0.4);
    Real64 constexpr Tolerance(0.1);
    Real64 constexpr DryCoilTestEvapInletHumRatReset(0.00001);
    static constexpr std::string_view RoutineName("CalcSecondaryDXCoilsSHR");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 DryCoilTestEvapInletHumRat;  // evaporator coil inlet humidity ratio test for dry coil
    Real64 DryCoilTestEvapInletWetBulb; // evaporator coil inlet dry bulb temperature test for dry coil
    Real64 FullLoadOutAirEnth;          // evaporator outlet full load enthalpy [J/kg]
    Real64 FullLoadOutAirTemp;          // evaporator outlet air temperature at full load [C]
    Real64 hTinwADP;                    // enthalpy of air at secondary coil entering temperature and Humidity ratio at ADP
    Real64 SHRadp;                      // Sensible heat ratio
    Real64 hADP;                        // enthalpy of air at secondary coil at ADP
    Real64 tADP;                        // dry bulb temperature of air at secondary coil at ADP
    Real64 wADP;                        // humidity ratio of air at secondary coil at ADP
    Real64 HumRatError;                 // humidity ratio error
    bool CoilMightBeDry;                // TRUE means the secondary DX coil runs dry
    int Counter;                        // iteration counter
    bool Converged;                     // convergence flag
    Real64 SHR;                         // current time step sensible heat ratio of secondary coil

    CoilMightBeDry = false;
    FullLoadOutAirEnth = EvapInletEnthalpy - (TotalHeatRemovalRate / PartLoadRatio) / EvapAirMassFlow;
    FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, EvapInletHumRat);
    if (FullLoadOutAirTemp > PsyTsatFnHPb(state, FullLoadOutAirEnth, state.dataEnvrn->OutBaroPress, RoutineName)) {
        CoilMightBeDry = true;
        // find wADP, humidity ratio at apparatus dewpoint and inlet hum rat that would have dry coil
        DryCoilTestEvapInletHumRat = EvapInletHumRat;
        DryCoilTestEvapInletWetBulb = EvapInletWetBulb;
        Counter = 0;
        Converged = false;
        while (!Converged) {
            // assumes coil bypass factor (CBF) = 0.0
            hADP = EvapInletEnthalpy - (TotalHeatRemovalRate / PartLoadRatio) / EvapAirMassFlow;
            tADP = PsyTsatFnHPb(state, hADP, state.dataEnvrn->OutBaroPress, RoutineName);
            wADP = min(EvapInletHumRat, PsyWFnTdbH(state, tADP, hADP, RoutineName));
            hTinwADP = PsyHFnTdbW(EvapInletDryBulb, wADP);
            if ((EvapInletEnthalpy - hADP) > 1.e-10) {
                SHRadp = min((hTinwADP - hADP) / (EvapInletEnthalpy - hADP), 1.0);
            } else {
                SHRadp = 1.0;
            }
            if ((wADP > DryCoilTestEvapInletHumRat) || (Counter >= 1 && Counter < MaxIter)) {
                if (DryCoilTestEvapInletHumRat <= 0.0) DryCoilTestEvapInletHumRat = DryCoilTestEvapInletHumRatReset;
                HumRatError = (DryCoilTestEvapInletHumRat - wADP) / DryCoilTestEvapInletHumRat;
                DryCoilTestEvapInletHumRat = RelaxationFactor * wADP + (1.0 - RelaxationFactor) * DryCoilTestEvapInletHumRat;
                DryCoilTestEvapInletWetBulb =
                    PsyTwbFnTdbWPb(state, EvapInletDryBulb, DryCoilTestEvapInletHumRat, state.dataEnvrn->OutBaroPress, RoutineName);
                ++Counter;
                if (std::abs(HumRatError) <= Tolerance) {
                    Converged = true;
                } else {
                    Converged = false;
                }
            } else {
                Converged = true;
            }
        }
    }
    // determine SHR from user specified nominal value and SHR modifier curves
    SHR = CalcSHRUserDefinedCurves(state, CondInletDryBulb, EvapInletWetBulb, SecCoilFlowFraction, SecCoilSHRFT, SecCoilSHRFF, SecCoilRatedSHR);
    if (CoilMightBeDry) {
        if ((EvapInletHumRat < DryCoilTestEvapInletHumRat) && (SHRadp > SHR)) { // coil is dry for sure
            SHR = 1.0;
        } else if (SHRadp > SHR) {
            SHR = SHRadp;
        }
    }
    return SHR;
}

void CalcVRFCoolingCoil_FluidTCtrl(EnergyPlusData &state,
                                   int const DXCoilNum,                    // the number of the DX coil to be simulated
                                   HVAC::CompressorOp const compressorOp,  // compressor operation; 1=on, 0=off
                                   bool const FirstHVACIteration,          // true if this is the first iteration of HVAC
                                   Real64 const PartLoadRatio,             // sensible cooling load / full load sensible cooling capacity
                                   HVAC::FanOp const fanOp,                // Allows parent object to control fan operation
                                   Real64 const CompCycRatio,              // cycling ratio of VRF condenser
                                   ObjexxFCL::Optional_int_const PerfMode, // Performance mode for MultiMode DX coil; Always 1 for other coil types
                                   ObjexxFCL::Optional<Real64 const> OnOffAirFlowRatio, // ratio of compressor on airflow to compressor off airflow
                                   Real64 MaxCoolCap                                    // maximum allowed cooling capacity
)
{
    // SUBROUTINE INFORMATION:
    //       AUTHOR         Xiufeng Pang, LBNL
    //       DATE WRITTEN   Jan 2013
    //       MODIFIED       Nov 2015, RP Zhang, LBNL

    // PURPOSE OF THIS SUBROUTINE:
    //         Calculates the air-side performance of a direct-expansion, air-cooled
    //         VRF terminal unit cooling coil, for the VRF_FluidTCtrl model.

    // METHODOLOGY EMPLOYED:
    //         This subroutine is derived from CalcVRFCoolingCoil, and implements the new VRF model for FluidTCtrl.

    // Using/Aliasing
    using Curve::CurveValue;
    Real64 SysTimeElapsed = state.dataHVACGlobal->SysTimeElapsed;
    Real64 TimeStepSys = state.dataHVACGlobal->TimeStepSys;
    using General::CreateSysTimeIntervalString;

    using namespace HVACVariableRefrigerantFlow;

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:

    Real64 AirMassFlow;       // dry air mass flow rate through coil [kg/s] (adjusted for bypass if any)
    Real64 AirVolumeFlowRate; // Air volume flow rate across the cooling coil [m3/s] (adjusted for bypass if any)
    // (average flow if cycling fan, full flow if constant fan)
    Real64 VolFlowperRatedTotCap; // Air volume flow rate divided by rated total cooling capacity [m3/s-W] (adjusted for bypass)
    Real64 TotCap;                // gross total cooling capacity at off-rated conditions [W]
    Real64 InletAirDryBulbTemp;   // inlet air dry bulb temperature [C]
    Real64 InletAirEnthalpy;      // inlet air enthalpy [J/kg]
    Real64 InletAirHumRat;        // inlet air humidity ratio [kg/kg]
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    Real64 RatedCBF;      // coil bypass factor at rated conditions
    Real64 CBF;           // coil bypass factor at off rated conditions
    Real64 A0;            // NTU * air mass flow rate, used in CBF calculation
    Real64 PLF;           // Part load factor, accounts for thermal lag at compressor startup, used in power calculation
    Real64 CondInletTemp; // Condenser inlet temperature (C). Outdoor dry-bulb temp for air-cooled condenser.
    // Outdoor Wetbulb +(1 - effectiveness)*(outdoor drybulb - outdoor wetbulb) for evap condenser.
    Real64 CondInletHumRat; // Condenser inlet humidity ratio (kg/kg). Zero for air-cooled condenser.
    // For evap condenser, its the humidity ratio of the air leaving the evap cooling pads.
    Real64 CondAirMassFlow;       // Condenser air mass flow rate [kg/s]
    Real64 RhoAir;                // Density of air [kg/m3]
    Real64 CrankcaseHeatingPower; // power due to crankcase heater
    Real64 CompAmbTemp(0.0);      // Ambient temperature at compressor
    Real64 AirFlowRatio;          // ratio of compressor on airflow to average timestep airflow
    // used when constant fan mode yields different air flow rates when compressor is ON and OFF
    // (e.g. Packaged Terminal Heat Pump)
    Real64 OutdoorDryBulb;  // Outdoor dry-bulb temperature at condenser (C)
    Real64 OutdoorWetBulb;  // Outdoor wet-bulb temperature at condenser (C)
    Real64 OutdoorHumRat;   // Outdoor humidity ratio at condenser (kg/kg)
    Real64 OutdoorPressure; // Outdoor barometric pressure at condenser (Pa)

    int Mode;                 // Performance mode for Multimode DX coil; Always 1 for other coil types
    Real64 OutletAirTemp;     // Supply air temperature (average value if constant fan, full output if cycling fan)
    Real64 OutletAirHumRat;   // Supply air humidity ratio (average value if constant fan, full output if cycling fan)
    Real64 OutletAirEnthalpy; // Supply air enthalpy (average value if constant fan, full output if cycling fan)
    Real64 ADiff;             // Used for exponential

    // Followings for VRF FluidTCtrl Only
    Real64 QCoilReq;       // Coil load (W)
    Real64 FanSpdRatio;    // Fan speed ratio
    Real64 AirMassFlowMin; // Min air mass flow rate due to OA requirement [kg/s]
    Real64 ActualSH;       // Super heating degrees (C)
    Real64 ActualSC;       // Sub cooling degrees (C)

    // If Performance mode not present, then set to 1.  Used only by Multimode/Multispeed DX coil (otherwise mode = 1)
    if (present(PerfMode)) {
        Mode = PerfMode;
    } else {
        Mode = 1;
    }

    // If AirFlowRatio not present, then set to 1. Used only by DX coils with different air flow
    // during cooling and when no cooling is required (constant fan, fan speed changes)
    if (present(OnOffAirFlowRatio)) {
        AirFlowRatio = OnOffAirFlowRatio;
    } else {
        AirFlowRatio = 1.0;
    }

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    // Initialize coil air side parameters
    CondInletTemp = 0.0;
    CondInletHumRat = 0.0;
    AirMassFlow = thisDXCoil.InletAirMassFlowRate;
    InletAirDryBulbTemp = thisDXCoil.InletAirTemp;
    InletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
    InletAirHumRat = thisDXCoil.InletAirHumRat;
    state.dataHeatBal->HeatReclaimDXCoil(DXCoilNum).AvailCapacity = 0.0;
    thisDXCoil.CoolingCoilRuntimeFraction = 0.0;
    thisDXCoil.PartLoadRatio = 0.0;
    thisDXCoil.BasinHeaterPower = 0.0;
    thisDXCoil.EvaporatingTemp = state.dataHVACVarRefFlow->VRF(thisDXCoil.VRFOUPtr).IUEvaporatingTemp;

    if (thisDXCoil.CondenserInletNodeNum(Mode) != 0) {
        OutdoorDryBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).Temp;
        if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Water) {
            OutdoorHumRat = state.dataEnvrn->OutHumRat;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
            OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
        } else {
            OutdoorPressure = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).Press;
            // If node is not connected to anything, pressure = default, use weather data
            if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press) {
                OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
                OutdoorHumRat = state.dataEnvrn->OutHumRat;
                OutdoorPressure = state.dataEnvrn->OutBaroPress;
                OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
            } else {
                OutdoorHumRat = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).HumRat;
                OutdoorWetBulb = state.dataLoopNodes->Node(thisDXCoil.CondenserInletNodeNum(Mode)).OutAirWetBulb;
            }
        }
    } else {
        OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
        OutdoorHumRat = state.dataEnvrn->OutHumRat;
        OutdoorPressure = state.dataEnvrn->OutBaroPress;
        OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
    }

    if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Evap) {
        RhoAir = PsyRhoAirFnPbTdbW(state, OutdoorPressure, OutdoorDryBulb, OutdoorHumRat);
        CondAirMassFlow = RhoAir * thisDXCoil.EvapCondAirFlow(Mode);
        // (Outdoor wet-bulb temp from DataEnvironment) + (1.0-EvapCondEffectiveness) * (drybulb - wetbulb)
        CondInletTemp = OutdoorWetBulb + (OutdoorDryBulb - OutdoorWetBulb) * (1.0 - thisDXCoil.EvapCondEffect(Mode));
        CondInletHumRat = PsyWFnTdbTwbPb(state, CondInletTemp, OutdoorWetBulb, OutdoorPressure);
        CompAmbTemp = OutdoorDryBulb;
    } else {                            // for air or water-cooled, inlet temp is stored in OutdoorDryBulb temp
        CondInletTemp = OutdoorDryBulb; // Outdoor dry-bulb temp or water inlet temp
        if (thisDXCoil.CondenserType(Mode) == DataHeatBalance::RefrigCondenserType::Water) {
            CompAmbTemp = state.dataEnvrn->OutDryBulbTemp; // for crankcase heater use actual outdoor temp for water-cooled
        } else {
            CompAmbTemp = OutdoorDryBulb;
        }
    }

    // Initialize crankcase heater, operates below OAT defined in input deck for HP DX cooling coil
    // If used in a heat pump, the value of MaxOAT in the heating coil overrides that in the cooling coil (in GetInput)
    if (CompAmbTemp < thisDXCoil.MaxOATCrankcaseHeater) {
        CrankcaseHeatingPower = thisDXCoil.CrankcaseHeaterCapacity;
        if (thisDXCoil.CrankcaseHeaterCapacityCurveIndex > 0) {
            CrankcaseHeatingPower *= Curve::CurveValue(state, thisDXCoil.CrankcaseHeaterCapacityCurveIndex, CompAmbTemp);
        }
    } else {
        CrankcaseHeatingPower = 0.0;
    }

    // calculate end time of current time step to determine if error messages should be printed
    state.dataDXCoils->CalcVRFCoolingCoil_FluidTCtrlCurrentEndTime = state.dataGlobal->CurrentTime + SysTimeElapsed;

    // The following checks are not necessary for VRF-FluidTCtrl model. (1) OAT check is already performed in the VRF OU routines (2)
    // VRF-FluidTCtrl model is physics based, not system curve based, and thus doesn't require special performance curves for operations at
    // low inlet temperatures
    //   Print warning messages only when valid and only for the first occurrence. Let summary provide statistics.
    //   Wait for next time step to print warnings. If simulation iterates, print out
    //   the warning for the last iteration only. Must wait for next time step to accomplish this.
    //   If a warning occurs and the simulation down shifts, the warning is not valid.
    // if ( DXCoil( DXCoilNum ).PrintLowAmbMessage ) { // .AND. &
    //     if ( CurrentEndTime > DXCoil( DXCoilNum ).CurrentEndTimeLast && TimeStepSys >= DXCoil( DXCoilNum ).TimeStepSysLast ) {
    //         if ( DXCoil( DXCoilNum ).LowAmbErrIndex == 0 ) {
    //             ShowWarningMessage(state,  DXCoil( DXCoilNum ).LowAmbBuffer1 );
    //             ShowContinueError(state,  DXCoil( DXCoilNum ).LowAmbBuffer2 );
    //             ShowContinueError(state,  "... Operation at low inlet temperatures may require special performance curves." );
    //         }
    //         ShowRecurringWarningErrorAtEnd(state,  DXCoil( DXCoilNum ).DXCoilType + " \"" + DXCoil( DXCoilNum ).Name + "\" - Low condenser inlet
    // temperature error continues...", DXCoil( DXCoilNum ).LowAmbErrIndex, DXCoil( DXCoilNum ).LowTempLast, DXCoil( DXCoilNum ).LowTempLast,
    // _,
    // "[C]", "[C]" );
    //     }
    // }
    //
    // if ( DXCoil( DXCoilNum ).PrintHighAmbMessage ) { // .AND. &
    //     if ( CurrentEndTime > DXCoil( DXCoilNum ).CurrentEndTimeLast && TimeStepSys >= DXCoil( DXCoilNum ).TimeStepSysLast ) {
    //         if ( DXCoil( DXCoilNum ).HighAmbErrIndex == 0 ) {
    //             ShowWarningMessage(state,  DXCoil( DXCoilNum ).HighAmbBuffer1 );
    //             ShowContinueError(state,  DXCoil( DXCoilNum ).HighAmbBuffer2 );
    //             ShowContinueError(state,  "... Operation at high inlet temperatures may require special performance curves." );
    //         }
    //         ShowRecurringWarningErrorAtEnd(state,  DXCoil( DXCoilNum ).DXCoilType + " \"" + DXCoil( DXCoilNum ).Name + "\" - High condenser inlet
    // temperature error continues...", DXCoil( DXCoilNum ).HighAmbErrIndex, DXCoil( DXCoilNum ).HighTempLast, DXCoil( DXCoilNum
    // ).HighTempLast,
    // _, "[C]", "[C]" );
    //     }
    // }

    if (thisDXCoil.PrintLowOutTempMessage) {
        if ((state.dataDXCoils->CalcVRFCoolingCoil_FluidTCtrlCurrentEndTime > thisDXCoil.CurrentEndTimeLast) &&
            (TimeStepSys >= thisDXCoil.TimeStepSysLast)) {
            if (thisDXCoil.LowOutletTempIndex == 0) {
                ShowWarningMessage(state, thisDXCoil.LowOutTempBuffer1);
                ShowContinueError(state, thisDXCoil.LowOutTempBuffer2);
                ShowContinueError(state, "... Possible reasons for low outlet air dry-bulb temperatures are: This DX coil");
                ShowContinueError(state,
                                  format("   1) may have a low inlet air dry-bulb temperature. Inlet air temperature = {:.3T} C.",
                                         thisDXCoil.FullLoadInletAirTempLast));
                ShowContinueError(state, "   2) may have a low air flow rate per watt of cooling capacity. Check inputs.");
                ShowContinueError(state,
                                  "   3) is used as part of a HX assisted cooling coil which uses a high sensible effectiveness. Check inputs.");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           thisDXCoil.DXCoilType + " \"" + thisDXCoil.Name +
                                               "\" - Full load outlet temperature indicates a possibility of frost/freeze error continues. "
                                               "Outlet air temperature statistics follow:",
                                           thisDXCoil.LowOutletTempIndex,
                                           thisDXCoil.FullLoadOutAirTempLast,
                                           thisDXCoil.FullLoadOutAirTempLast);
        }
    }

    // save last system time step and last end time of current time step (used to determine if warning is valid)
    thisDXCoil.TimeStepSysLast = TimeStepSys;
    thisDXCoil.CurrentEndTimeLast = state.dataDXCoils->CalcVRFCoolingCoil_FluidTCtrlCurrentEndTime;
    thisDXCoil.PrintLowAmbMessage = false;
    thisDXCoil.PrintLowOutTempMessage = false;

    if ((AirMassFlow > 0.0) && (GetCurrentScheduleValue(state, thisDXCoil.SchedPtr) > 0.0) && (PartLoadRatio > 0.0) &&
        (compressorOp == HVAC::CompressorOp::On)) { // for cycling fan, reset mass flow to full on rate

        if (thisDXCoil.RatedTotCap(Mode) <= 0.0) {
            ShowFatalError(state, format("{} \"{}\" - Rated total cooling capacity is zero or less.", thisDXCoil.DXCoilType, thisDXCoil.Name));
        }

        TotCap = min(MaxCoolCap, thisDXCoil.RatedTotCap(Mode));

        QCoilReq = -PartLoadRatio * TotCap;
        if (PartLoadRatio == 0.0) {
            AirMassFlowMin = state.dataHVACVarRefFlow->OACompOffMassFlow;
        } else {
            AirMassFlowMin = state.dataHVACVarRefFlow->OACompOnMassFlow;
        }

        // Call ControlVRFIUCoil to calculate: (1) FanSpdRatio, (2) coil inlet/outlet conditions, and (3) SH/SC
        ControlVRFIUCoil(state,
                         DXCoilNum,
                         QCoilReq,
                         thisDXCoil.InletAirTemp,
                         thisDXCoil.InletAirHumRat,
                         thisDXCoil.EvaporatingTemp,
                         AirMassFlowMin,
                         FanSpdRatio,
                         OutletAirHumRat,
                         OutletAirTemp,
                         OutletAirEnthalpy,
                         ActualSH,
                         ActualSC);
        AirMassFlow = FanSpdRatio * thisDXCoil.RatedAirMassFlowRate(Mode);

        AirVolumeFlowRate = AirMassFlow / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat);
        VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.RatedTotCap(Mode);
        // VolFlowperRatedTotCap was checked at the initialization step
        // No need to check VolFlowperRatedTotCap at the simulation
        // New VRF_FluidTCtrl model implements VAV fan which can vary air flow rate during simulation

        RatedCBF = thisDXCoil.RatedCBF(Mode);
        if (RatedCBF > 0.0) {
            A0 = -std::log(RatedCBF) * thisDXCoil.RatedAirMassFlowRate(Mode);
        } else {
            A0 = 0.0;
        }
        ADiff = -A0 / AirMassFlow;
        if (ADiff >= DataPrecisionGlobals::EXP_LowerLimit) {
            CBF = std::exp(ADiff);
        } else {
            CBF = 0.0;
        }

        // The following checks are not necessary for VRF-FluidTCtrl model. (1) OAT check is already performed in the VRF OU routines (2)
        // VRF-FluidTCtrl model is physics based, not system curve based, and thus doesn't require special performance curves for operations
        // at low inlet temperatures
        // // check boundary for low ambient temperature and post warnings to individual DX coil buffers to print at end of time step
        // if ( OutdoorDryBulb < DXCoil( DXCoilNum ).MinOATCompressor && ! WarmupFlag ) {
        //     DXCoil( DXCoilNum ).PrintLowAmbMessage = true;
        //     DXCoil( DXCoilNum ).LowTempLast = OutdoorDryBulb;
        //     if ( DXCoil( DXCoilNum ).LowAmbErrIndex == 0 ) {
        //         DXCoil( DXCoilNum ).LowAmbBuffer1 = DXCoil( DXCoilNum ).DXCoilType + " \"" + DXCoil( DXCoilNum ).Name + "\" - Condenser
        // inlet temperature below " + RoundSigDigits( DXCoil( DXCoilNum ).MinOATCompressor, 2 ) + " C. Condenser inlet temperature = " +
        // RoundSigDigits( OutdoorDryBulb, 2 );
        //         DXCoil( DXCoilNum ).LowAmbBuffer2 = " ... Occurrence info = " + EnvironmentName + ", " + CurMnDy + " " +
        // CreateSysTimeIntervalString();
        //     }
        // }
        //
        // // check boundary for high ambient temperature and post warnings to individual DX coil buffers to print at end of time step
        // if ( OutdoorDryBulb > DXCoil( DXCoilNum ).MaxOATCompressor && ! WarmupFlag ) {
        //     DXCoil( DXCoilNum ).PrintHighAmbMessage = true;
        //     DXCoil( DXCoilNum ).HighTempLast = OutdoorDryBulb;
        //     if ( DXCoil( DXCoilNum ).HighAmbErrIndex == 0 ) {
        //         DXCoil( DXCoilNum ).HighAmbBuffer1 = DXCoil( DXCoilNum ).DXCoilType + " \"" + DXCoil( DXCoilNum ).Name + "\" - Condenser
        // inlet temperature above " + RoundSigDigits( DXCoil( DXCoilNum ).MaxOATCompressor, 2 ) + " C. Condenser temperature = " +
        // RoundSigDigits( OutdoorDryBulb, 2 );         DXCoil( DXCoilNum ).HighAmbBuffer2 = " ... Occurrence info = " + EnvironmentName + ",
        // "
        // + CurMnDy + " " + CreateSysTimeIntervalString();
        //     }
        // }

        //  Get total capacity modifying factor (function of temperature) for off-rated conditions
        //  InletAirHumRat may be modified in this ADP/BF loop, use temporary varible for calculations

        // commented, not used issue #6950
        // InletAirHumRatTemp = InletAirHumRat;

        //// Calculate apparatus dew point conditions using TotCap and CBF
        // hDelta = TotCap / AirMassFlow;
        //// there is an issue here with using CBF to calculate the ADP enthalpy.
        //// at low loads the bypass factor increases significantly.
        // hADP = InletAirEnthalpy - hDelta / (1.0 - CBF);
        // tADP = PsyTsatFnHPb(hADP, OutdoorPressure, RoutineName);
        ////  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
        ////  tADP = PsyTsatFnHPb(hADP,InletAirPressure)
        // wADP = min(InletAirHumRat, PsyWFnTdbH(tADP, hADP, RoutineName));
        // hTinwADP = PsyHFnTdbW(InletAirDryBulbTemp, wADP);
        // if ((InletAirEnthalpy - hADP) > 1.e-10) {
        //    SHR = min((hTinwADP - hADP) / (InletAirEnthalpy - hADP), 1.0);
        //} else {
        //    SHR = 1.0;
        //}
        // commented, not used issue #6950 ends here

        if (thisDXCoil.PLFFPLR(Mode) > 0 && CompCycRatio < 1.0) {
            PLF = CurveValue(state, thisDXCoil.PLFFPLR(Mode), CompCycRatio); // Calculate part-load factor
        } else {
            PLF = 1.0;
        }

        if (PLF < 0.7) {
            if (thisDXCoil.ErrIndex2 == 0) {
                ShowWarningMessage(
                    state,
                    format(
                        "The PLF curve value for the DX cooling coil {} ={:.3R} for part-load ratio ={:.3R}", thisDXCoil.Name, PLF, PartLoadRatio));
                ShowContinueErrorTimeStamp(state, "PLF curve values must be >= 0.7. PLF has been reset to 0.7 and simulation is continuing.");
                ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Cooling:DX:SingleSpeed].");
            }
            ShowRecurringWarningErrorAtEnd(
                state, thisDXCoil.Name + ", DX cooling coil PLF curve < 0.7 warning continues...", thisDXCoil.ErrIndex2, PLF, PLF);
            PLF = 0.7;
        }

        thisDXCoil.PartLoadRatio = PartLoadRatio;
        thisDXCoil.CoolingCoilRuntimeFraction = CompCycRatio / PLF;
        if (thisDXCoil.CoolingCoilRuntimeFraction > 1.0 && std::abs(thisDXCoil.CoolingCoilRuntimeFraction - 1.0) > 0.001) {
            if (thisDXCoil.ErrIndex3 == 0) {
                ShowWarningMessage(state,
                                   format("The runtime fraction for DX cooling coil {} exceeded 1.0. [{:.4R}].",
                                          thisDXCoil.Name,
                                          thisDXCoil.CoolingCoilRuntimeFraction));
                ShowContinueError(state, "Runtime fraction reset to 1 and the simulation will continue.");
                ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Cooling:DX:SingleSpeed].");
                ShowContinueErrorTimeStamp(state, "");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           thisDXCoil.Name + ", DX cooling coil runtime fraction > 1.0 warning continues...",
                                           thisDXCoil.ErrIndex3,
                                           thisDXCoil.CoolingCoilRuntimeFraction,
                                           thisDXCoil.CoolingCoilRuntimeFraction);
            thisDXCoil.CoolingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
        } else if (thisDXCoil.CoolingCoilRuntimeFraction > 1.0) {
            thisDXCoil.CoolingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
        }

        // If cycling fan, send coil part-load fraction to on/off fan via HVACDataGlobals
        if (fanOp == HVAC::FanOp::Cycling) state.dataHVACGlobal->OnOffFanPartLoadFraction = thisDXCoil.CoolingCoilRuntimeFraction;

        // Check for saturation error and modify temperature at constant enthalpy
        if (OutletAirTemp < PsyTsatFnHPb(state, OutletAirEnthalpy, OutdoorPressure)) {
            OutletAirTemp = PsyTsatFnHPb(state, OutletAirEnthalpy, OutdoorPressure);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //   IF(FullLoadOutAirTemp .LT. PsyTsatFnHPb(FullLoadOutAirEnth,InletAirPressure)) THEN
            //    FullLoadOutAirTemp = PsyTsatFnHPb(FullLoadOutAirEnth,InletAirPressure)
            OutletAirHumRat = PsyWFnTdbH(state, OutletAirTemp, OutletAirEnthalpy);
        }

        // Store actual outlet conditions when DX coil is ON for use in heat recovery module
        state.dataDXCoils->DXCoilFullLoadOutAirTemp(DXCoilNum) = OutletAirTemp;
        state.dataDXCoils->DXCoilFullLoadOutAirHumRat(DXCoilNum) = OutletAirHumRat;

        // Add warning message for cold cooling coil (OutletAirTemp < 2 C)
        if (OutletAirTemp < 2.0 && !FirstHVACIteration && !state.dataGlobal->WarmupFlag) {
            thisDXCoil.PrintLowOutTempMessage = true;
            thisDXCoil.FullLoadOutAirTempLast = OutletAirTemp;
            if (thisDXCoil.LowOutletTempIndex == 0) {
                thisDXCoil.FullLoadInletAirTempLast = InletAirDryBulbTemp;
                thisDXCoil.LowOutTempBuffer1 = format("{} \"{}\" - Full load outlet air dry-bulb temperature < 2C. This indicates the "
                                                      "possibility of coil frost/freeze. Outlet temperature = {:.2R} C.",
                                                      thisDXCoil.DXCoilType,
                                                      thisDXCoil.Name,
                                                      OutletAirTemp);
                thisDXCoil.LowOutTempBuffer2 = " ...Occurrence info = " + state.dataEnvrn->EnvironmentName + ", " + state.dataEnvrn->CurMnDy + " " +
                                               CreateSysTimeIntervalString(state);
            }
        }

        // Coil total/sensible/latent cooling rates
        CalcComponentSensibleLatentOutput(AirMassFlow * PartLoadRatio,
                                          InletAirDryBulbTemp,
                                          InletAirHumRat,
                                          OutletAirTemp,
                                          OutletAirHumRat,
                                          thisDXCoil.SensCoolingEnergyRate,
                                          thisDXCoil.LatCoolingEnergyRate,
                                          thisDXCoil.TotalCoolingEnergyRate);

        // Coil outlet conditions
        thisDXCoil.OutletAirTemp = OutletAirTemp;
        thisDXCoil.OutletAirHumRat = OutletAirHumRat;
        thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;

        // Coil SH/SC
        thisDXCoil.ActualSH = ActualSH;
        thisDXCoil.ActualSC = ActualSC;

    } else {
        // DX coil is off; just pass through conditions

        thisDXCoil.OutletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
        thisDXCoil.OutletAirHumRat = thisDXCoil.InletAirHumRat;
        thisDXCoil.OutletAirTemp = thisDXCoil.InletAirTemp;

        thisDXCoil.ElecCoolingPower = 0.0;
        thisDXCoil.TotalCoolingEnergyRate = 0.0;
        thisDXCoil.SensCoolingEnergyRate = 0.0;
        thisDXCoil.LatCoolingEnergyRate = 0.0;
        thisDXCoil.EvapCondPumpElecPower = 0.0;
        thisDXCoil.EvapWaterConsumpRate = 0.0;

        thisDXCoil.ActualSH = 999.0;
        thisDXCoil.ActualSC = 999.0;

        // Reset globals when DX coil is OFF for use in heat recovery module
        state.dataDXCoils->DXCoilFullLoadOutAirTemp(DXCoilNum) = 0.0;
        state.dataDXCoils->DXCoilFullLoadOutAirHumRat(DXCoilNum) = 0.0;

    } // end of on/off

    // set water system demand request (if needed)
    if (thisDXCoil.EvapWaterSupplyMode == EvapWaterSupply::FromTank) {
        state.dataWaterData->WaterStorage(thisDXCoil.EvapWaterSupTankID).VdotRequestDemand(thisDXCoil.EvapWaterTankDemandARRID) =
            thisDXCoil.EvapWaterConsumpRate;
    }

    state.dataDXCoils->DXCoilOutletTemp(DXCoilNum) = thisDXCoil.OutletAirTemp;
    state.dataDXCoils->DXCoilOutletHumRat(DXCoilNum) = thisDXCoil.OutletAirHumRat;
    state.dataDXCoils->DXCoilPartLoadRatio(DXCoilNum) = thisDXCoil.PartLoadRatio;
    state.dataDXCoils->DXCoilFanOp(DXCoilNum) = fanOp;
    thisDXCoil.CondInletTemp = CondInletTemp;
    state.dataDXCoils->DXCoilTotalCooling(DXCoilNum) = thisDXCoil.TotalCoolingEnergyRate;
    state.dataDXCoils->DXCoilCoolInletAirWBTemp(DXCoilNum) = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRat, OutdoorPressure);
}

void CalcVRFHeatingCoil_FluidTCtrl(EnergyPlusData &state,
                                   HVAC::CompressorOp const compressorOp,               // compressor operation; 1=on, 0=off
                                   int const DXCoilNum,                                 // the number of the DX heating coil to be simulated
                                   Real64 const PartLoadRatio,                          // sensible cooling load / full load sensible cooling capacity
                                   HVAC::FanOp const fanOp,                             // Allows parent object to control fan mode
                                   ObjexxFCL::Optional<Real64 const> OnOffAirFlowRatio, // ratio of compressor on airflow to compressor off airflow
                                   ObjexxFCL::Optional<Real64 const> MaxHeatCap         // maximum allowed heating capacity
)
{
    // SUBROUTINE INFORMATION:
    //       AUTHOR         Xiufeng Pang (XP), LBNL
    //       DATE WRITTEN   Mar 2013
    //       MODIFIED       Nov 2015, RP Zhang, LBNL

    // PURPOSE OF THIS SUBROUTINE:
    //         Calculates the air-side performance of a direct-expansion, air-cooled
    //         VRF terminal unit heating coil, for the new VRF model.

    // METHODOLOGY EMPLOYED:
    //         This subroutine is derived from CalcVRFCoolingCoil, and implements the new VRF model for FluidTCtrl.

    // Using/Aliasing
    using Curve::CurveValue;

    using namespace HVACVariableRefrigerantFlow;

    // INTERFACE BLOCK SPECIFICATIONS
    static constexpr std::string_view RoutineNameFullLoad("CalcVRFHeatingCoil_FluidTCtrl:fullload");

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    Real64 AirMassFlow;           // dry air mass flow rate through coil [kg/s]
    Real64 AirMassFlowRatio;      // Ratio of actual air mass flow to rated air mass flow
    Real64 AirVolumeFlowRate;     // Air volume flow rate across the cooling coil [m3/s]
    Real64 VolFlowperRatedTotCap; // Air volume flow rate divided by rated total cooling capacity [m3/s-W]
    Real64 TotCap;                // gross total cooling capacity at off-rated conditions [W]
    Real64 TotCapAdj;             // adjusted total cooling capacity at off-rated conditions [W]
    // on the type of curve
    Real64 InletAirDryBulbTemp;  // inlet air dry bulb temperature [C]
    Real64 InletAirWetBulbC;     // wetbulb temperature of inlet air [C]
    Real64 InletAirEnthalpy;     // inlet air enthalpy [J/kg]
    Real64 InletAirHumRat;       // inlet air humidity ratio [kg/kg]
    Real64 FullLoadOutAirEnth;   // outlet full load enthalpy [J/kg]
    Real64 FullLoadOutAirHumRat; // outlet humidity ratio at full load
    Real64 FullLoadOutAirTemp;   // outlet air temperature at full load [C]
    Real64 FullLoadOutAirRH;     // outlet air relative humidity at full load
    Real64 EIRTempModFac(0.0);   // EIR modifier (function of entering drybulb, outside drybulb) depending on the
    //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
    // type of curve
    // Real64 DefrostEIRTempModFac; // EIR modifier for defrost (function of entering wetbulb, outside drybulb)
    Real64 EIRFlowModFac;             // EIR modifier (function of actual supply air flow vs rated flow)
    Real64 EIR;                       // EIR at part load and off rated conditions
    Real64 PLF;                       // Part load factor, accounts for thermal lag at compressor startup
    Real64 PLRHeating;                // PartLoadRatio in heating
    Real64 OutdoorCoilT;              // Outdoor coil temperature (C)
    Real64 OutdoorCoildw;             // Outdoor coil delta w assuming coil temp of OutdoorCoilT (kg/kg)
    Real64 FractionalDefrostTime;     // Fraction of time step system is in defrost
    Real64 HeatingCapacityMultiplier; // Multiplier for heating capacity when system is in defrost
    Real64 InputPowerMultiplier;      // Multiplier for power when system is in defrost
    Real64 LoadDueToDefrost;          // Additional load due to defrost
    Real64 CrankcaseHeatingPower;     // power due to crankcase heater
    Real64 OutdoorDryBulb;            // Outdoor dry-bulb temperature at condenser (C)
    Real64 OutdoorWetBulb;            // Outdoor wet-bulb temperature at condenser (C)
    Real64 OutdoorHumRat;             // Outdoor humidity ratio at condenser (kg/kg)
    Real64 OutdoorPressure;           // Outdoor barometric pressure at condenser (Pa)
    constexpr int Mode(1);            // Performance mode for MultiMode DX coil. Always 1 for other coil types
    Real64 AirFlowRatio;              // Ratio of compressor on airflow to average timestep airflow
    Real64 OutletAirTemp;             // Supply air temperature (average value if constant fan, full output if cycling fan)
    Real64 OutletAirHumRat;           // Supply air humidity ratio (average value if constant fan, full output if cycling fan)
    Real64 OutletAirEnthalpy;         // Supply air enthalpy (average value if constant fan, full output if cycling fan)

    // Followings for VRF FluidTCtrl Only
    Real64 QCoilReq;       // Coil load (W)
    Real64 FanSpdRatio;    // Fan Speed Ratio
    Real64 AirMassFlowMin; // Min air mass flow rate due to OA requirement [kg/s]
    Real64 ActualSH;       // Actual Super Heating
    Real64 ActualSC;       // Actual Sub Cooling

    if (present(OnOffAirFlowRatio)) {
        AirFlowRatio = OnOffAirFlowRatio;
    } else {
        AirFlowRatio = 1.0;
    }

    // Air cooled condenser
    OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
    OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
    OutdoorHumRat = state.dataEnvrn->OutHumRat;
    OutdoorPressure = state.dataEnvrn->OutBaroPress;

    auto &thisDXCoil = state.dataDXCoils->DXCoil(DXCoilNum);

    AirMassFlow = thisDXCoil.InletAirMassFlowRate;
    InletAirDryBulbTemp = thisDXCoil.InletAirTemp;
    InletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
    InletAirHumRat = thisDXCoil.InletAirHumRat;
    InletAirWetBulbC = PsyTwbFnTdbWPb(state, InletAirDryBulbTemp, InletAirHumRat, OutdoorPressure);
    PLRHeating = 0.0;
    thisDXCoil.HeatingCoilRuntimeFraction = 0.0;
    thisDXCoil.CondensingTemp = state.dataHVACVarRefFlow->VRF(thisDXCoil.VRFOUPtr).IUCondensingTemp;

    // Initialize crankcase heater, operates below OAT defined in input deck for HP DX heating coil
    if (OutdoorDryBulb < thisDXCoil.MaxOATCrankcaseHeater) {
        CrankcaseHeatingPower = thisDXCoil.CrankcaseHeaterCapacity;
        if (thisDXCoil.CrankcaseHeaterCapacityCurveIndex > 0) {
            CrankcaseHeatingPower *= Curve::CurveValue(state, thisDXCoil.CrankcaseHeaterCapacityCurveIndex, OutdoorDryBulb);
        }
    } else {
        CrankcaseHeatingPower = 0.0;
    }

    if ((AirMassFlow > 0.0) && (compressorOp == HVAC::CompressorOp::On) && (GetCurrentScheduleValue(state, thisDXCoil.SchedPtr) > 0.0) &&
        (PartLoadRatio > 0.0) && (OutdoorDryBulb > thisDXCoil.MinOATCompressor)) {

        TotCap = thisDXCoil.RatedTotCap(Mode);
        HeatingCapacityMultiplier = 1.0;
        // Modify total heating capacity based on defrost heating capacity multiplier
        // MaxHeatCap passed from parent object VRF Condenser and is used to limit capacity of TU's to that available from condenser
        if (present(MaxHeatCap)) {
            TotCapAdj = min(MaxHeatCap, TotCap * HeatingCapacityMultiplier);
            TotCap = min(MaxHeatCap, TotCap);
        } else {
            TotCapAdj = TotCap * HeatingCapacityMultiplier;
        }

        QCoilReq = PartLoadRatio * TotCap;
        if (PartLoadRatio == 0.0) {
            AirMassFlowMin = state.dataHVACVarRefFlow->OACompOffMassFlow;
        } else {
            AirMassFlowMin = state.dataHVACVarRefFlow->OACompOnMassFlow;
        }

        // Call ControlVRFIUCoil to calculate: (1) FanSpdRatio, (2) coil inlet/outlet conditions, and (3) SH/SC
        ControlVRFIUCoil(state,
                         DXCoilNum,
                         QCoilReq,
                         thisDXCoil.InletAirTemp,
                         thisDXCoil.InletAirHumRat,
                         thisDXCoil.CondensingTemp,
                         AirMassFlowMin,
                         FanSpdRatio,
                         OutletAirHumRat,
                         OutletAirTemp,
                         OutletAirEnthalpy,
                         ActualSH,
                         ActualSC);
        AirMassFlow = FanSpdRatio * thisDXCoil.RatedAirMassFlowRate(Mode);

        AirVolumeFlowRate = AirMassFlow / PsyRhoAirFnPbTdbW(state, OutdoorPressure, InletAirDryBulbTemp, InletAirHumRat);
        // Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
        VolFlowperRatedTotCap = AirVolumeFlowRate / thisDXCoil.RatedTotCap(Mode);
        // VolFlowperRatedTotCap was checked at the initialization step
        // No need to check VolFlowperRatedTotCap at the simulation
        // New VRF_FluidTCtrl model implements VAV fan which can vary air flow rate during simulation

        AirMassFlowRatio = AirMassFlow / thisDXCoil.RatedAirMassFlowRate(Mode);

        // Calculating adjustment factors for defrost
        // Calculate delta w through outdoor coil by assuming a coil temp of 0.82*DBT-9.7(F) per DOE2.1E
        OutdoorCoilT = 0.82 * OutdoorDryBulb - 8.589;
        OutdoorCoildw = max(1.0e-6, (OutdoorHumRat - PsyWFnTdpPb(state, OutdoorCoilT, OutdoorPressure)));

        // Initializing defrost adjustment factors
        LoadDueToDefrost = 0.0;
        FractionalDefrostTime = 0.0;
        InputPowerMultiplier = 1.0;

        // Calculate full load outlet conditions
        FullLoadOutAirEnth = InletAirEnthalpy + TotCapAdj / AirMassFlow;
        FullLoadOutAirHumRat = InletAirHumRat;
        FullLoadOutAirTemp = PsyTdbFnHW(FullLoadOutAirEnth, FullLoadOutAirHumRat);
        FullLoadOutAirRH = PsyRhFnTdbWPb(state, FullLoadOutAirTemp, FullLoadOutAirHumRat, OutdoorPressure, RoutineNameFullLoad);
        //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
        //  FullLoadOutAirRH = PsyRhFnTdbWPb(FullLoadOutAirTemp,FullLoadOutAirHumRat,InletAirPressure)
        if (FullLoadOutAirRH > 1.0) { // Limit to saturated conditions at FullLoadOutAirEnth
            FullLoadOutAirTemp = PsyTsatFnHPb(state, FullLoadOutAirEnth, OutdoorPressure);
            //  Eventually inlet air conditions will be used in DX Coil, these lines are commented out and marked with this comment line
            //    FullLoadOutAirTemp = PsyTsatFnHPb(FullLoadOutAirEnth,InletAirPressure)
            FullLoadOutAirHumRat = PsyWFnTdbH(state, FullLoadOutAirTemp, FullLoadOutAirEnth);
        }

        // Calculate electricity consumed. First, get EIR modifying factors for off-rated conditions
        // Model was extended to accept bi-quadratic curves. This allows sensitivity of the EIR
        // to the entering dry-bulb temperature as well as the outside dry-bulb temperature. User is
        // advised to use the bi-quaratic curve if sufficient manufacturer data is available.
        if (thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_Heating && thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_FluidTCtrl_Heating) {
            if (state.dataCurveManager->PerfCurve(thisDXCoil.EIRFTemp(Mode))->numDims == 1) {
                EIRTempModFac = CurveValue(state, thisDXCoil.EIRFTemp(Mode), OutdoorDryBulb);
            } else {
                EIRTempModFac = CurveValue(state, thisDXCoil.EIRFTemp(Mode), InletAirDryBulbTemp, OutdoorDryBulb);
            }
            EIRFlowModFac = CurveValue(state, thisDXCoil.EIRFFlow(Mode), AirMassFlowRatio);
        } else {
            EIRTempModFac = 1.0;
            EIRFlowModFac = 1.0;
        }
        EIR = thisDXCoil.RatedEIR(Mode) * EIRTempModFac * EIRFlowModFac;

        // Calculate PLRHeating: modified PartLoadRatio due to defrost ( reverse-cycle defrost only )
        if (TotCap > 0.0) {
            PLRHeating = min(1.0, (PartLoadRatio + LoadDueToDefrost / TotCap));
        } else {
            PLRHeating = min(1.0, PartLoadRatio);
        }

        if (thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_Heating && thisDXCoil.DXCoilType_Num != HVAC::CoilVRF_FluidTCtrl_Heating) {
            PLF = CurveValue(state, thisDXCoil.PLFFPLR(Mode), PLRHeating); // Calculate part-load factor
        } else {
            PLF = 1.0;
        }

        if (PLF < 0.7) {
            if (thisDXCoil.PLRErrIndex == 0) {
                ShowWarningMessage(
                    state,
                    format("The PLF curve value for DX heating coil {} ={:.2R} for part-load ratio ={:.2R}", thisDXCoil.Name, PLF, PLRHeating));
                ShowContinueError(state, "PLF curve values must be >= 0.7. PLF has been reset to 0.7 and simulation is continuing.");
                ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Heating:DX:SingleSpeed].");
                ShowContinueErrorTimeStamp(state, "");
            }
            ShowRecurringWarningErrorAtEnd(state, "DX heating coil PLF curve < 0.7 warning continues... ", thisDXCoil.PLRErrIndex, PLF, PLF);
            PLF = 0.7;
        }

        thisDXCoil.HeatingCoilRuntimeFraction = (PLRHeating / PLF);
        if (thisDXCoil.HeatingCoilRuntimeFraction > 1.0 && std::abs(thisDXCoil.HeatingCoilRuntimeFraction - 1.0) > 0.001) {
            if (thisDXCoil.ErrIndex4 == 0) {
                ShowWarningMessage(state,
                                   format("The runtime fraction for DX heating coil {} exceeded 1.0. [{:.4R}].",
                                          thisDXCoil.Name,
                                          thisDXCoil.HeatingCoilRuntimeFraction));
                ShowContinueError(state, "Runtime fraction is set to 1.0 and the simulation continues...");
                ShowContinueError(state, "Check the IO reference manual for PLF curve guidance [Coil:Heating:DX:SingleSpeed].");
                ShowContinueErrorTimeStamp(state, "");
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           thisDXCoil.Name + ", DX heating coil runtime fraction > 1.0 warning continues...",
                                           thisDXCoil.ErrIndex4,
                                           thisDXCoil.HeatingCoilRuntimeFraction,
                                           thisDXCoil.HeatingCoilRuntimeFraction);
            thisDXCoil.HeatingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
        } else if (thisDXCoil.HeatingCoilRuntimeFraction > 1.0) {
            thisDXCoil.HeatingCoilRuntimeFraction = 1.0; // Reset coil runtime fraction to 1.0
        }

        // if cycling fan, send coil part-load fraction to on / off fan via HVACDataGlobals
        if (fanOp == HVAC::FanOp::Cycling) state.dataHVACGlobal->OnOffFanPartLoadFraction = PLF;
        thisDXCoil.ElecHeatingPower = TotCap * EIR * thisDXCoil.HeatingCoilRuntimeFraction * InputPowerMultiplier;

        // Calculate crankcase heater power using the runtime fraction for this DX heating coil only if there is no companion DX coil.
        // Else use the largest runtime fraction of this DX heating coil and the companion DX cooling coil.
        if (thisDXCoil.CompanionUpstreamDXCoil == 0) {
            thisDXCoil.CrankcaseHeaterPower = CrankcaseHeatingPower * (1.0 - thisDXCoil.HeatingCoilRuntimeFraction);
        } else {
            thisDXCoil.CrankcaseHeaterPower =
                CrankcaseHeatingPower * (1.0 - max(thisDXCoil.HeatingCoilRuntimeFraction,
                                                   state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).CoolingCoilRuntimeFraction));
        }

        thisDXCoil.OutletAirTemp = OutletAirTemp;
        thisDXCoil.OutletAirHumRat = OutletAirHumRat;
        thisDXCoil.OutletAirEnthalpy = OutletAirEnthalpy;
        thisDXCoil.CompressorPartLoadRatio = PartLoadRatio;
        thisDXCoil.ActualSH = ActualSH;
        thisDXCoil.ActualSC = ActualSC;
        thisDXCoil.TotalHeatingEnergyRate = AirMassFlow * (OutletAirEnthalpy - InletAirEnthalpy) * PartLoadRatio;
        thisDXCoil.DefrostPower = thisDXCoil.DefrostPower * thisDXCoil.HeatingCoilRuntimeFraction;

    } else {
        // DX coil is off; just pass through conditions

        thisDXCoil.OutletAirEnthalpy = thisDXCoil.InletAirEnthalpy;
        thisDXCoil.OutletAirHumRat = thisDXCoil.InletAirHumRat;
        thisDXCoil.OutletAirTemp = thisDXCoil.InletAirTemp;

        thisDXCoil.ElecHeatingPower = 0.0;
        thisDXCoil.TotalHeatingEnergyRate = 0.0;
        thisDXCoil.DefrostPower = 0.0;

        // Calculate crankcase heater power using the runtime fraction for this DX heating coil (here DXHeatingCoilRTF=0) if
        // there is no companion DX coil, or the runtime fraction of the companion DX cooling coil (here DXCoolingCoilRTF>=0).
        if (thisDXCoil.CompanionUpstreamDXCoil == 0) {
            thisDXCoil.CrankcaseHeaterPower = CrankcaseHeatingPower;
        } else {
            thisDXCoil.CrankcaseHeaterPower =
                CrankcaseHeatingPower * (1.0 - state.dataDXCoils->DXCoil(thisDXCoil.CompanionUpstreamDXCoil).CoolingCoilRuntimeFraction);
        }
        thisDXCoil.CompressorPartLoadRatio = 0.0;

        thisDXCoil.ActualSH = 999.0;
        thisDXCoil.ActualSC = 999.0;
    } // end of on/off if - else

    state.dataDXCoils->DXCoilOutletTemp(DXCoilNum) = thisDXCoil.OutletAirTemp;
    state.dataDXCoils->DXCoilOutletHumRat(DXCoilNum) = thisDXCoil.OutletAirHumRat;
    state.dataDXCoils->DXCoilFanOp(DXCoilNum) = fanOp;
    state.dataDXCoils->DXCoilPartLoadRatio(DXCoilNum) = PLRHeating;
    state.dataDXCoils->DXCoilTotalHeating(DXCoilNum) = thisDXCoil.TotalHeatingEnergyRate;
    state.dataDXCoils->DXCoilHeatInletAirDBTemp(DXCoilNum) = InletAirDryBulbTemp;
    state.dataDXCoils->DXCoilHeatInletAirWBTemp(DXCoilNum) = InletAirWetBulbC;

    // calc secondary coil if specified
    if (thisDXCoil.IsSecondaryDXCoilInZone) {
        CalcSecondaryDXCoils(state, DXCoilNum);
    }
}

void ControlVRFIUCoil(EnergyPlusData &state,
                      int const CoilIndex,     // index to VRFTU coil
                      Real64 const QCoil,      // coil load
                      Real64 const Tin,        // inlet air temperature
                      Real64 const Win,        // inlet air humidity ratio
                      Real64 const TeTc,       // evaporating or condensing temperature
                      Real64 const OAMassFlow, // mass flow rate of outdoor air
                      Real64 &FanSpdRatio,     // fan speed ratio: actual flow rate / rated flow rate
                      Real64 &Wout,            // outlet air humidity ratio
                      Real64 &Tout,            // outlet air temperature
                      Real64 &Hout,            // outlet air enthalpy
                      Real64 &SHact,           // actual SH
                      Real64 &SCact            // actual SC
)
{
    // SUBROUTINE INFORMATION:
    //       AUTHOR         Xiufeng Pang, LBNL
    //       DATE WRITTEN   Feb 2013
    //       MODIFIED       Nov 2015, RP Zhang, LBNL
    //
    // PURPOSE OF THIS SUBROUTINE:
    //       Analyze the VRF Indoor Unit operations given coil loads.
    //       Calculated parameters include: (1) Fan Speed Ratio (2) SH/SC, (3) Coil Outlet conditions
    //
    // METHODOLOGY EMPLOYED:
    //       A new physics based VRF model applicable for Fluid Temperature Control.
    //
    // USE STATEMENTS:
    using Psychrometrics::PsyHFnTdbW;

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int MaxIter(500);              // Max iteration numbers (-)
    int SolFla;                    // Solving flag for SolveRoot (-)
    int constexpr FlagCoolMode(0); // Flag for cooling mode
    int constexpr FlagHeatMode(1); // Flag for heating mode
    Real64 BF;                     // Bypass factor (-)
    Real64 C1Tevap;                // Coefficient for indoor unit coil evaporating temperature curve (-)
    Real64 C2Tevap;                // Coefficient for indoor unit coil evaporating temperature curve (-)
    Real64 C3Tevap;                // Coefficient for indoor unit coil evaporating temperature curve (-)
    Real64 C1Tcond;                // Coefficient for indoor unit coil condensing temperature curve (-)
    Real64 C2Tcond;                // Coefficient for indoor unit coil condensing temperature curve (-)
    Real64 C3Tcond;                // Coefficient for indoor unit coil condensing temperature curve (-)
    Real64 CoilOnOffRatio;         // coil on/off ratio: time coil is on divided by total time
    Real64 deltaT;                 // Difference between evaporating/condensing temperature and coil surface temperature (C)
    Real64 FanSpdRatioMin;         // Min fan speed ratio, below which the cycling will be activated (-)
    Real64 FanSpdRatioMax;         // Max fan speed ratio (-)
    Real64 Garate;                 // Nominal air mass flow rate (m3/s)
    Real64 MaxSH;                  // Max super heating degrees (C)
    Real64 MaxSC;                  // Max subcooling degrees (C)
    Real64 QinSenMin1;             // Coil capacity at minimum fan speed, corresponding to real SH (W)
    Real64 QinSenMin2;             // Coil capacity at minimum fan speed, corresponding to corresponds maximum SH (W)
    Real64 QinSenPerFlowRate;      // Coil capacity per air mass flow rate(W-s/kg)
    Real64 QCoilSenCoolingLoad;    // Coil sensible cooling load (W)
    Real64 QCoilSenHeatingLoad;    // Coil sensible heating load (W)
    Real64 Ratio1;                 // Fan speed ratio (-)
    Real64 RHsat;                  // Relative humidity of the air at saturated condition(-)
    Real64 SH;                     // Super heating degrees (C)
    Real64 SC;                     // Subcooling degrees (C)
    Real64 Ts_1;                   // Air temperature at the coil surface, corresponding to SH (C)
    Real64 Ts_2;                   // Air temperature at the coil surface, corresponding to MaxSH (C)
    Real64 To_1;                   // Air temperature at the coil outlet, corresponding to SH (C)
    Real64 To_2;                   // Air temperature at the coil outlet, corresponding to MaxSH (C)
    Real64 Ts;                     // Air temperature at the coil surface (C)
    Real64 Ws;                     // Air humidity ratio at the coil surface (kg/kg)

    RHsat = 0.98; // Saturated RH
    MaxSH = 15;
    MaxSC = 20;
    Garate = state.dataDXCoils->DXCoil(CoilIndex).RatedAirMassFlowRate(1);
    FanSpdRatioMin = min(OAMassFlow / Garate, 1.0); // ensure that coil flow rate is higher than OA flow rate

    if (QCoil == 0) {
        // No Heating or Cooling
        FanSpdRatio = OAMassFlow / Garate;
        CoilOnOffRatio = 0.0;

        SHact = 999.0;
        SCact = 999.0;
        Tout = Tin;
        Hout = PsyHFnTdbW(Tin, Win);
        Wout = Win;

    } else if (QCoil < 0) {
        // Cooling Mode

        // Obtain coil cooling loads
        QCoilSenCoolingLoad = -QCoil;

        // Coefficients describing coil performance
        SH = state.dataDXCoils->DXCoil(CoilIndex).SH;
        C1Tevap = state.dataDXCoils->DXCoil(CoilIndex).C1Te;
        C2Tevap = state.dataDXCoils->DXCoil(CoilIndex).C2Te;
        C3Tevap = state.dataDXCoils->DXCoil(CoilIndex).C3Te;
        BF = state.dataDXCoils->DXCoil(CoilIndex).RateBFVRFIUEvap;

        // Coil sensible heat transfer_minimum value
        CalcVRFCoilSenCap(state, FlagCoolMode, CoilIndex, Tin, TeTc, SH, BF, QinSenPerFlowRate, Ts_1);
        To_1 = Tin - QinSenPerFlowRate / 1005;
        QinSenMin1 = FanSpdRatioMin * Garate * QinSenPerFlowRate; // Corresponds real SH

        CalcVRFCoilSenCap(state, FlagCoolMode, CoilIndex, Tin, TeTc, MaxSH, BF, QinSenPerFlowRate, Ts_2);
        To_2 = Tin - QinSenPerFlowRate / 1005;
        QinSenMin2 = FanSpdRatioMin * Garate * QinSenPerFlowRate; // Corresponds maximum SH

        if (QCoilSenCoolingLoad > QinSenMin1) {
            // Increase fan speed to meet room sensible load; SH is not updated
            FanSpdRatioMax = 1.0;
            auto f = [QCoilSenCoolingLoad, Ts_1, Tin, Garate, BF](Real64 FanSpdRto) {
                return FanSpdResidualCool(FanSpdRto, QCoilSenCoolingLoad, Ts_1, Tin, Garate, BF);
            };
            General::SolveRoot(state, 1.0e-3, MaxIter, SolFla, Ratio1, f, FanSpdRatioMin, FanSpdRatioMax);
            if (SolFla < 0) Ratio1 = FanSpdRatioMax; // over capacity
            FanSpdRatio = Ratio1;
            CoilOnOffRatio = 1.0;

            Tout = To_1; // Since SH is not updated
            Ws = PsyWFnTdbRhPb(state, Ts_1, RHsat, state.dataEnvrn->OutBaroPress, "ControlVRFIUCoil");
            if (Ws < Win) {
                Wout = Win - (Win - Ws) * (1 - BF);
            } else {
                Wout = Win;
            }
            Hout = PsyHFnTdbW(Tout, Wout);
            SCact = 999.0;
            SHact = SH;

        } else {
            // Low load modification algorithm
            // Need to increase SH to further reduce coil capacity
            // May further implement coil cycling control if SC modification is not enough

            FanSpdRatio = FanSpdRatioMin;

            CoilOnOffRatio = 1.0;

            Tout = Tin - QCoilSenCoolingLoad / 1005.0 / FanSpdRatioMin / Garate;
            Ts = Tin - (Tin - Tout) / (1 - BF);
            deltaT = Ts - TeTc;

            // Update SH
            if (C3Tevap <= 0.0) {
                if (C2Tevap > 0.0) {
                    SHact = (deltaT - C1Tevap) / C2Tevap;
                } else {
                    SHact = 998.0;
                }
            } else {
                SHact = (-C2Tevap + sqrt(pow_2(C2Tevap) - 4 * C3Tevap * (C1Tevap - deltaT))) / 2 / C3Tevap;
            }

            Ws = PsyWFnTdbRhPb(state, Ts, RHsat, state.dataEnvrn->OutBaroPress, "ControlVRFIUCoil");
            if (Ws < Win) {
                Wout = Win - (Win - Ws) * (1 - BF);
            } else {
                Wout = Win;
            }

            if (SHact > MaxSH) {
                // Further implement On/Off Control
                SHact = MaxSH;
                CoilOnOffRatio = QCoilSenCoolingLoad / QinSenMin2;

                Ts = Ts_2;
                Ws = PsyWFnTdbRhPb(state, Ts, RHsat, state.dataEnvrn->OutBaroPress, "ControlVRFIUCoil");
                if (Ws < Win) {
                    Wout = Win - (Win - Ws) * (1 - BF);
                } else {
                    Wout = Win;
                }

                // outlet air temperature and humidity ratio is time-weighted
                Tout = CoilOnOffRatio * To_2 + (1 - CoilOnOffRatio) * Tin;
                Wout = CoilOnOffRatio * Wout + (1 - CoilOnOffRatio) * Win;
            }

            Hout = PsyHFnTdbW(Tout, Wout);
            SCact = 999.0;
        }

    } else if (QCoil > 0) {
        // Heating Mode

        // Obtain zonal heating loads
        QCoilSenHeatingLoad = QCoil;

        // Coefficients describing coil performance
        SC = state.dataDXCoils->DXCoil(CoilIndex).SC;
        C1Tcond = state.dataDXCoils->DXCoil(CoilIndex).C1Tc;
        C2Tcond = state.dataDXCoils->DXCoil(CoilIndex).C2Tc;
        C3Tcond = state.dataDXCoils->DXCoil(CoilIndex).C3Tc;
        BF = state.dataDXCoils->DXCoil(CoilIndex).RateBFVRFIUCond;

        // Coil sensible heat transfer_minimum value
        CalcVRFCoilSenCap(state, FlagHeatMode, CoilIndex, Tin, TeTc, SC, BF, QinSenPerFlowRate, Ts_1);
        To_1 = QinSenPerFlowRate / 1005 + Tin;
        QinSenMin1 = FanSpdRatioMin * Garate * QinSenPerFlowRate; // Corresponds real SH

        CalcVRFCoilSenCap(state, FlagHeatMode, CoilIndex, Tin, TeTc, MaxSC, BF, QinSenPerFlowRate, Ts_2);
        To_2 = QinSenPerFlowRate / 1005 + Tin;
        QinSenMin2 = FanSpdRatioMin * Garate * QinSenPerFlowRate; // Corresponds maximum SH

        if (QCoilSenHeatingLoad > QinSenMin1) {
            // Modulate fan speed to meet room sensible load; SC is not updated
            FanSpdRatioMax = 1.0;
            auto f = [QCoilSenHeatingLoad, Ts_1, Tin, Garate, BF](Real64 FanSpdRto) {
                return FanSpdResidualHeat(FanSpdRto, QCoilSenHeatingLoad, Ts_1, Tin, Garate, BF);
            };
            General::SolveRoot(state, 1.0e-3, MaxIter, SolFla, Ratio1, f, FanSpdRatioMin, FanSpdRatioMax);
            // this will likely cause problems eventually, -1 and -2 mean different things
            if (SolFla < 0) Ratio1 = FanSpdRatioMax; // over capacity
            FanSpdRatio = Ratio1;
            CoilOnOffRatio = 1.0;

            Tout = Tin + (Ts_1 - Tin) * (1 - BF);
            Wout = Win;
            Hout = PsyHFnTdbW(Tout, Wout);
            SHact = 999.0;
            SCact = SC;

        } else {
            // Low load modification algorithm
            // Need to increase SC to further reduce coil heating capacity
            // May further implement coil cycling control if SC modification is not enough

            FanSpdRatio = FanSpdRatioMin;
            CoilOnOffRatio = 1.0;

            Tout = Tin + QCoilSenHeatingLoad / 1005.0 / FanSpdRatio / Garate;
            Ts = Tin + (Tout - Tin) / (1 - BF);
            deltaT = TeTc - Ts;

            // Update SC
            if (C3Tcond <= 0.0) {
                if (C2Tcond > 0.0) {
                    SCact = (deltaT - C1Tcond) / C2Tcond;
                } else {
                    SCact = 998.0;
                }
            } else {
                SCact = (-C2Tcond + sqrt(pow_2(C2Tcond) - 4 * C3Tcond * (C1Tcond - deltaT))) / 2 / C3Tcond;
            }

            if (SCact > MaxSC) {
                // Implement On/Off Control
                SCact = MaxSC;
                CoilOnOffRatio = QCoilSenHeatingLoad / QinSenMin2;
                // outlet air temperature is time-weighted
                Tout = CoilOnOffRatio * To_2 + (1 - CoilOnOffRatio) * Tin;
            }
            Wout = Win;
            Hout = PsyHFnTdbW(Tout, Wout);
            SHact = 999.0;
        }
    }
}

void CalcVRFCoilSenCap(EnergyPlusData &state,
                       int const OperationMode, // mode 0 for cooling, 1 for heating
                       int const CoilNum,       // index to VRFTU cooling or heating coil
                       Real64 const Tinlet,     // dry bulb temperature of air entering the coil
                       Real64 const TeTc,       // evaporating or condensing temperature
                       Real64 const SHSC,       // SH at cooling /SC at heating
                       Real64 const BF,         // Bypass factor
                       Real64 &Q_sen,           // VRF coil sensible capacity per air mass flow rate
                       Real64 &T_coil_surf      // Air temperature at coil surface
)
{
    // SUBROUTINE INFORMATION:
    //       AUTHOR         Rongpeng Zhang, LBNL
    //       DATE WRITTEN   Jul 2015
    //
    // PURPOSE OF THIS SUBROUTINE:
    //        Calculate the VRF coil sensible capacity per air mass flow rate, given:
    //        (1) refrigerant temperature (Te or Tc), (2) SH or SC, and (3) inlet air temperature.
    //
    // METHODOLOGY EMPLOYED:
    //        A new physics based VRF model appliable for Fluid Temperature Control.
    //

    int constexpr FlagCoolMode(0); // Flag for cooling mode
    int constexpr FlagHeatMode(1); // Flag for heating mode
    Real64 C1Tevap;                // Coefficient for indoor unit coil evaporating temperature curve (-)
    Real64 C2Tevap;                // Coefficient for indoor unit coil evaporating temperature curve (-)
    Real64 C3Tevap;                // Coefficient for indoor unit coil evaporating temperature curve (-)
    Real64 C1Tcond;                // Coefficient for indoor unit coil condensing temperature curve (-)
    Real64 C2Tcond;                // Coefficient for indoor unit coil condensing temperature curve (-)
    Real64 C3Tcond;                // Coefficient for indoor unit coil condensing temperature curve (-)
    Real64 deltaT;                 // Difference between Te/Tc and coil surface temperature (C)
    Real64 SH;                     // Super heating at cooling mode(C)
    Real64 SC;                     // Subcooling at heating mode (C)
    Real64 T_coil_in;              // Air temperature at coil inlet (C)
    Real64 T_coil_out;             // Air temperature at coil outlet (C)

    if (OperationMode == FlagCoolMode) {
        // Cooling: OperationMode 0

        C1Tevap = state.dataDXCoils->DXCoil(CoilNum).C1Te;
        C2Tevap = state.dataDXCoils->DXCoil(CoilNum).C2Te;
        C3Tevap = state.dataDXCoils->DXCoil(CoilNum).C3Te;
        SH = SHSC;
        T_coil_in = Tinlet;

        // Coil surface temperature
        deltaT = C3Tevap * SH * SH + C2Tevap * SH + C1Tevap;
        T_coil_surf = TeTc + deltaT;

        // Outlet air temperature
        T_coil_out = T_coil_in - (T_coil_in - T_coil_surf) * (1 - BF);

        // Coil sensilbe heat transfer per mass flow rate
        Q_sen = max(1005 * (T_coil_in - T_coil_out), 0.0);

    } else if (OperationMode == FlagHeatMode) {
        // Heating: OperationMode 1

        C1Tcond = state.dataDXCoils->DXCoil(CoilNum).C1Tc;
        C2Tcond = state.dataDXCoils->DXCoil(CoilNum).C2Tc;
        C3Tcond = state.dataDXCoils->DXCoil(CoilNum).C3Tc;
        SC = SHSC;
        T_coil_in = Tinlet;

        // Coil surface temperature
        deltaT = C3Tcond * SC * SC + C2Tcond * SC + C1Tcond;
        T_coil_surf = TeTc - deltaT;

        // Coil outlet air temperature
        T_coil_out = T_coil_in + (T_coil_surf - T_coil_in) * (1 - BF);

        // Coil sensilbe heat transfer_minimum value
        Q_sen = max(1005 * (T_coil_out - T_coil_in), 0.0);
    }
}

void CalcVRFCoilCapModFac(EnergyPlusData &state,
                          int const OperationMode,                   // mode 0 for cooling, 1 for heating
                          ObjexxFCL::Optional<int const> CoilIndex,  // index to VRFTU cooling or heating coil
                          ObjexxFCL::Optional<std::string> CoilName, // name of VRFTU cooling or heating coil
                          Real64 const Tinlet,                       // dry bulb temperature of air entering the coil
                          ObjexxFCL::Optional<Real64 const> TeTc,    // evaporating or condensing temperature
                          ObjexxFCL::Optional<Real64 const> SHSC,    // SH at cooling /SC at heating
                          ObjexxFCL::Optional<Real64 const> BF,      // Bypass factor
                          Real64 &CapModFac                          // Coil capacity modification factor
)
{
    // SUBROUTINE INFORMATION:
    //       AUTHOR         Rongpeng Zhang, LBNL
    //       DATE WRITTEN   Jul 2015
    //
    // PURPOSE OF THIS SUBROUTINE:
    //        Calculate the VRF coil capacity modification factor, which is the ratio of
    //        the capacity at real conditions and that at rated conditions.
    //        This is used for the coil sizing subroutine.
    //
    // METHODOLOGY EMPLOYED:
    //        A new physics based VRF model applicable for Fluid Temperature Control.
    //

    bool ErrorsFound(false);       // Flag for errors
    int constexpr FlagCoolMode(0); // Flag for cooling mode
    int constexpr FlagHeatMode(1); // Flag for heating mode
    Real64 constexpr SH_rate(3);   // Super heating at cooling mode, default 3(C)
    Real64 constexpr SC_rate(5);   // Subcooling at heating mode, default 5 (C)
    Real64 constexpr Te_rate(6);   // Evaporating temperature at cooling mode, default 6 (C)
    Real64 constexpr Tc_rate(44);  // Condensing temperature at heating mode, default 44 (C)
    int CoilNum;                   // index to VRFTU cooling or heating coil
    Real64 BF_real;                // Bypass factor (-)
    Real64 BFC_rate;               // Bypass factor at cooling mode (-)
    Real64 BFH_rate;               // Bypass factor at heating mode (-)
    Real64 SHSC_real;              // Super heating or Subcooling (C)
    Real64 TeTc_real;              // Evaporating temperature or condensing temperature (C)
    Real64 Ts;                     // Air temperature at coil surface (C)
    Real64 Q_real;                 // Coil capacity at given condition (W)
    Real64 Q_rate;                 // Coil capacity at rated condition (W)

    if (present(CoilIndex)) {
        CoilNum = CoilIndex;
    } else {
        GetDXCoilIndex(state, CoilName, CoilNum, ErrorsFound, "", true);
    }

    BFC_rate = state.dataDXCoils->DXCoil(CoilNum).RateBFVRFIUEvap;
    BFH_rate = state.dataDXCoils->DXCoil(CoilNum).RateBFVRFIUCond;

    if (OperationMode == FlagCoolMode) {
        // Cooling: OperationMode 0

        if (present(BF)) {
            BF_real = BF;
        } else {
            BF_real = BFC_rate;
        }
        if (present(TeTc)) {
            TeTc_real = TeTc;
        } else {
            TeTc_real = Te_rate;
        }
        if (present(SHSC)) {
            SHSC_real = SHSC;
        } else {
            SHSC_real = SH_rate;
        }

        // Coil capacity at rated conditions
        CalcVRFCoilSenCap(state, FlagCoolMode, CoilNum, 26, Te_rate, SH_rate, BFC_rate, Q_rate, Ts);

        // Coil capacity at given conditions
        CalcVRFCoilSenCap(state, FlagCoolMode, CoilNum, Tinlet, TeTc_real, SHSC_real, BF_real, Q_real, Ts);

        if (Q_rate > 0) {
            CapModFac = Q_real / Q_rate;
        } else {
            CapModFac = 1.0;
        }

    } else if (OperationMode == FlagHeatMode) {
        // Heating: OperationMode 1

        if (present(BF)) {
            BF_real = BF;
        } else {
            BF_real = BFH_rate;
        }
        if (present(TeTc)) {
            TeTc_real = TeTc;
        } else {
            TeTc_real = Tc_rate;
        }
        if (present(SHSC)) {
            SHSC_real = SHSC;
        } else {
            SHSC_real = SC_rate;
        }

        // Coil capacity at rated conditions
        CalcVRFCoilSenCap(state, FlagHeatMode, CoilNum, 20, Tc_rate, SC_rate, BFH_rate, Q_rate, Ts);

        // Coil capacity at given conditions
        CalcVRFCoilSenCap(state, FlagHeatMode, CoilNum, Tinlet, TeTc_real, SHSC_real, BF_real, Q_real, Ts);

        if (Q_rate > 0) {
            CapModFac = Q_real / Q_rate;
        } else {
            CapModFac = 1.0;
        }
    }
}

Real64 FanSpdResidualCool(
    Real64 const FanSpdRto, Real64 const QCoilSenCoolingLoad, Real64 const Ts_1, Real64 const Tin, Real64 const Garate, Real64 const BF)
{
    // FUNCTION INFORMATION:
    //       AUTHOR         Xiufeng Pang (XP)
    //       DATE WRITTEN   Mar 2013
    //       MODIFIED       Nov 2015, RP Zhang, LBNL
    //
    // PURPOSE OF THIS FUNCTION:
    //       Calculates residual function (desired zone cooling load - actual coil cooling capacity)
    //       This is used to modify the fan speed to adjust the coil cooling capacity to match
    //       the zone cooling load.
    //
    Real64 ZnSenLoad = QCoilSenCoolingLoad;
    // +-100 W minimum zone load?
    if (std::abs(ZnSenLoad) < 100.0) ZnSenLoad = sign(100.0, ZnSenLoad);
    Real64 Tout = Tin - (Tin - Ts_1) * (1 - BF);
    Real64 TotCap = FanSpdRto * Garate * 1005.0 * (Tin - Tout);
    return (TotCap - ZnSenLoad) / ZnSenLoad;
}

Real64 FanSpdResidualHeat(Real64 FanSpdRto, Real64 QCoilSenHeatingLoad, Real64 Ts_1, Real64 Tin, Real64 Garate, Real64 BF)
{

    // FUNCTION INFORMATION:
    //       AUTHOR         Xiufeng Pang (XP)
    //       DATE WRITTEN   Mar 2013
    //       MODIFIED       Nov 2015, RP Zhang, LBNL
    //
    // PURPOSE OF THIS FUNCTION:
    //       Calculates residual function (desired zone heating load - actual heating coil capacity)
    //       This is used to modify the fan speed to adjust the coil heating capacity to match
    //       the zone heating load.
    //

    Real64 ZnSenLoad = QCoilSenHeatingLoad;
    // +-100 W minimum zone load?
    if (std::abs(ZnSenLoad) < 100.0) ZnSenLoad = sign(100.0, ZnSenLoad);
    Real64 Tout = Tin + (Ts_1 - Tin) * (1 - BF);
    Real64 TotCap = FanSpdRto * Garate * 1005.0 * (Tout - Tin);
    return (TotCap - ZnSenLoad) / ZnSenLoad;
}

void SetMSHPDXCoilHeatRecoveryFlag(EnergyPlusData &state, int const DXCoilNum)
{

    // SUBROUTINE INFORMATION:
    //       AUTHOR         L. Gu
    //       DATE WRITTEN   Sep. 2015

    // PURPOSE OF THIS SUBROUTINE:
    // Set the heat recovery flag true when the parent object requests heat recovery.

    if (state.dataDXCoils->DXCoil(DXCoilNum).FuelType != Constant::eFuel::Electricity) {
        state.dataDXCoils->DXCoil(DXCoilNum).MSHPHeatRecActive = true;
    }
}

void SetDXCoilAirLoopNumber(EnergyPlusData &state, std::string const &CoilName, int const AirLoopNum)
{
    // SUBROUTINE INFORMATION:
    //       AUTHOR         L. Gu
    //       DATE WRITTEN   March, 2018

    // PURPOSE OF THIS SUBROUTINE:
    // Set AirLoopNum for AFN model with multiple AirLoops

    // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
    int WhichCoil;

    if (state.dataDXCoils->GetCoilsInputFlag) {
        GetDXCoils(state);
        state.dataDXCoils->GetCoilsInputFlag = false;
    }

    WhichCoil = Util::FindItemInList(CoilName, state.dataDXCoils->DXCoil);
    if (WhichCoil != 0) {
        state.dataDXCoils->DXCoil(WhichCoil).AirLoopNum = AirLoopNum;
    } else {
        ShowSevereError(state, format("SetDXCoilAirLoopNumber: Could not find Coil \"Name=\"{}\"", CoilName));
    }
} // must match coil names for the coil type

void DisableLatentDegradation(EnergyPlusData &state, int const DXCoilNum)
{
    // SUBROUTINE INFORMATION:
    //       AUTHOR         L. Gu
    //       DATE WRITTEN   JUne, 2019

    // PURPOSE OF THIS SUBROUTINE:
    // Disable latent degradation when direct solution is used.

    state.dataDXCoils->DXCoil(DXCoilNum).Twet_Rated(1) = 0.0;
}

} // namespace EnergyPlus::DXCoils
