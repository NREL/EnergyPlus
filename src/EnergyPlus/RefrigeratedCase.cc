// EnergyPlus, Copyright (c) 1996-2020, The Board of Trustees of the University of Illinois,
// The Regents of the University of California, through Lawrence Berkeley National Laboratory
// (subject to receipt of any required approvals from the U.S. Dept. of Energy), Oak Ridge
// National Laboratory, managed by UT-Battelle, Alliance for Sustainable Energy, LLC, and other
// contributors. All rights reserved.
//
// NOTICE: This Software was developed under funding from the U.S. Department of Energy and the
// U.S. Government consequently retains certain rights. As such, the U.S. Government has been
// granted for itself and others acting on its behalf a paid-up, nonexclusive, irrevocable,
// worldwide license in the Software to reproduce, distribute copies to the public, prepare
// derivative works, and perform publicly and display publicly, and to permit others to do so.
//
// Redistribution and use in source and binary forms, with or without modification, are permitted
// provided that the following conditions are met:
//
// (1) Redistributions of source code must retain the above copyright notice, this list of
//     conditions and the following disclaimer.
//
// (2) Redistributions in binary form must reproduce the above copyright notice, this list of
//     conditions and the following disclaimer in the documentation and/or other materials
//     provided with the distribution.
//
// (3) Neither the name of the University of California, Lawrence Berkeley National Laboratory,
//     the University of Illinois, U.S. Dept. of Energy nor the names of its contributors may be
//     used to endorse or promote products derived from this software without specific prior
//     written permission.
//
// (4) Use of EnergyPlus(TM) Name. If Licensee (i) distributes the software in stand-alone form
//     without changes from the version obtained under this License, or (ii) Licensee makes a
//     reference solely to the software portion of its product, Licensee must refer to the
//     software as "EnergyPlus version X" software, where "X" is the version number Licensee
//     obtained under this License and may not use a different name for the software. Except as
//     specifically required in this Section (4), Licensee shall not use in a company name, a
//     product name, in advertising, publicity, or other promotional activities any name, trade
//     name, trademark, logo, or other designation of "EnergyPlus", "E+", "e+" or confusingly
//     similar designation, without the U.S. Department of Energy's prior written consent.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// C++ Headers
#include <cmath>
#include <string>

// ObjexxFCL Headers
#include <ObjexxFCL/Array.functions.hh>
#include <ObjexxFCL/Array2D.hh>
#include <ObjexxFCL/Fmath.hh>
#include <ObjexxFCL/gio.hh>

// EnergyPlus Headers
#include <EnergyPlus/BranchNodeConnections.hh>
#include <EnergyPlus/CurveManager.hh>
#include <EnergyPlus/Data/EnergyPlusData.hh>
#include <EnergyPlus/DataEnvironment.hh>
#include <EnergyPlus/DataHVACGlobals.hh>
#include <EnergyPlus/DataHeatBalFanSys.hh>
#include <EnergyPlus/DataHeatBalance.hh>
#include <EnergyPlus/DataLoopNode.hh>
#include <EnergyPlus/DataWater.hh>
#include <EnergyPlus/DataZoneEnergyDemands.hh>
#include <EnergyPlus/DataZoneEquipment.hh>
#include <EnergyPlus/EMSManager.hh>
#include <EnergyPlus/FluidProperties.hh>
#include <EnergyPlus/General.hh>
#include <EnergyPlus/GlobalNames.hh>
#include <EnergyPlus/HeatBalanceInternalHeatGains.hh>
#include <EnergyPlus/IOFiles.hh>
#include <EnergyPlus/InputProcessing/InputProcessor.hh>
#include <EnergyPlus/NodeInputManager.hh>
#include <EnergyPlus/OutAirNodeManager.hh>
#include <EnergyPlus/OutputProcessor.hh>
#include <EnergyPlus/Plant/DataPlant.hh>
#include <EnergyPlus/PlantUtilities.hh>
#include <EnergyPlus/Psychrometrics.hh>
#include <EnergyPlus/RefrigeratedCase.hh>
#include <EnergyPlus/ScheduleManager.hh>
#include <EnergyPlus/UtilityRoutines.hh>
#include <EnergyPlus/WaterManager.hh>

namespace EnergyPlus {

namespace RefrigeratedCase {

    // MODULE INFORMATION:
    //       AUTHOR         Richard Raustad, FSEC
    //       DATE WRITTEN   Oct/Nov 2004
    //       MODIFIED       Shirey, FSEC Dec 2004; Hudson, ORNL Feb 2007, July 2007
    //       MODIFIED       Stovall, ORNL, April 2008 added detailed refrigeration systems
    //       MODIFIED       Stovall, ORNL, Fall 2009 added cascade condensers, secondary loops, and walk-ins.
    //       MODIFIED       Griffith, NREL, 2010, Plant upgrade, generalize plant fluid properties.
    //       MODIFIED       Fricke, ORNL, Fall 2011, added detailed transcritical CO2 refrigeration system.
    //       RE-ENGINEERED  na

    // PURPOSE OF THIS MODULE:
    // To simulate refrigerated cases,walk-in coolers, secondary loops,
    //             compressor racks, and detailed refrigeration systems.
    // Case performance is varied based on specific operating conditions within the zone.

    // METHODOLOGY EMPLOYED:
    // Refrigerated cases are simulated based on performance information available from manufacturers
    // and knowing the latent heat ratio of the case cooling load which can be obtained from ASHRAE or
    // others who have completed research to quantify this value. The sensible case credits
    // (sensible cooling provided to the surrounding zone air) are calculated during input
    // processing by subtracting the fan, lighting, and anti-sweat heater energy from the
    // design sensible capacity (TotCap * (1-LHR) * RTF).  The actual latent cooling provided
    // by the case (at the actual operating conditions) is calculated based on the latent performance
    // curve supplied by the user.  The actual sensible cooling provided by the case (at the actual
    // operating conditions) is calculated by summing all sensible components (fan + light + anti-sweat +
    // sensible case credit). The case (evaporator) fans are assumed to be disabled during hot-gas or
    // electric defrost modes. A stocking schedule (W/m) is available for added load if desired.
    // Walk-In coolers are simulated based on the specified sum of the conductance*area of each wall and door facing
    // up to three (extendible) zones.  Two types of doors are specified, stock doors and glass doors.  For each category
    // of doors, schedules for door openings are used with ASHRAE models for infiltration
    // which are a function of the height of the door.  That
    // infiltration is used to calculate the latent load on the cooler and the latent case credits for each zone.
    // The sensible case credit for each zone is the sum of the conductive and sensible infiltration load
    // for each surface/door facing that zone.  Note that the latent portion of the infiltration is unused
    // during defrost to be consistent with decision for refrigerated cases.
    // Compressor racks are simulated by summing the attached refrigerated case and walk-in cooler
    // capacities.  The energy use of the
    // compressor rack is then calculated with a simplified model for COP variation with temperature. Condenser fan power
    // is based on a user-supplied curve object. Racks are not scheduled.
    // Compressor racks may have indoor (in-zone) or outdoor condensers.  If outdoors, the condensers may be cooled
    // by dry air cooling or evaporative cooling. A water-cooled condenser is also available by specifying water-cooling
    // as the Condenser Type.  If a water-cooled condenser is utilized, a second entry to this module will
    // occur during the HVAC simulation as called from the NonZoneEquipmentManager.
    // Detailed refrigeration systems model each compressor individually using the manufacturer's rating curves.
    // A collection of such curves has been added in the datasets library. The curves produce the refrigeration
    // capacity and power consumption. The capacity needed is based on the sum of the case and walk-in loads (as is done
    // for the compressor racks).  The compressors are dispatched to meet this load according to the order
    // prescribed in the compressor list input object. The condenser for each system can be air-cooled,
    // evaporative-cooled, or water cooled.  For air and evap-cooled condensers, manufacturer's rating data
    // is input to describe the performance and to determine the required air flow rate, which is used to
    // calculate the fan power requirements.  The fans can be described as single-speed, two-speed, or variable
    // speed. The condenser performance data also is used to calculate the condensing temperature, which is a function
    // of the heat sink temperature and the load on the condenser.  This must be solved iteratively, checking on
    // the calculated refrigerant mass flow through the compressors.  The solution usually requires less than 5 iterations.
    // The refrigerant state exiting the compressor group is known so the amount of heat available for
    // desuperheat reclaim is explicitly known.
    // The detailed refrigeration model allows the use of subcoolers,secondary loops, and cascade condensers
    // to transfer load from one suction group to another. This introduces the need for further iterations among
    // the systems.  Three loops through the
    // systems are adequate to model these interactions.  The detailed model will also calculate a variable suction
    // pressure for systems with controls that allow the suction temperature/pressure to float
    // up when the case loads are less than their design capacity.

    // Secondary Systems include case and walk-in refrigeration loads.  However, the balance of the system is
    // made up of a heat exchanger and circulating pump(s) instead of a condenser and compressors.
    // The total load on the heat exchanger is the sum of the refrigeration loads, any pipe heat gains,
    // and the portion of the pump power that is absorbed by the circulating fluid. If the total load is
    // greater than the rated capacity of the secondary loop, the unmet load for any time step is carried over
    // to the next time step.  Each secondary system appears as a load on a detailed refrigeration system. If
    // any of the cases or walk-ins served by a secondary are defrosted using hot brine, the primary system
    // serving the secondary loop receives the defrost energy credits (i.e., heat reclaim used to generate defrost
    // energy).

    // Cascade Condensers allow the use of a higher temperature refrigeration system (primary system) to serve as a
    // heat rejection sink for a lower temperature refrigeration system (secondary system). The condensing
    // temperature can be fixed or can be allowed to float according to the minimum required evaporating temperature
    // for other loads upon the primary system. For cases and walk-ins served by cascade condensers, energy associated
    // with hot gas defrost is reclaimed from the primary system.  The refrigeration load the cascade condenser
    // places upon the primary system is the sum of all case and walk-in loads served by the secondary system plus
    // the sum of the secondary loop's compressor power. The same name used to identify the condenser in the
    // secondary loop is used to identify the cascade load on the primary system.

    // Detailed transcritical CO2 refrigeration systems model each compressor individually using the manufacturer's
    // performance data. A collection of CO2 compressor performance curves has been added in the datasets library.
    // The curves produce the refrigeration capacity and power consumption. The capacity required is based on the sum
    // of the case and walk-in loads and the compressors are dispatched to meet this load according to the order
    // prescribed in the compressor list input object. Currently, an air-cooled gas cooler is modeled, and
    // manufacturer's rating data is input to describe the performance and to determine the required fan power
    // requirements. The gas cooler fans can be described as single-speed, two-speed, or variable speed. During
    // transcritical operation, the optimal gas cooler pressure, which maximizes the system's COP, is determined as
    // a function of the ambient air temperature. During subcritical operation, the condensing pressure is allowed to
    // float with ambient temperature in order to achieve maximum performance.

    // This module was designed to be accessed once for each time step.  It uses several accumulating variables
    //  to carry unmet loads from one time step to the next (cases/walk-ins and compressors.  Also, it meets
    //  heat reclaim needs with the loads from the previous time step (because they are unknown for the current
    //  zone time step).  However, the loads time step may be repeated, such as when a demand manager is used.
    //  For that purpose, the values for these accumulating variables are saved at the start of each time step
    //  and reset whenever the time step is repeated.  (see the init subroutine.)
    // This correction is also applied when working on the system time step for coil-type loads by setting the saved values
    //  at the start of each system time step to the value at the end of the previous time step. They are reset
    //  to that value at each sys time step iteration. (see InitRefrigeration)

    // REFERENCES:
    // Specific references are provided for the equipment simulation subroutines below.

    // True at the start of each time step, False after first subtime step of time step
    // includes DataGlobals::CurrentTime, in fractional hours, from start of day. Uses Loads time step.
    // includes DataGlobals::NumOfZones

    static std::string const BlankString;

    // Anti-sweat heater control type
    int const ASNone(0);
    int const ASConstant(1);
    int const ASLinear(2);
    int const ASDewPoint(3);
    int const ASHeatBalance(4);
    // Refrigerated display case defrost type
    int const DefNone(0);
    int const DefOffCycle(1);
    int const DefHotFluid(2);
    int const DefHotFluidTerm(4);
    int const DefElectric(5);
    int const DefElectricOnDemand(6);
    int const DefElectricTerm(7);

    // Refrigerated display case rack heat rejection location
    int const LocationOutdoors(1);
    int const LocationZone(2);
    // Air- and evap-cooled condenser fan speed control types
    int const FanVariableSpeed(1);
    int const FanConstantSpeedLinear(2);
    int const FanTwoSpeed(3);
    int const FanConstantSpeed(4);
    // Water-cooled condenser loop flow type
    int const VariableFlow(1);
    int const ConstantFlow(2);
    // Condenser evap cooling water supply
    int const WaterSupplyFromMains(101);
    int const WaterSupplyFromTank(102);
    // Cascade condenser temperature control types
    int const CascadeTempSet(1);
    int const CascadeTempFloat(2);
    // Refrigerated display case energy equation form
    int const None(0);
    int const CaseTemperatureMethod(1);
    int const RHCubic(2);
    int const DPCubic(3);
    // Secondary loop parameters
    int const SecFluidTypeAlwaysLiquid(1);
    int const SecFluidTypePhaseChange(2);
    int const SecPumpControlConstant(1);
    int const SecPumpControlVariable(2);
    // Walk In Cooler Defrost type
    int const WalkInDefrostFluid(1);
    int const WalkInDefrostElec(2);
    int const WalkInDefrostNone(3);
    int const WalkInDefrostOffCycle(4);
    // Walk In Cooler Defrost Control type
    int const DefrostControlSched(1);
    int const DefrostContTempTerm(2);
    // Walk In Cooler Stock Door Protection types
    int const WIStockDoorNone(1);
    int const WIStockDoorAirCurtain(2);
    int const WIStockDoorStripCurtain(3);
    // Subcooler type
    int const LiquidSuction(1);
    int const Mechanical(2);
    // Compressor suction pressure control
    int const FloatSuctionTemperature(1);
    int const ConstantSuctionTemperature(2);
    // Compressor rating types
    int const RatedSuperheat(1);
    int const RatedReturnGasTemperature(2);
    int const RatedSubcooling(1);
    int const RatedLiquidTemperature(2);
    // Warehouse coil Defrost type
    int const DefrostFluid(1);
    int const DefrostElec(2);
    int const DefrostNone(3);
    int const DefrostOffCycle(4);

    int const RatedCapacityTotal(1);
    int const EuropeanSC1Std(2);
    int const EuropeanSC1Nom(3);
    int const EuropeanSC2Std(4);
    int const EuropeanSC2Nom(5);
    int const EuropeanSC3Std(6);
    int const EuropeanSC3Nom(7);
    int const EuropeanSC4Std(8);
    int const EuropeanSC4Nom(9);
    int const EuropeanSC5Std(10);
    int const EuropeanSC5Nom(11);
    int const UnitLoadFactorSens(12);
    int const SHR60(1);
    int const QuadraticSHR(2);
    int const European(3);
    int const TabularRH_DT1_TRoom(4);
    int const Ceiling(1);
    int const Middle(2);
    int const Floor(3);
    int const DetailedSystem(1);
    int const SecondarySystem(2);

    // Following constant approp for R22, future may make f(refrigerant)
    Real64 const CaseSuperheat(4.0);       // case superheat used to control thermal expansion valve, ASHRAE 2006 p 44.6 (C)
    Real64 const TransCaseSuperheat(10.0); // case superheat for transcritical CO2 systems (C)
    // Next two constants used to autosize evap condenser
    Real64 const CondPumpRatePower(0.004266);  // evap condenser pump rated, Wpump/Wcapacity (15 W/ton)
    Real64 const AirVolRateEvapCond(0.000144); // evap cond air flow rate for autosize, equiv 850 cfm/ton (m3/W-s)
    Real64 const EvapCutOutTdb(4.0);           // shut off evap water flow if outdoor drybulb < evapcutOutTdb (C)
    // Miscellaneous constants
    Real64 const MyLargeNumber(1.0e9);
    Real64 const MySmallNumber(1.0e-9);
    Real64 const Rair(0.3169);                  // Air resistance used with Heat Balance anti-sweat (AS) heater
    Real64 const IceMeltEnthalpy(335000.0);     // heat of fusion of water J/kg
    Real64 const TempTooHotToFrost(5.0);        // C, used to check for frosting conditions on evaporator coils
    Real64 const IcetoVaporEnthalpy(2833000.0); // J/kg to freeze water vapor to ice
    Real64 const SpecificHeatIce(2000.0);       // in the likely range (2040 at 0C and 1950 at -20C) (J/kg-C)
    Real64 const CondAirVolExponentDry(1.58);   // exponent for forced air over a cylinder, = 1/.633
    // per ASHRAE 2005 (page 3.15)
    Real64 const CondAirVolExponentEvap(1.32); // exponent for evap condenser air vol flow, = 1/.76
    // per Manske, 1999
    Real64 const EvaporatorAirVolExponent(1.54); // exponent for evapaporator air vol flow, = 1/.65
    // per Manske, 1999, page 35

    Real64 const FanHalfSpeedRatio(0.1768); // = 1/(2**2.5) for power step for two speed fan
    Real64 const CapFac60Percent(0.60);     // = 60%, load served by half power 2-speed fan

    Array1D<Real64> const EuropeanWetCoilFactor(5, {1.35, 1.15, 1.05, 1.01, 1.0});
    Array1D<Real64> const EuropeanAirInletTemp(5, {10.0, 0.0, -18.0, -25.0, -34.0});

    int NumSimulationCondAir(0);            // Number of air-cooled condensers in simulation
    int NumSimulationCondEvap(0);           // Number of evaporative condensers in simulation
    int NumSimulationCondWater(0);          // Number of water-cooled condensers in simulation
    int NumSimulationCascadeCondensers(0);  // Total number of Cascade condensers in IDF
    int NumSimulationGasCooler(0);          // Number of gas coolers in simulation
    int NumSimulationSharedGasCoolers(0);   // Total number of gas coolers that serve more than one system
    int NumTransRefrigSystems(0);           // Total number of transcritical CO2 refrigeration systems
    int NumSimulationSharedCondensers(0);   // Total number of condensers that serve more than one system
    int NumSimulationCases(0);              // Number of refrigerated cases in simulation
    int NumSimulationCaseAndWalkInLists(0); // Total number of CaseAndWalkIn Lists in IDF
    int NumSimulationWalkIns(0);            // Number of walk in coolers in simulation
    int NumSimulationCompressors(0);        // Number of refrigeration compressors in simulation
    int NumSimulationSubcoolers(0);         // Number of refrigeration subcoolers in simulation
    int NumSimulationMechSubcoolers(0);     // Number of mechanical subcoolers in simulation
    int NumSimulationRefrigAirChillers(0);  // Number of individual Air Chillers/coils in simulation
    int NumSimulationSecondarySystems(0);   // Number of Secondary loops in simulation
    int NumSimulationTransferLoadLists(0);  // Number of Secondary Lists in simulation
    int NumUnusedRefrigCases(0);            // Number of refrigerated cases not connected to a rack or system
    int NumUnusedCoils(0);                  // Number of refrigeration air coils not connected to a rack or system
    int NumUnusedCondensers(0);             // Number of refrigeration condensers not connected to a system
    int NumUnusedGasCoolers(0);             // Number of refrigeration gas coolers not connected to a system
    int NumUnusedCompressors(0);            // Number of refrigeration compressors not connected to a system
    int NumUnusedSecondarys(0);             // Number of refrigeration secondarys not connected to a system
    bool MyReferPlantScanFlag(true);

    // Refrigerated case variables
    Real64 CaseRAFactor(0.0);         // Factor determining case credit allocation (e.g. % to zone or HVAC)
    Array1D_bool ShowStockingWarning; // Used for one-time warning message for possible case
    // input error regarding stocking

    // Refrigeration compressor rack variables
    Real64 TotalRackDeliveredCapacity(0.0); // Total capacity of all refrigerated cases attached to rack (W)
    Real64 TotalCompressorPower(0.0);       // Total compressor electric power (W)
    Real64 CompressorCOPactual(0.0);        // Compressor coefficient of performance at specific operating conditions (W/W)
    Real64 RackSenCreditToZone(0.0);        // Amount of condenser heat applied to zone load (W)
    Real64 RackSenCreditToHVAC(0.0);        // Amount of condenser heat applied to HVAC RA duct (W)

    // Refrigeration condenser variables (used for both racks and detailed systems)
    Real64 TotalCondenserFanPower(0.0);  // Total condenser fan electric power (W)
    Real64 TotalCondenserPumpPower(0.0); // Total condenser pump electric power (W)
    Real64 TotalCondenserHeat(0.0);      // Total condenser heat from compressor rack (W)
    Real64 TotalBasinHeatPower(0.0);     // Total condenser basin water heater power (W)
    Real64 TotalEvapWaterUseRate(0.0);   // Total condenser water use rate (m3/s)

    // Refrigeration system variables
    Array1D_bool ShowUnmetEnergyWarning; // Used for one-time warning message for possible
    // compressor input error regarding total system compressor capacity
    Array1D_bool ShowHiStageUnmetEnergyWarning; // Used for one-time warning message for possible
    // high-stage compressor input error regarding high-stage compressor capacity

    // Transcritical refrigeration system variables
    Array1D_bool ShowUnmetEnergyWarningTrans; // Used for one-time warning message for possible
    // compressor input error regarding total system compressor capacity

    // Refrigeration Secondary Loop variables
    Array1D_bool ShowUnmetSecondEnergyWarning; // Used for one-time warning message for possible
    // compressor input error regarding secondary loop heat exchanger capacity

    // Refrigeration Plant connections checks
    Array1D_bool CheckEquipNameRackWaterCondenser;
    Array1D_bool CheckEquipNameWaterCondenser;

    // Control variables
    Array1D_bool RefrigPresentInZone; // Used when translating rate to energy for reporting
    //  total refrigeration impact on a zone
    Array1D_bool CheckChillerSetName; // used when sim chiller set called form zone equip manager

    bool GetRefrigerationInputFlag(true); // Flag to show case input should be read
    bool HaveRefrigRacks(true);           // Is initialized as TRUE and remains true when
    // refrigerated racks exist in the input deck
    bool HaveDetailedRefrig(true); // Is initialized as TRUE and remains true when
    // detailed refrigeration systems exist in the input deck
    bool HaveDetailedTransRefrig(true); // Is initialized as TRUE and remains true when
    // detailed transcritical CO2 refrigeration systems exist in the input deck
    bool ManageRefrigeration(true); // Is initialized as TRUE and remains true when
    // refrigerated racks or detailed systems exist in the input deck
    bool UseSysTimeStep(false); // Flag is true IF working on a system that includes a coil cooling a controlled zone on the system time step,
    // All other refrigeration calculations for case and walkin systems done on the load time step
    bool HaveCasesOrWalkins(true); // Is initialized as TRUE and remains true when
    // refrigerated cases or walkins exist in the input deck
    bool HaveChillers(true); // Is initialized as TRUE and remains true when
    // chillers exist in the input deck

    // Object Data
    Array1D<RefrigCaseData> RefrigCase;
    Array1D<RefrigRackData> RefrigRack;
    Array1D<CaseRAFractionData> CaseRAFraction;
    Array1D<RefrigSystemData> System;
    Array1D<TransRefrigSystemData> TransSystem;
    Array1D<RefrigCondenserData> Condenser;
    std::unordered_map<std::string, std::string> UniqueCondenserNames;
    Array1D<RefrigCompressorData> Compressor;
    Array1D<RefrigGasCoolerData> GasCooler;
    Array1D<SubcoolerData> Subcooler;
    Array1D<CaseAndWalkInListDef> CaseAndWalkInList;
    Array1D<CompressorListDef> CompressorLists;
    Array1D<SecondaryLoopData> Secondary;
    Array1D<TransferLoadListDef> TransferLoadList;
    Array1D<WalkInData> WalkIn;
    Array1D<WarehouseCoilData> WarehouseCoil;
    Array1D<AirChillerSetData> AirChillerSet;
    Array1D<CoilCreditData> CoilSysCredit;
    Array1D<CaseWIZoneReportData> CaseWIZoneReport;

    bool MyOneTimeFlag(true); // flag to skip first pass on next begin environment flag
    bool InitRefrigerationMyBeginEnvrnFlag(true);
    bool InitRefrigerationPlantConnectionsMyBeginEnvrnFlag(true);
    bool FigureRefrigerationZoneGainsMyEnvrnFlag(true);

    void clear_state()
    {
        NumSimulationCondAir = 0;
        NumSimulationCondEvap = 0;
        NumSimulationCondWater = 0;
        NumSimulationCascadeCondensers = 0;
        NumSimulationGasCooler = 0;
        NumSimulationSharedGasCoolers = 0;
        NumTransRefrigSystems = 0;
        NumSimulationSharedCondensers = 0;
        NumSimulationCases = 0;
        NumSimulationCaseAndWalkInLists = 0;
        NumSimulationWalkIns = 0;
        NumSimulationCompressors = 0;
        NumSimulationSubcoolers = 0;
        NumSimulationMechSubcoolers = 0;
        NumSimulationRefrigAirChillers = 0;
        NumSimulationSecondarySystems = 0;
        NumSimulationTransferLoadLists = 0;
        NumUnusedRefrigCases = 0;
        NumUnusedCoils = 0;
        NumUnusedCondensers = 0;
        NumUnusedGasCoolers = 0;
        NumUnusedCompressors = 0;
        NumUnusedSecondarys = 0;
        MyReferPlantScanFlag = true;

        CaseRAFactor = 0.0;

        ShowStockingWarning.deallocate();

        TotalRackDeliveredCapacity = 0.0;
        TotalCompressorPower = 0.0;
        CompressorCOPactual = 0.0;
        RackSenCreditToZone = 0.0;
        RackSenCreditToHVAC = 0.0;

        TotalCondenserFanPower = 0.0;
        TotalCondenserPumpPower = 0.0;
        TotalCondenserHeat = 0.0;
        TotalBasinHeatPower = 0.0;
        TotalEvapWaterUseRate = 0.0;

        ShowUnmetEnergyWarning.deallocate();
        ShowHiStageUnmetEnergyWarning.deallocate();
        ShowUnmetEnergyWarningTrans.deallocate();
        ShowUnmetSecondEnergyWarning.deallocate();
        CheckEquipNameRackWaterCondenser.deallocate();
        CheckEquipNameWaterCondenser.deallocate();
        RefrigPresentInZone.deallocate();
        CheckChillerSetName.deallocate();

        GetRefrigerationInputFlag = true;
        HaveRefrigRacks = true;
        HaveDetailedRefrig = true;
        HaveDetailedTransRefrig = true;
        ManageRefrigeration = true;
        UseSysTimeStep = false;
        HaveCasesOrWalkins = true;
        HaveChillers = true;

        RefrigCase.deallocate();
        RefrigRack.deallocate();
        CaseRAFraction.deallocate();
        System.deallocate();
        TransSystem.deallocate();
        Condenser.deallocate();
        UniqueCondenserNames.clear();
        Compressor.deallocate();
        GasCooler.deallocate();
        Subcooler.deallocate();
        CaseAndWalkInList.deallocate();
        CompressorLists.deallocate();
        Secondary.deallocate();
        TransferLoadList.deallocate();
        WalkIn.deallocate();
        WarehouseCoil.deallocate();
        AirChillerSet.deallocate();
        CoilSysCredit.deallocate();
        CaseWIZoneReport.deallocate();

        MyOneTimeFlag = true;
        InitRefrigerationMyBeginEnvrnFlag = true;
        InitRefrigerationPlantConnectionsMyBeginEnvrnFlag = true;
        FigureRefrigerationZoneGainsMyEnvrnFlag = true;
    }

    void ManageRefrigeratedCaseRacks(EnergyPlusData &state)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   Oct/Nov 2004
        //       MODIFIED       Shirey, FSEC Dec 2004, Stovall, ORNL, May 2008
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine is called from HVACManager.cc, subroutine ManageHVAC to
        // manage refrigerated cases and associated compressor racks on zone time step
        // OR from SimAirChillerSet in this module on sys time step (Stovall 2011)

        // METHODOLOGY EMPLOYED:
        // Each compressor rack is modeled by first simulating the attached refrigeration loads. The
        // loads can include refrigerated cases, walk-in coolers, and secondary fluid chillers.  The sum
        // of the total heat transfer for all attached loads determines the load on the compressor rack.
        // For the refrigeration rack approach, a simple model for variation of COP with
        // condensing temperature is used to determine rack power and energy consumption.
        // For the detailed system approach, the compressors and condensers are modeled individually
        // using manufacturer's data and rated performance curves.
        // Inter-system heat transfer via subcoolers and cascade condensers can be accommodated.
        // Secondary refrigeration cycles are also available.

        if (!ManageRefrigeration) return;

        CheckRefrigerationInput(state);

        InitRefrigeration();

        // ManageRefrigeratedCaseRacks is called on each zone time step.
        //  However, if have chillers, ManageRefrigeration will be .TRUE. and will
        //  need to bounce back. (InitRefrig has to be called anyway to zero values at zone time step.)
        //  Therefore...
        if ((!HaveCasesOrWalkins) && (!UseSysTimeStep)) {
            // Zero requests for cooling water from plant or tank
            ZeroHVACValues();
            return;
        }
        // Following case should never occur, but just for completeness:
        if ((!HaveChillers) && (UseSysTimeStep)) return;

        // Refrigerated cases are not simulated the first time through, replicate this on beginning of next environment
        if (DataGlobals::BeginEnvrnFlag && MyOneTimeFlag) {
            MyOneTimeFlag = false;
            return;
        }
        if (!DataGlobals::BeginEnvrnFlag) MyOneTimeFlag = true;

        if (HaveRefrigRacks) {
            for (int RackNum = 1; RackNum <= DataHeatBalance::NumRefrigeratedRacks; ++RackNum) {
                RefrigRack(RackNum).CalcRackSystem();
                RefrigRack(RackNum).ReportRackSystem(RackNum);
            }
        }

        if (HaveDetailedRefrig) SimulateDetailedRefrigerationSystems();
        if (HaveDetailedTransRefrig) SimulateDetailedTransRefrigSystems();
    }

    void GetRefrigerationInput(EnergyPlusData &state)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   Oct/Nov 2004
        //       MODIFIED       Shirey, FSEC Dec 2004; Hudson, ORNL Feb 2007, July 2007
        //       MODIFIED       Stovall, ORNL April 2008, Assisted by Hugh Henderson
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // GetObjectItem is called to read refrigerated case, rack, compressor, and condenser information
        // Lists of cases and compressors are then correlated to the appropriate system.
        // The nominal ratings of all components are then compared and a warning is printed if the system is not balanced

        // METHODOLOGY EMPLOYED:
        // GetObjectItem is called to read refrigerated case information

        static std::string const TrackMessage("from refrigerated case");
        static std::string const RoutineName("GetRefrigerationInput: ");
        static std::string const TrackMessageAlt("GetInput in RefrigeratedCase");
        static std::string const RoutineNameNoColon("GetRefrigerationInput");

        int const AlwaysOn(-1); // -1 pointer sent to schedule manager returns a value of 1.0
        //     input in both watts and flow rate
        int const NumWIAlphaFieldsBeforeZoneInput(9);   // Used to cycle through zones on input for walk in coolers
        int const NumWIAlphaFieldsPerZone(4);           // Used to cycle through zones on input for walk in coolers
        int const NumWINumberFieldsBeforeZoneInput(12); // Used to cycle through zones on input for walk in coolers
        int const NumWINumberFieldsPerZone(8);          // Used to cycle through zones on input for walk in coolers
        Real64 const CondARI460DelT(16.7);              // Rated sat cond temp - dry bulb air T for air-cooled Condensers, ARI460
        Real64 const CondARI460Tcond(51.7);             // Rated sat cond temp for air-cooled cond, ARI 460
        Real64 const CondARI490DelT(15.0);              // Rated sat cond temp - wet bulb air T for evap-cooled Cond w R22, ARI490
        Real64 const CondARI490Tcond(40.6);             // Rated sat cond temp for evap-cooled cond with R22, ARI 490
        Real64 const DelEvapTDefault(5.0);              // default difference between case T and evap T (C)
        Real64 const HoursPerDay(24.0);
        Real64 const SecondsPerHour(3600.0);
        Real64 const DefaultCascadeCondApproach(3.0); // Cascade condenser approach temperature difference (deltaC)
        Real64 const DefaultCircRate(2.5);            // Phase change liquid overfeed circulating rate (ASHRAE definition)
        Real64 const DefaultWISurfaceUValue(0.3154); // equiv R18 in Archaic American units (W/m2-delta T)
        Real64 const DefaultWIUValueGlassDr(1.136);  // equiv R5 in Archaic American units (W/m2-delta T)
        Real64 const DefaultWIUValueStockDr(0.3785); // equiv R15 in Archaic American units (W/m2-delta T)
        Real64 const DefaultWIHeightGlassDr(1.5);    // glass door height in walk-in cooler (m)
        Real64 const DefaultWIHeightStockDr(3.0);    // stock door height in walk-in cooler (m)
        Real64 const PumpImpellerEfficiency(0.78);   // same as used in pump auto-sizing, dimensionless
        Real64 const PumpMotorEfficiency(0.85);      // suggested as average value in ITT/Gould pump references,

        Array1D_string Alphas;                  // Alpha items for object
        Array1D_string cAlphaFieldNames;        // Alpha field names (from input processor)
        Array1D_string cNumericFieldNames;      // Numeric field names (from input processor)
        std::string CurrentModuleObject;   // Object type for getting and error messages

        Array1D_bool lAlphaBlanks;      // Logic array, alpha input blank = .TRUE.
        Array1D_bool lNumericBlanks;    // Logic array, numeric input blank = .TRUE.
        bool ErrorsFound(false);     // Set to true if errors in input, fatal at end of routine

        int AlphaNum(0);                       // Used to cycle through input
        int IOStatus(0);                       // Used in GetObjectItem
        int MaxNumAlphasRack(0);               // Maximum number of alphas for rack object
        int MaxNumAlphasAirChiller(0);         // Maximum number of alphas for air chiller
        int MaxNumAlphasAll(0);                // Maximum number of alphas for all objects
        int MaxNumAlphasSys(0);                // Maximum number of alphas for system object
        int MaxNumAlphasTransSys(0);           // Maximum number of alphas for transcritical system object
        int MaxNumAlphasChillerSet(0);         // Maximum number of alphas for chiller set
        int MaxNumAlphasConda(0);              // Maximum number of alphas for air-cooled condenser object
        int MaxNumAlphasConde(0);              // Maximum number of alphas for evap-cooled condenser object
        int MaxNumAlphasCondw(0);              // Maximum number of alphas for water-cooled condenser object
        int MaxNumAlphasGasCoolera(0);         // Maximum number of alphas for air-cooled gas cooler object
        int MaxNumAlphasComp(0);               // Maximum number of alphas for compressor object
        int MaxNumAlphasCompressorList(0);     // Maximum number of alphas for compressor list objects
        int MaxNumAlphasCase(0);               // Maximum number of alphas for case object
        int MaxNumAlphasCaseAndWalkInList(0);  // Maximum number of alphas in CaseAndWalkInList
        int MaxNumAlphasWalkIn(0);             // Maximum number of alphas for walkin object
        int MaxNumAlphasSecond(0);             // Maximum number of alphas for air chiller object
        int MaxNumNumbersAirChiller(0);        // Maximum number of numbers for air chiller object
        int MaxNumNumbersSecond(0);            // Maximum number of numbers for secondary system object
        int MaxNumNumbersWalkIn(0);            // Maximum number of numbers for walkin object
        int MaxNumNumbersCase(0);              // Maximum number of numbers for case object
        int MaxNumNumbersCaseAndWalkInList(0); // Maximum number of numbers in CaseAndWalkInList
        int MaxNumNumbersRack(0);              // Maximum number of numbers for rack object
        int MaxNumNumbersAll(0);               // Maximum number of numeric inputs for all objects
        int MaxNumNumbersSys(0);               // Maximum number of numbers for system object
        int MaxNumNumbersTransSys(0);          // Maximum number of numbers for transcritical system object
        int MaxNumNumbersChillerSet(0);        // Maximum number of numbers for chiller set object
        int MaxNumNumbersConda(0);             // Maximum number of numbers for air-cooled condenser object
        int MaxNumNumbersConde(0);             // Maximum number of numbers for evap-cooled condenser object
        int MaxNumNumbersCondw(0);             // Maximum number of numbers for water-cooled condenser object
        int MaxNumNumbersGasCoolera(0);        // Maximum number of numbers for air-cooled gas cooler object
        int MaxNumNumbersComp(0);              // Maximum number of numbers for compressor object
        int MaxNumNumbersCompressorList(0);    // Maximum number of numbers
        int MaxNumArgs(0);                     // Max number of alphas and numbers (arguments) for rack object
        int NumAlphas(0);                      // Number of Alphas for each GetObjectItem call
        int NumCases(0);                       // Number of refrigerated cases for single system
        int NumNum(0);                         // Used to cycle through input
        int NumNumbers(0);                     // Number of Numbers for each GetObjectItem call
        int NumDisplayCases(0);                // Counter for refrigerated cases in GetInput do loop
        int NumWalkIns(0);                     // Number of walk ins
        int RefrigSysNum(0);
        int RefrigIndex(0);                // Index used in fluid property routines
        Real64 DeltaHPhaseChange(0.0);     // Secondary loop enthalpy change in condenser w overfeed system (J/g)
        Real64 DelTempMin(0.0);            // min temperature for heat rej curve for air cooled condenser (C)
        Real64 DelTempMax(0.0);            // max temperature for heat rej curve for air cooled condenser (C)
        Real64 DensityBrineRated(0.0);     // density of circ fluid in secondary loop
        Real64 DensityPhaseChange(0.0);    // Secondary loop density at condensing temperature w overfeed system (g/m3)
        Real64 NominalTotalCompCapLP(0.0); // Total of nominal low pressure compressor capacities, used for rough input check (W) (Transcritical CO2)
        Real64 NominalTotalCompCapHP(0.0);
        Array1D<Real64> Numbers;                  // Numeric items for object
        Array2D<Real64> DayValues;                // Array of schedule values

        NumSimulationCascadeCondensers = inputProcessor->getNumObjectsFound("Refrigeration:Condenser:Cascade");
        NumSimulationCases = inputProcessor->getNumObjectsFound("Refrigeration:Case");
        NumSimulationCaseAndWalkInLists = inputProcessor->getNumObjectsFound("Refrigeration:CaseAndWalkInList");
        DataHeatBalance::NumRefrigeratedRacks = inputProcessor->getNumObjectsFound("Refrigeration:CompressorRack");
        NumSimulationSecondarySystems = inputProcessor->getNumObjectsFound("Refrigeration:SecondarySystem");
        NumSimulationTransferLoadLists = inputProcessor->getNumObjectsFound("Refrigeration:TransferLoadList");
        NumSimulationWalkIns = inputProcessor->getNumObjectsFound("Refrigeration:WalkIn");
        DataHeatBalance::NumRefrigSystems = inputProcessor->getNumObjectsFound("Refrigeration:System");
        NumTransRefrigSystems = inputProcessor->getNumObjectsFound("Refrigeration:TranscriticalSystem");
        NumSimulationCondAir = inputProcessor->getNumObjectsFound("Refrigeration:Condenser:AirCooled");
        NumSimulationCondEvap = inputProcessor->getNumObjectsFound("Refrigeration:Condenser:EvaporativeCooled");
        NumSimulationCondWater = inputProcessor->getNumObjectsFound("Refrigeration:Condenser:WaterCooled");
        NumSimulationGasCooler = inputProcessor->getNumObjectsFound("Refrigeration:GasCooler:AirCooled");
        DataHeatBalance::NumRefrigCondensers = NumSimulationCondAir + NumSimulationCondEvap + NumSimulationCondWater + NumSimulationCascadeCondensers;
        NumSimulationCompressors = inputProcessor->getNumObjectsFound("Refrigeration:Compressor");
        NumSimulationSubcoolers = inputProcessor->getNumObjectsFound("Refrigeration:Subcooler");
        int NumCompressorLists = inputProcessor->getNumObjectsFound("Refrigeration:CompressorList");
        DataHeatBalance::NumRefrigChillerSets = inputProcessor->getNumObjectsFound("ZoneHVAC:RefrigerationChillerSet");
        NumSimulationRefrigAirChillers = inputProcessor->getNumObjectsFound("Refrigeration:AirChiller");

        // Set flags used later to avoid unnecessary steps.
        if (DataHeatBalance::NumRefrigeratedRacks == 0) HaveRefrigRacks = false;
        if (DataHeatBalance::NumRefrigSystems == 0) HaveDetailedRefrig = false;
        if (NumTransRefrigSystems == 0) HaveDetailedTransRefrig = false;
        if (NumSimulationCases == 0 && NumSimulationWalkIns == 0) HaveCasesOrWalkins = false;
        if (NumSimulationRefrigAirChillers == 0) HaveChillers = false;

        if (DataHeatBalance::NumRefrigeratedRacks > 0) {
            RefrigRack.allocate(DataHeatBalance::NumRefrigeratedRacks);
            DataHeatBalance::HeatReclaimRefrigeratedRack.allocate(DataHeatBalance::NumRefrigeratedRacks);
        }
        if (DataHeatBalance::NumRefrigSystems > 0) {
            System.allocate(DataHeatBalance::NumRefrigSystems);
            ShowUnmetEnergyWarning.allocate(DataHeatBalance::NumRefrigSystems);
            ShowHiStageUnmetEnergyWarning.allocate(DataHeatBalance::NumRefrigSystems);
            ShowUnmetEnergyWarning = true;
            ShowHiStageUnmetEnergyWarning = true;
        }
        if (NumTransRefrigSystems > 0) {
            TransSystem.allocate(NumTransRefrigSystems);
            ShowUnmetEnergyWarningTrans.dimension(NumTransRefrigSystems, true);
        }
        if (DataHeatBalance::NumRefrigChillerSets > 0) AirChillerSet.allocate(DataHeatBalance::NumRefrigChillerSets);
        if (DataHeatBalance::NumRefrigCondensers > 0) {
            DataHeatBalance::HeatReclaimRefrigCondenser.allocate(DataHeatBalance::NumRefrigCondensers);
            Condenser.allocate(DataHeatBalance::NumRefrigCondensers);
            UniqueCondenserNames.reserve(static_cast<unsigned>(DataHeatBalance::NumRefrigCondensers));
        }
        if (NumSimulationGasCooler > 0) {
            GasCooler.allocate(NumSimulationGasCooler);
        }
        if (NumSimulationCases > 0) {
            CaseRAFraction.allocate(DataGlobals::NumOfZones);
            RefrigCase.allocate(NumSimulationCases);
            ShowStockingWarning.dimension(NumSimulationCases, true);
        }
        if (NumSimulationWalkIns > 0) {
            WalkIn.allocate(NumSimulationWalkIns);
        }
        if ((NumSimulationWalkIns > 0) || (NumSimulationCases > 0)) {
            CaseWIZoneReport.allocate(DataGlobals::NumOfZones);
        } else {
            UseSysTimeStep = true;
            // needed to avoid accessing unallocated caseWIZoneReport on early call to SumZones
        }
        if (NumSimulationSecondarySystems > 0) {
            Secondary.allocate(NumSimulationSecondarySystems);
            ShowUnmetSecondEnergyWarning.dimension(NumSimulationSecondarySystems, true);
        }
        if (NumSimulationRefrigAirChillers > 0) {
            WarehouseCoil.allocate(NumSimulationRefrigAirChillers);
            CoilSysCredit.allocate(DataGlobals::NumOfZones);
        }
        if (NumSimulationCompressors > 0) Compressor.allocate(NumSimulationCompressors);
        if (NumSimulationSubcoolers > 0) Subcooler.allocate(NumSimulationSubcoolers);
        if (NumSimulationCaseAndWalkInLists > 0) CaseAndWalkInList.allocate(NumSimulationCaseAndWalkInLists);
        if (NumCompressorLists > 0) CompressorLists.allocate(NumCompressorLists);
        if (NumSimulationTransferLoadLists > 0) TransferLoadList.allocate(NumSimulationTransferLoadLists);

        DayValues.allocate(DataGlobals::NumOfTimeStepInHour, 24);
        RefrigPresentInZone.dimension(DataGlobals::NumOfZones, false);

        inputProcessor->getObjectDefMaxArgs("Refrigeration:Case", MaxNumArgs, MaxNumAlphasCase, MaxNumNumbersCase);
        inputProcessor->getObjectDefMaxArgs(
            "Refrigeration:CaseAndWalkInList", MaxNumArgs, MaxNumAlphasCaseAndWalkInList, MaxNumNumbersCaseAndWalkInList);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:CompressorRack", MaxNumArgs, MaxNumAlphasRack, MaxNumNumbersRack);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:System", MaxNumArgs, MaxNumAlphasSys, MaxNumNumbersSys);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:TranscriticalSystem", MaxNumArgs, MaxNumAlphasTransSys, MaxNumNumbersTransSys);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:Condenser:AirCooled", MaxNumArgs, MaxNumAlphasConda, MaxNumNumbersConda);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:Condenser:EvaporativeCooled", MaxNumArgs, MaxNumAlphasConde, MaxNumNumbersConde);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:Condenser:WaterCooled", MaxNumArgs, MaxNumAlphasCondw, MaxNumNumbersCondw);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:GasCooler:AirCooled", MaxNumArgs, MaxNumAlphasGasCoolera, MaxNumNumbersGasCoolera);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:Compressor", MaxNumArgs, MaxNumAlphasComp, MaxNumNumbersComp);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:CompressorList", MaxNumArgs, MaxNumAlphasCompressorList, MaxNumNumbersCompressorList);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:WalkIn", MaxNumArgs, MaxNumAlphasWalkIn, MaxNumNumbersWalkIn);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:SecondarySystem", MaxNumArgs, MaxNumAlphasSecond, MaxNumNumbersSecond);
        inputProcessor->getObjectDefMaxArgs("ZoneHVAC:RefrigerationChillerSet", MaxNumArgs, MaxNumAlphasChillerSet, MaxNumNumbersChillerSet);
        inputProcessor->getObjectDefMaxArgs("Refrigeration:AirChiller", MaxNumArgs, MaxNumAlphasAirChiller, MaxNumNumbersAirChiller);

        MaxNumAlphasAll = max(MaxNumAlphasCase,
                              MaxNumAlphasCaseAndWalkInList,
                              MaxNumAlphasRack,
                              MaxNumAlphasSys,
                              MaxNumAlphasTransSys,
                              MaxNumAlphasConda,
                              MaxNumAlphasConde,
                              MaxNumAlphasCondw,
                              MaxNumAlphasGasCoolera,
                              MaxNumAlphasComp,
                              MaxNumAlphasCompressorList,
                              MaxNumAlphasSecond,
                              MaxNumAlphasWalkIn,
                              MaxNumAlphasChillerSet,
                              MaxNumAlphasAirChiller);
        MaxNumNumbersAll = max(MaxNumNumbersCase,
                               MaxNumNumbersCaseAndWalkInList,
                               MaxNumNumbersRack,
                               MaxNumNumbersSys,
                               MaxNumNumbersTransSys,
                               MaxNumNumbersConda,
                               MaxNumNumbersConde,
                               MaxNumNumbersCondw,
                               MaxNumNumbersGasCoolera,
                               MaxNumNumbersComp,
                               MaxNumNumbersCompressorList,
                               MaxNumNumbersSecond,
                               MaxNumNumbersWalkIn,
                               MaxNumNumbersChillerSet,
                               MaxNumNumbersAirChiller);

        Alphas.allocate(MaxNumAlphasAll);
        Numbers.dimension(MaxNumNumbersAll, 0.0);
        cAlphaFieldNames.allocate(MaxNumAlphasAll);
        cNumericFieldNames.allocate(MaxNumNumbersAll);
        lAlphaBlanks.dimension(MaxNumAlphasAll, true);
        lNumericBlanks.dimension(MaxNumNumbersAll, true);
        // bbb stovall note for future - for all curve entries, see if need fail on type or if can allow table input
        if (NumSimulationCases > 0) {
            CurrentModuleObject = "Refrigeration:Case";
            for (int CaseNum = 1; CaseNum <= NumSimulationCases; ++CaseNum) {
                inputProcessor->getObjectItem(CurrentModuleObject,
                                              CaseNum,
                                              Alphas,
                                              NumAlphas,
                                              Numbers,
                                              NumNumbers,
                                              IOStatus,
                                              lNumericBlanks,
                                              lAlphaBlanks,
                                              cAlphaFieldNames,
                                              cNumericFieldNames);

                ++NumDisplayCases;

                AlphaNum = 1;
                UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);
                RefrigCase(CaseNum).Name = Alphas(AlphaNum);

                AlphaNum = 2;
                if (!lAlphaBlanks(AlphaNum)) {
                    RefrigCase(CaseNum).SchedPtr = ScheduleManager::GetScheduleIndex(Alphas(AlphaNum)); // convert schedule name to pointer
                    if (RefrigCase(CaseNum).SchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " +
                                        cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                        ErrorsFound = true;
                    }    // ptr == 0
                } else { // no schedule specified
                    RefrigCase(CaseNum).SchedPtr = AlwaysOn;
                } // not blank

                //   check availability schedule for values between 0 and 1
                if (RefrigCase(CaseNum).SchedPtr > 0) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(RefrigCase(CaseNum).SchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\"");
                        ShowContinueError("Error found in " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }

                // Get the Zone node number from the zone name entered by the user
                RefrigCase(CaseNum).ZoneName = Alphas(3);
                RefrigCase(CaseNum).ActualZoneNum = UtilityRoutines::FindItemInList(Alphas(3), DataHeatBalance::Zone);

                if (RefrigCase(CaseNum).ActualZoneNum == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " + cAlphaFieldNames(3) +
                                    " not valid: " + Alphas(3));
                    ErrorsFound = true;
                } else {
                    RefrigPresentInZone(RefrigCase(CaseNum).ActualZoneNum) = true;
                }

                RefrigCase(CaseNum).ZoneNodeNum = DataZoneEquipment::GetSystemNodeNumberForZone(state, RefrigCase(CaseNum).ZoneName);

                RefrigCase(CaseNum).RatedAmbientTemp = Numbers(1);
                if (Numbers(1) <= 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(1) +
                                    " must be greater than 0 C");
                    ErrorsFound = true;
                }

                RefrigCase(CaseNum).RatedAmbientRH = Numbers(2);
                if (Numbers(2) <= 0.0 || Numbers(2) >= 100.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(2) +
                                    " must be greater than 0% and less than 100%");
                    ErrorsFound = true;
                }
                RefrigCase(CaseNum).RatedAmbientDewPoint = Psychrometrics::PsyTdpFnWPb(
                    Psychrometrics::PsyWFnTdbRhPb(
                        RefrigCase(CaseNum).RatedAmbientTemp, (RefrigCase(CaseNum).RatedAmbientRH / 100.0), DataEnvironment::StdBaroPress),
                    DataEnvironment::StdBaroPress);

                RefrigCase(CaseNum).RateTotCapPerLength = Numbers(3);
                if (Numbers(3) <= 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(3) +
                                    " must be greater than 0 W/m");
                    ErrorsFound = true;
                }

                RefrigCase(CaseNum).RatedLHR = Numbers(4);
                if (Numbers(4) < 0.0 || Numbers(4) > 1.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(4) +
                                    " must be >= 0 and <= 1");
                    ErrorsFound = true;
                }

                RefrigCase(CaseNum).RatedRTF = Numbers(5);
                if (Numbers(5) <= 0.0 || Numbers(5) > 1.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(5) +
                                    " must be > 0 and <= to 1");
                    ErrorsFound = true;
                }

                RefrigCase(CaseNum).Length = Numbers(6);
                if (Numbers(6) <= 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(6) +
                                    " must be greater than 0 m");
                    ErrorsFound = true;
                }

                RefrigCase(CaseNum).Temperature = Numbers(7);
                if (RefrigCase(CaseNum).Temperature >= RefrigCase(CaseNum).RatedAmbientTemp) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(7) +
                                    " must be below " + cNumericFieldNames(1));
                    ErrorsFound = true;
                }

                if (UtilityRoutines::SameString(Alphas(4), "CaseTemperatureMethod")) {
                    RefrigCase(CaseNum).LatentEnergyCurveType = CaseTemperatureMethod;
                } else if (UtilityRoutines::SameString(Alphas(4), "RelativeHumidityMethod")) {
                    RefrigCase(CaseNum).LatentEnergyCurveType = RHCubic;
                } else if (UtilityRoutines::SameString(Alphas(4), "DewpointMethod")) {
                    RefrigCase(CaseNum).LatentEnergyCurveType = DPCubic;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " + cAlphaFieldNames(4) +
                                    "=\"" + Alphas(4) + "\".");
                    ErrorsFound = true;
                }

                RefrigCase(CaseNum).LatCapCurvePtr = CurveManager::GetCurveIndex(Alphas(5)); // convert curve name to number
                if (RefrigCase(CaseNum).LatCapCurvePtr == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " + cAlphaFieldNames(5) +
                                    " not found:" + Alphas(5));
                    ErrorsFound = true;
                }

                ErrorsFound |= CurveManager::CheckCurveDims(RefrigCase(CaseNum).LatCapCurvePtr, // Curve index
                    {1},                            // Valid dimensions
                    RoutineName,                    // Routine name
                    CurrentModuleObject,            // Object Type
                    RefrigCase(CaseNum).Name,   // Object Name
                    cAlphaFieldNames(5));               // Field Name

                NumNum = 8;
                if (!lNumericBlanks(NumNum)) {
                    RefrigCase(CaseNum).STDFanPower = Numbers(NumNum);
                    if (Numbers(NumNum) < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                        " must be greater than or equal to 0 W/m");
                        ErrorsFound = true;
                    }
                } else { // blank use default of 75 W/m
                    RefrigCase(CaseNum).STDFanPower = 75.0;
                } // blank input

                NumNum = 9;
                if (!lNumericBlanks(NumNum)) {
                    RefrigCase(CaseNum).OperatingFanPower = Numbers(NumNum);
                    if (Numbers(NumNum) < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                        " must be greater than or equal to 0 W/m");
                        ErrorsFound = true;
                    }
                } else { // if blank set = to std fan power
                    RefrigCase(CaseNum).OperatingFanPower = RefrigCase(CaseNum).STDFanPower;
                } // if blank

                NumNum = 10;
                if (!lNumericBlanks(NumNum)) {
                    RefrigCase(CaseNum).RatedLightingPower = Numbers(NumNum);
                    if (Numbers(NumNum) < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                        " must be greater than or equal to 0 W/m");
                        ErrorsFound = true;
                    }
                } else { // blank input - use default of 90 W/m
                    RefrigCase(CaseNum).RatedLightingPower = 90.0;
                } // blank input

                NumNum = 11;
                if (!lNumericBlanks(NumNum)) {
                    RefrigCase(CaseNum).LightingPower = Numbers(NumNum);
                    if (Numbers(NumNum) < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                        " must be greater than or equal to 0 W/m");
                        ErrorsFound = true;
                    }
                } else { // blank input so set lighting power equal to rated/std lighting power
                    RefrigCase(CaseNum).LightingPower = RefrigCase(CaseNum).RatedLightingPower;
                } // blank input

                if (!lAlphaBlanks(6)) {
                    RefrigCase(CaseNum).LightingSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(6)); // convert schedule name to pointer
                    if (RefrigCase(CaseNum).LightingSchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " + cAlphaFieldNames(6) +
                                        " not found: " + Alphas(6));
                        ErrorsFound = true;
                    }    // ptr == 0
                } else { // no schedule specified
                    RefrigCase(CaseNum).LightingSchedPtr = AlwaysOn;
                } // not blank

                //   check lighting schedule for values between 0 and 1
                if (RefrigCase(CaseNum).LightingSchedPtr > 0) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(RefrigCase(CaseNum).LightingSchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\"");
                        ShowContinueError("Error found in " + cAlphaFieldNames(6) + " = " + Alphas(6));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }

                NumNum = 12;
                RefrigCase(CaseNum).LightingFractionToCase = 1.0; // default value
                if (!lNumericBlanks(NumNum)) {
                    RefrigCase(CaseNum).LightingFractionToCase = Numbers(NumNum);
                } // blank input lighting fraction to case
                //   check lighting fraction to case input
                if (RefrigCase(CaseNum).LightingFractionToCase < 0.0 || RefrigCase(CaseNum).LightingFractionToCase > 1.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " has a value outside the valid range");
                    ShowContinueError("  Minimum should be >= 0.0 and Maximum should be <= 1.0");
                    ErrorsFound = true;
                }

                NumNum = 13;
                RefrigCase(CaseNum).AntiSweatPower = Numbers(NumNum);
                if (Numbers(NumNum) < 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be greater than or equal to 0 W/m");
                    ErrorsFound = true;
                }

                NumNum = 14;
                RefrigCase(CaseNum).MinimumASPower = Numbers(NumNum);
                if (Numbers(NumNum) < 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be greater than or equal to 0 W/m");
                    ErrorsFound = true;
                }

                if (UtilityRoutines::SameString(Alphas(7), "None")) {
                    RefrigCase(CaseNum).AntiSweatControlType = ASNone;
                    RefrigCase(CaseNum).AntiSweatPower = 0.0;
                } else if (UtilityRoutines::SameString(Alphas(7), "Constant")) {
                    RefrigCase(CaseNum).AntiSweatControlType = ASConstant;
                } else if (UtilityRoutines::SameString(Alphas(7), "Linear")) {
                    RefrigCase(CaseNum).AntiSweatControlType = ASLinear;
                } else if (UtilityRoutines::SameString(Alphas(7), "DewpointMethod")) {
                    RefrigCase(CaseNum).AntiSweatControlType = ASDewPoint;
                } else if (UtilityRoutines::SameString(Alphas(7), "HeatBalanceMethod")) {
                    RefrigCase(CaseNum).AntiSweatControlType = ASHeatBalance;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " + cAlphaFieldNames(7) +
                                    "=\"" + Alphas(7) + "\".");
                    ErrorsFound = true;
                }

                //   Assure that case temperature is below the rated dew point when anti-sweat heater control type is dew point method
                if (RefrigCase(CaseNum).Temperature >= RefrigCase(CaseNum).RatedAmbientDewPoint &&
                    RefrigCase(CaseNum).AntiSweatControlType == ASDewPoint) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(7) +
                                    " must be below the Rated Ambient Dew Point when " + cAlphaFieldNames(7) + " is Dew Point Method");
                    ErrorsFound = true;
                }

                NumNum = 15;
                //  negative values for minimum humidity are allowed
                RefrigCase(CaseNum).HumAtZeroAS = Numbers(NumNum);

                //   check minimum humidity when linear AS control type is used
                if (RefrigCase(CaseNum).HumAtZeroAS >= RefrigCase(CaseNum).RatedAmbientRH && RefrigCase(CaseNum).AntiSweatControlType == ASLinear) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be less than " + cNumericFieldNames(2));
                    ShowContinueError(" for Linear " + cAlphaFieldNames(7) + '.');
                    ErrorsFound = true;
                }

                NumNum = 16;
                RefrigCase(CaseNum).Height = Numbers(NumNum);
                if (Numbers(NumNum) < 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be greater than or equal to 0 m");
                    ErrorsFound = true;
                }

                if (RefrigCase(CaseNum).Height <= 0.0 && RefrigCase(CaseNum).AntiSweatControlType == ASHeatBalance) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be greater than 0 when " + cAlphaFieldNames(7) + " is Heat Balance Method.");
                    ShowContinueError("..given " + cNumericFieldNames(NumNum) + " was: " + General::RoundSigDigits(RefrigCase(CaseNum).Height, 3));
                    ErrorsFound = true;
                }

                //   initialize case resistance for anti-sweat heater control type = Heat Balance Method
                if (RefrigCase(CaseNum).AntiSweatControlType == ASHeatBalance) {
                    Real64 Rcase(0.0);      // Case thermal resistance used with anti-sweat heater control
                    Real64 RcaseDenom(0.0); // Denominator of case thermal resistance calculation for anti-sweat

                    if (RefrigCase(CaseNum).Height == 0.0) {
                        Rcase = 0.0;
                    } else {
                        RcaseDenom = ((RefrigCase(CaseNum).AntiSweatPower / RefrigCase(CaseNum).Height) -
                                      (RefrigCase(CaseNum).RatedAmbientDewPoint - RefrigCase(CaseNum).RatedAmbientTemp) / Rair);
                        Rcase = (RefrigCase(CaseNum).RatedAmbientDewPoint - RefrigCase(CaseNum).Temperature) / RcaseDenom;
                    }
                    RefrigCase(CaseNum).Rcase = max(0.0, Rcase);
                    if (RefrigCase(CaseNum).Rcase == 0.0) {
                        ShowWarningError(CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name +
                                         "\" A case thermal resistance of 0 was calculated for anti-sweat heater performance using the");
                        ShowContinueError(" Heat Balance Method control type. Anti-sweat heater performance cannot be calculated and " +
                                          cAlphaFieldNames(7) + " will be set to None and simulation continues.");
                        ShowContinueError(" See Engineering Documentation for anti-sweat heater control of refrigerated cases.");
                    }
                }

                NumNum = 17;
                RefrigCase(CaseNum).ASHeaterFractionToCase = Numbers(NumNum);
                if (Numbers(NumNum) < 0.0 || Numbers(NumNum) > 1.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be >= 0 and <= 1");
                    ErrorsFound = true;
                }

                if (UtilityRoutines::SameString(Alphas(8), "None")) {
                    RefrigCase(CaseNum).DefrostType = DefNone;
                } else if (UtilityRoutines::SameString(Alphas(8), "OffCycle")) {
                    RefrigCase(CaseNum).DefrostType = DefOffCycle;
                } else if ((UtilityRoutines::SameString(Alphas(8), "HotFluid")) || (UtilityRoutines::SameString(Alphas(8), "HotGas"))) {
                    RefrigCase(CaseNum).DefrostType = DefHotFluid;
                } else if ((UtilityRoutines::SameString(Alphas(8), "HotFluidWithTemperatureTermination")) ||
                           (UtilityRoutines::SameString(Alphas(8), "HotGasWithTemperatureTermination"))) {
                    RefrigCase(CaseNum).DefrostType = DefHotFluidTerm;
                    //   ELSEIF (UtilityRoutines::SameString(Alphas(8),'Hot-Fluid On Demand')) THEN
                    //     RefrigCase(CaseNum)%DefrostType = DefHotFluidOnDemand
                } else if (UtilityRoutines::SameString(Alphas(8), "Electric")) {
                    RefrigCase(CaseNum).DefrostType = DefElectric;
                } else if (UtilityRoutines::SameString(Alphas(8), "ElectricWithTemperatureTermination")) {
                    RefrigCase(CaseNum).DefrostType = DefElectricTerm;
                    //   ELSEIF (UtilityRoutines::SameString(Alphas(8),'Electric On Demand')) THEN
                    //     RefrigCase(CaseNum)%DefrostType = DefElectricOnDemand
                } else {
                    ShowWarningError(CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " + cAlphaFieldNames(8) + "=\"" +
                                     Alphas(8) + "\".");
                    ShowContinueError("Simulation will default to " + cAlphaFieldNames(8) + "=\"None\" and continue.");
                    RefrigCase(CaseNum).DefrostType = DefNone;
                }

                int DefType = RefrigCase(CaseNum).DefrostType;
                NumNum = 18;
                if (!lNumericBlanks(NumNum)) {
                    RefrigCase(CaseNum).DefrostPower = Numbers(NumNum);
                    if (Numbers(NumNum) < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                        " must be greater than or equal to 0 W/m");
                        ErrorsFound = true;
                    }
                    //   disregard defrost power for Off-Cycle or None defrost types
                    if ((DefType == DefOffCycle || DefType == DefNone) && (RefrigCase(CaseNum).DefrostPower > 0.0)) {
                        RefrigCase(CaseNum).DefrostPower = 0.0;
                        ShowWarningError(CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) + " for " +
                                         cAlphaFieldNames(8) + " None or Off-Cycle will be set to 0 and simulation continues.");
                    }
                } else {
                    RefrigCase(CaseNum).DefrostPower = 0.0;
                }

                // defrost power needed to calculate heat gain to case even if not needed for electric consumption
                if ((DefType == DefHotFluid || DefType == DefHotFluidTerm || DefType == DefElectric || DefType == DefElectricTerm) &&
                    RefrigCase(CaseNum).DefrostPower <= 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be greater than 0 W/m for " + cAlphaFieldNames(8) + ' ' + Alphas(8));
                    ErrorsFound = true;
                }

                RefrigCase(CaseNum).DefrostSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(9)); // convert schedule name to pointer
                if (RefrigCase(CaseNum).DefrostSchedPtr == 0 && RefrigCase(CaseNum).DefrostType != DefNone) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " + cAlphaFieldNames(9) +
                                    " not found: " + Alphas(9));
                    ShowContinueError("required when " + cAlphaFieldNames(8) + "=\"" + Alphas(8) + "\".");
                    ErrorsFound = true;
                }

                //   check defrost schedule for values between 0 and 1
                if (RefrigCase(CaseNum).DefrostSchedPtr > 0) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(RefrigCase(CaseNum).DefrostSchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\".");
                        ShowContinueError("Error found in " + cAlphaFieldNames(9) + " = " + Alphas(9));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }
                //   Note that next section counting number cycles and setting maxkgfrost not used now, but may be in the future.
                //   count the number of defrost cycles

                // Flag for counting defrost cycles
                bool StartCycle = false;
                int NumDefCycles = 0;
                DayValues = 0.0;
                ScheduleManager::GetScheduleValuesForDay(RefrigCase(CaseNum).DefrostSchedPtr, DayValues, 1);
                for (int HRNum = 1; HRNum <= 24; ++HRNum) {
                    for (int TSNum = 1; TSNum <= DataGlobals::NumOfTimeStepInHour; ++TSNum) {
                        if (DayValues(TSNum, HRNum) > 0.0) {
                            if (!StartCycle) {
                                ++NumDefCycles;
                                StartCycle = true;
                            }
                        } else {
                            StartCycle = false;
                        }
                    }
                }

                if (NumDefCycles > 0) {
                    //     calculate maximum frost formation based on defrost schedule, heat of vaporization+fusion for water = 2833.0 kJ/kg
                    RefrigCase(CaseNum).MaxKgFrost = (RefrigCase(CaseNum).RateTotCapPerLength * RefrigCase(CaseNum).RatedLHR *
                                                      RefrigCase(CaseNum).RatedRTF * SecondsPerHour * HoursPerDay / 1000.0 / 2833.0) /
                                                     (NumDefCycles);
                } else {
                    RefrigCase(CaseNum).MaxKgFrost = 9999999.9;
                }

                //   some defrost types do not use drip-down schedules, use same defrost schedule pointer in that case
                if (!lAlphaBlanks(10)) {
                    RefrigCase(CaseNum).DefrostDripDownSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(10)); // convert schedule name to pointer
                    if (RefrigCase(CaseNum).DefrostDripDownSchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " +
                                        cAlphaFieldNames(10) + " not found: " + Alphas(10));
                        ErrorsFound = true;
                    }
                } else {
                    RefrigCase(CaseNum).DefrostDripDownSchedPtr = RefrigCase(CaseNum).DefrostSchedPtr;
                }

                //   check defrost drip-down schedule for values between 0 and 1
                if (RefrigCase(CaseNum).DefrostDripDownSchedPtr > 0 && (!lAlphaBlanks(10))) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(RefrigCase(CaseNum).DefrostDripDownSchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\".");
                        ShowContinueError("Error found in " + cAlphaFieldNames(10) + " = " + Alphas(10));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }

                if (UtilityRoutines::SameString(Alphas(11), "CaseTemperatureMethod")) {
                    RefrigCase(CaseNum).DefrostEnergyCurveType = CaseTemperatureMethod;
                } else if (UtilityRoutines::SameString(Alphas(11), "RelativeHumidityMethod")) {
                    RefrigCase(CaseNum).DefrostEnergyCurveType = RHCubic;
                } else if (UtilityRoutines::SameString(Alphas(11), "DewpointMethod")) {
                    RefrigCase(CaseNum).DefrostEnergyCurveType = DPCubic;
                } else if (UtilityRoutines::SameString(Alphas(11), "None")) {
                    RefrigCase(CaseNum).DefrostEnergyCurveType = None;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " + cAlphaFieldNames(11) +
                                    "=\"" + Alphas(11) + "\".");
                    ErrorsFound = true;
                }

                RefrigCase(CaseNum).DefCapCurvePtr = CurveManager::GetCurveIndex(Alphas(12)); // convert curve name to number
                if ((RefrigCase(CaseNum).DefrostType == DefElectricTerm || RefrigCase(CaseNum).DefrostType == DefHotFluidTerm) &&
                    (RefrigCase(CaseNum).DefCapCurvePtr == 0)) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " + cAlphaFieldNames(12) +
                                    " not found:" + Alphas(12));
                    ErrorsFound = true;
                }

                if (RefrigCase(CaseNum).DefCapCurvePtr > 0) {
                    ErrorsFound |= CurveManager::CheckCurveDims(RefrigCase(CaseNum).DefCapCurvePtr, // Curve index
                        {1},                            // Valid dimensions
                        RoutineName,                    // Routine name
                        CurrentModuleObject,            // Object Type
                        RefrigCase(CaseNum).Name,   // Object Name
                        cAlphaFieldNames(12));               // Field Name
                }

                //  warn user if defrost energy curve is entered that it is only used for temperature termination types
                if (RefrigCase(CaseNum).DefCapCurvePtr > 0) {
                    if (RefrigCase(CaseNum).DefrostType != DefElectricTerm && RefrigCase(CaseNum).DefrostType != DefHotFluidTerm) {
                        ShowWarningError(CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " + cAlphaFieldNames(12) +
                                         " is only applicable to Defrost Temperature Termination types.");
                        ShowContinueError(cAlphaFieldNames(12) + " will be disregarded and simulation continues.");
                    }
                }

                NumNum = 19;
                RefrigCase(CaseNum).RAFrac = Numbers(NumNum);
                if (Numbers(NumNum) < 0.0 || Numbers(NumNum) > 1.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be >= 0 or <= 1 ");
                    ErrorsFound = true;
                }

                // Set return air node number
                RefrigCase(CaseNum).ZoneRANode = 0;
                std::string retNodeName;
                if (!lAlphaBlanks(15)) {
                    retNodeName = Alphas(15);
                }
                if (RefrigCase(CaseNum).RAFrac > 0.0) {
                    std::string callDescription = CurrentModuleObject + "=" + RefrigCase(CaseNum).Name;
                    RefrigCase(CaseNum).ZoneRANode =
                        DataZoneEquipment::GetReturnAirNodeForZone(state, RefrigCase(CaseNum).ZoneName, retNodeName, callDescription);
                }

                if (RefrigCase(CaseNum).ActualZoneNum >= 0) {
                    if (RefrigCase(CaseNum).ZoneNodeNum == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name +
                                        "\", System Node Number not found for " + cAlphaFieldNames(3) + " = " + Alphas(3));
                        ShowContinueError(
                            "..Refrigerated cases must reference a controlled Zone (appear in a ZoneHVAC:EquipmentConnections object).");
                        ErrorsFound = true;
                    }
                    if ((RefrigCase(CaseNum).RAFrac > 0.0) && (RefrigCase(CaseNum).ZoneRANode == 0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name +
                                        "\", Under Case HVAC Return Air Node number not found for " + cAlphaFieldNames(3) + " = " + Alphas(3));
                        ShowContinueError("..Refrigerated cases must reference a controlled Zone (appear in a ZoneHVAC:EquipmentConnections object) "
                                          "with at least one return air node.");
                        ErrorsFound = true;
                    }
                }

                // set flag in Zone Data if RAFrac > 0
                if (RefrigCase(CaseNum).RAFrac > 0.0) {
                    DataHeatBalance::Zone(RefrigCase(CaseNum).ActualZoneNum).RefrigCaseRA = true;
                }

                //   Make sure RA node exists for display cases with under case HVAC returns
                if (RefrigCase(CaseNum).ZoneRANode == 0 && RefrigCase(CaseNum).RAFrac > 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", " + cNumericFieldNames(19) +
                                    " not applicable to zones without return air systems.");
                    ErrorsFound = true;
                }

                if (RefrigCase(CaseNum).ActualZoneNum != 0) {
                    CaseRAFraction(RefrigCase(CaseNum).ActualZoneNum).TotalCaseRAFraction += RefrigCase(CaseNum).RAFrac;
                    CaseRAFraction(RefrigCase(CaseNum).ActualZoneNum).ZoneName = RefrigCase(CaseNum).ZoneName;
                }

                RefrigCase(CaseNum).StockingSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(13)); // convert schedule name to pointer
                if (!lAlphaBlanks(13)) {
                    if (RefrigCase(CaseNum).StockingSchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " +
                                        cAlphaFieldNames(13) + " not found: " + Alphas(13));
                        ErrorsFound = true;
                    }
                } else {
                    RefrigCase(CaseNum).StockingSchedPtr = 0;
                }

                //   calculate sensible case load at design conditions
                // Case sensible capacity used for error messages
                Real64 DesignSensibleCap = RefrigCase(CaseNum).RateTotCapPerLength * (1.0 - RefrigCase(CaseNum).RatedLHR) *
                                           RefrigCase(CaseNum).RatedRTF * RefrigCase(CaseNum).Length;

                //   calculate case heat gain = lights + fans + anti-sweat
                Real64 CaseHeatGain =
                    ((RefrigCase(CaseNum).RatedLightingPower * RefrigCase(CaseNum).LightingFractionToCase) +
                                (RefrigCase(CaseNum).AntiSweatPower * RefrigCase(CaseNum).ASHeaterFractionToCase) + RefrigCase(CaseNum).STDFanPower) *
                               RefrigCase(CaseNum).Length;

                //   sensible case credits are calculated as the difference between the design sensible capacity and the case heat gain
                RefrigCase(CaseNum).DesignSensCaseCredit = DesignSensibleCap - CaseHeatGain;

                //   compare case loads to design capacity
                if (DesignSensibleCap < CaseHeatGain) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name +
                                    "\", the sum of lighting, fan, and anti-sweat heater energy is greater than refrigerated case sensible capacity");
                    ErrorsFound = true;
                }

                RefrigCase(CaseNum).CaseCreditFracSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(14)); // convert schedule name to pointer
                if (!lAlphaBlanks(14)) {
                    if (RefrigCase(CaseNum).CaseCreditFracSchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\", invalid  " +
                                        cAlphaFieldNames(14) + " not found: " + Alphas(14));
                        ErrorsFound = true;
                    }
                } else {
                    RefrigCase(CaseNum).CaseCreditFracSchedPtr = 0;
                }

                //   check case credit fraction schedule for values between 0 and 1
                if (RefrigCase(CaseNum).CaseCreditFracSchedPtr > 0) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(RefrigCase(CaseNum).CaseCreditFracSchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\".");
                        ShowContinueError("Error found in " + cAlphaFieldNames(14) + " = " + Alphas(14));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }

                RefrigCase(CaseNum).DesignRatedCap = RefrigCase(CaseNum).RateTotCapPerLength * RefrigCase(CaseNum).Length;
                RefrigCase(CaseNum).DesignLatentCap =
                    RefrigCase(CaseNum).DesignRatedCap * RefrigCase(CaseNum).RatedLHR * RefrigCase(CaseNum).RatedRTF;
                RefrigCase(CaseNum).DesignDefrostCap = RefrigCase(CaseNum).DefrostPower * RefrigCase(CaseNum).Length;
                RefrigCase(CaseNum).DesignLighting = RefrigCase(CaseNum).LightingPower * RefrigCase(CaseNum).Length;
                RefrigCase(CaseNum).DesignFanPower = RefrigCase(CaseNum).OperatingFanPower * RefrigCase(CaseNum).Length;

                // Design evaporating temperature:  for a DX system, saturated temperature for pressure leaving case
                //                              :  for a liquid system, liquid temperature entering case
                NumNum = 20;
                if (!lNumericBlanks(NumNum)) {
                    RefrigCase(CaseNum).EvapTempDesign = Numbers(NumNum);
                    if (RefrigCase(CaseNum).EvapTempDesign >= RefrigCase(CaseNum).Temperature) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\" " + cNumericFieldNames(NumNum) +
                                        " must be below " + cNumericFieldNames(7));
                        ErrorsFound = true;
                    }
                } else {
                    RefrigCase(CaseNum).EvapTempDesign = RefrigCase(CaseNum).Temperature - DelEvapTDefault;
                    //    default 5C less than case operating temperature
                }

                NumNum = 21;
                if (!lNumericBlanks(NumNum)) {
                    RefrigCase(CaseNum).RefrigInventory = Numbers(NumNum);
                    RefrigCase(CaseNum).DesignRefrigInventory = RefrigCase(CaseNum).RefrigInventory * RefrigCase(CaseNum).Length;
                    if (RefrigCase(CaseNum).RefrigInventory < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigCase(CaseNum).Name + "\" " + cNumericFieldNames(NumNum) +
                                        " must be a positive number.");
                        ErrorsFound = true;
                    }
                } else {
                    RefrigCase(CaseNum).RefrigInventory = 0.0;
                }

            } // Individual refrigerated cases
        }     //(NumSimulationCases > 0 )

        //************ START WALK IN COOLER INPUT **************

        if (NumSimulationWalkIns > 0) {
            CurrentModuleObject = "Refrigeration:WalkIn";
            for (int WalkInID = 1; WalkInID <= NumSimulationWalkIns; ++WalkInID) {
                inputProcessor->getObjectItem(CurrentModuleObject,
                                              WalkInID,
                                              Alphas,
                                              NumAlphas,
                                              Numbers,
                                              NumNumbers,
                                              IOStatus,
                                              lNumericBlanks,
                                              lAlphaBlanks,
                                              cAlphaFieldNames,
                                              cNumericFieldNames);
                UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                WalkIn(WalkInID).Name = Alphas(1);

                if (!lAlphaBlanks(2)) {
                    WalkIn(WalkInID).SchedPtr = ScheduleManager::GetScheduleIndex(Alphas(2)); // convert schedule name to pointer
                    if (WalkIn(WalkInID).SchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", invalid  " + cAlphaFieldNames(2) +
                                        " not found: " + Alphas(2));
                        ErrorsFound = true;
                    }    // ptr == 0
                } else { // no schedule specified
                    WalkIn(WalkInID).SchedPtr = AlwaysOn;
                } // not blank

                //   check availability schedule for values between 0 and 1
                if (WalkIn(WalkInID).SchedPtr > 0) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(WalkIn(WalkInID).SchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\"");
                        ShowContinueError("Error found in " + cAlphaFieldNames(2) + " = " + Alphas(2));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }

                WalkIn(WalkInID).DesignRatedCap = Numbers(1);
                if (Numbers(1) <= 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(1) +
                                    " must be greater than 0 W");
                    ErrorsFound = true;
                }

                if (!lNumericBlanks(2)) {
                    WalkIn(WalkInID).Temperature = Numbers(2);
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(2) +
                                    " must be input ");
                    ErrorsFound = true;
                }

                if (!lNumericBlanks(3)) {
                    WalkIn(WalkInID).TEvapDesign = Numbers(3);
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(3) +
                                    " must be input");
                    ErrorsFound = true;
                }

                if (!lNumericBlanks(4)) {
                    WalkIn(WalkInID).HeaterPower = Numbers(4);
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(4) +
                                    " must be input ");
                    ErrorsFound = true;
                }

                AlphaNum = 3;
                if (!lAlphaBlanks(AlphaNum)) {
                    WalkIn(WalkInID).HeaterSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(AlphaNum)); // convert heater schedule name to pointer
                    if (WalkIn(WalkInID).HeaterSchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", invalid  " +
                                        cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                        ErrorsFound = true;
                    }    // ptr == 0
                } else { // no schedule specified
                    WalkIn(WalkInID).HeaterSchedPtr = AlwaysOn;
                } // not blank

                //   check heater schedule for values between 0 and 1
                if (WalkIn(WalkInID).HeaterSchedPtr > 0) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(WalkIn(WalkInID).HeaterSchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\"");
                        ShowContinueError("Error found in " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }

                if (!lNumericBlanks(5) && Numbers(5) > 0.0) {
                    WalkIn(WalkInID).CoilFanPower = Numbers(5);
                } else {
                    ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(5) +
                                     " was not input or was less than 0 and default of 375.0 W will be used ");
                    WalkIn(WalkInID).CoilFanPower = 375.0; // default value = 1/2 hp
                }

                if (lNumericBlanks(6)) {
                    WalkIn(WalkInID).CircFanPower = 0.0;
                } else {
                    WalkIn(WalkInID).CircFanPower = Numbers(6);
                    if (Numbers(7) < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(6) +
                                        " must be greater than >= 0 W");
                        ErrorsFound = true;
                    }
                }

                if (!lNumericBlanks(7)) {
                    WalkIn(WalkInID).DesignLighting = Numbers(7);
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\" " + cNumericFieldNames(7) +
                                    " must be input ");
                    ErrorsFound = true;
                }

                AlphaNum = 4;
                if (!lAlphaBlanks(AlphaNum)) {
                    WalkIn(WalkInID).LightingSchedPtr =
                        ScheduleManager::GetScheduleIndex(Alphas(AlphaNum)); // convert lighting schedule name to pointer
                    if (WalkIn(WalkInID).LightingSchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", invalid  " +
                                        cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                        ErrorsFound = true;
                    }    // ptr == 0
                } else { // no schedule specified
                    WalkIn(WalkInID).LightingSchedPtr = AlwaysOn;
                } // schedule name not blank
                //   check Lighting schedule for values between 0 and 1
                if (WalkIn(WalkInID).LightingSchedPtr > 0) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(WalkIn(WalkInID).LightingSchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\"");
                        ShowContinueError("Error found in " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }

                // Input walk-in cooler defrost information
                AlphaNum = 5;
                if (lAlphaBlanks(AlphaNum) || UtilityRoutines::SameString(Alphas(AlphaNum), "Electric")) {
                    WalkIn(WalkInID).DefrostType = WalkInDefrostElec;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "HotFluid")) {
                    WalkIn(WalkInID).DefrostType = WalkInDefrostFluid;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "None")) {
                    WalkIn(WalkInID).DefrostType = WalkInDefrostNone;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "OffCycle")) {
                    WalkIn(WalkInID).DefrostType = WalkInDefrostOffCycle;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", invalid  " + cAlphaFieldNames(AlphaNum) +
                                    "=\"" + Alphas(AlphaNum) + "\".");
                    ErrorsFound = true;
                }

                AlphaNum = 6;
                if (lAlphaBlanks(AlphaNum) || UtilityRoutines::SameString(Alphas(AlphaNum), "TimeSchedule")) {
                    WalkIn(WalkInID).DefrostControlType = DefrostControlSched;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "TemperatureTermination")) {
                    WalkIn(WalkInID).DefrostControlType = DefrostContTempTerm;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", invalid  " + cAlphaFieldNames(AlphaNum) +
                                    " not found: " + Alphas(AlphaNum));
                    ErrorsFound = true;
                } // defrost control type

                // convert defrost schedule name to pointer
                AlphaNum = 7;
                WalkIn(WalkInID).DefrostSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(AlphaNum));
                if (WalkIn(WalkInID).DefrostSchedPtr == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", invalid  " + cAlphaFieldNames(AlphaNum) +
                                    " not found: " + Alphas(AlphaNum));
                    ErrorsFound = true;
                }
                //   check defrost schedule for values between 0 and 1
                if (WalkIn(WalkInID).DefrostSchedPtr > 0) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(WalkIn(WalkInID).DefrostSchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + " = \"" + WalkIn(WalkInID).Name + "\"");
                        ShowContinueError("Error found in " + cAlphaFieldNames(AlphaNum) + '=' + Alphas(AlphaNum));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }

                // convert defrost drip-down schedule name to pointer
                // some defrost types do not use drip-down schedules, use same defrost schedule pointer in that case
                AlphaNum = 8;
                if (!lAlphaBlanks(AlphaNum)) {
                    WalkIn(WalkInID).DefrostDripDownSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(AlphaNum));
                    if (WalkIn(WalkInID).DefrostDripDownSchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", invalid  " +
                                        cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                        ErrorsFound = true;
                    }
                    // check schedule for values between 0 and 1
                    if (WalkIn(WalkInID).DefrostDripDownSchedPtr > 0) {
                        if (!ScheduleManager::CheckScheduleValueMinMax(WalkIn(WalkInID).DefrostDripDownSchedPtr, ">=", 0.0, "<=", 1.0)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\"");
                            ShowContinueError("Error found in " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum));
                            ShowContinueError("schedule values must be (>=0., <=1.)");
                            ErrorsFound = true;
                        }
                    }
                } else { // blank input so use drip down schedule for defrost
                    WalkIn(WalkInID).DefrostDripDownSchedPtr = WalkIn(WalkInID).DefrostSchedPtr;
                }

                if (WalkIn(WalkInID).DefrostType == WalkInDefrostOffCycle || WalkIn(WalkInID).DefrostType == WalkInDefrostNone) {
                    WalkIn(WalkInID).DefrostCapacity = 0.0;
                    // Don't even need to read N8 or N9 for those two defrost types.
                } else { // have electric or hot gas/brine defrost
                    if ((lNumericBlanks(8)) || (Numbers(8) <= 0.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(8) +
                                        " must be input and greater than or equal to 0 W for " + cAlphaFieldNames(5) + ' ' + Alphas(5));
                        ErrorsFound = true;
                    } else {
                        WalkIn(WalkInID).DefrostCapacity = Numbers(8);
                    } // Blank  or negative N8

                    // defaults for defrost energy fraction are 0.7 for elec defrost and 0.3 for warm fluid
                    // note this value is only used for temperature terminated defrost control type
                    if (WalkIn(WalkInID).DefrostType == WalkInDefrostElec) WalkIn(WalkInID).DefEnergyFraction = 0.7;
                    if (WalkIn(WalkInID).DefrostType == WalkInDefrostFluid) WalkIn(WalkInID).DefEnergyFraction = 0.3;
                    if (!lNumericBlanks(9)) {
                        if ((Numbers(9) > 1.0) || (Numbers(9) < 0.0)) {
                            ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(9) +
                                             " must be between 0 and 1, default values will be used.");
                        } else {
                            WalkIn(WalkInID).DefEnergyFraction = Numbers(9);
                        } // number out of range
                    }     // lnumericblanks
                }         // defrost type

                // convert restocking schedule name to pointer, default of 0.1 is assigned inside walkin subroutine if blank
                AlphaNum = 9;
                if (lAlphaBlanks(AlphaNum)) {
                    WalkIn(WalkInID).StockingSchedPtr = 0;
                } else {
                    WalkIn(WalkInID).StockingSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(AlphaNum));
                    if (WalkIn(WalkInID).StockingSchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", invalid  " +
                                        cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                        ErrorsFound = true;
                    }
                } // blank

                WalkIn(WalkInID).DesignRefrigInventory = 0.0;
                if (!lNumericBlanks(10)) WalkIn(WalkInID).DesignRefrigInventory = Numbers(10);

                if (!lNumericBlanks(11)) {
                    WalkIn(WalkInID).FloorArea = Numbers(11);
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(11) +
                                    " must be input");
                    ErrorsFound = true;
                }

                if (lNumericBlanks(12)) {
                    WalkIn(WalkInID).FloorUValue = DefaultWISurfaceUValue;
                } else {
                    WalkIn(WalkInID).FloorUValue = Numbers(12);
                    if (Numbers(12) <= 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(12) +
                                        " must be > 0.");
                        ErrorsFound = true;
                    }
                }

                // Calculate the number of zones exposed to walk-in based on number of input fields, all integer math,
                // This approach used because last zone could have less than NumWIFieldsPerZone due to optional values
                int NumWIFieldsPerZone = NumWIAlphaFieldsPerZone + NumWINumberFieldsPerZone;
                int NumWIFieldsTotal = NumNumbers + NumAlphas - NumWIAlphaFieldsBeforeZoneInput - NumWINumberFieldsBeforeZoneInput;
                int NumZones = 1;
                if (NumWIFieldsTotal > NumWIFieldsPerZone) NumZones = 2;
                if (NumWIFieldsTotal > (2 * NumWIFieldsPerZone)) NumZones = 3;
                if (NumWIFieldsTotal > (3 * NumWIFieldsPerZone)) NumZones = 4;
                if (NumWIFieldsTotal > (4 * NumWIFieldsPerZone)) NumZones = 5;
                if (NumWIFieldsTotal > (5 * NumWIFieldsPerZone)) NumZones = 6;
                WalkIn(WalkInID).NumZones = NumZones;

                // All variables for walk-in/zone interactions need to be allocated after know number of zones
                // Autodesk Missing initialization added below: At least SensZoneCreditRate was used uninitialized
                if (!allocated(WalkIn(WalkInID).ZoneName)) WalkIn(WalkInID).ZoneName.allocate(NumZones);
                if (!allocated(WalkIn(WalkInID).ZoneNum)) WalkIn(WalkInID).ZoneNum.allocate(NumZones) = 0;
                if (!allocated(WalkIn(WalkInID).ZoneNodeNum)) WalkIn(WalkInID).ZoneNodeNum.allocate(NumZones) = 0;
                if (!allocated(WalkIn(WalkInID).SurfaceArea)) WalkIn(WalkInID).SurfaceArea.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).UValue)) WalkIn(WalkInID).UValue.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).UValueGlassDr)) WalkIn(WalkInID).UValueGlassDr.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).GlassDoorOpenSchedPtr)) WalkIn(WalkInID).GlassDoorOpenSchedPtr.allocate(NumZones) = 0;
                if (!allocated(WalkIn(WalkInID).AreaGlassDr)) WalkIn(WalkInID).AreaGlassDr.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).HeightGlassDr)) WalkIn(WalkInID).HeightGlassDr.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).UValueStockDr)) WalkIn(WalkInID).UValueStockDr.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).StockDoorOpenSchedPtr)) WalkIn(WalkInID).StockDoorOpenSchedPtr.allocate(NumZones) = 0;
                if (!allocated(WalkIn(WalkInID).StockDoorProtectType)) WalkIn(WalkInID).StockDoorProtectType.allocate(NumZones) = 0;
                if (!allocated(WalkIn(WalkInID).AreaStockDr)) WalkIn(WalkInID).AreaStockDr.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).HeightStockDr)) WalkIn(WalkInID).HeightStockDr.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).SensZoneCreditRate)) WalkIn(WalkInID).SensZoneCreditRate.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).SensZoneCreditCoolRate)) WalkIn(WalkInID).SensZoneCreditCoolRate.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).SensZoneCreditCool)) WalkIn(WalkInID).SensZoneCreditCool.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).SensZoneCreditHeatRate)) WalkIn(WalkInID).SensZoneCreditHeatRate.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).SensZoneCreditHeat)) WalkIn(WalkInID).SensZoneCreditHeat.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).LatZoneCreditRate)) WalkIn(WalkInID).LatZoneCreditRate.allocate(NumZones) = 0.0;
                if (!allocated(WalkIn(WalkInID).LatZoneCredit)) WalkIn(WalkInID).LatZoneCredit.allocate(NumZones) = 0.0;

                int AStart = NumWIAlphaFieldsBeforeZoneInput + 1;
                int NStart = NumWINumberFieldsBeforeZoneInput + 1;
                for (int ZoneID = 1; ZoneID <= NumZones; ++ZoneID) {
                    // Get the Zone node number from the zone name
                    // The Zone Node is needed to get the zone's ambient conditions, DataGlobals::NumOfZones from dataglobals
                    WalkIn(WalkInID).ZoneName(ZoneID) = Alphas(AStart);
                    WalkIn(WalkInID).ZoneNum(ZoneID) = UtilityRoutines::FindItemInList(Alphas(AStart), DataHeatBalance::Zone);

                    if (WalkIn(WalkInID).ZoneNum(ZoneID) == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", invalid  " +
                                        cAlphaFieldNames(AStart) + " not valid: " + Alphas(AStart));
                        ErrorsFound = true;
                    } else {
                        RefrigPresentInZone(WalkIn(WalkInID).ZoneNum(ZoneID)) = true;
                    }
                    WalkIn(WalkInID).ZoneNodeNum(ZoneID) = DataZoneEquipment::GetSystemNodeNumberForZone(state, WalkIn(WalkInID).ZoneName(ZoneID));
                    if (WalkIn(WalkInID).ZoneNum(ZoneID) >= 0) {
                        if (WalkIn(WalkInID).ZoneNodeNum(ZoneID) == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name +
                                            "\" System Node Number not found for " + cAlphaFieldNames(AStart) + " = " + Alphas(AStart));
                            ShowContinueError(".. Walk Ins must reference a controlled Zone (appear in a ZoneHVAC:EquipmentConnections object.");
                            ErrorsFound = true;
                        }
                    }

                    if (!lNumericBlanks(NStart)) {
                        WalkIn(WalkInID).SurfaceArea(ZoneID) = Numbers(NStart);
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", " + cNumericFieldNames(NStart) +
                                        " must be input for Zone: " + WalkIn(WalkInID).ZoneName(ZoneID));
                        ErrorsFound = true;
                    }

                    if (lNumericBlanks(NStart + 1)) {
                        WalkIn(WalkInID).UValue(ZoneID) = DefaultWISurfaceUValue;
                    } else {
                        WalkIn(WalkInID).UValue(ZoneID) = Numbers(NStart + 1);
                        if (Numbers(NStart + 1) <= 0.0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", Zone=\"" +
                                            WalkIn(WalkInID).ZoneName(ZoneID) + "\", " + cNumericFieldNames(NStart + 1) + " must be > 0.");
                            ErrorsFound = true;
                        }
                    }

                    // start IF set for glass doors in this zone
                    WalkIn(WalkInID).AreaGlassDr(ZoneID) = 0.0;
                    WalkIn(WalkInID).HeightGlassDr(ZoneID) = 0.0;
                    WalkIn(WalkInID).UValueGlassDr(ZoneID) = 0.0;
                    if (!lNumericBlanks(NStart + 2)) {
                        WalkIn(WalkInID).AreaGlassDr(ZoneID) = Numbers(NStart + 2);

                        WalkIn(WalkInID).HeightGlassDr(ZoneID) = DefaultWIHeightGlassDr;
                        if (!lNumericBlanks(NStart + 3)) WalkIn(WalkInID).HeightGlassDr(ZoneID) = Numbers(NStart + 3);

                        WalkIn(WalkInID).UValueGlassDr(ZoneID) = DefaultWIUValueGlassDr;
                        if (!lNumericBlanks(NStart + 4)) WalkIn(WalkInID).UValueGlassDr(ZoneID) = Numbers(NStart + 4);

                        // convert door opening schedule name to pointer, default of 0.1 is assigned inside walkin subroutine if blank
                        if (lAlphaBlanks(AStart + 1)) {
                            WalkIn(WalkInID).GlassDoorOpenSchedPtr(ZoneID) = 0;
                        } else {
                            WalkIn(WalkInID).GlassDoorOpenSchedPtr(ZoneID) = ScheduleManager::GetScheduleIndex(Alphas(AStart + 1));
                            if (WalkIn(WalkInID).GlassDoorOpenSchedPtr(ZoneID) == 0) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", Zone=\"" +
                                                WalkIn(WalkInID).ZoneName(ZoneID) + "\", invalid  " + cAlphaFieldNames(AStart + 1) +
                                                " not found: " + Alphas(AStart + 1));
                                ErrorsFound = true;
                            } else {
                                //       check schedule for values between 0 and 1
                                if (!ScheduleManager::CheckScheduleValueMinMax(
                                        WalkIn(WalkInID).GlassDoorOpenSchedPtr(ZoneID), ">=", 0.0, "<=", 1.0)) {
                                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", Zone=\"" +
                                                    WalkIn(WalkInID).ZoneName(ZoneID) + "\"");
                                    ShowContinueError("Error found in " + cAlphaFieldNames(AStart + 1) + " = " + Alphas(AStart + 1));
                                    ShowContinueError("schedule values must be (>=0., <=1.)");
                                    ErrorsFound = true;
                                } // schedule values outside range
                            }     // have schedule pointer
                        }         // blank on door opening schedule (AStart + 1)
                    }             // have glassdoor area facing zone (blank on lNumericBlanks(NStart+2))

                    // start IF set for stock doors in this zone
                    WalkIn(WalkInID).AreaStockDr(ZoneID) = 0.0;
                    WalkIn(WalkInID).HeightStockDr(ZoneID) = 0.0;
                    WalkIn(WalkInID).UValueStockDr(ZoneID) = 0.0;
                    if (!lNumericBlanks(NStart + 5)) {
                        WalkIn(WalkInID).AreaStockDr(ZoneID) = Numbers(NStart + 5);

                        WalkIn(WalkInID).HeightStockDr(ZoneID) = DefaultWIHeightStockDr;
                        if (!lNumericBlanks(NStart + 6)) WalkIn(WalkInID).HeightStockDr(ZoneID) = Numbers(NStart + 6);

                        WalkIn(WalkInID).UValueStockDr(ZoneID) = DefaultWIUValueStockDr;
                        if (!lNumericBlanks(NStart + 7)) WalkIn(WalkInID).UValueStockDr(ZoneID) = Numbers(NStart + 7);

                        // convert door opening schedule name to pointer, default of 0.1 is assigned inside walkin subroutine if blank
                        if (lAlphaBlanks(AStart + 2)) {
                            WalkIn(WalkInID).StockDoorOpenSchedPtr(ZoneID) = 0;
                        } else {
                            WalkIn(WalkInID).StockDoorOpenSchedPtr(ZoneID) = ScheduleManager::GetScheduleIndex(Alphas(AStart + 2));
                            if (WalkIn(WalkInID).StockDoorOpenSchedPtr(ZoneID) == 0) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", Zone=\"" +
                                                WalkIn(WalkInID).ZoneName(ZoneID) + "\", invalid  " + cAlphaFieldNames(AStart + 2) +
                                                " not found: " + Alphas(AStart + 2));
                                ErrorsFound = true;
                            } else {
                                //       check schedule for values between 0 and 1
                                if (!ScheduleManager::CheckScheduleValueMinMax(
                                        WalkIn(WalkInID).StockDoorOpenSchedPtr(ZoneID), ">=", 0.0, "<=", 1.0)) {
                                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", Zone=\"" +
                                                    WalkIn(WalkInID).ZoneName(ZoneID) + "\"");
                                    ShowContinueError("Error found in " + cAlphaFieldNames(AStart + 2) + " = " + Alphas(AStart + 2));
                                    ShowContinueError("schedule values must be (>=0., <=1.)");
                                    ErrorsFound = true;
                                } // schedule values outside range
                            }     // have schedule pointer
                        }         // blank on door opening schedule (AStart + 2)

                        if (lAlphaBlanks(AStart + 3) || UtilityRoutines::SameString(Alphas(AStart + 3), "AirCurtain")) {
                            // default air curtain
                            WalkIn(WalkInID).StockDoorProtectType(ZoneID) = WIStockDoorAirCurtain;
                        } else if (UtilityRoutines::SameString(Alphas(AStart + 3), "None")) {
                            WalkIn(WalkInID).StockDoorProtectType(ZoneID) = WIStockDoorNone;
                        } else if (UtilityRoutines::SameString(Alphas(AStart + 3), "StripCurtain")) {
                            WalkIn(WalkInID).StockDoorProtectType(ZoneID) = WIStockDoorStripCurtain;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WalkIn(WalkInID).Name + "\", invalid  " +
                                            cAlphaFieldNames(AStart + 3) + "=\"" + Alphas(AStart + 3) + "\".");
                            ErrorsFound = true;
                        } // stock door protection (AStart + 3) blank
                    }     // have Stockdoor area facing zone

                    AStart += NumWIAlphaFieldsPerZone;
                    NStart += NumWINumberFieldsPerZone;
                } // Zones for Walk Ins
            }     // Individual Walk Ins
        }         //(NumSimulationWalkIns > 0 )

        //************* Start Indiv Refrig Air Chillers

        if (NumSimulationRefrigAirChillers > 0) {
            CurrentModuleObject = "Refrigeration:AirChiller";
            for (int CoilID = 1; CoilID <= NumSimulationRefrigAirChillers; ++CoilID) {
                // A1
                AlphaNum = 1;
                inputProcessor->getObjectItem(CurrentModuleObject,
                                              CoilID,
                                              Alphas,
                                              NumAlphas,
                                              Numbers,
                                              NumNumbers,
                                              IOStatus,
                                              lNumericBlanks,
                                              lAlphaBlanks,
                                              cAlphaFieldNames,
                                              cNumericFieldNames);
                UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                WarehouseCoil(CoilID).Name = Alphas(AlphaNum);

                // A2
                ++AlphaNum;
                if (!lAlphaBlanks(AlphaNum)) {
                    WarehouseCoil(CoilID).SchedPtr = ScheduleManager::GetScheduleIndex(Alphas(AlphaNum)); // convert schedule name to pointer
                    if (WarehouseCoil(CoilID).SchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                        cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                        ErrorsFound = true;
                    }    // ptr == 0
                } else { // no schedule specified
                    WarehouseCoil(CoilID).SchedPtr = AlwaysOn;
                } // not blank

                //   check availability schedule for values between 0 and 1
                if (WarehouseCoil(CoilID).SchedPtr > 0) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(WarehouseCoil(CoilID).SchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\"");
                        ShowContinueError("Error found in " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }

                // Input capacity rating type
                // bbbbb input values (DT1 or DTM type)translate DT1 to DTm here because node will give avg temp?
                //      ask whether ceiling or floor mounted? - effects translation from DT1 to DTM
                //      input coil condition, wet or dry OR input rating basis, European SC1, SC2 etc., have to combine with refrigerant factor)
                //      rated capacity, BAC give W/C, European gives W
                //      fin material factor, default 1
                //      refrigerant factor (factor of both refrigerant and Tevap)

                // A3
                ++AlphaNum;
                if (lAlphaBlanks(AlphaNum)) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + cAlphaFieldNames(AlphaNum) +
                                    " is required and not found.");
                    ErrorsFound = true;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "UnitLoadFactorSensibleOnly")) {
                    WarehouseCoil(CoilID).RatingType = UnitLoadFactorSens;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "CapacityTotalSpecificConditions")) {
                    WarehouseCoil(CoilID).RatingType = RatedCapacityTotal;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "EuropeanSC1Standard")) {
                    WarehouseCoil(CoilID).RatingType = EuropeanSC1Std;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "EuropeanSC1NominalWet")) {
                    WarehouseCoil(CoilID).RatingType = EuropeanSC1Nom;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "EuropeanSC2Standard")) {
                    WarehouseCoil(CoilID).RatingType = EuropeanSC2Std;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "EuropeanSC2NominalWet")) {
                    WarehouseCoil(CoilID).RatingType = EuropeanSC2Nom;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "EuropeanSC3Standard")) {
                    WarehouseCoil(CoilID).RatingType = EuropeanSC3Std;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "EuropeanSC3NominalWet")) {
                    WarehouseCoil(CoilID).RatingType = EuropeanSC3Nom;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "EuropeanSC4Standard")) {
                    WarehouseCoil(CoilID).RatingType = EuropeanSC4Std;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "EuropeanSC4NominalWet")) {
                    WarehouseCoil(CoilID).RatingType = EuropeanSC4Nom;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "EuropeanSC5Standard")) {
                    WarehouseCoil(CoilID).RatingType = EuropeanSC5Std;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "EuropeanSC5NominalWet")) {
                    WarehouseCoil(CoilID).RatingType = EuropeanSC5Nom;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                    cAlphaFieldNames(AlphaNum) + "=\"" + Alphas(AlphaNum) + "\".");
                    ErrorsFound = true;
                }

                // Here have to do select case with one numeric field with units of W and the second with units of W/deltaC,
                //  (RatedRH field only used for RatedCapacityTotal type)
                {
                    auto const SELECT_CASE_var(WarehouseCoil(CoilID).RatingType);
                    if (SELECT_CASE_var == UnitLoadFactorSens) {
                        // N1
                        NumNum = 1;
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).UnitLoadFactorSens = Numbers(NumNum);
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W/C");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == RatedCapacityTotal) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to N2 with rating in W
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedCapTotal = Numbers(NumNum);
                            // N3
                            NumNum = 3; // read rated RH only for this type of rating at N3
                            if (lNumericBlanks(NumNum)) {
                                WarehouseCoil(CoilID).RatedRH = 0.85;
                            } else {
                                if (Numbers(NumNum) <= 0.0 || Numbers(NumNum) >= 100.0) {
                                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                                    cNumericFieldNames(NumNum) + " must be greater than 0% and less than 100%");
                                    ErrorsFound = true;
                                }
                                WarehouseCoil(CoilID).RatedRH = Numbers(NumNum) / 100.0;
                            }
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == EuropeanSC1Std) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to rating in W at N2
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedSensibleCap = Numbers(NumNum);
                            WarehouseCoil(CoilID).SCIndex = 1;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == EuropeanSC1Nom) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to rating in W at N2
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedCapTotal = Numbers(NumNum);
                            WarehouseCoil(CoilID).RatedSensibleCap = Numbers(NumNum) / EuropeanWetCoilFactor(1);
                            WarehouseCoil(CoilID).SCIndex = 1;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == EuropeanSC2Std) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to rating in W at N2
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedSensibleCap = Numbers(NumNum);
                            WarehouseCoil(CoilID).SCIndex = 2;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == EuropeanSC2Nom) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to rating in W at N2
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedCapTotal = Numbers(NumNum);
                            WarehouseCoil(CoilID).RatedSensibleCap = Numbers(NumNum) / EuropeanWetCoilFactor(2);
                            WarehouseCoil(CoilID).SCIndex = 2;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == EuropeanSC3Std) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to rating in W at N2
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedSensibleCap = Numbers(NumNum);
                            WarehouseCoil(CoilID).SCIndex = 3;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == EuropeanSC3Nom) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to rating in W at N2
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedCapTotal = Numbers(NumNum);
                            WarehouseCoil(CoilID).RatedSensibleCap = Numbers(NumNum) / EuropeanWetCoilFactor(3);
                            WarehouseCoil(CoilID).SCIndex = 3;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == EuropeanSC4Std) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to rating in W at N2
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedSensibleCap = Numbers(NumNum);
                            WarehouseCoil(CoilID).SCIndex = 4;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == EuropeanSC4Nom) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to rating in W at N2
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedCapTotal = Numbers(NumNum);
                            WarehouseCoil(CoilID).RatedSensibleCap = Numbers(NumNum) / EuropeanWetCoilFactor(4);
                            WarehouseCoil(CoilID).SCIndex = 4;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == EuropeanSC5Std) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to rating in W at N2
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedSensibleCap = Numbers(NumNum);
                            WarehouseCoil(CoilID).SCIndex = 5;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    } else if (SELECT_CASE_var == EuropeanSC5Nom) {
                        // N2
                        NumNum = 2; // advance past rating in W/C to rating in W at N2
                        if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                            WarehouseCoil(CoilID).RatedCapTotal = Numbers(NumNum);
                            WarehouseCoil(CoilID).RatedSensibleCap = Numbers(NumNum) / EuropeanWetCoilFactor(5);
                            WarehouseCoil(CoilID).SCIndex = 5;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                            cNumericFieldNames(NumNum) + " must be input and be greater than 0 W");
                            ErrorsFound = true;
                        }
                    }
                } // WarehouseCoil(CoilID)%RatingType

                // N4
                NumNum = 4;
                if (!lNumericBlanks(NumNum)) {
                    WarehouseCoil(CoilID).TEvapDesign = Numbers(NumNum); // also used to rep inlet brine T later when add that option
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be input");
                    ErrorsFound = true;
                }

                ++NumNum; // N5
                if (!lNumericBlanks(NumNum)) {
                    WarehouseCoil(CoilID).RatedTemperatureDif = Numbers(NumNum);
                    // INLET temperature - evaporating temperature, NOT room temp - evap temp
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be input");
                    ErrorsFound = true;
                }

                ++NumNum; // N6
                if (!lNumericBlanks(NumNum)) {
                    WarehouseCoil(CoilID).MaxTemperatureDif = Numbers(NumNum);
                    // Maximum difference between INLET temperature - evaporating temperature, NOT room temp - evap temp
                    // Important when cooling down space at start of environment or if large stocking loads imposed.
                } else {
                    WarehouseCoil(CoilID).MaxTemperatureDif = 1.3 * WarehouseCoil(CoilID).RatedTemperatureDif;
                    ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " + cNumericFieldNames(NumNum) +
                                     " not entered, default 1.3 times rated temperature difference will be used.");
                }

                // Correction factor from manufacturer's rating for coil material, default 1.0
                ++NumNum;                                 // N7
                WarehouseCoil(CoilID).CorrMaterial = 1.0; // default value
                if (!lNumericBlanks(NumNum)) WarehouseCoil(CoilID).CorrMaterial = Numbers(NumNum);

                // Correction factor from manufacturer's rating for refrigerant, default 1.0
                ++NumNum;                                    // N8
                WarehouseCoil(CoilID).CorrRefrigerant = 1.0; // default value
                if (!lNumericBlanks(NumNum)) WarehouseCoil(CoilID).CorrRefrigerant = Numbers(NumNum);
                // ONLY used if the Capacity Rating Type is CapacityTotalSpecificConditions

                // Convert all European sensible capacities to sensible load factors
                if ((WarehouseCoil(CoilID).RatingType != UnitLoadFactorSens) && (WarehouseCoil(CoilID).RatingType != RatedCapacityTotal))
                    WarehouseCoil(CoilID).UnitLoadFactorSens = WarehouseCoil(CoilID).RatedSensibleCap / WarehouseCoil(CoilID).RatedTemperatureDif;
                // Now have UnitLoadFactorSens for all except RatingType == RatedCapacityTotal

                // Apply material and refrigerant correction factors to sensible load factors
                if ((WarehouseCoil(CoilID).RatingType != RatedCapacityTotal))
                    WarehouseCoil(CoilID).UnitLoadFactorSens *= WarehouseCoil(CoilID).CorrMaterial * WarehouseCoil(CoilID).CorrRefrigerant;
                // First calc of ratedsensiblecap for type type unitloadfactorsens
                WarehouseCoil(CoilID).RatedSensibleCap = WarehouseCoil(CoilID).UnitLoadFactorSens * WarehouseCoil(CoilID).RatedTemperatureDif;
                // A4    Enter capacity correction curve type
                AlphaNum = 4;
                if ((lAlphaBlanks(AlphaNum)) && (WarehouseCoil(CoilID).RatingType != RatedCapacityTotal)) {
                    // For all except RatedCapacityTotal - default to linear capacity factor approximating Nelson August 2010 ASHRAE journal
                    WarehouseCoil(CoilID).SHRCorrectionType = SHR60;
                } else if (WarehouseCoil(CoilID).RatingType == RatedCapacityTotal) {
                    // For RatedCapacityTotal, the manufacturer's coil performance map is required
                    // Specify the performance map with TabularRHxDT1xTRoom
                    WarehouseCoil(CoilID).SHRCorrectionType = TabularRH_DT1_TRoom;
                    if (!(UtilityRoutines::SameString(Alphas(AlphaNum), "TabularRHxDT1xTRoom"))) {
                        ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid " +
                                         cAlphaFieldNames(AlphaNum) + "=\"" + Alphas(AlphaNum) + "\".");
                        ShowContinueError("The \"CapacityTotalSpecificConditions\" Capacity Rating Type has been specified for this air chiller.  "
                                          "This rating type requires ");
                        ShowContinueError(
                            R"(the "TabularRHxDT1xTRoom" correction curve.  Verify that a valid "TabularRHxDT1xTRoom" curve is specified in ")" +
                            cAlphaFieldNames(AlphaNum + 1) + "\".");
                    }
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "LinearSHR60")) {
                    WarehouseCoil(CoilID).SHRCorrectionType = SHR60;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "QuadraticSHR")) {
                    WarehouseCoil(CoilID).SHRCorrectionType = QuadraticSHR;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "European")) {
                    WarehouseCoil(CoilID).SHRCorrectionType = European;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "TabularRHxDT1xTRoom")) {
                    WarehouseCoil(CoilID).SHRCorrectionType = TabularRH_DT1_TRoom;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                    cAlphaFieldNames(AlphaNum) + "=\"" + Alphas(AlphaNum) + "\".");
                    ErrorsFound = true;
                }

                ++AlphaNum; // A5
                ++NumNum;   // N9
                {
                    auto const SELECT_CASE_var(WarehouseCoil(CoilID).SHRCorrectionType);
                    if (SELECT_CASE_var == SHR60) {
                        WarehouseCoil(CoilID).SHRCorrection60 = 1.48; // reference Nelson, ASHRAE journal August 2010 Fig 2
                        if (!lNumericBlanks(NumNum)) WarehouseCoil(CoilID).SHRCorrection60 = Numbers(NumNum);
                        //(1.66667 would be a perfect effectiveness, 1.0 would be artificial coil that does only sensible)
                        if (WarehouseCoil(CoilID).SHRCorrection60 > 1.67) {
                            WarehouseCoil(CoilID).SHRCorrection60 = 1.67;
                            ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                             cNumericFieldNames(NumNum) + " must be between 1 and 1.67, 1.67 will be used.");
                        }
                        if (WarehouseCoil(CoilID).SHRCorrection60 < 1.0) {
                            WarehouseCoil(CoilID).SHRCorrection60 = 1.0;
                            ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                             cNumericFieldNames(NumNum) + " must be between 1 and 1.67, 1.00 will be used.");
                        }
                    } else if (SELECT_CASE_var == European) {
                        // WarehouseCoil(CoilID)%SHRCorrectionCurvePtr = CurveManager::GetCurveIndex('ChillerEuropeanWetCoilFactor')
                        // This is a place holder, currently use embedded constants for European ratings, future may want a curve
                    } else if (SELECT_CASE_var == QuadraticSHR) {
                        WarehouseCoil(CoilID).SHRCorrectionCurvePtr = CurveManager::GetCurveIndex(Alphas(AlphaNum)); // convert curve name to number
                        if (lAlphaBlanks(AlphaNum)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                            cAlphaFieldNames(AlphaNum) + " is blank, required.");
                            ErrorsFound = true;
                        } else if (WarehouseCoil(CoilID).SHRCorrectionCurvePtr == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  ");
                            ShowContinueError("...invalid curve " + cAlphaFieldNames(AlphaNum) + "=\"" + Alphas(AlphaNum) + "\".");
                            ErrorsFound = true;
                        }
                        // error checks for curve type entered and curve name
                        ErrorsFound |= CurveManager::CheckCurveDims(WarehouseCoil(CoilID).SHRCorrectionCurvePtr, // Curve index
                            {1},                            // Valid dimensions
                            RoutineName,                    // Routine name
                            CurrentModuleObject,            // Object Type
                            WarehouseCoil(CoilID).Name,     // Object Name
                            cAlphaFieldNames(AlphaNum));    // Field Name
                    } else if (SELECT_CASE_var == TabularRH_DT1_TRoom) {
                        WarehouseCoil(CoilID).SHRCorrectionCurvePtr = CurveManager::GetCurveIndex(Alphas(AlphaNum)); // convert curve name to number
                        if (lAlphaBlanks(AlphaNum)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                            cAlphaFieldNames(AlphaNum) + " is blank, required.");
                            ErrorsFound = true;
                        } else if (WarehouseCoil(CoilID).SHRCorrectionCurvePtr == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  ");
                            ShowContinueError("...invalid curve " + cAlphaFieldNames(AlphaNum) + "=\"" + Alphas(AlphaNum) + "\".");
                            ErrorsFound = true;
                        }
                        ErrorsFound |= CurveManager::CheckCurveDims(WarehouseCoil(CoilID).SHRCorrectionCurvePtr, // Curve index
                            {3},                            // Valid dimensions
                            RoutineName,                    // Routine name
                            CurrentModuleObject,            // Object Type
                            WarehouseCoil(CoilID).Name,     // Object Name
                            cAlphaFieldNames(AlphaNum));    // Field Name
                        //        IF(WarehouseCoil(CoilID)%SHRCorrectionCurvePtr == 0) THEN
                        //          CALL ShowSevereError(RoutineName//TRIM(CurrentModuleObject)//'="'//TRIM(WarehouseCoil(CoilID)%Name)//&
                        //                           '", not found  '//TRIM(cAlphaFieldNames(AlphaNum)))
                        //          ErrorsFound = .TRUE.
                        //        END IF !valid table name
                    }
                } // SHRCorrectionType

                ++NumNum; // N10
                if (!lNumericBlanks(NumNum)) {
                    WarehouseCoil(CoilID).HeaterPower = Numbers(NumNum);
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " must be input ");
                    ErrorsFound = true;
                }

                ++AlphaNum; // A6
                if (!lAlphaBlanks(AlphaNum)) {
                    WarehouseCoil(CoilID).HeaterSchedPtr =
                        ScheduleManager::GetScheduleIndex(Alphas(AlphaNum)); // convert heater schedule name to pointer
                    if (WarehouseCoil(CoilID).HeaterSchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                        cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                        ErrorsFound = true;
                    } else { //   check heater schedule for values between 0 and 1
                        if (!ScheduleManager::CheckScheduleValueMinMax(WarehouseCoil(CoilID).HeaterSchedPtr, ">=", 0.0, "<=", 1.0)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\"");
                            ShowContinueError("Error found in " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum));
                            ShowContinueError("schedule values must be (>=0., <=1.)");
                            ErrorsFound = true;
                        } // heater schedule ptr == 0
                    }     // htr sched == 0
                } else {  // lalphaBlanks, no schedule specified
                    WarehouseCoil(CoilID).HeaterSchedPtr = AlwaysOn;
                } // not blank

                // Input fan control type
                ++AlphaNum; // A7
                if (lAlphaBlanks(AlphaNum) || UtilityRoutines::SameString(Alphas(AlphaNum), "Fixed")) {
                    WarehouseCoil(CoilID).FanType = FanConstantSpeed;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "FixedLinear")) {
                    WarehouseCoil(CoilID).FanType = FanConstantSpeedLinear;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "VariableSpeed")) {
                    WarehouseCoil(CoilID).FanType = FanVariableSpeed;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "TwoSpeed")) {
                    WarehouseCoil(CoilID).FanType = FanTwoSpeed;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                    cAlphaFieldNames(AlphaNum) + "=\"" + Alphas(AlphaNum) + "\".");
                    ErrorsFound = true;
                } // fan control type

                ++NumNum; // N11
                if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                    WarehouseCoil(CoilID).RatedFanPower = Numbers(NumNum);
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " was not input or was less than 0 ");
                    ErrorsFound = true;
                } // coil fan power

                ++NumNum; // N12
                if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) {
                    WarehouseCoil(CoilID).RatedAirVolumeFlow = Numbers(NumNum);
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " + cNumericFieldNames(NumNum) +
                                    " is required and was not input or was less than 0  ");
                } // air volume flow

                ++NumNum;                                       // N13
                WarehouseCoil(CoilID).FanMinAirFlowRatio = 0.2; // default value
                if (!lNumericBlanks(NumNum) && Numbers(NumNum) > 0.0) WarehouseCoil(CoilID).FanMinAirFlowRatio = Numbers(NumNum);

                // Input defrost type
                ++AlphaNum; // A8
                if (lAlphaBlanks(AlphaNum) || UtilityRoutines::SameString(Alphas(AlphaNum), "Electric")) {
                    WarehouseCoil(CoilID).DefrostType = DefrostElec;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "HotFluid")) {
                    WarehouseCoil(CoilID).DefrostType = DefrostFluid;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "None")) {
                    WarehouseCoil(CoilID).DefrostType = DefrostNone;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "OffCycle")) {
                    WarehouseCoil(CoilID).DefrostType = DefrostOffCycle;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                    cAlphaFieldNames(AlphaNum) + "=\"" + Alphas(AlphaNum) + "\".");
                    ErrorsFound = true;
                } // defrost type

                ++AlphaNum; // A9
                if (lAlphaBlanks(AlphaNum) || UtilityRoutines::SameString(Alphas(AlphaNum), "TimeSchedule")) {
                    WarehouseCoil(CoilID).DefrostControlType = DefrostControlSched;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "TemperatureTermination")) {
                    WarehouseCoil(CoilID).DefrostControlType = DefrostContTempTerm;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                    cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                    ErrorsFound = true;
                } // defrost control type

                // convert defrost schedule name to pointer
                ++AlphaNum; // A10
                WarehouseCoil(CoilID).DefrostSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(AlphaNum));
                if (WarehouseCoil(CoilID).DefrostSchedPtr == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                    cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                    ErrorsFound = true;
                } else { //   check defrost schedule for values between 0 and 1
                    if (!ScheduleManager::CheckScheduleValueMinMax(WarehouseCoil(CoilID).DefrostSchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + " = \"" + WarehouseCoil(CoilID).Name + "\"");
                        ShowContinueError("Error found in " + cAlphaFieldNames(AlphaNum) + '=' + Alphas(AlphaNum));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    } // checkschedulevalueMinMax
                }     // check for valid schedule name

                // convert defrost drip-down schedule name to pointer
                // some defrost types do not use drip-down schedules, use same defrost schedule pointer in that case
                ++AlphaNum; // A11
                if (!lAlphaBlanks(AlphaNum)) {
                    WarehouseCoil(CoilID).DefrostDripDownSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(AlphaNum));
                    if (WarehouseCoil(CoilID).DefrostDripDownSchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                        cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                        ErrorsFound = true;
                    } else { // check schedule for values between 0 and 1
                        if (!ScheduleManager::CheckScheduleValueMinMax(WarehouseCoil(CoilID).DefrostDripDownSchedPtr, ">=", 0.0, "<=", 1.0)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\"");
                            ShowContinueError("Error found in " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum));
                            ShowContinueError("schedule values must be (>=0., <=1.)");
                            ErrorsFound = true;
                        } // Check schedule value between 0 and 1
                    }     // Check if drip down schedule name is valid
                } else {  // .not. lAlphaBlanks  so use drip down schedule for defrost
                    WarehouseCoil(CoilID).DefrostDripDownSchedPtr = WarehouseCoil(CoilID).DefrostSchedPtr;
                } // .not. lAlphaBlanks

                ++NumNum; // N14
                if (WarehouseCoil(CoilID).DefrostType == DefrostOffCycle || WarehouseCoil(CoilID).DefrostType == DefrostNone) {
                    WarehouseCoil(CoilID).DefrostCapacity = 0.0;
                    // Don't even need to read Defrost capacity for those two defrost types.
                } else { // have electric or hot gas/brine defrost
                    if ((lNumericBlanks(NumNum)) || (Numbers(NumNum) <= 0.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " + cNumericFieldNames(NumNum) +
                                        " must be input and greater than or equal to 0 W for " + cAlphaFieldNames(AlphaNum) + ' ' + Alphas(AlphaNum));
                        ErrorsFound = true;
                    } else {
                        WarehouseCoil(CoilID).DefrostCapacity = Numbers(NumNum);
                    } // Blank  or negative Defrost Capacity

                    // defaults for defrost energy fraction are 0.7 for elec defrost and 0.3 for warm fluid
                    // note this value is only used for temperature terminated defrost control type
                    if (WarehouseCoil(CoilID).DefrostType == DefrostElec) WarehouseCoil(CoilID).DefEnergyFraction = 0.7;
                    if (WarehouseCoil(CoilID).DefrostType == DefrostFluid) WarehouseCoil(CoilID).DefEnergyFraction = 0.3;

                    ++NumNum; // N15
                    if (!lNumericBlanks(NumNum)) {
                        if ((Numbers(NumNum) > 1.0) || (Numbers(NumNum) < 0.0)) {
                            ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", " +
                                             cNumericFieldNames(NumNum) + " must be between 0 and 1, default values will be used.");
                        } else {
                            WarehouseCoil(CoilID).DefEnergyFraction = Numbers(NumNum);
                        } // number out of range
                    }     // lnumericblanks
                }         // defrost type

                ++AlphaNum; // A12
                if (lAlphaBlanks(AlphaNum) || UtilityRoutines::SameString(Alphas(AlphaNum), "Middle")) {
                    WarehouseCoil(CoilID).VerticalLocation = Middle; // default position
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "Ceiling")) {
                    WarehouseCoil(CoilID).VerticalLocation = Ceiling;
                } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "Floor")) {
                    WarehouseCoil(CoilID).VerticalLocation = Floor;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + WarehouseCoil(CoilID).Name + "\", invalid  " +
                                    cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                    ErrorsFound = true;
                } // Vertical location class

                ++NumNum; // N16
                WarehouseCoil(CoilID).DesignRefrigInventory = 0.0;
                if (!lNumericBlanks(NumNum)) WarehouseCoil(CoilID).DesignRefrigInventory = Numbers(NumNum);
            } // NumRefrigAirChillers
        }     // NumRefrigerationAirChillers > 0

        //************ START Warehouse Coil SET INPUT **************
        // One Set allowed per zone, but indiv coils within zone can be served by different compressor/condenser systems

        if (DataHeatBalance::NumRefrigChillerSets > 0) {

            CheckChillerSetName.dimension(DataHeatBalance::NumRefrigChillerSets, true);

            CurrentModuleObject = "ZoneHVAC:RefrigerationChillerSet";
            for (int SetID = 1; SetID <= DataHeatBalance::NumRefrigChillerSets; ++SetID) {
                inputProcessor->getObjectItem(CurrentModuleObject,
                                              SetID,
                                              Alphas,
                                              NumAlphas,
                                              Numbers,
                                              NumNumbers,
                                              IOStatus,
                                              lNumericBlanks,
                                              lAlphaBlanks,
                                              cAlphaFieldNames,
                                              cNumericFieldNames);
                AlphaNum = 1;
                UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                AirChillerSet(SetID).Name = Alphas(AlphaNum);

                AlphaNum = 2;
                if (!lAlphaBlanks(AlphaNum)) {
                    AirChillerSet(SetID).SchedPtr = ScheduleManager::GetScheduleIndex(Alphas(AlphaNum)); // convert schedule name to pointer
                    if (AirChillerSet(SetID).SchedPtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + AirChillerSet(SetID).Name + "\", invalid  " +
                                        cAlphaFieldNames(AlphaNum) + " not found: " + Alphas(AlphaNum));
                        ErrorsFound = true;
                    }    // ptr == 0
                } else { // no schedule specified
                    AirChillerSet(SetID).SchedPtr = AlwaysOn;
                } // not blank

                //   check availability schedule for values between 0 and 1
                if (AirChillerSet(SetID).SchedPtr > 0) {
                    if (!ScheduleManager::CheckScheduleValueMinMax(AirChillerSet(SetID).SchedPtr, ">=", 0.0, "<=", 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + AirChillerSet(SetID).Name + "\"");
                        ShowContinueError("Error found in " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum));
                        ShowContinueError("schedule values must be (>=0., <=1.)");
                        ErrorsFound = true;
                    }
                }

                ++AlphaNum;
                AirChillerSet(SetID).ZoneName = Alphas(AlphaNum);
                AirChillerSet(SetID).ZoneNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), DataHeatBalance::Zone);

                if (AirChillerSet(SetID).ZoneNum == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + AirChillerSet(SetID).Name + "\", invalid  " +
                                    cAlphaFieldNames(AlphaNum) + " not valid: " + Alphas(AlphaNum));
                    ErrorsFound = true;
                }
                AirChillerSet(SetID).ZoneNodeNum = DataZoneEquipment::GetSystemNodeNumberForZone(state, AirChillerSet(SetID).ZoneName);
                if (AirChillerSet(SetID).ZoneNodeNum == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + AirChillerSet(SetID).Name + "\" System Node Number not found for " +
                                    cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum));
                    ShowContinueError(
                        ".. Refrigeration chillers must reference a controlled Zone (appear in a ZoneHVAC:EquipmentConnections object.");
                    ErrorsFound = true;
                }
                RefrigPresentInZone(AirChillerSet(SetID).ZoneNum) = true;

                ++AlphaNum;
                if (!lAlphaBlanks(AlphaNum)) {
                    ShowMessage(RoutineName + CurrentModuleObject + "=\"" + AirChillerSet(SetID).Name + "\" " + cAlphaFieldNames(AlphaNum) +
                                " is not used. This is not an error.  Energy is exchanged directly with the zone independent of any air system. ");
                    // Node identification reserved for future use.  Currently exchange energy directly with zone outside any air system
                    // AirChillerSet(SetID)%NodeNumInlet = &
                    //       NodeInputManager::GetOnlySingleNode(Alphas(AlphaNum),ErrorsFound,TRIM(CurrentModuleObject), &
                    //                    AirChillerSet(SetID)%Name,DataLoopNode::NodeType_Air,DataLoopNode::NodeConnectionType_Inlet,1,DataLoopNode::ObjectIsNotParent)
                }

                ++AlphaNum;
                if (!lAlphaBlanks(AlphaNum)) {
                    ShowMessage(RoutineName + CurrentModuleObject + "=\"" + AirChillerSet(SetID).Name + "\" " + cAlphaFieldNames(AlphaNum) +
                                " is not used. This is not an error.  Energy is exchanged directly with the zone independent of any air system. ");
                    // Node identification reserved for future use.  Currently exchange energy directly with zone outside any air system
                    // AirChillerSet(SetID)%NodeNumOutlet = &
                    //         NodeInputManager::GetOnlySingleNode(Alphas(AlphaNum),ErrorsFound,TRIM(CurrentModuleObject), &
                    //                      AirChillerSet(SetID)%Name,DataLoopNode::NodeType_Air,DataLoopNode::NodeConnectionType_Outlet,1,DataLoopNode::ObjectIsNotParent)
                }

                // An extensible list is used to enter the individual names of each chiller in the set.
                // These chillers will be dispatched in this list order to meet the required zone load
                int NumChillersInSet = NumAlphas - AlphaNum;
                int AlphaStartList = AlphaNum; //+ 1
                AirChillerSet(SetID).NumCoils = NumChillersInSet;
                if (!allocated(AirChillerSet(SetID).CoilNum)) AirChillerSet(SetID).CoilNum.allocate(NumChillersInSet);
                for (int ChillerIndex = 1; ChillerIndex <= NumChillersInSet; ++ChillerIndex) {
                    int AlphaListNum = AlphaStartList + ChillerIndex;
                    if (!lAlphaBlanks(AlphaListNum)) {
                        int CoilNum = UtilityRoutines::FindItemInList(Alphas(AlphaListNum), WarehouseCoil);
                        if (CoilNum == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + AirChillerSet(SetID).Name + "\", has an invalid " +
                                            cAlphaFieldNames(AlphaListNum) + " defined as " + Alphas(AlphaListNum));
                            ErrorsFound = true;
                        } // == 0
                        AirChillerSet(SetID).CoilNum(ChillerIndex) = CoilNum;
                        WarehouseCoil(CoilNum).ZoneName = AirChillerSet(SetID).ZoneName;
                        WarehouseCoil(CoilNum).ZoneNum = AirChillerSet(SetID).ZoneNum;
                        WarehouseCoil(CoilNum).ZoneNodeNum = AirChillerSet(SetID).ZoneNodeNum;
                    } // ! = alphablanks
                }     // CoilID over NumChillersInSet
            }         // NumChillerSets
        }             // NumChillerSets > 0
        //************* End Air Chiller Sets

        //**** Read CaseAndWalkIn Lists **********************************************************
        if (NumSimulationCaseAndWalkInLists > 0) {
            CurrentModuleObject = "Refrigeration:CaseAndWalkInList";
            for (int ListNum = 1; ListNum <= NumSimulationCaseAndWalkInLists; ++ListNum) {
                inputProcessor->getObjectItem(CurrentModuleObject,
                                              ListNum,
                                              Alphas,
                                              NumAlphas,
                                              Numbers,
                                              NumNumbers,
                                              IOStatus,
                                              lNumericBlanks,
                                              lAlphaBlanks,
                                              cAlphaFieldNames,
                                              cNumericFieldNames);
                UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);
                CaseAndWalkInList(ListNum).Name = Alphas(1);

                // CaseAndWalkInList alphas include CaseAndWalkInList name and one name for each Case or WalkIn in list
                // below allocates larger than needed (each allocated to sum of both), but avoids two loops through input fields
                int NumTotalLoadsOnList = NumAlphas - 1;
                if (!allocated(CaseAndWalkInList(ListNum).WalkInItemNum)) CaseAndWalkInList(ListNum).WalkInItemNum.allocate(NumTotalLoadsOnList);
                if (!allocated(CaseAndWalkInList(ListNum).CaseItemNum)) CaseAndWalkInList(ListNum).CaseItemNum.allocate(NumTotalLoadsOnList);
                if (!allocated(CaseAndWalkInList(ListNum).CoilItemNum)) CaseAndWalkInList(ListNum).CoilItemNum.allocate(NumTotalLoadsOnList);

                int NumCasesOnList = 0;
                int NumCoilsOnList = 0;
                int NumWalkInsOnList = 0;
                int LoadCount = 0;
                for (int NumLoad = 1; NumLoad <= NumTotalLoadsOnList; ++NumLoad) {
                    int AlphaListNum = 1 + NumLoad;
                    if (!lAlphaBlanks(AlphaListNum)) {
                        ++LoadCount;
                        int LoadWalkInNum = 0;
                        int LoadCaseNum = 0;
                        int LoadCoilNum = 0;
                        if (NumSimulationWalkIns > 0) LoadWalkInNum = UtilityRoutines::FindItemInList(Alphas(AlphaListNum), WalkIn);
                        if (NumSimulationCases > 0) LoadCaseNum = UtilityRoutines::FindItemInList(Alphas(AlphaListNum), RefrigCase);
                        if (NumSimulationRefrigAirChillers > 0) LoadCoilNum = UtilityRoutines::FindItemInList(Alphas(AlphaListNum), WarehouseCoil);
                        if ((LoadWalkInNum == 0) && (LoadCaseNum == 0) && (LoadCoilNum == 0)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + cAlphaFieldNames(AlphaListNum) +
                                            "\", has an invalid value of " + Alphas(AlphaListNum));
                            ErrorsFound = true;
                        } else if ((LoadWalkInNum != 0) && (LoadCaseNum != 0) && (LoadCoilNum != 0)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + cAlphaFieldNames(AlphaListNum) + "\", " +
                                            Alphas(AlphaListNum) + " Case and WalkIns and Refrigerated Coils cannot have the same name.");
                            ErrorsFound = true;
                        } else if (LoadWalkInNum != 0) {
                            ++NumWalkInsOnList;
                            CaseAndWalkInList(ListNum).WalkInItemNum(NumWalkInsOnList) = LoadWalkInNum;
                        } else if (LoadCaseNum != 0) {
                            ++NumCasesOnList;
                            CaseAndWalkInList(ListNum).CaseItemNum(NumCasesOnList) = LoadCaseNum;
                        } else if (LoadCoilNum != 0) {
                            ++NumCoilsOnList;
                            CaseAndWalkInList(ListNum).CoilItemNum(NumCoilsOnList) = LoadCoilNum;
                        }
                    } // lAlphaBlanks
                }     // Num Total Loads on List
                if (LoadCount == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + ", \"" + CaseAndWalkInList(ListNum).Name +
                                    "\" : degenerate list All entries were blank.");
                    ErrorsFound = true;
                } // loadcount == 0
                CaseAndWalkInList(ListNum).NumCases = NumCasesOnList;
                CaseAndWalkInList(ListNum).NumCoils = NumCoilsOnList;
                CaseAndWalkInList(ListNum).NumWalkIns = NumWalkInsOnList;
            } // ListNum=1,NumSimulationCaseAndWalkInLists
        }     //(NumSimulationCaseAndWalkInLists > 0)

        //**** End read CaseAndWalkIn Lists **********************************************************

        //************** Start RefrigerationRacks

        if (DataHeatBalance::NumRefrigeratedRacks > 0) {

            CurrentModuleObject = "Refrigeration:CompressorRack";

            for (int RackNum = 1; RackNum <= DataHeatBalance::NumRefrigeratedRacks; ++RackNum) {

                inputProcessor->getObjectItem(CurrentModuleObject,
                                              RackNum,
                                              Alphas,
                                              NumAlphas,
                                              Numbers,
                                              NumNumbers,
                                              IOStatus,
                                              lNumericBlanks,
                                              lAlphaBlanks,
                                              cAlphaFieldNames,
                                              cNumericFieldNames);
                UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                RefrigRack(RackNum).Name = Alphas(1);
                RefrigRack(RackNum).MyIdx = RackNum;
                DataHeatBalance::HeatReclaimRefrigeratedRack(RackNum).Name = Alphas(1);
                DataHeatBalance::HeatReclaimRefrigeratedRack(RackNum).SourceType = CurrentModuleObject;
                if (UtilityRoutines::SameString(Alphas(2), "Outdoors")) {
                    RefrigRack(RackNum).HeatRejectionLocation = LocationOutdoors;
                } else if (UtilityRoutines::SameString(Alphas(2), "Zone")) {
                    RefrigRack(RackNum).HeatRejectionLocation = LocationZone;
                    // don't need to set RefrigPresentInZone to .TRUE. here because only allowed to reject heat to zone
                    // holding all served cases,  so already set when case read in
                } else {
                    RefrigRack(RackNum).HeatRejectionLocation = LocationOutdoors;
                    ShowWarningError(CurrentModuleObject + ", " + cAlphaFieldNames(1) + " = \"" + RefrigRack(RackNum).Name +
                                     "\": " + cAlphaFieldNames(2) + " defined as " + Alphas(2) + " not found. Will assume " + cAlphaFieldNames(2) +
                                     " is OUTDOORS and simulation continues.");
                }

                RefrigRack(RackNum).RatedCOP = Numbers(1);

                if (RefrigRack(RackNum).RatedCOP <= 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\" " + cNumericFieldNames(1) +
                                    " must be greater than 0.0");
                    ErrorsFound = true;
                }

                RefrigRack(RackNum).COPFTempPtr = CurveManager::GetCurveIndex(Alphas(3)); // convert curve name to number
                if (RefrigRack(RackNum).COPFTempPtr == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", invalid  " + cAlphaFieldNames(3) +
                                    " not found:" + Alphas(3));
                    ErrorsFound = true;
                }

                ErrorsFound |= CurveManager::CheckCurveDims(RefrigRack(RackNum).COPFTempPtr, // Curve index
                    {1},                            // Valid dimensions
                    RoutineName,                    // Routine name
                    CurrentModuleObject,            // Object Type
                    RefrigRack(RackNum).Name,     // Object Name
                    cAlphaFieldNames(3));    // Field Name

                RefrigRack(RackNum).CondenserFanPower = Numbers(2);
                if (Numbers(2) < 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\" " + cNumericFieldNames(2) +
                                    " must be greater than or equal to 0 Watts.");
                    ErrorsFound = true;
                }

                RefrigRack(RackNum).TotCondFTempPtr = CurveManager::GetCurveIndex(Alphas(4)); // convert curve name to number
                if ((!lAlphaBlanks(4)) && RefrigRack(RackNum).TotCondFTempPtr == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", invalid  " + cAlphaFieldNames(4) +
                                    " not found:" + Alphas(4));
                    ErrorsFound = true;
                }

                if (!lAlphaBlanks(4)) {
                    ErrorsFound |= CurveManager::CheckCurveDims(RefrigRack(RackNum).TotCondFTempPtr, // Curve index
                        {1},                            // Valid dimensions
                        RoutineName,                    // Routine name
                        CurrentModuleObject,            // Object Type
                        RefrigRack(RackNum).Name,     // Object Name
                        cAlphaFieldNames(4));    // Field Name
                }

                if (UtilityRoutines::SameString(Alphas(5), "EvaporativelyCooled")) {
                    RefrigRack(RackNum).CondenserType = DataHeatBalance::RefrigCondenserTypeEvap;
                    if (RefrigRack(RackNum).HeatRejectionLocation == LocationZone) {
                        ShowWarningError(CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\" Evap cooled " + cAlphaFieldNames(5) +
                                         " not available with " + cAlphaFieldNames(2) + " = Zone.");
                        ShowContinueError(cAlphaFieldNames(5) + " reset to Air Cooled and simulation continues.");
                        RefrigRack(RackNum).CondenserType = DataHeatBalance::RefrigCondenserTypeAir;
                    }
                } else if (UtilityRoutines::SameString(Alphas(5), "WaterCooled")) {
                    RefrigRack(RackNum).CondenserType = DataHeatBalance::RefrigCondenserTypeWater;
                    if (RefrigRack(RackNum).HeatRejectionLocation == LocationZone) {
                        ShowWarningError(CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\" Water cooled " + cAlphaFieldNames(5) +
                                         " not available with " + cAlphaFieldNames(2) + " = Zone.");
                        ShowContinueError(cAlphaFieldNames(5) + " reset to Air Cooled and simulation continues.");
                        RefrigRack(RackNum).CondenserType = DataHeatBalance::RefrigCondenserTypeAir;
                    }
                } else {
                    RefrigRack(RackNum).CondenserType = DataHeatBalance::RefrigCondenserTypeAir;
                }
                // Get water-cooled condenser input, if applicable
                if (RefrigRack(RackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeWater) {
                    RefrigRack(RackNum).InletNode = NodeInputManager::GetOnlySingleNode(Alphas(6),
                                                                                        ErrorsFound,
                                                                                        CurrentModuleObject,
                                                                                        Alphas(1),
                                                                                        DataLoopNode::NodeType_Water,
                                                                                        DataLoopNode::NodeConnectionType_Inlet,
                                                                                        1,
                                                                                        DataLoopNode::ObjectIsNotParent);
                    RefrigRack(RackNum).OutletNode = NodeInputManager::GetOnlySingleNode(Alphas(7),
                                                                                         ErrorsFound,
                                                                                         CurrentModuleObject,
                                                                                         Alphas(1),
                                                                                         DataLoopNode::NodeType_Water,
                                                                                         DataLoopNode::NodeConnectionType_Outlet,
                                                                                         1,
                                                                                         DataLoopNode::ObjectIsNotParent);
                    // Check node connections
                    BranchNodeConnections::TestCompSet(CurrentModuleObject, Alphas(1), Alphas(6), Alphas(7), "RefrigRack Nodes");
                    // Get loop flow type
                    if (UtilityRoutines::SameString(Alphas(8), "VariableFlow")) {
                        RefrigRack(RackNum).FlowType = VariableFlow;
                    } else if (UtilityRoutines::SameString(Alphas(8), "ConstantFlow")) {
                        RefrigRack(RackNum).FlowType = ConstantFlow;
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", invalid  " + cAlphaFieldNames(8) +
                                        " not recognized: " + Alphas(8));
                        ShowContinueError("Check input value choices.");
                        ErrorsFound = true;
                    }
                    // Get outlet temperature schedule for variable flow case
                    if (RefrigRack(RackNum).FlowType == VariableFlow) {
                        if (lAlphaBlanks(9)) {
                            RefrigRack(RackNum).OutletTempSchedPtr = 0;
                        } else {
                            RefrigRack(RackNum).OutletTempSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(9)); // convert schedule name to pointer
                        }
                        if (RefrigRack(RackNum).OutletTempSchedPtr == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", invalid  " +
                                            cAlphaFieldNames(9) + " : " + Alphas(9));
                            ShowContinueError("A schedule with this name is not defined in this input data file.");
                            ErrorsFound = true;
                        }
                    }
                    // Get volumetric flow rate if applicable
                    if (RefrigRack(RackNum).FlowType == ConstantFlow) {
                        RefrigRack(RackNum).DesVolFlowRate = Numbers(3);
                        RefrigRack(RackNum).VolFlowRate = Numbers(3);
                    }
                    // Get maximum flow rates
                    RefrigRack(RackNum).VolFlowRateMax = Numbers(4);

                    // Check constant flow for max violation, if applicable
                    if (RefrigRack(RackNum).FlowType == ConstantFlow && RefrigRack(RackNum).VolFlowRate > Numbers(4)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\" " + cNumericFieldNames(3) + " > " +
                                        cNumericFieldNames(4) + '.');
                        ShowContinueError("Revise flow rates.");
                        ErrorsFound = true;
                    }
                    // Get max/min allowed water temps
                    RefrigRack(RackNum).OutletTempMax = Numbers(5);
                    RefrigRack(RackNum).InletTempMin = Numbers(6);
                    // set flow request for plant sizing.
                    PlantUtilities::RegisterPlantCompDesignFlow(RefrigRack(RackNum).InletNode, RefrigRack(RackNum).VolFlowRateMax);
                } // Water cooled condenser data

                // Get evaporative cooled condenser input
                if (lAlphaBlanks(10)) {
                    RefrigRack(RackNum).EvapSchedPtr = 0;
                } else {
                    RefrigRack(RackNum).EvapSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(10)); // convert schedule name to pointer
                    //   check availability schedule for values >= 0
                    if (RefrigRack(RackNum).EvapSchedPtr > 0) {
                        if (!ScheduleManager::CheckScheduleValueMinMax(RefrigRack(RackNum).EvapSchedPtr, ">=", 0.0)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\" .");
                            ShowContinueError("Error found in " + cAlphaFieldNames(10) + " = " + Alphas(10));
                            ShowContinueError("schedule values must be (>=0.).");
                            ErrorsFound = true;
                        }
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", invalid  " +
                                        cAlphaFieldNames(10) + " = " + Alphas(10));
                        ShowContinueError("A schedule with this name is not defined in this input data file.");
                        ErrorsFound = true;
                    }
                }

                RefrigRack(RackNum).EvapEffect = Numbers(7);
                if (RefrigRack(RackNum).EvapEffect < 0.0 || RefrigRack(RackNum).EvapEffect > 1.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\" " + cNumericFieldNames(7) +
                                    " cannot be less than zero or greater than 1.0.");
                    ErrorsFound = true;
                }

                RefrigRack(RackNum).CondenserAirFlowRate = Numbers(8);
                if (RefrigRack(RackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap &&
                    RefrigRack(RackNum).CondenserAirFlowRate <= 0.0 && RefrigRack(RackNum).CondenserAirFlowRate != DataGlobals::AutoCalculate) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", " + cNumericFieldNames(8) +
                                    " cannot be less than or equal to zero.");
                    ErrorsFound = true;
                }

                //   Basin heater power as a function of temperature must be greater than or equal to 0
                RefrigRack(RackNum).BasinHeaterPowerFTempDiff = Numbers(9);
                if (RefrigRack(RackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap && Numbers(9) < 0.0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", " + cNumericFieldNames(9) +
                                    " must be >= 0");
                    ErrorsFound = true;
                }

                RefrigRack(RackNum).BasinHeaterSetPointTemp = Numbers(10);
                if (RefrigRack(RackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap &&
                    RefrigRack(RackNum).BasinHeaterSetPointTemp < 2.0) {
                    ShowWarningError(CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", " + cNumericFieldNames(10) +
                                     " is less than 2 deg C. Freezing could occur.");
                }

                RefrigRack(RackNum).EvapPumpPower = Numbers(11);
                if (RefrigRack(RackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap && RefrigRack(RackNum).EvapPumpPower < 0.0 &&
                    RefrigRack(RackNum).EvapPumpPower != DataGlobals::AutoCalculate) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", " + cNumericFieldNames(11) +
                                    " cannot be less than zero.");
                    ErrorsFound = true;
                }

                // Get Water System tank connections
                RefrigRack(RackNum).SupplyTankName = Alphas(11);
                if (lAlphaBlanks(11)) {
                    RefrigRack(RackNum).EvapWaterSupplyMode = WaterSupplyFromMains;
                } else {
                    RefrigRack(RackNum).EvapWaterSupplyMode = WaterSupplyFromTank;
                    WaterManager::SetupTankDemandComponent(RefrigRack(RackNum).Name,
                                             CurrentModuleObject,
                                             RefrigRack(RackNum).SupplyTankName,
                                             ErrorsFound,
                                             RefrigRack(RackNum).EvapWaterSupTankID,
                                             RefrigRack(RackNum).EvapWaterTankDemandARRID);
                }

                // Check condenser air inlet node connection
                if (lAlphaBlanks(12)) {
                    RefrigRack(RackNum).OutsideAirNodeNum = 0;
                } else {
                    RefrigRack(RackNum).OutsideAirNodeNum = NodeInputManager::GetOnlySingleNode(Alphas(12),
                                                                              ErrorsFound,
                                                                              CurrentModuleObject,
                                                                              Alphas(1),
                                                                                                DataLoopNode::NodeType_Air,
                                                                                                DataLoopNode::NodeConnectionType_OutsideAirReference,
                                                                              1,
                                                                                                DataLoopNode::ObjectIsParent);
                    if (!OutAirNodeManager::CheckOutAirNodeNumber(RefrigRack(RackNum).OutsideAirNodeNum)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", " + cAlphaFieldNames(12) +
                                        " not found: " + Alphas(12));
                        ShowContinueError("...does not appear in an OutdoorAir:NodeList or as an OutdoorAir:Node.");
                        ErrorsFound = true;
                    }
                }

                if (!lAlphaBlanks(13)) RefrigRack(RackNum).EndUseSubcategory = Alphas(13);

                // Read all loads on this rack: cases and walk-ins and coils
                NumCases = 0;
                int NumCoils = 0;
                NumWalkIns = 0;
                RefrigRack(RackNum).NumCases = 0;
                RefrigRack(RackNum).NumCoils = 0;
                RefrigRack(RackNum).NumWalkIns = 0;
                RefrigRack(RackNum).TotalRackLoad = 0.0;

                //   Read display case and walkin assignments for this rack
                AlphaNum = 14;
                if (lAlphaBlanks(AlphaNum)) {
                    // No cases or walkins or coils specified, ie, rack has no load
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name +
                                    "\" : has no loads, must have at least one of: " + cAlphaFieldNames(14));
                    ErrorsFound = true;
                } else { // (.NOT. lAlphaBlanks(AlphaNum))
                    // Entry for Alphas(AlphaNum) can be either a Case, WalkIn, Coil, or CaseAndWalkInList name
                    int CaseAndWalkInListNum = 0;
                    int CaseNum = 0;
                    int WalkInNum = 0;
                    int CoilNum = 0;
                    if (NumSimulationCaseAndWalkInLists > 0)
                        CaseAndWalkInListNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), CaseAndWalkInList);
                    if (NumSimulationCases > 0) CaseNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), RefrigCase);
                    if (NumSimulationWalkIns > 0) WalkInNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), WalkIn);
                    if (NumSimulationRefrigAirChillers > 0) CoilNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), WarehouseCoil);
                    int NumNameMatches = 0;
                    if (CaseAndWalkInListNum != 0) ++NumNameMatches;
                    if (CaseNum != 0) ++NumNameMatches;
                    if (WalkInNum != 0) ++NumNameMatches;
                    if (CoilNum != 0) ++NumNameMatches;

                    if (NumNameMatches != 1) { // name must uniquely point to a list or a single case or walkin
                        ErrorsFound = true;
                        if (NumNameMatches == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\" : has an invalid " +
                                            cAlphaFieldNames(AlphaNum) + ": " + Alphas(AlphaNum));
                        } else if (NumNameMatches > 1) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name +
                                            "\" : has a non-unique name that could be either a " + cAlphaFieldNames(AlphaNum) + ": " +
                                            Alphas(AlphaNum));
                        }                                   // num matches = 0 or > 1
                    } else if (CaseAndWalkInListNum != 0) { // Name points to a CaseAndWalkInList
                        NumCoils = CaseAndWalkInList(CaseAndWalkInListNum).NumCoils;
                        NumCases = CaseAndWalkInList(CaseAndWalkInListNum).NumCases;
                        NumWalkIns = CaseAndWalkInList(CaseAndWalkInListNum).NumWalkIns;
                        RefrigRack(RackNum).NumCoils = NumCoils;
                        RefrigRack(RackNum).NumCases = NumCases;
                        RefrigRack(RackNum).NumWalkIns = NumWalkIns;
                        if (!allocated(RefrigRack(RackNum).CoilNum)) RefrigRack(RackNum).CoilNum.allocate(NumCoils);
                        RefrigRack(RackNum).CoilNum({1, NumCoils}) = CaseAndWalkInList(CaseAndWalkInListNum).CoilItemNum({1, NumCoils});
                        if (!allocated(RefrigRack(RackNum).CaseNum)) RefrigRack(RackNum).CaseNum.allocate(NumCases);
                        RefrigRack(RackNum).CaseNum({1, NumCases}) = CaseAndWalkInList(CaseAndWalkInListNum).CaseItemNum({1, NumCases});
                        if (!allocated(RefrigRack(RackNum).WalkInNum)) RefrigRack(RackNum).WalkInNum.allocate(NumWalkIns);
                        RefrigRack(RackNum).WalkInNum({1, NumWalkIns}) = CaseAndWalkInList(CaseAndWalkInListNum).WalkInItemNum({1, NumWalkIns});
                    } else if (CoilNum != 0) { // Name points to a coil
                        NumCoils = 1;
                        RefrigRack(RackNum).NumCoils = 1;
                        if (!allocated(RefrigRack(RackNum).CoilNum)) RefrigRack(RackNum).CoilNum.allocate(NumCoils);
                        RefrigRack(RackNum).CoilNum(NumCoils) = CoilNum;
                    } else if (CaseNum != 0) { // Name points to a case
                        NumCases = 1;
                        RefrigRack(RackNum).NumCases = 1;
                        if (!allocated(RefrigRack(RackNum).CaseNum)) RefrigRack(RackNum).CaseNum.allocate(NumCases);
                        RefrigRack(RackNum).CaseNum(NumCases) = CaseNum;
                    } else if (WalkInNum != 0) { // Name points to a walkin
                        NumWalkIns = 1;
                        RefrigRack(RackNum).NumWalkIns = 1;
                        if (!allocated(RefrigRack(RackNum).WalkInNum)) RefrigRack(RackNum).WalkInNum.allocate(NumWalkIns);
                        RefrigRack(RackNum).WalkInNum(NumWalkIns) = WalkInNum;
                    } // NumNameMatches /= 1
                }     // blank input for loads on rack

                if (NumCases > 0) {
                    for (int caseIndex = 1; caseIndex <= NumCases; ++caseIndex) {
                        int caseID = RefrigRack(RackNum).CaseNum(caseIndex);
                        // mark all cases on rack as used by this system (checking for unused or non-unique cases)
                        ++RefrigCase(caseID).NumSysAttach;
                        // determine total capacity on rack
                        RefrigRack(RackNum).TotalRackLoad += RefrigCase(caseID).DesignRatedCap;
                    } // CaseIndex=1,NumCases
                    //     check that all refrigerated cases attached to a rack are to the same zone if heat rejection location is "Zone"
                    //     however, won't matter if walk-in specified
                    if (RefrigRack(RackNum).HeatRejectionLocation == LocationZone && RefrigRack(RackNum).NumCases > 1 &&
                        RefrigCase(RefrigRack(RackNum).CaseNum(1)).ActualZoneNum != 0 && NumWalkIns < 1 && NumCoils < 1) {
                        int ZoneNum = RefrigCase(RefrigRack(RackNum).CaseNum(1)).ActualZoneNum;
                        for (int caseIndex = 2; caseIndex <= RefrigRack(RackNum).NumCases; ++caseIndex) {
                            if (RefrigCase(RefrigRack(RackNum).CaseNum(caseIndex)).ActualZoneNum == ZoneNum) continue;
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name +
                                            "\" : All cases attached to a rack must be in the same zone when " + cAlphaFieldNames(2) +
                                            " equals \"Zone\".");
                            ErrorsFound = true;
                            break;
                        }
                    } // heat rejection location is zone
                }     // numcases > 0

                if (NumCoils > 0) {
                    RefrigRack(RackNum).CoilFlag = true;
                    for (int CoilIndex = 1; CoilIndex <= NumCoils; ++CoilIndex) {
                        int CoilNum = RefrigRack(RackNum).CoilNum(CoilIndex);
                        // mark all Coils on rack as used by this system (checking for unused or non-unique Coils)
                        ++WarehouseCoil(CoilNum).NumSysAttach;
                        // determine total capacity on rack
                        RefrigRack(RackNum).TotalRackLoad += WarehouseCoil(CoilNum).RatedSensibleCap;
                    } // CoilIndex=1,NumCoils
                }     // numcoils > 0

                if (NumWalkIns > 0) {
                    for (int WalkInIndex = 1; WalkInIndex <= NumWalkIns; ++WalkInIndex) {
                        int WalkInID = RefrigRack(RackNum).WalkInNum(WalkInIndex);
                        // mark all WalkIns on rack as used by this system (checking for unused or non-unique WalkIns)
                        ++WalkIn(WalkInID).NumSysAttach;
                        // determine total capacity on rack
                        RefrigRack(RackNum).TotalRackLoad += WalkIn(WalkInID).DesignRatedCap;
                    } // WalkInIndex=1,NumWalkIns
                }     // NumWalkins

                if (NumWalkIns > 0 || NumCoils > 0) {
                    // Get the heat rejection Zone node number from the zone name entered by the user (if heatrej location = zone)
                    if (RefrigRack(RackNum).HeatRejectionLocation == LocationZone) {
                        if (lAlphaBlanks(15)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + cAlphaFieldNames(15) +
                                            " must be input if walkins or AirChillers connected to rack and heat rejection location = zone.");
                            ErrorsFound = true;
                        } else { // alpha (15) not blank
                            RefrigRack(RackNum).HeatRejectionZoneNum = UtilityRoutines::FindItemInList(Alphas(15), DataHeatBalance::Zone);
                            RefrigRack(RackNum).HeatRejectionZoneNodeNum = DataZoneEquipment::GetSystemNodeNumberForZone(state, Alphas(15));
                            if (RefrigRack(RackNum).HeatRejectionZoneNum == 0) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + RefrigRack(RackNum).Name + "\", invalid  " +
                                                cAlphaFieldNames(15) + " not valid: " + Alphas(15));
                                ErrorsFound = true;
                            } else {
                                RefrigPresentInZone(RefrigRack(RackNum).HeatRejectionZoneNum) = true;
                            } // zonenum == 0
                        }     // alpha 15 blank
                    }         // zone heat rej and walk-ins or coils present, must input heat rejection zone
                }             // numwalkins or coils > 0

                // set condenser air flow and evap water pump power if autocalculated
                // autocalculate condenser evap water pump if needed
                if (RefrigRack(RackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap &&
                    RefrigRack(RackNum).EvapPumpPower == DataGlobals::AutoCalculate) {
                    RefrigRack(RackNum).EvapPumpPower = CondPumpRatePower * RefrigRack(RackNum).TotalRackLoad;
                }
                // autocalculate evap condenser air volume flow rate if needed
                if (RefrigRack(RackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap &&
                    RefrigRack(RackNum).CondenserAirFlowRate == DataGlobals::AutoCalculate) {
                    RefrigRack(RackNum).CondenserAirFlowRate = AirVolRateEvapCond * RefrigRack(RackNum).TotalRackLoad;
                }

            } // RackNum=1,NumRefrigeratedRacks

            CheckEquipNameRackWaterCondenser.dimension(DataHeatBalance::NumRefrigeratedRacks, true);
        } //(NumRefrigeratedRacks > 0)

        if (DataHeatBalance::NumRefrigSystems > 0 || NumTransRefrigSystems > 0) {

            if (DataHeatBalance::NumRefrigSystems > 0 && DataHeatBalance::NumRefrigCondensers == 0) {
                ShowSevereError("Refrigeration:System objects were found during input processing, however no Rrefrigeration condenser objects (which "
                                "may be either: ");
                ShowContinueError(" Refrigeration:Condenser:AirCooled, Refrigeration:Condenser:WaterCooled, "
                                  "Refrigeration:Condenser:EvaporativeCooled,or Refrigeration:Condenser:CascadeCooled) were found.");
                ErrorsFound = true;
            }
            if (NumTransRefrigSystems > 0 && NumSimulationGasCooler == 0) {
                ShowSevereError("Refrigeration:TranscriticalSystem objects were found during input processing, however no Refrigeration gas cooler "
                                "objects (Refrigeration:GasCooler:AirCooled) were found.");
                ErrorsFound = true;
            }
            if (NumSimulationCompressors == 0) {
                ShowSevereError(
                    "Refrigeration:System objects were found during input processing, however no Refrigeration:Compressor objects were found.");
                ErrorsFound = true;
            }

            //************ START CONDENSER INPUT  **************

            if (NumSimulationCondAir > 0) {
                CurrentModuleObject = "Refrigeration:Condenser:AirCooled";
                for (int CondNum = 1; CondNum <= NumSimulationCondAir; ++CondNum) {
                    inputProcessor->getObjectItem(CurrentModuleObject,
                                                  CondNum,
                                                  Alphas,
                                                  NumAlphas,
                                                  Numbers,
                                                  NumNumbers,
                                                  IOStatus,
                                                  lNumericBlanks,
                                                  lAlphaBlanks,
                                                  cAlphaFieldNames,
                                                  cNumericFieldNames);
                    GlobalNames::VerifyUniqueInterObjectName(UniqueCondenserNames, Alphas(1), CurrentModuleObject, cAlphaFieldNames(1), ErrorsFound);
                    Condenser(CondNum).Name = Alphas(1);
                    DataHeatBalance::HeatReclaimRefrigCondenser(CondNum).Name = Alphas(1);
                    Condenser(CondNum).CapCurvePtr = CurveManager::GetCurveIndex(Alphas(2)); // convert curve name to number
                    if (Condenser(CondNum).CapCurvePtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", invalid  " + cAlphaFieldNames(2) +
                                        " not found:" + Alphas(2));
                        ErrorsFound = true;
                    }

                    // set start of count for number of systems attached to this condenser
                    Condenser(CondNum).NumSysAttach = 0;
                    if (!allocated(Condenser(CondNum).SysNum)) Condenser(CondNum).SysNum.allocate(DataHeatBalance::NumRefrigSystems);

                    // set CondenserType and rated temperature difference (51.7 - 35)C per ARI 460
                    Condenser(CondNum).CondenserType = DataHeatBalance::RefrigCondenserTypeAir;
                    DataHeatBalance::HeatReclaimRefrigCondenser(CondNum).SourceType = CurrentModuleObject;
                    Condenser(CondNum).RatedDelT = CondARI460DelT; //= 16.7d0 ,Rated sat cond temp - dry bulb air T for air-cooled Condensers, ARI460
                    Condenser(CondNum).RatedTCondense = CondARI460Tcond;
                    if (Condenser(CondNum).CapCurvePtr > 0) {
                        Condenser(CondNum).RatedCapacity = CurveManager::CurveValue(Condenser(CondNum).CapCurvePtr, CondARI460DelT);
                    }
                    // elevation capacity correction on air-cooled condensers, Carrier correlation more conservative than Trane
                    Condenser(CondNum).RatedCapacity *= (1.0 - 7.17e-5 * DataEnvironment::Elevation);
                    if (Condenser(CondNum).RatedCapacity > 0.0) {
                        CurveManager::GetCurveMinMaxValues(Condenser(CondNum).CapCurvePtr, DelTempMin, DelTempMax);
                        Real64 Capmin = CurveManager::CurveValue(Condenser(CondNum).CapCurvePtr, DelTempMin) *
                                        (1.0 - 7.17e-5 * DataEnvironment::Elevation); // Mar 2011 bug fix
                        Real64 Capmax = CurveManager::CurveValue(Condenser(CondNum).CapCurvePtr, DelTempMax) *
                                        (1.0 - 7.17e-5 * DataEnvironment::Elevation); // Mar 2011 bug
                        Condenser(CondNum).TempSlope =
                            (DelTempMax - DelTempMin) / ((Capmax - Capmin)); // * ( 1.0 - 7.17e-5 * DataEnvironment::Elevation ) ) //Mar 2011 bug fix
                        Condenser(CondNum).MinCondLoad = Capmax - DelTempMax / Condenser(CondNum).TempSlope;
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name +
                                        "\" Condenser capacity curve per ARI 460 must be input and must be greater than 0 Watts at 16.7C temperature "
                                        "difference.");
                        ErrorsFound = true;
                    }

                    Condenser(CondNum).RatedSubcool = 0.0; // default value
                    if (!lNumericBlanks(1)) Condenser(CondNum).RatedSubcool = Numbers(1);

                    // Get fan control type
                    if (UtilityRoutines::SameString(Alphas(3), "FixedLinear")) {
                        Condenser(CondNum).FanSpeedControlType = FanConstantSpeedLinear;
                    } else if (UtilityRoutines::SameString(Alphas(3), "VariableSpeed")) {
                        Condenser(CondNum).FanSpeedControlType = FanVariableSpeed;
                    } else if (UtilityRoutines::SameString(Alphas(3), "TwoSpeed")) {
                        Condenser(CondNum).FanSpeedControlType = FanTwoSpeed;
                    } else {
                        Condenser(CondNum).FanSpeedControlType = FanConstantSpeed; // default
                    }                                                              // Set fan control type

                    if (!lNumericBlanks(2)) Condenser(CondNum).RatedFanPower = Numbers(2);
                    if ((lNumericBlanks(2)) || (Numbers(2) < 0.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(2) +
                                        " must be input greater than or equal to 0 Watts.");
                        ErrorsFound = true;
                    }

                    Condenser(CondNum).FanMinAirFlowRatio = 0.2; // default value
                    if (!lNumericBlanks(3)) Condenser(CondNum).FanMinAirFlowRatio = Numbers(3);

                    // Check condenser air inlet node connection
                    // Jan 2011 - added ability to reject heat to a zone from air-cooled condenser
                    Condenser(CondNum).CondenserRejectHeatToZone = false;
                    if (lAlphaBlanks(4)) {
                        Condenser(CondNum).InletAirNodeNum = 0;
                    } else { // see if it's an outside air node name or an indoor zone name,
                        // have to check inside first because outside check automatically generates an error message
                        Condenser(CondNum).InletAirZoneNum = UtilityRoutines::FindItemInList(Alphas(4), DataHeatBalance::Zone);
                        // need to clearly id node number for air inlet conditions and zone number for casecredit assignment
                        if (Condenser(CondNum).InletAirZoneNum != 0) {
                            // set condenser flag (later used to set system flag) and zone flag
                            Condenser(CondNum).InletAirNodeNum = DataZoneEquipment::GetSystemNodeNumberForZone(state, Alphas(4));
                            Condenser(CondNum).CondenserRejectHeatToZone = true;
                            RefrigPresentInZone(Condenser(CondNum).InletAirZoneNum) = true;
                        } else { // not in a conditioned zone, so see if it's outside
                            Condenser(CondNum).InletAirNodeNum =
                                NodeInputManager::GetOnlySingleNode(Alphas(4),
                                                                                   ErrorsFound,
                                                                                   CurrentModuleObject,
                                                                                   Alphas(1),
                                                                    DataLoopNode::NodeType_Air,
                                                                    DataLoopNode::NodeConnectionType_OutsideAirReference,
                                                                                   1,
                                                                    DataLoopNode::ObjectIsParent);
                            if (!OutAirNodeManager::CheckOutAirNodeNumber(Condenser(CondNum).InletAirNodeNum)) {
                                // not outside and not a zone
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", " + cAlphaFieldNames(4) +
                                                " not found: " + Alphas(4));
                                ShowContinueError("...does not appear in an OutdoorAir:NodeList or as an OutdoorAir:Node or as a Zone.");
                                ErrorsFound = true;
                            } // checkoutairnodenumber
                        }     // InletAirZoneNum \=0
                    }         // Condenser air inlet node connection

                    Condenser(CondNum).EndUseSubcategory = "";
                    if (!lAlphaBlanks(5)) Condenser(CondNum).EndUseSubcategory = Alphas(5);

                    Condenser(CondNum).RefOpCharge = 0.0;
                    Condenser(CondNum).RefReceiverInventory = 0.0;
                    Condenser(CondNum).RefPipingInventory = 0.0;
                    if (!lNumericBlanks(4)) Condenser(CondNum).RefOpCharge = Numbers(4);
                    if (!lNumericBlanks(5)) Condenser(CondNum).RefReceiverInventory = Numbers(5);
                    if (!lNumericBlanks(6)) Condenser(CondNum).RefPipingInventory = Numbers(6);

                } // Read input for REFRIGERATION:Condenser:AirCooled
            }     // NumSimulationCondAir > 0

            if (NumSimulationCondEvap > 0) {
                CurrentModuleObject = "Refrigeration:Condenser:EvaporativeCooled";
                for (int CondIndex = 1; CondIndex <= NumSimulationCondEvap; ++CondIndex) {
                    int CondNum = CondIndex + NumSimulationCondAir;
                    inputProcessor->getObjectItem(CurrentModuleObject,
                                                  CondIndex,
                                                  Alphas,
                                                  NumAlphas,
                                                  Numbers,
                                                  NumNumbers,
                                                  IOStatus,
                                                  lNumericBlanks,
                                                  lAlphaBlanks,
                                                  cAlphaFieldNames,
                                                  cNumericFieldNames);

                    GlobalNames::VerifyUniqueInterObjectName(UniqueCondenserNames, Alphas(1), CurrentModuleObject, cAlphaFieldNames(1), ErrorsFound);
                    Condenser(CondNum).Name = Alphas(1);
                    DataHeatBalance::HeatReclaimRefrigCondenser(CondNum).Name = Alphas(1);

                    // set start of count for number of systems attached to this condenser
                    Condenser(CondNum).NumSysAttach = 0;
                    if (!allocated(Condenser(CondNum).SysNum)) Condenser(CondNum).SysNum.allocate(DataHeatBalance::NumRefrigSystems);

                    // set CondenserType and rated Heat Rejection per ARI 490 rating
                    Condenser(CondNum).CondenserType = DataHeatBalance::RefrigCondenserTypeEvap;
                    DataHeatBalance::HeatReclaimRefrigCondenser(CondNum).SourceType = CurrentModuleObject;
                    Condenser(CondNum).RatedTCondense = CondARI490Tcond;
                    Condenser(CondNum).RatedDelT = CondARI490DelT;

                    if ((!lNumericBlanks(1)) && (Numbers(1) > 0.0)) {
                        Condenser(CondNum).RatedCapacity = Numbers(1);
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(1) +
                                        " per ARI 490 must be input and must be greater than 0 Watts.");
                        ErrorsFound = true;
                    }
                    // Calculate capacity elevation derate factor per ARI 490 barometric pressure correction factor
                    Condenser(CondNum).EvapElevFact = 1.0 - 3.074e-5 * DataEnvironment::Elevation;

                    Condenser(CondNum).RatedSubcool = 0.0; // default value
                    if ((!lNumericBlanks(2)) && (Numbers(2) > 0.0)) Condenser(CondNum).RatedSubcool = Numbers(2);

                    // Get fan control type
                    if (UtilityRoutines::SameString(Alphas(3), "FixedLinear")) {
                        Condenser(CondNum).FanSpeedControlType = FanConstantSpeedLinear;
                    } else if (UtilityRoutines::SameString(Alphas(2), "VariableSpeed")) {
                        Condenser(CondNum).FanSpeedControlType = FanVariableSpeed;
                    } else if (UtilityRoutines::SameString(Alphas(2), "TwoSpeed")) {
                        Condenser(CondNum).FanSpeedControlType = FanTwoSpeed;
                    } else {
                        Condenser(CondNum).FanSpeedControlType = FanConstantSpeed; // default
                    }                                                              // Set fan control type

                    Condenser(CondNum).RatedFanPower = Numbers(3);
                    if (Numbers(3) < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(3) +
                                        " must be greater than or equal to 0 Watts.");
                        ErrorsFound = true;
                    }

                    Condenser(CondNum).FanMinAirFlowRatio = 0.2; // default value
                    if (!lNumericBlanks(4)) Condenser(CondNum).FanMinAirFlowRatio = Numbers(4);

                    // Enter min and max and default coefficients for evap condenser HRCF correlation
                    // Defaults taken from 2008 BAC equipment for R22, R134a, series CXV
                    // Correlation coefficients for other manufacturers are very similar per Hugh Henderson's work
                    Condenser(CondNum).EvapCoeff1 = 6.63;
                    Condenser(CondNum).EvapCoeff2 = 0.468;
                    Condenser(CondNum).EvapCoeff3 = 17.93;
                    Condenser(CondNum).EvapCoeff4 = -0.322;
                    Condenser(CondNum).MinCapFacEvap = 0.5;
                    Condenser(CondNum).MaxCapFacEvap = 5.0;
                    NumNum = 5; // added warnings if below not blank but unused due to limits
                    if (!lNumericBlanks(NumNum)) {
                        if (Numbers(NumNum) >= 0.0) {
                            Condenser(CondNum).EvapCoeff1 = Numbers(NumNum);
                        } else {
                            ShowWarningError(CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                             " is less than 0 and was not used. Default was used.");
                        }
                    }
                    NumNum = 6; // EvapCoeff2 can't be equal to 0 because used in a denominator
                    if (!lNumericBlanks(NumNum)) {
                        if (Numbers(NumNum) > 0.0) {
                            Condenser(CondNum).EvapCoeff2 = Numbers(NumNum);
                        } else {
                            ShowWarningError(CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                             " is less than or equal to 0 and was not used. Default was used.");
                        }
                    }
                    NumNum = 7;
                    if (!lNumericBlanks(NumNum)) {
                        if (Numbers(NumNum) >= 0.0) {
                            Condenser(CondNum).EvapCoeff3 = Numbers(NumNum);
                        } else {
                            ShowWarningError(CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                             " is less than 0 and was not used. Default was used.");
                        }
                    }
                    NumNum = 8;
                    if (!lNumericBlanks(NumNum)) {
                        if (Numbers(NumNum) >= -20.0) {
                            Condenser(CondNum).EvapCoeff4 = Numbers(NumNum);
                        } else {
                            ShowWarningError(CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                             " is less than -20 and was not used. Default was used.");
                        }
                    }
                    NumNum = 9;
                    if (!lNumericBlanks(NumNum)) {
                        if (Numbers(NumNum) >= 0.0) {
                            Condenser(CondNum).MinCapFacEvap = Numbers(NumNum);
                        } else {
                            ShowWarningError(CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                             " is less than 0 and was not used. Default was used.");
                        }
                    }
                    NumNum = 10;
                    if (!lNumericBlanks(NumNum)) {
                        if (Numbers(NumNum) >= 0.0) {
                            Condenser(CondNum).MaxCapFacEvap = Numbers(NumNum);
                        } else {
                            ShowWarningError(CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                             " is less than 0 and was not used. Default was used.");
                        }
                    }

                    // Check condenser air inlet node connection
                    if (lAlphaBlanks(3)) {
                        Condenser(CondNum).InletAirNodeNum = 0;
                    } else {
                        Condenser(CondNum).InletAirNodeNum = NodeInputManager::GetOnlySingleNode(Alphas(3),
                                                                               ErrorsFound,
                                                                               CurrentModuleObject,
                                                                               Alphas(1),
                                                                                                 DataLoopNode::NodeType_Air,
                                                                                                 DataLoopNode::NodeConnectionType_OutsideAirReference,
                                                                               1,
                                                                                                 DataLoopNode::ObjectIsParent);
                        if (!OutAirNodeManager::CheckOutAirNodeNumber(Condenser(CondNum).InletAirNodeNum)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", " + cAlphaFieldNames(3) +
                                            " not found: " + Alphas(3));
                            ShowContinueError("...does not appear in an OutdoorAir:NodeList or as an OutdoorAir:Node.");
                            ErrorsFound = true;
                        }
                    } // Condenser air inlet node connection

                    NumNum = 11;
                    Condenser(CondNum).RatedAirFlowRate = Numbers(NumNum);
                    // Note the autocalculate feature for this value takes place in the system section because
                    //  it is a function of the total cooling capacity of the cases served by the condenser

                    // Evaporative condensers basin heater power as a function of temperature must be greater than or equal to 0
                    NumNum = 12;
                    Condenser(CondNum).BasinHeaterPowerFTempDiff = Numbers(NumNum);
                    if (Numbers(NumNum) < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                        " must be >= 0");
                        ErrorsFound = true;
                    }

                    NumNum = 13;
                    Condenser(CondNum).BasinHeaterSetPointTemp = 2.0; // default
                    if (!lNumericBlanks(NumNum)) Condenser(CondNum).BasinHeaterSetPointTemp = Numbers(NumNum);
                    if (Condenser(CondNum).BasinHeaterSetPointTemp < 2.0) {
                        ShowWarningError(CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", " + cNumericFieldNames(NumNum) +
                                         " is less than 2 deg C. Freezing could occur.");
                    }

                    NumNum = 14;
                    Condenser(CondNum).EvapPumpPower = 1000.0; // default
                    if (!lNumericBlanks(NumNum)) Condenser(CondNum).EvapPumpPower = Numbers(NumNum);
                    // Note the autocalculate feature for this value takes place in the system section because
                    //  it is a function of the total cooling capacity of the cases served by the condenser

                    // Get Evaporative Water System tank connections
                    Condenser(CondNum).SupplyTankName = Alphas(4);
                    if (lAlphaBlanks(4)) {
                        Condenser(CondNum).EvapWaterSupplyMode = WaterSupplyFromMains;
                    } else {
                        Condenser(CondNum).EvapWaterSupplyMode = WaterSupplyFromTank;
                        WaterManager::SetupTankDemandComponent(Condenser(CondNum).Name,
                                                 CurrentModuleObject,
                                                 Condenser(CondNum).SupplyTankName,
                                                 ErrorsFound,
                                                 Condenser(CondNum).EvapWaterSupTankID,
                                                 Condenser(CondNum).EvapWaterTankDemandARRID);
                    }

                    if (lAlphaBlanks(5)) {
                        Condenser(CondNum).EvapSchedPtr = 0;
                    } else {
                        Condenser(CondNum).EvapSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(5)); // convert schedule name to pointer
                        //   check availability schedule for values >= 0
                        if (Condenser(CondNum).EvapSchedPtr > 0) {
                            if (!ScheduleManager::CheckScheduleValueMinMax(Condenser(CondNum).EvapSchedPtr, ">=", 0.0)) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" .");
                                ShowContinueError("Error found in " + cAlphaFieldNames(5) + " = " + Alphas(5));
                                ShowContinueError("schedule values must be (>=0.).");
                                ErrorsFound = true;
                            }
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", invalid  " +
                                            cAlphaFieldNames(5) + " = " + Alphas(5));
                            ShowContinueError("A schedule with this name is not defined in this input data file.");
                            ErrorsFound = true;
                        }
                    } // Set Evap Schedule Pointer

                    Condenser(CondNum).EndUseSubcategory = "";
                    if (!lAlphaBlanks(6)) Condenser(CondNum).EndUseSubcategory = Alphas(6);

                    Condenser(CondNum).RefOpCharge = 0.0;
                    Condenser(CondNum).RefReceiverInventory = 0.0;
                    Condenser(CondNum).RefPipingInventory = 0.0;
                    NumNum = 15;
                    if (!lNumericBlanks(NumNum)) Condenser(CondNum).RefOpCharge = Numbers(NumNum);
                    NumNum = 16;
                    if (!lNumericBlanks(NumNum)) Condenser(CondNum).RefReceiverInventory = Numbers(NumNum);
                    NumNum = 17;
                    if (!lNumericBlanks(NumNum)) Condenser(CondNum).RefPipingInventory = Numbers(NumNum);
                } // Read input for CONDENSER:REFRIGERATION:EVAPorativeCooled
            }     // If NumSimulationCondEvap > 0

            if (NumSimulationCondWater > 0) {
                CurrentModuleObject = "Refrigeration:Condenser:WaterCooled";
                for (int CondIndex = 1; CondIndex <= NumSimulationCondWater; ++CondIndex) {
                    int CondNum = CondIndex + NumSimulationCondAir + NumSimulationCondEvap;
                    inputProcessor->getObjectItem(CurrentModuleObject,
                                                  CondIndex,
                                                  Alphas,
                                                  NumAlphas,
                                                  Numbers,
                                                  NumNumbers,
                                                  IOStatus,
                                                  lNumericBlanks,
                                                  lAlphaBlanks,
                                                  cAlphaFieldNames,
                                                  cNumericFieldNames);

                    GlobalNames::VerifyUniqueInterObjectName(UniqueCondenserNames, Alphas(1), CurrentModuleObject, cAlphaFieldNames(1), ErrorsFound);
                    Condenser(CondNum).Name = Alphas(1);
                    DataHeatBalance::HeatReclaimRefrigCondenser(CondNum).Name = Alphas(1);

                    // set start of count for number of systems attached to this condenser
                    Condenser(CondNum).NumSysAttach = 0;
                    if (!allocated(Condenser(CondNum).SysNum)) Condenser(CondNum).SysNum.allocate(DataHeatBalance::NumRefrigSystems);

                    // set CondenserType and rated Heat Rejection per ARI 450 rating
                    Condenser(CondNum).CondenserType = DataHeatBalance::RefrigCondenserTypeWater;
                    DataHeatBalance::HeatReclaimRefrigCondenser(CondNum).SourceType = CurrentModuleObject;
                    if ((!lNumericBlanks(1)) && (Numbers(1) > 0.0)) {
                        Condenser(CondNum).RatedCapacity = Numbers(1);
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(1) +
                                        " per ARI 450 must be input and must be greater than 0 Watts.");
                        ErrorsFound = true;
                    }

                    if ((!lNumericBlanks(2)) && (Numbers(2) > 0.0)) {
                        Condenser(CondNum).RatedTCondense = Numbers(2);
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(2) +
                                        " per ARI 450 must be input and must be greater than 0 C.");
                        ErrorsFound = true;
                    }

                    if (!lNumericBlanks(3)) {
                        if (Numbers(3) >= 0.0) {
                            Condenser(CondNum).RatedSubcool = Numbers(3);
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(3) +
                                            " must be greater than or equal to zero.");
                            ErrorsFound = true;
                        }
                    } else {
                        Condenser(CondNum).RatedSubcool = 0.0; // default value
                    }

                    if ((!lNumericBlanks(4)) && (Numbers(4) > 0.0)) {
                        Condenser(CondNum).RatedWaterInletT = Numbers(4);
                        Condenser(CondNum).RatedApproachT = Condenser(CondNum).RatedTCondense - Numbers(4);
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(4) +
                                        " must be input and greater than zero.");
                        ErrorsFound = true;
                    }

                    Condenser(CondNum).InletNode = NodeInputManager::GetOnlySingleNode(Alphas(2),
                                                                                       ErrorsFound,
                                                                                       CurrentModuleObject,
                                                                                       Alphas(1),
                                                                                       DataLoopNode::NodeType_Water,
                                                                                       DataLoopNode::NodeConnectionType_Inlet,
                                                                                       1,
                                                                                       DataLoopNode::ObjectIsNotParent);
                    Condenser(CondNum).OutletNode = NodeInputManager::GetOnlySingleNode(Alphas(3),
                                                                                        ErrorsFound,
                                                                                        CurrentModuleObject,
                                                                                        Alphas(1),
                                                                                        DataLoopNode::NodeType_Water,
                                                                                        DataLoopNode::NodeConnectionType_Outlet,
                                                                                        1,
                                                                                        DataLoopNode::ObjectIsNotParent);
                    // Check node connections
                    BranchNodeConnections::TestCompSet(CurrentModuleObject, Alphas(1), Alphas(2), Alphas(3), "Water Cooled Condenser Nodes");
                    // Get loop flow type
                    if (UtilityRoutines::SameString(Alphas(4), "VariableFlow")) { // set FlowType
                        Condenser(CondNum).FlowType = VariableFlow;
                    } else if (UtilityRoutines::SameString(Alphas(4), "ConstantFlow")) {
                        Condenser(CondNum).FlowType = ConstantFlow;
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", invalid  " + cAlphaFieldNames(4) +
                                        " not recognized: " + Alphas(4));
                        ShowContinueError("Check input value choices.");
                        ErrorsFound = true;
                    } // Set FlowType

                    // Get outlet temperature schedule for variable flow case
                    if (Condenser(CondNum).FlowType == VariableFlow) {
                        if (lAlphaBlanks(5)) {
                            Condenser(CondNum).OutletTempSchedPtr = 0;
                        } else {
                            Condenser(CondNum).OutletTempSchedPtr = ScheduleManager::GetScheduleIndex(Alphas(5)); // convert schedule name to pointer
                        }
                        if (Condenser(CondNum).OutletTempSchedPtr == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", invalid  " +
                                            cAlphaFieldNames(5) + " = " + Alphas(5));
                            ShowContinueError("A schedule with this name is not defined in this input data file.");
                            ErrorsFound = true;
                        }
                    } // Outlet temperature schedule

                    // Get volumetric flow rate if applicable
                    if (Condenser(CondNum).FlowType == ConstantFlow) {
                        if ((!lNumericBlanks(5)) && (Numbers(5) > 0.0)) {
                            Condenser(CondNum).DesVolFlowRate = Numbers(5);
                            Condenser(CondNum).VolFlowRate = Numbers(5);
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(5) +
                                            " must be greater than zero.");
                            ShowContinueError("Revise flow rates.");
                            ErrorsFound = true;
                        }
                        PlantUtilities::RegisterPlantCompDesignFlow(Condenser(CondNum).InletNode, Condenser(CondNum).DesVolFlowRate);
                    }

                    // Get maximum flow rates
                    if (Numbers(6) > 0.0) {
                        Condenser(CondNum).VolFlowRateMax = Numbers(6);
                        // Check constant flow for max violation, if applicable
                        if (Condenser(CondNum).FlowType == ConstantFlow && Condenser(CondNum).VolFlowRate > Numbers(6)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(5) +
                                            " > " + cNumericFieldNames(6) + " .");
                            ShowContinueError("Revise flow rates.");
                            ErrorsFound = true;
                        } // Error check on max flow rate
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(6) +
                                        " must be greater than zero.");
                        ErrorsFound = true;
                    }

                    // Get max/min allowed water temps
                    Condenser(CondNum).OutletTempMax = Numbers(7);
                    Condenser(CondNum).InletTempMin = Numbers(8);

                    Condenser(CondNum).EndUseSubcategory = "";
                    if (!lAlphaBlanks(6)) Condenser(CondNum).EndUseSubcategory = Alphas(6);

                    Condenser(CondNum).RefOpCharge = 0.0;
                    Condenser(CondNum).RefReceiverInventory = 0.0;
                    Condenser(CondNum).RefPipingInventory = 0.0;
                    if (!lNumericBlanks(9)) Condenser(CondNum).RefOpCharge = Numbers(9);
                    if (!lNumericBlanks(10)) Condenser(CondNum).RefReceiverInventory = Numbers(10);
                    if (!lNumericBlanks(11)) Condenser(CondNum).RefPipingInventory = Numbers(11);

                } // Read input for CONDENSER:REFRIGERATION:WaterCooled

                CheckEquipNameWaterCondenser.dimension(DataHeatBalance::NumRefrigCondensers, true);
            } // NumSimulationCondWater > 0

            // cascade condensers assumed to provide zero subcooling
            if (NumSimulationCascadeCondensers > 0) {
                CurrentModuleObject = "Refrigeration:Condenser:Cascade";
                for (int CondIndex = 1; CondIndex <= NumSimulationCascadeCondensers; ++CondIndex) {
                    int CondNum = CondIndex + NumSimulationCondAir + NumSimulationCondEvap + NumSimulationCondWater;
                    inputProcessor->getObjectItem(CurrentModuleObject,
                                                  CondIndex,
                                                  Alphas,
                                                  NumAlphas,
                                                  Numbers,
                                                  NumNumbers,
                                                  IOStatus,
                                                  lNumericBlanks,
                                                  lAlphaBlanks,
                                                  cAlphaFieldNames,
                                                  cNumericFieldNames);

                    GlobalNames::VerifyUniqueInterObjectName(UniqueCondenserNames, Alphas(1), CurrentModuleObject, cAlphaFieldNames(1), ErrorsFound);
                    Condenser(CondNum).Name = Alphas(1);
                    DataHeatBalance::HeatReclaimRefrigCondenser(CondNum).Name = Alphas(1);

                    // set start of count for number of systems attached to this condenser
                    Condenser(CondNum).NumSysAttach = 0;
                    if (!allocated(Condenser(CondNum).SysNum)) Condenser(CondNum).SysNum.allocate(DataHeatBalance::NumRefrigSystems);

                    // set CondenserType
                    Condenser(CondNum).CondenserType = DataHeatBalance::RefrigCondenserTypeCascade;

                    if (!lNumericBlanks(1)) {
                        Condenser(CondNum).RatedTCondense = Numbers(1);
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(1) +
                                        " must be input.");
                        ErrorsFound = true;
                    }

                    if (!lNumericBlanks(2)) {
                        if (Numbers(2) >= 0.0) {
                            Condenser(CondNum).RatedApproachT = Numbers(2);
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(2) +
                                            " must be greater than or equal to zero.");
                            ErrorsFound = true;
                        }
                    } else {
                        Condenser(CondNum).RatedApproachT = DefaultCascadeCondApproach;
                    }

                    if ((!lNumericBlanks(3)) && (Numbers(3) > 0.0)) {
                        Condenser(CondNum).RatedCapacity = Numbers(3);
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\" " + cNumericFieldNames(3) +
                                        " must be in put and must be greater than or equal to zero.");
                        ErrorsFound = true;
                    }

                    // Get condensing temperature type, either fixed by design or allowed to float to match other loads on supply system
                    if (!lAlphaBlanks(2)) {
                        if (UtilityRoutines::SameString(Alphas(2), "Fixed")) { // set Condenser Temperature Control Type
                            Condenser(CondNum).CascadeTempControl = CascadeTempSet;
                        } else if (UtilityRoutines::SameString(Alphas(2), "Float")) {
                            Condenser(CondNum).CascadeTempControl = CascadeTempFloat;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name + "\", invalid  " +
                                            cAlphaFieldNames(2) + " not recognized: " + Alphas(2));
                            ShowContinueError("Check input value choices.");
                            ErrorsFound = true;
                        }    // string comparison to key choices
                    } else { // default is fixed/cascadetempset
                        Condenser(CondNum).CascadeTempControl = CascadeTempSet;
                    } // not blank

                    Condenser(CondNum).CascadeRatedEvapTemp = Condenser(CondNum).RatedTCondense - Condenser(CondNum).RatedApproachT;

                    // future - add refrigerant inventory on system side accepting reject heat (as was done for secondary)
                    Condenser(CondNum).RefOpCharge = 0.0;
                    Condenser(CondNum).RefReceiverInventory = 0.0;
                    Condenser(CondNum).RefPipingInventory = 0.0;
                    if (!lNumericBlanks(4)) Condenser(CondNum).RefOpCharge = Numbers(4);
                    if (!lNumericBlanks(5)) Condenser(CondNum).RefReceiverInventory = Numbers(5);
                    if (!lNumericBlanks(6)) Condenser(CondNum).RefPipingInventory = Numbers(6);

                } // Read input for CONDENSER:REFRIGERATION:Cascade
            }     // NumSimulationCascadeCondensers > 0

            //************ END CONDENSER INPUT   **************

            //**********  START GAS COOLER INPUT  **********

            if (NumSimulationGasCooler > 0) {
                CurrentModuleObject = "Refrigeration:GasCooler:AirCooled";
                for (int GCNum = 1; GCNum <= NumSimulationGasCooler; ++GCNum) {
                    inputProcessor->getObjectItem(CurrentModuleObject,
                                                  GCNum,
                                                  Alphas,
                                                  NumAlphas,
                                                  Numbers,
                                                  NumNumbers,
                                                  IOStatus,
                                                  lNumericBlanks,
                                                  lAlphaBlanks,
                                                  cAlphaFieldNames,
                                                  cNumericFieldNames);
                    UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);
                    GasCooler(GCNum).Name = Alphas(1);

                    GasCooler(GCNum).CapCurvePtr = CurveManager::GetCurveIndex(Alphas(2)); // convert curve name to number
                    if (GasCooler(GCNum).CapCurvePtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + GasCooler(GCNum).Name + "\", invalid " + cAlphaFieldNames(2) +
                                        " not found:" + Alphas(2));
                        ErrorsFound = true;
                    }

                    // set start of count for number of systems attached to this gas cooler
                    GasCooler(GCNum).NumSysAttach = 0;
                    if (!allocated(GasCooler(GCNum).SysNum)) GasCooler(GCNum).SysNum.allocate(NumTransRefrigSystems);

                    GasCooler(GCNum).RatedApproachT = 3.0; // rated CO2 gas cooler approach temperature
                    if (GasCooler(GCNum).CapCurvePtr > 0) {
                        GasCooler(GCNum).RatedCapacity = CurveManager::CurveValue(GasCooler(GCNum).CapCurvePtr, GasCooler(GCNum).RatedApproachT);
                    }
                    // elevation capacity correction on air-cooled condensers, Carrier correlation more conservative than Trane
                    GasCooler(GCNum).RatedCapacity *= (1.0 - 7.17e-5 * DataEnvironment::Elevation);
                    if (GasCooler(GCNum).RatedCapacity > 0.0) {
                        CurveManager::GetCurveMinMaxValues(GasCooler(GCNum).CapCurvePtr, DelTempMin, DelTempMax);
                        Real64 Capmin =
                            CurveManager::CurveValue(GasCooler(GCNum).CapCurvePtr, DelTempMin) * (1.0 - 7.17e-5 * DataEnvironment::Elevation);
                        Real64 Capmax =
                            CurveManager::CurveValue(GasCooler(GCNum).CapCurvePtr, DelTempMax) * (1.0 - 7.17e-5 * DataEnvironment::Elevation);
                        GasCooler(GCNum).TempSlope = (DelTempMax - DelTempMin) / ((Capmax - Capmin));
                        GasCooler(GCNum).MinCondLoad = Capmax - DelTempMax / GasCooler(GCNum).TempSlope;
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + GasCooler(GCNum).Name +
                                        "\" Gas Cooler capacity curve must be input and must be greater than 0 Watts at 3C temperature difference.");
                        ErrorsFound = true;
                    }

                    // Get fan control type
                    if (UtilityRoutines::SameString(Alphas(3), "FixedLinear")) {
                        GasCooler(GCNum).FanSpeedControlType = FanConstantSpeedLinear;
                    } else if (UtilityRoutines::SameString(Alphas(3), "VariableSpeed")) {
                        GasCooler(GCNum).FanSpeedControlType = FanVariableSpeed;
                    } else if (UtilityRoutines::SameString(Alphas(3), "TwoSpeed")) {
                        GasCooler(GCNum).FanSpeedControlType = FanTwoSpeed;
                    } else {
                        GasCooler(GCNum).FanSpeedControlType = FanConstantSpeed; // default
                    }                                                            // Set fan control type

                    // Gas cooler fan power
                    GasCooler(GCNum).RatedFanPower = 5000.0; // default value
                    if (!lNumericBlanks(1)) GasCooler(GCNum).RatedFanPower = Numbers(1);
                    if (Numbers(1) < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + GasCooler(GCNum).Name + "\" " + cNumericFieldNames(1) +
                                        " must be input greater than or equal to 0 Watts.");
                        ErrorsFound = true;
                    }

                    // Gas cooler minimum fan air flow ratio
                    GasCooler(GCNum).FanMinAirFlowRatio = 0.2; // default value
                    if (!lNumericBlanks(2)) GasCooler(GCNum).FanMinAirFlowRatio = Numbers(2);
                    if ((GasCooler(GCNum).FanMinAirFlowRatio < 0.0) || (GasCooler(GCNum).FanMinAirFlowRatio > 1.0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + GasCooler(GCNum).Name + "\" " + cNumericFieldNames(2) +
                                        " must be a value between zero and one.  The default value (0.2) will be used.");
                        GasCooler(GCNum).FanMinAirFlowRatio = 0.2;
                    }

                    // Gas cooler transition temperature
                    GasCooler(GCNum).TransitionTemperature = 2.7e1; // default value
                    if (!lNumericBlanks(3)) GasCooler(GCNum).TransitionTemperature = Numbers(3);
                    if (GasCooler(GCNum).TransitionTemperature < 2.5e1) {
                        ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + GasCooler(GCNum).Name + "\" " + cNumericFieldNames(3) +
                                         " is low (less than 25C).  Consider raising the transition temperature to operate for longer periods of "
                                         "time in the subcritical region.");
                    }
                    if (GasCooler(GCNum).TransitionTemperature > 30.978) {
                        ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + GasCooler(GCNum).Name + "\" " + cNumericFieldNames(3) +
                                         " is greater than the critical temperature of carbon dioxide.  The default value (27C) will be used.");
                        GasCooler(GCNum).TransitionTemperature = 2.7e1;
                    }

                    // Gas cooler approach temperature for transcritical operation
                    GasCooler(GCNum).GasCoolerApproachT = 3.0; // default value
                    if (!lNumericBlanks(4)) GasCooler(GCNum).GasCoolerApproachT = Numbers(4);
                    if (GasCooler(GCNum).GasCoolerApproachT < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + GasCooler(GCNum).Name + "\" " + cNumericFieldNames(4) +
                                        " must be greater than 0C.");
                        ErrorsFound = true;
                    }

                    // Gas cooler temperature difference for subcritical operation
                    GasCooler(GCNum).SubcriticalTempDiff = 1.0e1; // default value
                    if (!lNumericBlanks(5)) GasCooler(GCNum).SubcriticalTempDiff = Numbers(5);
                    if (GasCooler(GCNum).SubcriticalTempDiff < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + GasCooler(GCNum).Name + "\" " + cNumericFieldNames(5) +
                                        " must be greater than 0C.");
                        ErrorsFound = true;
                    }

                    // Gas cooler minimum condensing temperature for subcritical operation
                    GasCooler(GCNum).MinCondTemp = 1.0e1; // default value
                    if (!lNumericBlanks(6)) GasCooler(GCNum).MinCondTemp = Numbers(6);
                    if (GasCooler(GCNum).MinCondTemp > 30.9) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + GasCooler(GCNum).Name + "\" " + cNumericFieldNames(6) +
                                        " must be less than the critical temperature of carbon dioxide (31C).");
                        ErrorsFound = true;
                    }

                    // Check GasCooler air inlet node connection
                    GasCooler(GCNum).GasCoolerRejectHeatToZone = false;
                    if (lAlphaBlanks(4)) {
                        GasCooler(GCNum).InletAirNodeNum = 0;
                    } else { // see if it's an outside air node name or an indoor zone name,
                        // have to check inside first because outside check automatically generates an error message
                        GasCooler(GCNum).InletAirZoneNum = UtilityRoutines::FindItemInList(Alphas(4), DataHeatBalance::Zone);
                        // need to clearly id node number for air inlet conditions and zone number for casecredit assignment
                        if (GasCooler(GCNum).InletAirZoneNum != 0) {
                            // set condenser flag (later used to set system flag) and zone flag
                            GasCooler(GCNum).InletAirNodeNum = DataZoneEquipment::GetSystemNodeNumberForZone(state, Alphas(4));
                            GasCooler(GCNum).GasCoolerRejectHeatToZone = true;
                            RefrigPresentInZone(GasCooler(GCNum).InletAirZoneNum) = true;
                        } else { // not in a conditioned zone, so see if it's outside
                            GasCooler(GCNum).InletAirNodeNum =
                                NodeInputManager::GetOnlySingleNode(Alphas(4),
                                                                                 ErrorsFound,
                                                                                 CurrentModuleObject,
                                                                                 Alphas(1),
                                                                    DataLoopNode::NodeType_Air,
                                                                    DataLoopNode::NodeConnectionType_OutsideAirReference,
                                                                                 1,
                                                                    DataLoopNode::ObjectIsParent);
                            if (!OutAirNodeManager::CheckOutAirNodeNumber(GasCooler(GCNum).InletAirNodeNum)) {
                                // not outside and not a zone
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + GasCooler(GCNum).Name + "\", " + cAlphaFieldNames(4) +
                                                " not found: " + Alphas(4));
                                ShowContinueError("...does not appear in an OutdoorAir:NodeList or as an OutdoorAir:Node or as a Zone.");
                                ErrorsFound = true;
                            } // checkoutairnodenumber
                        }     // InletAirZoneNum \=0
                    }         // Gas cooler air inlet node connection

                    GasCooler(GCNum).EndUseSubcategory = "";
                    if (!lAlphaBlanks(5)) GasCooler(GCNum).EndUseSubcategory = Alphas(5);

                    GasCooler(GCNum).RefOpCharge = 0.0;
                    GasCooler(GCNum).RefReceiverInventory = 0.0;
                    GasCooler(GCNum).RefPipingInventory = 0.0;
                    if (!lNumericBlanks(7)) GasCooler(GCNum).RefOpCharge = Numbers(7);
                    if (!lNumericBlanks(8)) GasCooler(GCNum).RefReceiverInventory = Numbers(8);
                    if (!lNumericBlanks(9)) GasCooler(GCNum).RefPipingInventory = Numbers(9);

                } // Read input for REFRIGERATION:GasCooler:AirCooled
            }     // NumSimulationGasCooler > 0

            //**********  END GAS COOLER INPUT  **********

            //************ START SECONDARY LOOP INPUT (before system input) **************
            if (NumSimulationSecondarySystems > 0) {
                CurrentModuleObject = "Refrigeration:SecondarySystem";
                for (int SecondaryNum = 1; SecondaryNum <= NumSimulationSecondarySystems; ++SecondaryNum) {
                    inputProcessor->getObjectItem(CurrentModuleObject,
                                                  SecondaryNum,
                                                  Alphas,
                                                  NumAlphas,
                                                  Numbers,
                                                  NumNumbers,
                                                  IOStatus,
                                                  lNumericBlanks,
                                                  lAlphaBlanks,
                                                  cAlphaFieldNames,
                                                  cNumericFieldNames);
                    UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                    Secondary(SecondaryNum).Name = Alphas(1);

                    //   Find the loads on the secondary loop: can be input in form of case or walkin or CaseAndWalkInList names
                    Real64 NominalTotalCaseCap = 0.0;
                    NumCases = 0;
                    Real64 NominalTotalCoilCap = 0.0;
                    int NumCoils = 0;
                    NumWalkIns = 0;
                    Real64 NominalTotalWalkInCap = 0.0;
                    Secondary(SecondaryNum).RefInventory = 0.0;

                    //   Read display case and walkin assignments for this secondary
                    AlphaNum = 2;
                    if (lAlphaBlanks(AlphaNum)) {
                        // No cases or walkins specified, ie, secondary has no load
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                        "\", has no loads, must have at least one of: " + cAlphaFieldNames(AlphaNum));
                        ErrorsFound = true;
                    } else { // (.NOT. lAlphaBlanks(AlphaNum))

                        // Entry for Alphas(AlphaNum) can be either a Case, WalkIn Coil, or CaseAndWalkInList name
                        int CaseAndWalkInListNum = 0;
                        int CaseNum = 0;
                        int WalkInNum = 0;
                        int CoilNum = 0;
                        if (NumSimulationCaseAndWalkInLists > 0)
                            CaseAndWalkInListNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), CaseAndWalkInList);
                        if (NumSimulationCases > 0) CaseNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), RefrigCase);
                        if (NumSimulationWalkIns > 0) WalkInNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), WalkIn);
                        if (NumSimulationRefrigAirChillers > 0) CoilNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), WarehouseCoil);
                        int NumNameMatches = 0;
                        if (CaseAndWalkInListNum != 0) ++NumNameMatches;
                        if (CaseNum != 0) ++NumNameMatches;
                        if (WalkInNum != 0) ++NumNameMatches;
                        if (CoilNum != 0) ++NumNameMatches;

                        if (NumNameMatches != 1) { // name must uniquely point to a list or a single case or walkin or coil
                            ErrorsFound = true;
                            if (NumNameMatches == 0) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", has an invalid " +
                                                cAlphaFieldNames(AlphaNum) + ": " + Alphas(AlphaNum));
                            } else if (NumNameMatches > 1) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                                "\", has a non-unique name that could be either a " + cAlphaFieldNames(AlphaNum) + ": " +
                                                Alphas(AlphaNum));
                            }                                   // num matches = 0 or > 1
                        } else if (CaseAndWalkInListNum != 0) { // Name points to a CaseAndWalkInList
                            NumCoils = CaseAndWalkInList(CaseAndWalkInListNum).NumCoils;
                            NumCases = CaseAndWalkInList(CaseAndWalkInListNum).NumCases;
                            NumWalkIns = CaseAndWalkInList(CaseAndWalkInListNum).NumWalkIns;
                            Secondary(SecondaryNum).NumCases = NumCases;
                            Secondary(SecondaryNum).NumCoils = NumCoils;
                            Secondary(SecondaryNum).NumWalkIns = NumWalkIns;
                            if (!allocated(Secondary(SecondaryNum).CaseNum)) Secondary(SecondaryNum).CaseNum.allocate(NumCases);
                            Secondary(SecondaryNum).CaseNum({1, NumCases}) = CaseAndWalkInList(CaseAndWalkInListNum).CaseItemNum({1, NumCases});
                            if (!allocated(Secondary(SecondaryNum).CoilNum)) Secondary(SecondaryNum).CoilNum.allocate(NumCoils);
                            Secondary(SecondaryNum).CoilNum({1, NumCoils}) = CaseAndWalkInList(CaseAndWalkInListNum).CoilItemNum({1, NumCoils});
                            if (!allocated(Secondary(SecondaryNum).WalkInNum)) Secondary(SecondaryNum).WalkInNum.allocate(NumWalkIns);
                            Secondary(SecondaryNum).WalkInNum({1, NumWalkIns}) =
                                CaseAndWalkInList(CaseAndWalkInListNum).WalkInItemNum({1, NumWalkIns});
                        } else if (CaseNum != 0) { // Name points to a case
                            NumCases = 1;
                            Secondary(SecondaryNum).NumCases = 1;
                            if (!allocated(Secondary(SecondaryNum).CaseNum)) Secondary(SecondaryNum).CaseNum.allocate(NumCases);
                            Secondary(SecondaryNum).CaseNum(NumCases) = CaseNum;
                        } else if (CoilNum != 0) { // Name points to a coil
                            NumCoils = 1;
                            Secondary(SecondaryNum).NumCoils = 1;
                            if (!allocated(Secondary(SecondaryNum).CoilNum)) Secondary(SecondaryNum).CoilNum.allocate(NumCoils);
                            Secondary(SecondaryNum).CoilNum(NumCoils) = CoilNum;
                        } else if (WalkInNum != 0) { // Name points to a walkin
                            NumWalkIns = 1;
                            Secondary(SecondaryNum).NumWalkIns = 1;
                            if (!allocated(Secondary(SecondaryNum).WalkInNum)) Secondary(SecondaryNum).WalkInNum.allocate(NumWalkIns);
                            Secondary(SecondaryNum).WalkInNum(NumWalkIns) = WalkInNum;
                        } // NumNameMatches /= 1
                    }     // blank input for loads on secondary

                    if (NumCases > 0) {
                        // Find lowest design T loop fluid out of secondary chiller
                        // Sum rated capacity of all cases on Secondary
                        for (int caseIndex = 1; caseIndex <= NumCases; ++caseIndex) {
                            // mark all cases on Secondary as used by this Secondary - checking for unused or non-unique cases
                            int CaseNum = Secondary(SecondaryNum).CaseNum(caseIndex);
                            ++RefrigCase(CaseNum).NumSysAttach;
                            NominalTotalCaseCap += RefrigCase(CaseNum).DesignRatedCap * RefrigCase(CaseNum).RatedRTF;
                            Secondary(SecondaryNum).RefInventory += RefrigCase(CaseNum).DesignRefrigInventory;
                            if (caseIndex == 1) { // look for lowest case design evap T for Secondary
                                Secondary(SecondaryNum).TMinNeeded = RefrigCase(CaseNum).EvapTempDesign;
                            } else {
                                Secondary(SecondaryNum).TMinNeeded = min(RefrigCase(CaseNum).EvapTempDesign, Secondary(SecondaryNum).TMinNeeded);
                            }
                        } // CaseIndex=1,NumCases
                    }     // Numcases > 0

                    if (NumCoils > 0) {
                        // Find lowest design T loop fluid out of secondary chiller
                        // Sum rated capacity of all Coils on Secondary
                        for (int CoilIndex = 1; CoilIndex <= NumCoils; ++CoilIndex) {
                            // mark all Coils on Secondary as used by this Secondary - checking for unused or non-unique Coils
                            int CoilNum = Secondary(SecondaryNum).CoilNum(CoilIndex);
                            ++WarehouseCoil(CoilNum).NumSysAttach;
                            NominalTotalCoilCap += WarehouseCoil(CoilNum).RatedSensibleCap;
                            Secondary(SecondaryNum).RefInventory += WarehouseCoil(CoilNum).DesignRefrigInventory;
                            if ((CoilIndex == 1) && (NumCases == 0)) { // look for lowest Coil design evap T for Secondary
                                Secondary(SecondaryNum).TMinNeeded = WarehouseCoil(CoilNum).TEvapDesign;
                            } else {
                                Secondary(SecondaryNum).TMinNeeded = min(WarehouseCoil(CoilNum).TEvapDesign, Secondary(SecondaryNum).TMinNeeded);
                            }
                        } // CoilIndex=1,NumCoils
                    }     // NumCoils > 0

                    if (NumWalkIns > 0) {
                        // Find lowest design T loop fluid out of secondary chiller
                        // Sum rated capacity of all WalkIns on Secondary
                        for (int WalkInIndex = 1; WalkInIndex <= NumWalkIns; ++WalkInIndex) {
                            // mark all WalkIns on Secondary as used by this Secondary - checking for unused or non-unique WalkIns
                            int WalkInID = Secondary(SecondaryNum).WalkInNum(WalkInIndex);
                            ++WalkIn(WalkInID).NumSysAttach;
                            NominalTotalWalkInCap += WalkIn(WalkInID).DesignRatedCap;
                            Secondary(SecondaryNum).RefInventory += WalkIn(WalkInID).DesignRefrigInventory;
                            if ((WalkInIndex == 1) && (NumCases == 0) && (NumCoils == 0)) { // look for lowest load design evap T for Secondary
                                Secondary(SecondaryNum).TMinNeeded = WalkIn(WalkInID).TEvapDesign;
                            } else {
                                Secondary(SecondaryNum).TMinNeeded = min(Secondary(SecondaryNum).TMinNeeded, WalkIn(WalkInID).TEvapDesign);
                            }
                        } // WalkInIndex=1,NumWalkIns
                    }     // Numwalkins > 0

                    // Get circulating fluid type
                    AlphaNum = 3;
                    if (!lAlphaBlanks(AlphaNum)) {
                        if (UtilityRoutines::SameString(Alphas(AlphaNum), "FluidAlwaysLiquid")) {
                            Secondary(SecondaryNum).FluidType = SecFluidTypeAlwaysLiquid;
                        } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "FluidPhaseChange")) {
                            Secondary(SecondaryNum).FluidType = SecFluidTypePhaseChange;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\"  " +
                                            cAlphaFieldNames(AlphaNum) + " not recognized = " + Alphas(AlphaNum));
                            ShowContinueError("Input value choices should be FluidAlwaysLiquid or FluidPhaseChange.");
                            ErrorsFound = true;
                        } // Set FluidType
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\" " +
                                        cAlphaFieldNames(AlphaNum) + " must be specified.");
                        ErrorsFound = true;
                    } // blank on cir fluid type

                    AlphaNum = 4;
                    Secondary(SecondaryNum).FluidName = Alphas(AlphaNum);
                    // Error messages for refrigerants and glycols already found in fluidproperties

                    // Note remainder of inputs for secondary don't follow IDD input order because of different interpretations
                    //   and intermediate calculations used to assign default values for brine type vs. liquid overfeed/phase change loops

                    if (!lNumericBlanks(3)) {
                        Secondary(SecondaryNum).TEvapDesign = Numbers(3);
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\" " + cNumericFieldNames(3) +
                                        " must be specified.");
                        ErrorsFound = true;
                    } // blank on N3

                    if (!lNumericBlanks(4)) {
                        Secondary(SecondaryNum).TApproachDifRated = Numbers(4);
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\" " + cNumericFieldNames(4) +
                                        " must be specified.");
                        ErrorsFound = true;
                    } // blank on N4

                    //^^^^^^^Now look at input and once-only calculations required only for liquid/brine secondary loops^^^^^^^^^^^^^^^^^^^^^^
                    //   Ensure that required input data is not missing prior to performing the following once-only calculations
                    if (ErrorsFound) {
                        ShowFatalError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                       "\", Program terminated due to previous condition(s).");
                    } // ErrorsFound

                    Real64 CpBrineRated = 0.0;
                    Real64 PumpTotRatedFlowVol(0.0);   // Rated flow from input pump data, m3/s
                    Real64 SecondaryFlowVolRated(0.0); // Rated flow of secondary fluid, used to calculate capacity (m3/s)
                    Real64 TBrineOutRated(0.0);        // Rated temperature of circ fluid LEAVING heat exchanger,C
                    Real64 TBrineInRated(0.0);         // Rated temperature of circ fluid going INTO heat exchanger, C

                    if (Secondary(SecondaryNum).FluidType == SecFluidTypeAlwaysLiquid) {
                        if (!lNumericBlanks(5)) {
                            Secondary(SecondaryNum).TRangeDifRated = Numbers(5);
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", " +
                                            cNumericFieldNames(5) + " must be specified.");
                            ShowContinueError("...when " + cAlphaFieldNames(3) + "=\"FluidAlwaysLiquid\".");
                            ErrorsFound = true;
                        } // blank on N5

                        // Get fluid properties at rated conditions, will be used to calculate ht exchgr effectiveness
                        TBrineOutRated = Secondary(SecondaryNum).TEvapDesign + Secondary(SecondaryNum).TApproachDifRated;
                        TBrineInRated = TBrineOutRated + Secondary(SecondaryNum).TRangeDifRated;
                        Real64 TBrineAverage = (TBrineOutRated + TBrineInRated) / 2.0;
                        Secondary(SecondaryNum).TBrineAverage = TBrineAverage;
                        DensityBrineRated = FluidProperties::GetDensityGlycol(
                            Secondary(SecondaryNum).FluidName, TBrineAverage, Secondary(SecondaryNum).FluidID, TrackMessage);
                        Secondary(SecondaryNum).DensityBrineRated = DensityBrineRated;
                        CpBrineRated = FluidProperties::GetSpecificHeatGlycol(
                            Secondary(SecondaryNum).FluidName, TBrineAverage, Secondary(SecondaryNum).FluidID, TrackMessage);
                        Secondary(SecondaryNum).CpBrineRated = CpBrineRated;

                        // Users can input either design brine flow (m3/s), or capacity in W, or both.  Now have
                        //  temperatures needed to calculate either the loop cooling capacity or fluid flow rate, if one was not input
                        //  Don't need to save as a flow vol as a permanent var because calc whichever is missing here
                        Real64 FlowMassRated(0.0); // Design mass flow rate of circ fluid in secondary loop(kg/s)
                        if ((!lNumericBlanks(1)) && (!lNumericBlanks(2))) {
                            // Both values input, check for approximate agreement
                            Secondary(SecondaryNum).CoolingLoadRated = Numbers(1);
                            SecondaryFlowVolRated = Numbers(2);
                            FlowMassRated = SecondaryFlowVolRated * DensityBrineRated;
                            Real64 NominalSecondaryCapacity = FlowMassRated * CpBrineRated * Secondary(SecondaryNum).TRangeDifRated;
                            Real64 TestDelta = (NominalSecondaryCapacity - Secondary(SecondaryNum).CoolingLoadRated) / NominalSecondaryCapacity;
                            if (std::abs(TestDelta) > 0.2) {
                                ShowWarningError(CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                                 " You may wish to check the system definition. Based upon the design flow rate and range "
                                                 "temperature difference,  The nominal secondary loop heat exchanger capacity is, " +
                                                 General::RoundSigDigits(NominalSecondaryCapacity, 0) + " but the specified design capacity is,  " +
                                                 General::RoundSigDigits(Secondary(SecondaryNum).CoolingLoadRated, 0));
                            }
                        } else if (!lNumericBlanks(1)) {
                            Secondary(SecondaryNum).CoolingLoadRated = Numbers(1);
                            // Calc flow vol rated
                            FlowMassRated = Secondary(SecondaryNum).CoolingLoadRated / (CpBrineRated * Secondary(SecondaryNum).TRangeDifRated);
                            SecondaryFlowVolRated = FlowMassRated / DensityBrineRated;
                        } else if (!lNumericBlanks(2)) {
                            SecondaryFlowVolRated = Numbers(2);
                            // Calc rated load
                            FlowMassRated = SecondaryFlowVolRated * DensityBrineRated;
                            Secondary(SecondaryNum).CoolingLoadRated = FlowMassRated * CpBrineRated * Secondary(SecondaryNum).TRangeDifRated;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", Either \"" +
                                            cNumericFieldNames(1) + "\" OR \"" + cNumericFieldNames(2) + "\" must be input.");
                            ErrorsFound = true;
                        } // Capacity Input via either or both options

                        if (!ErrorsFound) {
                            // Calculate heat exchanger effectiveness based on rated flow and temperature differences
                            Secondary(SecondaryNum).HeatExchangeEta =
                                Secondary(SecondaryNum).CoolingLoadRated /
                                (FlowMassRated * CpBrineRated * (TBrineInRated - Secondary(SecondaryNum).TEvapDesign));
                            Secondary(SecondaryNum).TBrineInRated = TBrineInRated;
                            if (Secondary(SecondaryNum).HeatExchangeEta > 0.99) {
                                ShowWarningError(CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                                 " You may wish to check the system definition.  The heat exchanger effectiveness is, " +
                                                 General::RoundSigDigits(Secondary(SecondaryNum).HeatExchangeEta, 2));
                                Secondary(SecondaryNum).HeatExchangeEta = 0.99;
                            }
                        } else {
                            ShowContinueError("...remainder of this object input skipped due to previous errors");
                            continue;
                        }

                        PumpTotRatedFlowVol = SecondaryFlowVolRated;
                        if (!lNumericBlanks(7)) PumpTotRatedFlowVol = Numbers(7);

                    } else { // FluidType = FluidTypePhaseChange     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                        if (!lNumericBlanks(1)) {
                            Secondary(SecondaryNum).CoolingLoadRated = Numbers(1);
                        } else {
                            Secondary(SecondaryNum).CoolingLoadRated = NominalTotalCaseCap + NominalTotalWalkInCap;
                            // first estimate, will later be adjusted to include pump power
                        } // input capacity

                        Secondary(SecondaryNum).TCondense = Secondary(SecondaryNum).TEvapDesign + Secondary(SecondaryNum).TApproachDifRated;
                        Secondary(SecondaryNum).CircRate = DefaultCircRate;
                        if (!lNumericBlanks(10)) Secondary(SecondaryNum).CircRate = Numbers(10);

                        DensityPhaseChange = FluidProperties::GetSatDensityRefrig(Secondary(SecondaryNum).FluidName,
                                                                 Secondary(SecondaryNum).TCondense,
                                                                 0.0,
                                                                 Secondary(SecondaryNum).FluidID,
                                                                 TrackMessageAlt);
                        DeltaHPhaseChange = FluidProperties::GetSatEnthalpyRefrig(Secondary(SecondaryNum).FluidName,
                                                                 Secondary(SecondaryNum).TCondense,
                                                                 1.0,
                                                                 Secondary(SecondaryNum).FluidID,
                                                                 TrackMessageAlt) -
                                            FluidProperties::GetSatEnthalpyRefrig(Secondary(SecondaryNum).FluidName,
                                                                 Secondary(SecondaryNum).TCondense,
                                                                 0.0,
                                                                 Secondary(SecondaryNum).FluidID,
                                                                 TrackMessageAlt);

                        // TotRatedFlowVol= capacity*circrate/deltahphasechange/density
                        Real64 CalcTotFlowVol =
                            Secondary(SecondaryNum).CoolingLoadRated * Secondary(SecondaryNum).CircRate / (DensityPhaseChange * DeltaHPhaseChange);
                        PumpTotRatedFlowVol = CalcTotFlowVol;
                        if (!lNumericBlanks(7)) {
                            PumpTotRatedFlowVol = Numbers(7);
                            Real64 CalcCircRate =
                                DensityPhaseChange * DeltaHPhaseChange * PumpTotRatedFlowVol / Secondary(SecondaryNum).CoolingLoadRated;
                            Real64 DiffCircRates = (CalcCircRate - Secondary(SecondaryNum).CircRate) / Secondary(SecondaryNum).CircRate;
                            if (std::abs(DiffCircRates) > 0.3) {
                                ShowWarningError(CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + ' ' + cNumericFieldNames(7) +
                                                 " Produces a circulating rate of " + General::RoundSigDigits(CalcCircRate, 2) +
                                                 " ;  A circulating rate of " + General::RoundSigDigits(Secondary(SecondaryNum).CircRate, 2) +
                                                 " would need a " + cNumericFieldNames(7) + " of " + General::RoundSigDigits(CalcTotFlowVol, 2) +
                                                 " m3/s");
                            } // warning check on pump flow rate vs circ rate input
                        }     // blank pump flow rate
                        SecondaryFlowVolRated = PumpTotRatedFlowVol;

                    } // fluid type AlwaysLiquid or PhaseChange ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                    // Read number of pumps (or pump stages) in secondary loop
                    int NumPumps = 1; // default value
                    if ((!lNumericBlanks(6)) && (Numbers(6) >= 1)) NumPumps = Numbers(6);
                    Secondary(SecondaryNum).NumPumps = NumPumps;
                    // Get pump power (users can input either power in W or head in Pa or both)
                    // Assume pump impeller efficiency is 0.78 (consistent with E+ Pump auto sizing assumption)
                    // Assume pump motor efficiency is 0.85 (Goulds Pumps motor data sheet)
                    // It is important that tot rated head must be for specific fluid
                    Real64 PumpTotRatedHead(0.0); // Total pump rated head on secondary loop (Pa)

                    if ((!lNumericBlanks(8)) && (!lNumericBlanks(9))) {
                        Secondary(SecondaryNum).PumpTotRatedPower = Numbers(8);
                        PumpTotRatedHead = Numbers(9);
                        Real64 ErrSecondPumpPower = (Secondary(SecondaryNum).PumpTotRatedPower -
                                              PumpTotRatedFlowVol * PumpTotRatedHead / (PumpImpellerEfficiency * PumpMotorEfficiency)) /
                                             Secondary(SecondaryNum).PumpTotRatedPower;
                        if (std::abs(ErrSecondPumpPower) > 0.35)
                            ShowWarningError(CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + " Input value for " +
                                             cNumericFieldNames(9) + " not consistent with input value for " + cNumericFieldNames(8) + ". " +
                                             cNumericFieldNames(8) +
                                             " will be used"); // generous diff allowed because comparing to my assumed impeller and motor effs
                    } else if (!lNumericBlanks(8)) {
                        Secondary(SecondaryNum).PumpTotRatedPower = Numbers(8);
                    } else if (!lNumericBlanks(9)) {
                        PumpTotRatedHead = Numbers(9);
                        Secondary(SecondaryNum).PumpTotRatedPower =
                            PumpTotRatedFlowVol * PumpTotRatedHead / (PumpImpellerEfficiency * PumpMotorEfficiency);
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", Either \"" +
                                        cNumericFieldNames(8) + "\" OR \"" + cNumericFieldNames(9) + "\" must be input.");
                        ErrorsFound = true;
                    } // Either or pump power Input variations (head or power)

                    // Get pump drive type
                    AlphaNum = 5;
                    Secondary(SecondaryNum).PumpControlType = SecPumpControlConstant; // default
                    if (!lAlphaBlanks(AlphaNum)) {
                        if (UtilityRoutines::SameString(Alphas(AlphaNum), "Constant")) {
                            Secondary(SecondaryNum).PumpControlType = SecPumpControlConstant;
                        } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "Variable")) {
                            Secondary(SecondaryNum).PumpControlType = SecPumpControlVariable;
                        } else {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\"  " +
                                            cAlphaFieldNames(AlphaNum) + " not recognized = " + Alphas(AlphaNum));
                            ShowContinueError("Check input value choices.");
                            ErrorsFound = true;
                        } // Set PumpControlType
                    }     // blank on pump drive control type

                    //  Print warning if Pump Control = Constant and Variable Speed Curve is specified.
                    if ((Secondary(SecondaryNum).PumpControlType == SecPumpControlConstant) && (!lAlphaBlanks(AlphaNum + 1))) {
                        ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", A " +
                                         cAlphaFieldNames(AlphaNum + 1) + " is specified even though " + cAlphaFieldNames(AlphaNum) +
                                         " is \"CONSTANT\".");
                        ShowContinueError("The secondary loop pump(s) will be modeled as constant speed and the " + cAlphaFieldNames(AlphaNum + 1) +
                                          " will be ignored.");
                    }

                    if (Secondary(SecondaryNum).PumpControlType == SecPumpControlConstant) {
                        // Set incremental flow and power amounts for pump dispatch
                        Secondary(SecondaryNum).PumpIncrementFlowVol = PumpTotRatedFlowVol / NumPumps;
                        Secondary(SecondaryNum).PumpIncrementPower = Secondary(SecondaryNum).PumpTotRatedPower / NumPumps;
                    } else { // Variable speed drive need to read in power curve
                        AlphaNum = 6;
                        Secondary(SecondaryNum).VarSpeedCurvePtr = CurveManager::GetCurveIndex(Alphas(AlphaNum)); // convert curve name to number
                        if (Secondary(SecondaryNum).VarSpeedCurvePtr == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", invalid  " +
                                            cAlphaFieldNames(AlphaNum) + " not found:" + Alphas(AlphaNum));
                            ErrorsFound = true;
                        }
                        ErrorsFound |= CurveManager::CheckCurveDims(Secondary(SecondaryNum).VarSpeedCurvePtr, // Curve index
                            {1},                            // Valid dimensions
                            RoutineName,                    // Routine name
                            CurrentModuleObject,            // Object Type
                            Secondary(SecondaryNum).Name,     // Object Name
                            cAlphaFieldNames(AlphaNum));    // Field Name
                    } // input power conditions/levels for constant or variable speed pump drives

                    // Default non-hermetic motor eff at 85% and all shaft power goes to heat in fluid
                    // In a semi-hermetic motor, assume all power to motor goes to heat in fluid
                    Secondary(SecondaryNum).PumpPowerToHeat = PumpMotorEfficiency;
                    NumNum = 11;
                    if (!lNumericBlanks(NumNum)) {
                        if ((0.5 <= Numbers(NumNum)) && (1.0 >= Numbers(NumNum))) {
                            Secondary(SecondaryNum).PumpPowerToHeat = Numbers(NumNum);
                        } else {
                            ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\" " +
                                             cNumericFieldNames(NumNum) + " must be between 0.5 and 1.0. Default value of : " +
                                             General::RoundSigDigits(PumpMotorEfficiency, 3) + " will be used");
                        } // range of pump moter heat to fluid
                    }     // blank input for pumppowertoheat

                    // Distribution piping heat gain - optional
                    //  Input UA and Zone containing the bulk of the secondary coolant distribution piping
                    //  This Zone ID will be used to determine the temperature used for distribution piping heat gain.
                    //  Zone Id is only required if Sum UA Distribution Piping >0.0
                    //  Get the Zone node number from the zone name entered by the user
                    Secondary(SecondaryNum).SumUADistPiping = 0.0;
                    AlphaNum = 7;
                    NumNum = 12;
                    if (!lNumericBlanks(NumNum) && !lAlphaBlanks(AlphaNum)) {
                        Secondary(SecondaryNum).SumUADistPiping = Numbers(NumNum);
                        Secondary(SecondaryNum).DistPipeZoneNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), DataHeatBalance::Zone);
                        Secondary(SecondaryNum).DistPipeZoneNodeNum = DataZoneEquipment::GetSystemNodeNumberForZone(state, Alphas(AlphaNum));

                        if (Secondary(SecondaryNum).DistPipeZoneNum == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", invalid  " +
                                            cAlphaFieldNames(AlphaNum) + " not valid: " + Alphas(AlphaNum));
                            ErrorsFound = true;
                        } else {
                            RefrigPresentInZone(Secondary(SecondaryNum).DistPipeZoneNum) = true;
                        }

                        if (Secondary(SecondaryNum).DistPipeZoneNodeNum == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                            "\" System Node Number not found for " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum) +
                                            " even though " + cNumericFieldNames(NumNum) +
                                            " is greater than zero. Distribution piping heat gain cannot be calculated unless a controlled Zone "
                                            "(appear in a ZoneHVAC:EquipmentConnections object.) is defined to determine the environmental "
                                            "temperature surrounding the piping.");
                            ErrorsFound = true;
                        }
                    } else if (!lNumericBlanks(NumNum) && lAlphaBlanks(AlphaNum)) {
                        ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", " +
                                         cAlphaFieldNames(AlphaNum) + " not found even though " + cNumericFieldNames(NumNum) +
                                         " is greater than zero. Distribution piping heat gain will not be calculated unless a Zone is defined to "
                                         "deterimine the environmental temperature surrounding the piping.");
                    } else if (lNumericBlanks(NumNum) && !lAlphaBlanks(AlphaNum)) {
                        ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", " +
                                         cAlphaFieldNames(AlphaNum) +
                                         " will not be used and distribution piping heat gain will not be calculated because " +
                                         cNumericFieldNames(NumNum) + " was blank.");
                    } // distribution piping

                    // Separator/receiver heat gain - optional
                    //  Input UA and Zone containing the Separator/receiver
                    //  This Zone ID will be used to determine the temperature used for Separator/receiver heat gain.
                    //  Zone Id is only required if Sum UA Separator/receiver >0.0
                    //  Get the Zone node number from the zone name entered by the user
                    Secondary(SecondaryNum).SumUAReceiver = 0.0;
                    AlphaNum = 8;
                    NumNum = 13;
                    if (!lNumericBlanks(NumNum) && !lAlphaBlanks(AlphaNum)) {
                        Secondary(SecondaryNum).SumUAReceiver = Numbers(NumNum);
                        Secondary(SecondaryNum).ReceiverZoneNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), DataHeatBalance::Zone);
                        Secondary(SecondaryNum).ReceiverZoneNodeNum = DataZoneEquipment::GetSystemNodeNumberForZone(state, Alphas(AlphaNum));

                        if (Secondary(SecondaryNum).ReceiverZoneNum == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", invalid  " +
                                            cAlphaFieldNames(AlphaNum) + " not valid: " + Alphas(AlphaNum));
                            ErrorsFound = true;
                        } else {
                            RefrigPresentInZone(Secondary(SecondaryNum).ReceiverZoneNum) = true;
                        }
                        if (Secondary(SecondaryNum).ReceiverZoneNodeNum == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                            "\" System Node Number not found for " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum) +
                                            " even though " + cNumericFieldNames(NumNum) +
                                            " is greater than zero. Receiver heat gain cannot be calculated unless a controlled Zone (appear in a "
                                            "ZoneHVAC:EquipmentConnections object.) is defined to determine the environmental temperature "
                                            "surrounding the Receiver.");
                            ErrorsFound = true;
                        }
                    } else if (!lNumericBlanks(NumNum) && lAlphaBlanks(AlphaNum)) {
                        ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", " +
                                         cAlphaFieldNames(AlphaNum) + " not found even though " + cNumericFieldNames(NumNum) +
                                         " is greater than zero. Receiver heat gain will not be calculated unless a Zone is defined to deterimine "
                                         "the environmental temperature surrounding the Receiver.");
                    } else if (lNumericBlanks(NumNum) && !lAlphaBlanks(AlphaNum)) {
                        ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", " +
                                         cAlphaFieldNames(AlphaNum) + " will not be used and Receiver heat gain will not be calculated because " +
                                         cNumericFieldNames(NumNum) + " was blank.");
                    } // Receiver

                    NumNum = 14;
                    Secondary(SecondaryNum).ChillerRefInventory = 0.0;
                    if (!lNumericBlanks(NumNum)) Secondary(SecondaryNum).ChillerRefInventory = Numbers(NumNum);
                    if (Secondary(SecondaryNum).ChillerRefInventory < 0.0) {
                        Secondary(SecondaryNum).ChillerRefInventory = 0.0;
                        ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name + "\", The value specified for " +
                                         cNumericFieldNames(NumNum) + " is less than zero. The default value of zero will be used.");
                    }

                    AlphaNum = 9;
                    if (!lAlphaBlanks(AlphaNum)) Secondary(SecondaryNum).EndUseSubcategory = Alphas(AlphaNum);

                    // Error checks on secondary loop:
                    // Note, rated capacities can be far off from operating capacities, but rough checks here
                    //       (don't include dist piping or receiver heat gains).
                    // Load limit logic here (maxvolflow and maxload used in calcs later)
                    Secondary(SecondaryNum).MaxVolFlow = min(SecondaryFlowVolRated, PumpTotRatedFlowVol);
                    Real64 NominalSecondaryRefLoad = NominalTotalCaseCap + NominalTotalWalkInCap + Secondary(SecondaryNum).PumpTotRatedPower;

                    if (Secondary(SecondaryNum).FluidType == SecFluidTypeAlwaysLiquid) {
                        if (TBrineOutRated > (Secondary(SecondaryNum).TMinNeeded + 0.5)) {
                            ShowWarningError(
                                CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                " The design brine temperature to the refrigeration loads: " + General::RoundSigDigits(TBrineOutRated, 1) + " ;");
                            ShowContinueError(" is greater than the design inlet temperature for at least one of the cases or walkins: " +
                                              General::RoundSigDigits(Secondary(SecondaryNum).TMinNeeded, 1));
                            ShowContinueError(
                                " Compare your Approach and Evaporating Temperature to the design inlet temperatures needed for the loads.");
                            // ErrorsFound = .TRUE.
                        } // Tbrine out warning
                        Real64 CapacityAtMaxVolFlow = Secondary(SecondaryNum).MaxVolFlow * Secondary(SecondaryNum).HeatExchangeEta *
                                               (CpBrineRated * DensityBrineRated) * (TBrineInRated - Secondary(SecondaryNum).TEvapDesign);
                        Secondary(SecondaryNum).MaxLoad = min(Secondary(SecondaryNum).CoolingLoadRated, CapacityAtMaxVolFlow);
                        Real64 DeltaCap1 =
                            std::abs((Secondary(SecondaryNum).CoolingLoadRated - CapacityAtMaxVolFlow) / Secondary(SecondaryNum).CoolingLoadRated);
                        if (DeltaCap1 > (0.3)) { // diff between chiller rating and capacity at max flow > 30%
                            ShowWarningError(CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                             "\" You may wish to check the system sizing.  The nominal secondary loop heat exchanger capacity is " +
                                             General::RoundSigDigits(Secondary(SecondaryNum).CoolingLoadRated, 0) +
                                             " But the capacity based upon the maximum flow rate is " +
                                             General::RoundSigDigits(CapacityAtMaxVolFlow, 0));
                        }                            // DeltaCap1 > .3
                    } else {                         // Fluid type phase change                !^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                        if (lNumericBlanks(1)) {     // Chiller/evaporator capacity was not specified
                            if (lNumericBlanks(7)) { // Pump power was not input, calc based on flow and head
                                // need to refine because capacity calculated, but needs to include pump power (which was prev
                                //   estimated based upon capacity which had been estimated as sum of case and walk-in capacities)
                                PumpTotRatedFlowVol =
                                    NominalSecondaryRefLoad * Secondary(SecondaryNum).CircRate / (DensityPhaseChange * DeltaHPhaseChange);
                                Secondary(SecondaryNum).PumpTotRatedPower =
                                    PumpTotRatedFlowVol * PumpTotRatedHead / (PumpImpellerEfficiency * PumpMotorEfficiency);
                                // need to recalc nominal load with new pump power value
                                NominalSecondaryRefLoad = NominalTotalCaseCap + NominalTotalWalkInCap + Secondary(SecondaryNum).PumpTotRatedPower;
                                if (Secondary(SecondaryNum).PumpControlType == SecPumpControlConstant) {
                                    // Set incremental flow and power amounts for pump dispatch
                                    Secondary(SecondaryNum).PumpIncrementFlowVol = PumpTotRatedFlowVol / NumPumps;
                                    Secondary(SecondaryNum).PumpIncrementPower = Secondary(SecondaryNum).PumpTotRatedPower / NumPumps;
                                } // constant speed pump
                            }     // Pump power was not specified
                            Secondary(SecondaryNum).CoolingLoadRated = NominalSecondaryRefLoad;
                        } // Chiller/evap capacity was not specified
                        Secondary(SecondaryNum).MaxLoad = Secondary(SecondaryNum).CoolingLoadRated;
                    } // SecFluidType

                    Real64 DeltaCap2 =
                        std::abs((Secondary(SecondaryNum).CoolingLoadRated - NominalSecondaryRefLoad) / Secondary(SecondaryNum).CoolingLoadRated);
                    if (DeltaCap2 > (0.3)) { // diff between chiller rating and sum of nominal loads > 30%
                        ShowWarningError(CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                         "\" You may wish to check the system sizing. Total nominal refrigerating load is " +
                                         General::RoundSigDigits(NominalSecondaryRefLoad, 0) +
                                         " (Including cases, walk-ins, and pump heat).  The nominal secondary loop heat exchanger capacity is " +
                                         General::RoundSigDigits(Secondary(SecondaryNum).CoolingLoadRated, 0));
                    }
                    // compare rated xt xchanger brine flow to the total rated pump flow
                    if (SecondaryFlowVolRated > (1.1 * PumpTotRatedFlowVol)) {
                        ShowWarningError(CurrentModuleObject + "=\"" + Secondary(SecondaryNum).Name +
                                         "\" You may wish to check the pump sizing. Total nominal brine flow is " +
                                         General::RoundSigDigits(SecondaryFlowVolRated, 0) + " m3/s, but the total nominal pump flow rate is:  " +
                                         General::RoundSigDigits(PumpTotRatedFlowVol, 0) + " m3/s. ");
                    }

                } // Secondary Loops
            }     //(  IF (NumSimulationSecondarySystems > 0)

            //************ END SECONDARY SYSTEM INPUT  **************

            //************ START Compressor INPUT  **************

            CurrentModuleObject = "Refrigeration:Compressor";
            for (int CompNum = 1; CompNum <= NumSimulationCompressors; ++CompNum) {
                inputProcessor->getObjectItem(CurrentModuleObject,
                                              CompNum,
                                              Alphas,
                                              NumAlphas,
                                              Numbers,
                                              NumNumbers,
                                              IOStatus,
                                              lNumericBlanks,
                                              lAlphaBlanks,
                                              cAlphaFieldNames,
                                              cNumericFieldNames);
                UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                Compressor(CompNum).Name = Alphas(1);

                Compressor(CompNum).ElecPowerCurvePtr = CurveManager::GetCurveIndex(Alphas(2)); // convert curve name to number
                if ((!lAlphaBlanks(2)) && Compressor(CompNum).ElecPowerCurvePtr == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Compressor(CompNum).Name + "\", invalid  " + cAlphaFieldNames(2) +
                                    " not found = " + Alphas(2));
                    ErrorsFound = true;
                }

                Compressor(CompNum).CapacityCurvePtr = CurveManager::GetCurveIndex(Alphas(3)); // convert curve name to number
                if ((!lAlphaBlanks(3)) && Compressor(CompNum).CapacityCurvePtr == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Compressor(CompNum).Name + "\", invalid  " + cAlphaFieldNames(3) +
                                    " not found = " + Alphas(3));
                    ErrorsFound = true;
                }

                // Get superheat rating type (Either N1 or N2 Must be input)
                if (((!lNumericBlanks(1)) && (!lNumericBlanks(2))) || (lNumericBlanks(1) && lNumericBlanks(2))) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Compressor(CompNum).Name + "\"One, and Only One of " +
                                    cNumericFieldNames(1) + " or " + cNumericFieldNames(2));
                    ShowContinueError("Must Be Entered. Check input value choices.");
                    ErrorsFound = true;
                } else if (!lNumericBlanks(1)) {
                    Compressor(CompNum).SuperheatRatingType = RatedSuperheat;
                    Compressor(CompNum).RatedSuperheat = Numbers(1);
                } else if (!lNumericBlanks(2)) {
                    Compressor(CompNum).SuperheatRatingType = RatedReturnGasTemperature;
                    Compressor(CompNum).RatedSuperheat = Numbers(2);
                } // Set SuperheatRatingType

                // Get subcool rating type (Either N3 or N4 Must be input)
                if (((!lNumericBlanks(3)) && (!lNumericBlanks(4))) || (lNumericBlanks(3) && lNumericBlanks(4))) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Compressor(CompNum).Name + "\" One, and Only One of " +
                                    cNumericFieldNames(3) + " or " + cNumericFieldNames(4));
                    ShowContinueError("Must Be Entered. Check input value choices.");
                    ErrorsFound = true;
                } else if (!lNumericBlanks(3)) {
                    Compressor(CompNum).SubcoolRatingType = RatedLiquidTemperature;
                    Compressor(CompNum).RatedSubcool = Numbers(3);
                } else if (!lNumericBlanks(4)) {
                    Compressor(CompNum).SubcoolRatingType = RatedSubcooling;
                    Compressor(CompNum).RatedSubcool = Numbers(4);
                } // Set SubcoolRatingType

                Compressor(CompNum).EndUseSubcategory = "General";
                if (!lAlphaBlanks(4)) Compressor(CompNum).EndUseSubcategory = Alphas(4);

                //  If the compressor is a transcritical CO compressor, get transcritical power and capacity curves
                if (UtilityRoutines::SameString(Alphas(5), "Transcritical")) { // Mode of Operation = Transcritical
                    Compressor(CompNum).TransFlag = true;
                    Compressor(CompNum).TransElecPowerCurvePtr = CurveManager::GetCurveIndex(Alphas(6)); // convert curve name to number
                    if (lAlphaBlanks(6) && Compressor(CompNum).TransElecPowerCurvePtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + '=' + Compressor(CompNum).Name + ": " + cAlphaFieldNames(6) +
                                        " not found.");
                        ErrorsFound = true;
                    }
                    Compressor(CompNum).TransCapacityCurvePtr = CurveManager::GetCurveIndex(Alphas(7)); // convert curve name to number
                    if (lAlphaBlanks(7) && Compressor(CompNum).TransCapacityCurvePtr == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + '=' + Compressor(CompNum).Name + ": " + cAlphaFieldNames(7) +
                                        " not found.");
                        ErrorsFound = true;
                    }
                } else if ((UtilityRoutines::SameString(Alphas(5), "Subcritical")) || (lAlphaBlanks(5))) { // Mode of Operation = Subcritical
                    Compressor(CompNum).TransFlag = false;
                    if ((!lAlphaBlanks(6)) || (!lAlphaBlanks(7))) { // Transcritical compressor curves specified for subcritical compressor
                        ShowWarningError(RoutineName + CurrentModuleObject + '=' + Compressor(CompNum).Name +
                                         " is specified to be a subcritical compressor, however transcritical compressor curve(s) are given.");
                        ShowContinueError(
                            "The compressor will be modeled as a subcritical compressor and the transcritical compressor curve(s) will be ignored.");
                    }
                } else { // Invalid Mode of Operation
                    ShowSevereError(RoutineName + CurrentModuleObject + ": " + cAlphaFieldNames(5) + " for " + Compressor(CompNum).Name + '=' +
                                    Alphas(5) + R"( is invalid. Valid choices are "Subcritical" or "Transcritical".)");
                    ErrorsFound = true;
                }

            } // RefrigCompressor

            //************ END Compressor INPUT         **************

            //************ START Subcooler INPUT        **************
            if (NumSimulationSubcoolers > 0) {
                CurrentModuleObject = "Refrigeration:Subcooler";
                NumSimulationMechSubcoolers = 0;
                for (int SubcoolerNum = 1; SubcoolerNum <= NumSimulationSubcoolers; ++SubcoolerNum) {
                    inputProcessor->getObjectItem(CurrentModuleObject,
                                                  SubcoolerNum,
                                                  Alphas,
                                                  NumAlphas,
                                                  Numbers,
                                                  NumNumbers,
                                                  IOStatus,
                                                  lNumericBlanks,
                                                  lAlphaBlanks,
                                                  cAlphaFieldNames,
                                                  cNumericFieldNames);
                    UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                    Subcooler(SubcoolerNum).Name = Alphas(1);

                    // Get subcooler type
                    Subcooler(SubcoolerNum).SubcoolerType = LiquidSuction;      // default subcooler type
                    if (UtilityRoutines::SameString(Alphas(2), "Mechanical")) { // set subcooler type
                        Subcooler(SubcoolerNum).SubcoolerType = Mechanical;
                        ++NumSimulationMechSubcoolers;
                    } else if (UtilityRoutines::SameString(Alphas(2), "LiquidSuction")) {
                        Subcooler(SubcoolerNum).SubcoolerType = LiquidSuction;
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Subcooler(SubcoolerNum).Name + "\", " + cAlphaFieldNames(2) +
                                        " not recognized = " + Alphas(2));
                        ShowContinueError("Check input value choices.");
                        ErrorsFound = true;
                    } // Set Subcooler Type

                    {
                        auto const SELECT_CASE_var(Subcooler(SubcoolerNum).SubcoolerType);

                        if (SELECT_CASE_var == LiquidSuction) {
                            Subcooler(SubcoolerNum).LiqSuctDesignDelT = 10.0; // default value
                            if (!lNumericBlanks(1)) Subcooler(SubcoolerNum).LiqSuctDesignDelT = Numbers(1);
                            if (Subcooler(SubcoolerNum).LiqSuctDesignDelT < 0.0) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Subcooler(SubcoolerNum).Name + "\" " +
                                                cNumericFieldNames(1) + " cannot be less than zero.");
                                ErrorsFound = true;
                            }

                            if (!lNumericBlanks(2)) {
                                Subcooler(SubcoolerNum).LiqSuctDesignTliqIn = Numbers(2);
                            } else {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Subcooler(SubcoolerNum).Name + "\" " +
                                                cNumericFieldNames(2) + " must be specified.");
                                ErrorsFound = true;
                            }

                            if (!lNumericBlanks(3)) {
                                Subcooler(SubcoolerNum).LiqSuctDesignTvapIn = Numbers(3);
                            } else {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Subcooler(SubcoolerNum).Name + "\" " +
                                                cNumericFieldNames(3) + " must be specified.");
                                ErrorsFound = true;
                            }
                            if (Subcooler(SubcoolerNum).LiqSuctDesignTvapIn > Subcooler(SubcoolerNum).LiqSuctDesignTliqIn) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Subcooler(SubcoolerNum).Name + "\" " +
                                                cNumericFieldNames(3) + " cannot be greater than " + cNumericFieldNames(2) + '.');
                                ErrorsFound = true;
                            } // error check

                        } else if (SELECT_CASE_var == Mechanical) {
                            Subcooler(SubcoolerNum).MechSourceSys = Alphas(3);
                            // Error check on system name comes later after systems have been read

                            if (!lNumericBlanks(4)) {
                                Subcooler(SubcoolerNum).MechControlTliqOut = Numbers(4);
                            } else {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Subcooler(SubcoolerNum).Name + "\" " +
                                                cNumericFieldNames(4) + " must be specified.");
                                ErrorsFound = true;
                            } // error check
                        }
                    }

                } // Subcooler Input
            }     // If there are subcoolers

            // ********END SUBCOOLER INPUTS ************

            //**** Read TransferLoad Lists **********************************************************
            if (NumSimulationTransferLoadLists > 0) {
                CurrentModuleObject = "Refrigeration:TransferLoadList";
                for (int ListNum = 1; ListNum <= NumSimulationTransferLoadLists; ++ListNum) {
                    inputProcessor->getObjectItem(CurrentModuleObject,
                                                  ListNum,
                                                  Alphas,
                                                  NumAlphas,
                                                  Numbers,
                                                  NumNumbers,
                                                  IOStatus,
                                                  lNumericBlanks,
                                                  lAlphaBlanks,
                                                  cAlphaFieldNames,
                                                  cNumericFieldNames);
                    UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                    TransferLoadList(ListNum).Name = Alphas(1);

                    // Transfer load list alphas include TransferLoadList name and one name for each Secondary or Cascade Condenser in list
                    // below allocates larger than needed (each allocated to sum of both), but avoids two loops through input fields
                    int NumTotalLoadsOnList = NumAlphas - 1;
                    if (!allocated(TransferLoadList(ListNum).CascadeLoadItemNum))
                        TransferLoadList(ListNum).CascadeLoadItemNum.allocate(NumTotalLoadsOnList);
                    if (!allocated(TransferLoadList(ListNum).SecondaryItemNum))
                        TransferLoadList(ListNum).SecondaryItemNum.allocate(NumTotalLoadsOnList);

                    int NumSecondarysOnList = 0;
                    int NumCascadeLoadsOnList = 0;
                    for (int NumLoad = 1; NumLoad <= NumTotalLoadsOnList; ++NumLoad) {
                        int AlphaListNum = 1 + NumLoad;
                        int LoadCascadeNum = 0;
                        int LoadSecondaryNum = 0;
                        if (DataHeatBalance::NumRefrigCondensers > 0)
                            LoadCascadeNum = UtilityRoutines::FindItemInList(Alphas(AlphaListNum), Condenser);
                        if (NumSimulationSecondarySystems > 0) LoadSecondaryNum = UtilityRoutines::FindItemInList(Alphas(AlphaListNum), Secondary);
                        if ((LoadCascadeNum == 0) && (LoadSecondaryNum == 0)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + cAlphaFieldNames(AlphaListNum) +
                                            "\" : has an invalid value of " + Alphas(AlphaListNum));
                            ErrorsFound = true;
                        } else if ((LoadCascadeNum != 0) && (LoadSecondaryNum != 0)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + cAlphaFieldNames(AlphaListNum) +
                                            "\" : has a non-unique name : " + Alphas(AlphaListNum));
                            ErrorsFound = true;
                        } else if (LoadCascadeNum != 0) {
                            if (Condenser(LoadCascadeNum).CondenserType != DataHeatBalance::RefrigCondenserTypeCascade) {
                                ShowSevereError(
                                    RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                    "\" : has a condenser listed as a transfer load that is not a cascade condenser: " + Alphas(AlphaListNum));
                                ErrorsFound = true;
                            } else {
                                ++NumCascadeLoadsOnList;
                                TransferLoadList(ListNum).CascadeLoadItemNum(NumCascadeLoadsOnList) = LoadCascadeNum;
                            } // /= condenser cascade type
                        } else if (LoadSecondaryNum != 0) {
                            ++NumSecondarysOnList;
                            TransferLoadList(ListNum).SecondaryItemNum(NumSecondarysOnList) = LoadSecondaryNum;
                        }
                        TransferLoadList(ListNum).NumSecondarys = NumSecondarysOnList;
                        TransferLoadList(ListNum).NumCascadeLoads = NumCascadeLoadsOnList;
                    } // Num Total Loads on List
                }     // ListNum=1,NumSimulationTransferLoadLists
            }         //(NumSimulationTransferLoadLists > 0)

            //**** End read transfer load Lists **********************************************************

            //**** Read Compressor Lists **********************************************************
            CurrentModuleObject = "Refrigeration:CompressorList";
            for (int ListNum = 1; ListNum <= NumCompressorLists; ++ListNum) {
                inputProcessor->getObjectItem(CurrentModuleObject,
                                              ListNum,
                                              Alphas,
                                              NumAlphas,
                                              Numbers,
                                              NumNumbers,
                                              IOStatus,
                                              lNumericBlanks,
                                              lAlphaBlanks,
                                              cAlphaFieldNames,
                                              cNumericFieldNames);
                CompressorLists(ListNum).NumCompressors = NumAlphas - 1;
                UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                CompressorLists(ListNum).Name = Alphas(1);
                if (!allocated(CompressorLists(ListNum).CompItemNum))
                    CompressorLists(ListNum).CompItemNum.allocate(CompressorLists(ListNum).NumCompressors);

                for (int CompIndex = 1; CompIndex <= CompressorLists(ListNum).NumCompressors; ++CompIndex) {
                    int AlphaListNum = CompIndex + 1; // same as do loop from 2 to end of list
                    if (!lAlphaBlanks(AlphaListNum)) {
                        CompressorLists(ListNum).CompItemNum(CompIndex) = UtilityRoutines::FindItemInList(Alphas(AlphaListNum), Compressor);
                        if (CompressorLists(ListNum).CompItemNum(CompIndex) == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + CompressorLists(ListNum).Name + "\", has an invalid " +
                                            cAlphaFieldNames(AlphaListNum) + " defined as " + Alphas(AlphaListNum));
                            ErrorsFound = true;
                        }
                    }
                } // NumCompressors in CompressorList

            } // NumCompressorLists

            // ********READ REFRIGERATION SYSTEMS  ***********

            CurrentModuleObject = "Refrigeration:System";
            for (RefrigSysNum = 1; RefrigSysNum <= DataHeatBalance::NumRefrigSystems; ++RefrigSysNum) {

                inputProcessor->getObjectItem(CurrentModuleObject,
                                              RefrigSysNum,
                                              Alphas,
                                              NumAlphas,
                                              Numbers,
                                              NumNumbers,
                                              IOStatus,
                                              lNumericBlanks,
                                              lAlphaBlanks,
                                              cAlphaFieldNames,
                                              cNumericFieldNames);
                UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                System(RefrigSysNum).Name = Alphas(1);

                // Read all loads on this System: cases, walk-ins, cascade loads, and secondary loops
                if (lAlphaBlanks(2) && lAlphaBlanks(3)) {
                    // No cases, walkins, cascade loads, or secondary loops specified, ie, System has no load
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                    "\", has no loads, must have at least one of: " + cAlphaFieldNames(2) + " or " + cAlphaFieldNames(3) +
                                    " objects attached.");
                    ErrorsFound = true;
                }
                NumCases = 0;
                System(RefrigSysNum).NumCases = 0;
                int NumCoils = 0;
                System(RefrigSysNum).NumCoils = 0;
                NumWalkIns = 0;
                System(RefrigSysNum).NumWalkIns = 0;
                int NumSecondary = 0;
                System(RefrigSysNum).NumSecondarys = 0;
                System(RefrigSysNum).NumCascadeLoads = 0;
                System(RefrigSysNum).NumNonCascadeLoads = 0;
                Real64 NominalTotalCaseCap = 0.0;
                Real64 NominalTotalCoilCap = 0.0;
                Real64 NominalTotalWalkInCap = 0.0;
                Real64 NominalTotalSecondaryCap = 0.0;
                Real64 NominalTotalCoolingCap;
                Real64 NominalTotalCascadeLoad = 0.0;
                System(RefrigSysNum).RefInventory = 0.0;

                //   Check for case or walkin or CaseAndWalkInList names
                AlphaNum = 2;
                if (!lAlphaBlanks(AlphaNum)) {

                    // Entry for Alphas(AlphaNum) can be either a Case, WalkIn or CaseAndWalkInList name
                    int CaseAndWalkInListNum = 0;
                    int CaseNum = 0;
                    int WalkInNum = 0;
                    int CoilNum = 0;
                    if (NumSimulationCaseAndWalkInLists > 0)
                        CaseAndWalkInListNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), CaseAndWalkInList);
                    if (NumSimulationCases > 0) CaseNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), RefrigCase);
                    if (NumSimulationWalkIns > 0) WalkInNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), WalkIn);
                    if (NumSimulationRefrigAirChillers > 0) CoilNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), WarehouseCoil);
                    int NumNameMatches = 0;
                    if (CaseAndWalkInListNum != 0) ++NumNameMatches;
                    if (CaseNum != 0) ++NumNameMatches;
                    if (WalkInNum != 0) ++NumNameMatches;
                    if (CoilNum != 0) ++NumNameMatches;

                    if (NumNameMatches != 1) { // name must uniquely point to a list or a single case or walkin or coil
                        ErrorsFound = true;
                        if (NumNameMatches == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", has an invalid " +
                                            cAlphaFieldNames(AlphaNum) + ": " + Alphas(AlphaNum));
                        } else if (NumNameMatches > 1) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                            "\",  has a non-unique name that could be either a " + cAlphaFieldNames(AlphaNum) + ": " +
                                            Alphas(AlphaNum));
                        }                                   // num matches = 0 or > 1
                    } else if (CaseAndWalkInListNum != 0) { // Name points to a CaseAndWalkInList
                        NumCases = CaseAndWalkInList(CaseAndWalkInListNum).NumCases;
                        NumWalkIns = CaseAndWalkInList(CaseAndWalkInListNum).NumWalkIns;
                        NumCoils = CaseAndWalkInList(CaseAndWalkInListNum).NumCoils;
                        System(RefrigSysNum).NumCases = NumCases;
                        System(RefrigSysNum).NumWalkIns = NumWalkIns;
                        System(RefrigSysNum).NumCoils = NumCoils;
                        if (NumCases > 0) {
                            if (!allocated(System(RefrigSysNum).CaseNum)) System(RefrigSysNum).CaseNum.allocate(NumCases);
                            System(RefrigSysNum).CaseNum({1, NumCases}) = CaseAndWalkInList(CaseAndWalkInListNum).CaseItemNum({1, NumCases});
                        }
                        if (NumCoils > 0) {
                            if (!allocated(System(RefrigSysNum).CoilNum)) System(RefrigSysNum).CoilNum.allocate(NumCoils);
                            System(RefrigSysNum).CoilNum({1, NumCoils}) = CaseAndWalkInList(CaseAndWalkInListNum).CoilItemNum({1, NumCoils});
                        }
                        if (NumWalkIns > 0) {
                            if (!allocated(System(RefrigSysNum).WalkInNum)) System(RefrigSysNum).WalkInNum.allocate(NumWalkIns);
                            System(RefrigSysNum).WalkInNum({1, NumWalkIns}) = CaseAndWalkInList(CaseAndWalkInListNum).WalkInItemNum({1, NumWalkIns});
                        }
                    } else if (CaseNum != 0) { // Name points to a case
                        NumCases = 1;
                        System(RefrigSysNum).NumCases = 1;
                        if (!allocated(System(RefrigSysNum).CaseNum)) System(RefrigSysNum).CaseNum.allocate(NumCases);
                        System(RefrigSysNum).CaseNum(NumCases) = CaseNum;
                    } else if (CoilNum != 0) { // Name points to a coil
                        NumCoils = 1;
                        System(RefrigSysNum).NumCoils = 1;
                        if (!allocated(System(RefrigSysNum).CoilNum)) System(RefrigSysNum).CoilNum.allocate(NumCoils);
                        System(RefrigSysNum).CoilNum(NumCoils) = CoilNum;
                    } else if (WalkInNum != 0) { // Name points to a walkin
                        NumWalkIns = 1;
                        System(RefrigSysNum).NumWalkIns = 1;
                        if (!allocated(System(RefrigSysNum).WalkInNum)) System(RefrigSysNum).WalkInNum.allocate(NumWalkIns);
                        System(RefrigSysNum).WalkInNum(NumWalkIns) = WalkInNum;
                    } // NumNameMatches /= 1
                }     // blank input for cases, walkins, or caseandwalkinlist

                if (NumCases > 0) {
                    // Find lowest design evap T
                    // Sum rated capacity of all cases on system
                    for (int caseIndex = 1; caseIndex <= NumCases; ++caseIndex) {
                        // mark all cases on system as used by this system - checking for unused or non-unique cases
                        int CaseNum = System(RefrigSysNum).CaseNum(caseIndex);
                        ++RefrigCase(CaseNum).NumSysAttach;
                        NominalTotalCaseCap += RefrigCase(CaseNum).DesignRatedCap;
                        System(RefrigSysNum).RefInventory += RefrigCase(CaseNum).DesignRefrigInventory;
                        if (caseIndex == 1) { // look for lowest case design evap T for system
                            System(RefrigSysNum).TEvapDesign = RefrigCase(CaseNum).EvapTempDesign;
                        } else {
                            System(RefrigSysNum).TEvapDesign = min(RefrigCase(CaseNum).EvapTempDesign, System(RefrigSysNum).TEvapDesign);
                        }
                    } // CaseIndex=1,NumCases
                    System(RefrigSysNum).NumNonCascadeLoads += System(RefrigSysNum).NumCases;
                } // Numcases > 0

                if (NumCoils > 0) {
                    // Find lowest design evap T
                    // Sum rated capacity of all Coils on system
                    for (int CoilIndex = 1; CoilIndex <= NumCoils; ++CoilIndex) {
                        // mark all Coils on system as used by this system - checking for unused or non-unique Coils
                        int CoilNum = System(RefrigSysNum).CoilNum(CoilIndex);
                        ++WarehouseCoil(CoilNum).NumSysAttach;
                        NominalTotalCoilCap += WarehouseCoil(CoilNum).RatedSensibleCap;
                        System(RefrigSysNum).RefInventory += WarehouseCoil(CoilNum).DesignRefrigInventory;
                        if ((CoilIndex == 1) && (System(RefrigSysNum).NumCases == 0)) { // look for lowest Coil design evap T for system
                            System(RefrigSysNum).TEvapDesign = WarehouseCoil(CoilNum).TEvapDesign;
                        } else {
                            System(RefrigSysNum).TEvapDesign = min(WarehouseCoil(CoilNum).TEvapDesign, System(RefrigSysNum).TEvapDesign);
                        }
                    } // CoilIndex=1,NumCoils
                    System(RefrigSysNum).NumNonCascadeLoads += System(RefrigSysNum).NumCoils;
                } // NumCoils > 0

                if (NumWalkIns > 0) {
                    for (int WalkInIndex = 1; WalkInIndex <= NumWalkIns; ++WalkInIndex) {
                        int WalkInID = System(RefrigSysNum).WalkInNum(WalkInIndex);
                        // mark all WalkIns on rack as used by this system (checking for unused or non-unique WalkIns)
                        ++WalkIn(WalkInID).NumSysAttach;
                        NominalTotalWalkInCap += WalkIn(WalkInID).DesignRatedCap;
                        System(RefrigSysNum).RefInventory += WalkIn(WalkInID).DesignRefrigInventory;
                        // Defrost capacity is treated differently by compressor racks and detailed systems,
                        //  so this value may be adjusted (or warnings issued) after the walkin is assigned
                        //  to either the rack or system.
                        // for walkins served by detailed system, need capacity for both fluid and electric types.
                        if (WalkIn(WalkInID).DefrostCapacity <= -98.0) {
                            // - 99 used as a flag for blank input error message for detailed systems
                            ShowSevereError(RoutineName + "Refrigeration:WalkIn=\"" + WalkIn(WalkInID).Name +
                                            "\", Defrost capacity must be greater than or equal to 0 W for electric and hotfluid defrost types");
                            ErrorsFound = true;
                        }
                        // Find design evaporating temperature for system by getting min design evap for ALL loads
                        if ((WalkInIndex == 1) && (System(RefrigSysNum).NumCases == 0) && (System(RefrigSysNum).NumCoils == 0)) {
                            // note use walk in index, not walkinid here to get
                            // first walkin on this suction group/system
                            System(RefrigSysNum).TEvapDesign = WalkIn(WalkInID).TEvapDesign;
                        } else {
                            System(RefrigSysNum).TEvapDesign = min(WalkIn(WalkInID).TEvapDesign, System(RefrigSysNum).TEvapDesign);
                        }
                    } // WalkInIndex=1,NumWalkIns
                    System(RefrigSysNum).NumNonCascadeLoads += System(RefrigSysNum).NumWalkIns;
                } // numwalkins > 0

                AlphaNum = 3;
                // Read Transfer Loads (Secondary and Cascade) assignments for this System ,
                //     already allow more than one mech subcooler to load onto a system so they don't need to go in list
                if (!lAlphaBlanks(AlphaNum)) {

                    // Entry for Alphas(AlphaNum) can be either a Secondary, CascadeLoad name or a TransferLoadList name
                    int TransferLoadListNum = 0;
                    int SecondaryNum = 0;
                    int CascadeLoadNum = 0;
                    if (NumSimulationTransferLoadLists > 0) TransferLoadListNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), TransferLoadList);
                    if (NumSimulationSecondarySystems > 0) SecondaryNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), Secondary);
                    if (DataHeatBalance::NumRefrigCondensers > 0) CascadeLoadNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), Condenser);
                    int NumNameMatches = 0;
                    if (TransferLoadListNum != 0) ++NumNameMatches;
                    if (SecondaryNum != 0) ++NumNameMatches;
                    if (CascadeLoadNum != 0) ++NumNameMatches;
                    int NumCascadeLoad = 0;

                    if (NumNameMatches != 1) { // name must uniquely point to a list or a single transfer load
                        ErrorsFound = true;
                        if (NumNameMatches == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", has an invalid " +
                                            cAlphaFieldNames(AlphaNum) + ": " + Alphas(AlphaNum));
                        } else if (NumNameMatches > 1) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                            "\", has a non-unique name that could be either a " + cAlphaFieldNames(AlphaNum) + ": " +
                                            Alphas(AlphaNum));
                        }                                  // num matches = 0 or > 1
                    } else if (TransferLoadListNum != 0) { // Name points to a transferLoad list
                        NumSecondary = TransferLoadList(TransferLoadListNum).NumSecondarys;
                        NumCascadeLoad = TransferLoadList(TransferLoadListNum).NumCascadeLoads;
                        System(RefrigSysNum).NumSecondarys = NumSecondary;
                        System(RefrigSysNum).NumCascadeLoads = NumCascadeLoad;
                        if (!allocated(System(RefrigSysNum).SecondaryNum)) System(RefrigSysNum).SecondaryNum.allocate(NumSecondary);
                        System(RefrigSysNum).SecondaryNum({1, NumSecondary}) =
                            TransferLoadList(TransferLoadListNum).SecondaryItemNum({1, NumSecondary});
                        if (!allocated(System(RefrigSysNum).CascadeLoadNum)) System(RefrigSysNum).CascadeLoadNum.allocate(NumCascadeLoad);
                        System(RefrigSysNum).CascadeLoadNum({1, NumCascadeLoad}) =
                            TransferLoadList(TransferLoadListNum).CascadeLoadItemNum({1, NumCascadeLoad});
                    } else if (SecondaryNum != 0) { // Name points to a secondary loop load
                        NumSecondary = 1;
                        System(RefrigSysNum).NumSecondarys = 1;
                        if (!allocated(System(RefrigSysNum).SecondaryNum)) System(RefrigSysNum).SecondaryNum.allocate(NumSecondary);
                        System(RefrigSysNum).SecondaryNum(NumSecondary) = SecondaryNum;
                    } else if (CascadeLoadNum != 0) { // Name points to a cascade condenser load
                        NumCascadeLoad = 1;
                        System(RefrigSysNum).NumCascadeLoads = 1;
                        if (!allocated(System(RefrigSysNum).CascadeLoadNum)) System(RefrigSysNum).CascadeLoadNum.allocate(NumCascadeLoad);
                        System(RefrigSysNum).CascadeLoadNum(NumCascadeLoad) = CascadeLoadNum;
                    } // NumNameMatches /= 1

                    System(RefrigSysNum).CoilFlag = false;
                    // Now need to loop through all transfer loads to see if they change the minimum required system evaporating temperature
                    if (NumSecondary > 0) {
                        for (int SecondaryIndex = 1; SecondaryIndex <= NumSecondary; ++SecondaryIndex) {
                            int SecondaryID = System(RefrigSysNum).SecondaryNum(SecondaryIndex);
                            if (SecondaryIndex == 1) { // check for consistency of loads (coils calc on sys time step, all others on zone time step)
                                if (Secondary(SecondaryID).CoilFlag) System(RefrigSysNum).CoilFlag = true;
                            } else if (Secondary(SecondaryID).CoilFlag != System(RefrigSysNum).CoilFlag) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                                "\", Serves an inconsistent mixture of loads. Coil-type loads are served on a different time step "
                                                "than case or walkin loads. Compare loads on system served by secondary loop \"" +
                                                Secondary(SecondaryID).Name);
                                ErrorsFound = true;
                            } // check for consistency of loads (coils calc on sys time step, all others on zone time step)
                            // mark all Secondarys on system as used by this system (checking for unused or non-unique Secondarys)
                            ++Secondary(SecondaryID).NumSysAttach;
                            NominalTotalSecondaryCap += Secondary(SecondaryID).CoolingLoadRated;
                            System(RefrigSysNum).RefInventory += Secondary(SecondaryID).ChillerRefInventory;
                            // Find design evaporating temperature for system by getting min design evap for ALL loads
                            if ((SecondaryIndex == 1) && (System(RefrigSysNum).NumCases == 0) && (System(RefrigSysNum).NumCoils == 0) &&
                                (System(RefrigSysNum).NumWalkIns == 0)) {
                                // note use secondary index above, not secondaryid here to get
                                // first secondary on this suction group/system
                                // note - TMinNeeded on secondary defined by cases and walkins served by secondary, not by
                                //       the secondary's rated evaporating temperature (which is used to calc secondary heat
                                //       exchanger effectiveness with other rated values)
                                System(RefrigSysNum).TEvapDesign = Secondary(SecondaryID).TMinNeeded;
                            } else {
                                System(RefrigSysNum).TEvapDesign = min(Secondary(SecondaryID).TMinNeeded, System(RefrigSysNum).TEvapDesign);
                            }
                        } // SecondaryIndex=1,NumSecondary
                        System(RefrigSysNum).NumNonCascadeLoads += System(RefrigSysNum).NumSecondarys;
                    } // numsecondary > 0

                    if (NumCascadeLoad > 0) {
                        for (int cascadeLoadIndex = 1; cascadeLoadIndex <= NumCascadeLoad; ++cascadeLoadIndex) {
                            int CondID = System(RefrigSysNum).CascadeLoadNum(cascadeLoadIndex);
                            if (Condenser(CondID).CondenserType != DataHeatBalance::RefrigCondenserTypeCascade) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", has a  " +
                                                cAlphaFieldNames(AlphaNum) + ": " + Alphas(AlphaNum) +
                                                " cascade load that is not a cascade condenser.");
                                ErrorsFound = true;
                            }
                            // For a cascade condenser, need to identify the system absorbing the heat
                            Condenser(CondID).CascadeSinkSystemID = RefrigSysNum;
                            NominalTotalCascadeLoad += Condenser(CondID).RatedCapacity;
                            // Find design evaporating temperature for system by getting min design evap for ALL loads
                            if (System(RefrigSysNum).NumNonCascadeLoads == 0) {
                                if (cascadeLoadIndex == 1) {
                                    // note use cascadeload index above, not condid here to get
                                    // first cascade condenser served by this suction group/system
                                    System(RefrigSysNum).TEvapDesign = Condenser(CondID).CascadeRatedEvapTemp;
                                } else {
                                    System(RefrigSysNum).TEvapDesign = min(Condenser(CondID).CascadeRatedEvapTemp, System(RefrigSysNum).TEvapDesign);
                                }    // CascadeLoadIndex == 1
                            } else { // (NumNonCascadeLoads > 0 so initial TEvapDesign set above with those other loads)
                                if (Condenser(CondID).CascadeTempControl == CascadeTempSet)
                                    System(RefrigSysNum).TEvapDesign =
                                        min(Condenser(CondID).CascadeRatedEvapTemp,
                                            System(RefrigSysNum).TEvapDesign); // other wise TEvapDesign set by other loads
                            }
                        } // CascadeLoadIndex=1,NumCascadeLoad
                    }     // CascadeLoadNum > 0
                }         // yes/no blank input for transfer loads

                // check for consistency of loads (coils calc on sys time step, all others on zone time step, so can't mix on one system)
                if (System(RefrigSysNum).CoilFlag) { // could already be true if serving secondary that serves coils
                    if ((System(RefrigSysNum).NumCases > 0) || (System(RefrigSysNum).NumWalkIns > 0)) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                        "\", Serves an inconsistent mixture of loads. Coil-type loads are served on a different time step than case "
                                        "or walkin loads.");
                        ErrorsFound = true;
                    }
                } else {                                     // no coils on secondary or no secondary
                    if (System(RefrigSysNum).NumCoils > 0) { //(note, coilflag set to .FALSE. for all systems as default above
                        System(RefrigSysNum).CoilFlag = true;
                        if ((System(RefrigSysNum).NumCases > 0) || (System(RefrigSysNum).NumWalkIns > 0)) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                            "\", Serves an inconsistent mixture of loads. Coil-type loads are served on a different time step than "
                                            "case or walkin loads.");
                            ErrorsFound = true;
                        }
                    } // NumCoils > 0
                }     // Coil flag already true due to secondary coil loads

                NominalTotalCoolingCap = NominalTotalCaseCap + NominalTotalWalkInCap + NominalTotalSecondaryCap + NominalTotalCascadeLoad;

                // read condenser
                // currently assumes one condenser per refrigeration system and but multiple systems allowed per condenser
                AlphaNum = 4;
                int NumCondensers = 1;
                if (!allocated(System(RefrigSysNum).CondenserNum)) System(RefrigSysNum).CondenserNum.allocate(NumCondensers);
                System(RefrigSysNum).NumCondensers = 1;
                // Find condenser number, note condensers were read in one of four objects, but all read into same list
                int CondNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), Condenser);
                if (CondNum == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", has an invalid " +
                                    cAlphaFieldNames(AlphaNum) + " defined as " + Alphas(AlphaNum));
                    ErrorsFound = true;
                } else {
                    System(RefrigSysNum).CondenserNum(NumCondensers) = CondNum;
                    // Now take care of case where multiple systems share a condenser
                    ++Condenser(CondNum).NumSysAttach;
                    Condenser(CondNum).SysNum(Condenser(CondNum).NumSysAttach) = RefrigSysNum;
                }

                System(RefrigSysNum).RefInventory +=
                    Condenser(CondNum).RefReceiverInventory + Condenser(CondNum).RefPipingInventory + Condenser(CondNum).RefOpCharge;
                if (Condenser(CondNum).CondenserType == DataHeatBalance::RefrigCondenserTypeCascade) Condenser(CondNum).CascadeSysID = RefrigSysNum;
                if ((Condenser(CondNum).CondenserType == DataHeatBalance::RefrigCondenserTypeAir) && (Condenser(CondNum).CondenserRejectHeatToZone))
                    System(RefrigSysNum).SystemRejectHeatToZone = true;

                // Now do evaporative condenser auto sizing because it is a function of the system's cooling load
                if (Condenser(CondNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) {
                    if (Condenser(CondNum).RatedAirFlowRate == DataGlobals::AutoCalculate) {
                        Condenser(CondNum).RatedAirFlowRate = AirVolRateEvapCond * Condenser(CondNum).RatedCapacity;
                    }
                    if (Condenser(CondNum).RatedAirFlowRate <= 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name +
                                        "\", Evaporative Condenser Air Volume Flow Rate cannot be less than or equal to zero.");
                        ErrorsFound = true;
                    }
                    if (Condenser(CondNum).EvapPumpPower == DataGlobals::AutoCalculate) {
                        Condenser(CondNum).EvapPumpPower = CondPumpRatePower * Condenser(CondNum).RatedCapacity;
                    }
                    if (Condenser(CondNum).EvapPumpPower < 0.0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Condenser(CondNum).Name +
                                        "\", Design Evaporative Condenser Water Pump Power cannot be less than zero.");
                        ErrorsFound = true;
                    }
                }

                // Read the compressor data.
                // If the system consists of two stages of compression, these compressors will be the low-stage compressors.
                AlphaNum = 5;
                int NumCompressorsSys = 0;
                if (lAlphaBlanks(AlphaNum)) {
                    // blank input where must have compressor or compressor list input.
                    ShowSevereError(RoutineName + CurrentModuleObject + ' ' + cAlphaFieldNames(AlphaNum) + "\" : must be input.");
                    ErrorsFound = true;
                } else { //     Entry for Alphas(AlphaNum) can be either a compressor name or a compressorlist name
                    int ListNum;
                    if (NumCompressorLists > 0) {
                        ListNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), CompressorLists);
                    } else {
                        ListNum = 0;
                    }
                    int CompNum;
                    if (NumSimulationCompressors > 0) {
                        CompNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), Compressor);
                    } else {
                        CompNum = 0;
                    }
                    if ((ListNum == 0) && (CompNum == 0)) { // name doesn't match either a compressor or a compressor list
                        ShowSevereError(RoutineName + CurrentModuleObject + ' ' + cAlphaFieldNames(AlphaNum) +
                                        ", has an invalid or undefined value=\"" + Alphas(AlphaNum) + "\".");
                        ErrorsFound = true;
                    } else if ((ListNum != 0) && (CompNum != 0)) { // have compressor list and compressor with same name
                        ShowSevereError(RoutineName + CurrentModuleObject + ' ' + cAlphaFieldNames(AlphaNum) +
                                        ", has a non-unique name used for both Compressor and CompressorList name: \"" + Alphas(AlphaNum) + "\".");
                        ErrorsFound = true;
                    } else if (ListNum != 0) {
                        NumCompressorsSys = CompressorLists(ListNum).NumCompressors;
                        System(RefrigSysNum).NumCompressors = NumCompressorsSys;
                        if (!allocated(System(RefrigSysNum).CompressorNum)) System(RefrigSysNum).CompressorNum.allocate(NumCompressorsSys);
                        System(RefrigSysNum).CompressorNum({1, NumCompressorsSys}) = CompressorLists(ListNum).CompItemNum({1, NumCompressorsSys});
                    } else if (CompNum != 0) {
                        NumCompressorsSys = 1;
                        System(RefrigSysNum).NumCompressors = 1;
                        if (!allocated(System(RefrigSysNum).CompressorNum)) System(RefrigSysNum).CompressorNum.allocate(NumCompressorsSys);
                        System(RefrigSysNum).CompressorNum(NumCompressorsSys) = CompNum;
                    }
                }

                if (!lNumericBlanks(1)) {
                    System(RefrigSysNum).TCondenseMin = Numbers(1);
                    System(RefrigSysNum).TCondenseMinInput = System(RefrigSysNum).TCondenseMin;
                    if (DataGlobals::AnyEnergyManagementSystemInModel) {
                        SetupEMSActuator("Refrigeration:System",
                                         System(RefrigSysNum).Name,
                                         "Minimum Condensing Temperature",
                                         "[C]",
                                         System(RefrigSysNum).EMSOverrideOnTCondenseMin,
                                         System(RefrigSysNum).EMSOverrideValueTCondenseMin);
                    }
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", " + cNumericFieldNames(1) +
                                    " must be defined.");
                    ErrorsFound = true;
                }
                if ((Condenser(CondNum).CondenserType == DataHeatBalance::RefrigCondenserTypeCascade) &&
                    (System(RefrigSysNum).TCondenseMin > Condenser(CondNum).RatedTCondense))
                    ShowWarningError(CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                     "\", The system specified minimum condensing temperature is greater than the rated condensing temperature for "
                                     "the cascade condenser. ");

                AlphaNum = 6;
                System(RefrigSysNum).RefrigerantName = Alphas(AlphaNum);
                // error messages for refrigerants already found in fluidproperties

                AlphaNum = 7;
                if (!lAlphaBlanks(AlphaNum)) {
                    if (UtilityRoutines::SameString(Alphas(AlphaNum), "ConstantSuctionTemperature")) {
                        System(RefrigSysNum).CompSuctControl = ConstantSuctionTemperature;
                    } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "FloatSuctionTemperature")) {
                        System(RefrigSysNum).CompSuctControl = FloatSuctionTemperature;
                        if (System(RefrigSysNum).CoilFlag) {
                            ShowWarningError(CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                             "\", The system specified a FloatSuctionTemperature, but that is not available with air chiller loads "
                                             "so ConstantSuctionTemperature will be used. ");
                        } // coilflag
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", invalid  " +
                                        cAlphaFieldNames(AlphaNum) + " not found = " + Alphas(AlphaNum));
                        ErrorsFound = true;
                    }
                } else {
                    System(RefrigSysNum).CompSuctControl = ConstantSuctionTemperature; // Default for blank
                }

                // Count subcoolers on system and allocate
                AlphaNum = 8;
                System(RefrigSysNum).NumSubcoolers = 0;
                if (!lAlphaBlanks(AlphaNum)) {
                    ++System(RefrigSysNum).NumSubcoolers;
                }
                if (!lAlphaBlanks(AlphaNum + 1)) {
                    ++System(RefrigSysNum).NumSubcoolers;
                }

                if (System(RefrigSysNum).NumSubcoolers > 0) {
                    if (!allocated(System(RefrigSysNum).SubcoolerNum)) System(RefrigSysNum).SubcoolerNum.allocate(System(RefrigSysNum).NumSubcoolers);
                    int NumSubcooler = 1;
                    if (!lAlphaBlanks(AlphaNum)) {
                        System(RefrigSysNum).SubcoolerNum(NumSubcooler) =
                            inputProcessor->getObjectItemNum("Refrigeration:Subcooler", Alphas(AlphaNum));
                        if (System(RefrigSysNum).SubcoolerNum(NumSubcooler) <= 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", has an invalid " +
                                            cAlphaFieldNames(AlphaNum) + " defined as \"" + Alphas(AlphaNum) + "\".");
                            ErrorsFound = true;
                        } else {
                            Subcooler(System(RefrigSysNum).SubcoolerNum(NumSubcooler)).CoilFlag = System(RefrigSysNum).CoilFlag;
                        }
                        ++NumSubcooler;
                    }
                    if (!lAlphaBlanks(AlphaNum + 1)) {
                        System(RefrigSysNum).SubcoolerNum(NumSubcooler) =
                            inputProcessor->getObjectItemNum("Refrigeration:Subcooler", Alphas(AlphaNum + 1));
                        if (System(RefrigSysNum).SubcoolerNum(NumSubcooler) <= 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", has an invalid " +
                                            cAlphaFieldNames(AlphaNum + 1) + " defined as \"" + Alphas(AlphaNum + 1) + "\".");
                            ErrorsFound = true;
                        } else {
                            Subcooler(System(RefrigSysNum).SubcoolerNum(NumSubcooler)).CoilFlag = System(RefrigSysNum).CoilFlag;
                        }
                    }
                }

                // Suction piping heat gain - optional
                //  Input UA and identify the Zone containing the bulk of the suction piping
                //  This Zone ID will be used to determine the temperature used for suction piping heat gain.
                //  The pipe heat gains are also counted as cooling credit for the zone.
                //  Zone Id is only required if Sum UA Suction Piping >0.0
                //  Get the Zone and zone node numbers from the zone name entered by the user
                AlphaNum = 10;
                System(RefrigSysNum).SumUASuctionPiping = 0.0;
                if (!lNumericBlanks(2) && !lAlphaBlanks(AlphaNum)) {
                    System(RefrigSysNum).SumUASuctionPiping = Numbers(2);
                    System(RefrigSysNum).SuctionPipeActualZoneNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), DataHeatBalance::Zone);
                    System(RefrigSysNum).SuctionPipeZoneNodeNum = DataZoneEquipment::GetSystemNodeNumberForZone(state, Alphas(AlphaNum));
                    if (System(RefrigSysNum).SuctionPipeZoneNodeNum == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                        "\", System Node Number not found for " + cAlphaFieldNames(AlphaNum) + " = " + Alphas(AlphaNum) +
                                        " even though " + cNumericFieldNames(2) +
                                        " is greater than zero. Suction piping heat gain cannot be calculated unless a Zone is defined to deterimine "
                                        "the environmental temperature surrounding the piping.");
                        ErrorsFound = true;
                    } else {
                        RefrigPresentInZone(System(RefrigSysNum).SuctionPipeActualZoneNum) = true;
                    }
                } else if (!lNumericBlanks(2) && lAlphaBlanks(AlphaNum)) {
                    ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\" " + cAlphaFieldNames(AlphaNum) +
                                     " not found even though " + cNumericFieldNames(2) +
                                     " is greater than zero. Suction piping heat gain will not be calculated unless a Zone is defined to determine "
                                     "the environmental temperature surrounding the piping.");
                } else if (lNumericBlanks(2) && !lAlphaBlanks(AlphaNum)) {
                    ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\" " + cAlphaFieldNames(AlphaNum) +
                                     " will not be used and suction piping heat gain will not be calculated because " + cNumericFieldNames(2) +
                                     " was blank.");
                } // suction piping heat gains

                AlphaNum = 11;
                if (!lAlphaBlanks(AlphaNum)) System(RefrigSysNum).EndUseSubcategory = Alphas(AlphaNum);

                // Single-stage or two-stage compression system
                if (!lNumericBlanks(3)) {
                    System(RefrigSysNum).NumStages = Numbers(3);
                    if (System(RefrigSysNum).NumStages < 1 || System(RefrigSysNum).NumStages > 2) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", " + cNumericFieldNames(3) +
                                        R"( has an invalid value.  Only \"1\" or \"2\" compressor stages are allowed.)");
                        ErrorsFound = true;
                    }
                } else {
                    System(RefrigSysNum).NumStages = 1; // Default for blank
                }

                // Intercooler type
                // None (0) for single-stage compression systems
                // Flash intercooler (1) or coil-and-shell intercooler (2) for two-stage compression systems
                AlphaNum = 12;
                if (!lAlphaBlanks(AlphaNum)) {
                    if (UtilityRoutines::SameString(Alphas(AlphaNum), "None")) {
                        System(RefrigSysNum).IntercoolerType = 0;
                    } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "Flash Intercooler")) {
                        System(RefrigSysNum).IntercoolerType = 1;
                    } else if (UtilityRoutines::SameString(Alphas(AlphaNum), "Shell-and-Coil Intercooler")) {
                        System(RefrigSysNum).IntercoolerType = 2;
                    } else {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", Invalid " +
                                        cAlphaFieldNames(AlphaNum) + " specified.");
                        ShowContinueError("\"" + Alphas(AlphaNum) + "\" is not a recognized intercooler type.");
                        ErrorsFound = true;
                    }
                } else {
                    System(RefrigSysNum).IntercoolerType = 0; // Default for blank
                }

                if (System(RefrigSysNum).NumStages == 1 && (System(RefrigSysNum).IntercoolerType == 1 || System(RefrigSysNum).IntercoolerType == 2)) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", A single-stage compression system");
                    ShowContinueError("has been specified with an intercooler.  Verify that the number of compressor stages");
                    ShowContinueError("and the intercooler type are consistent.");
                    ErrorsFound = true;
                } else if (System(RefrigSysNum).NumStages == 2 && System(RefrigSysNum).IntercoolerType == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", A two-stage compression system");
                    ShowContinueError("has been specified without an intercooler.  Verify that the number of compressor stages");
                    ShowContinueError("and the intercooler type are consistent.");
                    ErrorsFound = true;
                }

                // Shell-and-coil intercooler effectiveness
                if (!lNumericBlanks(4)) {
                    System(RefrigSysNum).IntercoolerEffectiveness = Numbers(4);
                    if (System(RefrigSysNum).IntercoolerEffectiveness < 0.0 || System(RefrigSysNum).IntercoolerEffectiveness > 1.0) {
                        ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", The specified value for the");
                        ShowContinueError(cNumericFieldNames(4) + " = " + General::RoundSigDigits(System(RefrigSysNum).IntercoolerEffectiveness, 2) +
                                          " is invalid.  This value must be");
                        ShowContinueError("between 0.0 and 1.0.  The default value of 0.8 will be used.");
                        System(RefrigSysNum).IntercoolerEffectiveness = 0.8;
                    }
                } else {
                    System(RefrigSysNum).IntercoolerEffectiveness = 0.8;
                }

                // Read the high-stage compressor info, if two-stage compression has been specified.
                AlphaNum = 13;
                int NumHiStageCompressorsSys = 0;
                if (System(RefrigSysNum).NumStages == 2) {
                    if (lAlphaBlanks(AlphaNum)) {
                        // blank input where must have high-stage compressor or compressor list input.
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", " + cAlphaFieldNames(AlphaNum) +
                                        " must be input for two-stage compression systems.");
                        ErrorsFound = true;
                    } else { //     Entry for Alphas(AlphaNum) can be either a compressor name or a compressorlist name
                        int ListNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), CompressorLists);
                        int CompNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), Compressor);
                        if ((ListNum == 0) && (CompNum == 0)) { // name doesn't match either a compressor or a compressor list
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", " +
                                            cAlphaFieldNames(AlphaNum) + " has an invalid or undefined value=\"" + Alphas(AlphaNum) + "\".");
                            ErrorsFound = true;
                        } else if ((ListNum != 0) && (CompNum != 0)) { // have compressor list and compressor with same name
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name + "\", " +
                                            cAlphaFieldNames(AlphaNum) +
                                            " has a non-unique name used for both Compressor and CompressorList name: \"" + Alphas(AlphaNum) + "\".");
                            ErrorsFound = true;
                        } else if (ListNum != 0) {
                            NumHiStageCompressorsSys = CompressorLists(ListNum).NumCompressors;
                            System(RefrigSysNum).NumHiStageCompressors = NumHiStageCompressorsSys;
                            if (!allocated(System(RefrigSysNum).HiStageCompressorNum))
                                System(RefrigSysNum).HiStageCompressorNum.allocate(NumHiStageCompressorsSys);
                            System(RefrigSysNum).HiStageCompressorNum({1, NumHiStageCompressorsSys}) =
                                CompressorLists(ListNum).CompItemNum({1, NumHiStageCompressorsSys});
                        } else if (CompNum != 0) {
                            NumHiStageCompressorsSys = 1;
                            System(RefrigSysNum).NumHiStageCompressors = 1;
                            if (!allocated(System(RefrigSysNum).HiStageCompressorNum))
                                System(RefrigSysNum).HiStageCompressorNum.allocate(NumHiStageCompressorsSys);
                            System(RefrigSysNum).HiStageCompressorNum(NumHiStageCompressorsSys) = CompNum;
                        }
                    }
                }

                // Determine intercooler pressure and temperature at design conditions
                if (System(RefrigSysNum).NumStages == 2) {
                    Real64 PCond = FluidProperties::GetSatPressureRefrig(System(RefrigSysNum).RefrigerantName,
                                                 Condenser(System(RefrigSysNum).CondenserNum(1)).RatedTCondense,
                                                 System(RefrigSysNum).RefIndex,
                                                 RoutineName);
                    Real64 PEvap = FluidProperties::GetSatPressureRefrig(
                        System(RefrigSysNum).RefrigerantName, System(RefrigSysNum).TEvapDesign, System(RefrigSysNum).RefIndex, RoutineName);
                    System(RefrigSysNum).PIntercooler = std::sqrt(PCond * PEvap);
                    System(RefrigSysNum).TIntercooler = FluidProperties::GetSatTemperatureRefrig(
                        System(RefrigSysNum).RefrigerantName, System(RefrigSysNum).PIntercooler, System(RefrigSysNum).RefIndex, RoutineName);
                } // NumStages

                // Sum capacity of single-stage compressors or low-stage compressors if two-stage system
                Real64 NominalTotalCompCap = 0.0;
                for (int CompIndex = 1; CompIndex <= NumCompressorsSys; ++CompIndex) {
                    int CompNum = System(RefrigSysNum).CompressorNum(CompIndex);
                    if (!Compressor(CompNum).TransFlag) {          //  Subcritical Compressor
                        if (System(RefrigSysNum).NumStages == 1) { //  Single-stage compression
                            Compressor(CompNum).NomCap = CurveManager::CurveValue(Compressor(CompNum).CapacityCurvePtr,
                                                                    System(RefrigSysNum).TEvapDesign,
                                                                    Condenser(System(RefrigSysNum).CondenserNum(1)).RatedTCondense);
                            NominalTotalCompCap += Compressor(CompNum).NomCap;
                            ++Compressor(CompNum).NumSysAttach;
                        } else { //  Two-stage compression, low-stage compressors
                            Compressor(CompNum).NomCap = CurveManager::CurveValue(
                                Compressor(CompNum).CapacityCurvePtr, System(RefrigSysNum).TEvapDesign, System(RefrigSysNum).TIntercooler);
                            NominalTotalCompCap += Compressor(CompNum).NomCap;
                            ++Compressor(CompNum).NumSysAttach;
                        }    // NumStages
                    } else { //  Transcritical compressor attached to subcritical refigeration cycle
                        ShowSevereError(RoutineName + CurrentModuleObject +
                                        ". A transcritical compressor is attached to a subcritical refrigeration system.");
                        ShowContinueError("Check input to ensure that subcritical compressors are connected only to subcritical systems and "
                                          "transcritical compressors are connected only to transcritical systems.");
                        ErrorsFound = true;
                    } // .NOT. Compressor(CompNum)%TransFlag
                }

                Real64 NominalTotalHiStageCompCap(0.0); // Total of nominal high-stage compressor capacities, used for rough input check (W)

                // Sum capacity of high-stage compressors if two stage system
                if (System(RefrigSysNum).NumStages == 2) {
                    for (int CompIndex = 1; CompIndex <= NumHiStageCompressorsSys; ++CompIndex) {
                        int CompNum = System(RefrigSysNum).HiStageCompressorNum(CompIndex);
                        if (!Compressor(CompNum).TransFlag) { //  Subcritical Compressor
                            Compressor(CompNum).NomCap = CurveManager::CurveValue(Compressor(CompNum).CapacityCurvePtr,
                                                                    System(RefrigSysNum).TIntercooler,
                                                                    Condenser(System(RefrigSysNum).CondenserNum(1)).RatedTCondense);
                            NominalTotalHiStageCompCap += Compressor(CompNum).NomCap;
                            ++Compressor(CompNum).NumSysAttach;
                        } else { //  Transcritical compressor attached to subcritical refigeration cycle
                            ShowSevereError(RoutineName + CurrentModuleObject +
                                            ". A transcritical compressor is attached to a subcritical refrigeration system.");
                            ShowContinueError("Check input to ensure that subcritical compressors are connected only to subcritical systems and "
                                              "transcritical compressors are connected only to transcritical systems.");
                            ErrorsFound = true;
                        }
                    }
                } // NumStages

                // Compare the rated capacity of compressor, condenser, and cases.
                // Note, rated capacities can be far off from operating capacities, but rough check.
                Real64 NominalCondCap = Condenser(System(RefrigSysNum).CondenserNum(1)).RatedCapacity;
                if (System(RefrigSysNum).SystemRejectHeatToZone) NominalCondCap *= 2.0;
                if (System(RefrigSysNum).NumStages == 1) { // Single-stage system
                    if ((NominalTotalCompCap < (0.7 * NominalTotalCoolingCap)) || (NominalCondCap < (1.3 * NominalTotalCoolingCap))) {
                        ShowWarningError(CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                         "\", You may wish to check the system sizing. Total nominal cooling capacity is " +
                                         General::RoundSigDigits(NominalTotalCoolingCap, 0) + "W. Condenser capacity is " +
                                         General::RoundSigDigits(NominalCondCap, 0) + "W. Nominal compressor capacity is " +
                                         General::RoundSigDigits(NominalTotalCompCap, 0) + "W.");
                    }
                } else if (System(RefrigSysNum).NumStages == 2) { // Two-stage system
                    if ((NominalTotalHiStageCompCap < (0.7 * NominalTotalCoolingCap)) || (NominalCondCap < (1.3 * NominalTotalCoolingCap))) {
                        ShowWarningError(CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                         "\", You may wish to check the system sizing. Total nominal cooling capacity is " +
                                         General::RoundSigDigits(NominalTotalCoolingCap, 0) + "W. Condenser capacity is " +
                                         General::RoundSigDigits(NominalCondCap, 0) + "W. Nominal compressor capacity is " +
                                         General::RoundSigDigits(NominalTotalCompCap, 0) + "W.");
                    }
                } // NumStages

            } // Refrigeration systems

            // Assign coilflags to compressors, condensers, and subcoolers (coils calc on sys time step, all other refrig loads on zone time step, so
            // can't mix on one system) need to do here once again after all cascade condensers and cascade sink systems have been identified
            for (RefrigSysNum = 1; RefrigSysNum <= DataHeatBalance::NumRefrigSystems; ++RefrigSysNum) {
                // assign flags to all condensers to match system below condenser (system rejecting heat to cascade condenser)
                int CondNum = System(RefrigSysNum).CondenserNum(1); // right now only have one condenser per system
                Condenser(CondNum).CoilFlag = System(RefrigSysNum).CoilFlag;
                for (int CompIndex = 1; CompIndex <= System(RefrigSysNum).NumCompressors; ++CompIndex) {
                    int CompNum = System(RefrigSysNum).CompressorNum(CompIndex);
                    Compressor(CompNum).CoilFlag = System(RefrigSysNum).CoilFlag;
                }

            } // assign coil flags to all condensers

            // Finished setting cascade condenser coilflags to match system rejecting heat to the cascade condenser
            // Now have to see if there's a mismatch in the coilflag with the system absorbing heat from the cascade condenser
            // Note a system can cool multiple cascade condensers.  If so, need to be sure all are consistent - all coil or all non-coil(called case
            // here) check for consistency of loads (coils calc on sys time step, all others on zone time step, so can't mix on one system)
            for (RefrigSysNum = 1; RefrigSysNum <= DataHeatBalance::NumRefrigSystems;
                 ++RefrigSysNum) { // check flags for systems reflect all cascade loads
                if (System(RefrigSysNum).NumCascadeLoads == 0) continue;
                if (System(RefrigSysNum).CoilFlag) { // system already identified as serving coils
                    for (int CondID = 1; CondID <= DataHeatBalance::NumRefrigCondensers; ++CondID) {
                        if (Condenser(CondID).CondenserType != DataHeatBalance::RefrigCondenserTypeCascade) continue;
                        if (RefrigSysNum != Condenser(CondID).CascadeSinkSystemID) continue; // this condenser is not a cascade load on this system
                        if (!Condenser(CondID).CoilFlag) {
                            // would mean system already serving coil loads and this condenser cooling system with case-type loads
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                            "\", Serves an inconsistent mixture of loads. Coil-type loads are served on a different time step than "
                                            "case or walkin loads. Compare loads on system served by cascade condenser \"" +
                                            Condenser(CondID).Name);
                            ErrorsFound = true;
                        }
                    }    // CondID
                } else { // %coilflag == false, so no coil loads prev identified directly or through secondary loop
                    // Flag to help verify load type with loads served by systems cooled by cascade condensers
                    bool CaseLoads = false;
                    int NumCascadeLoadsChecked = 0;
                    for (int CondID = 1; CondID <= DataHeatBalance::NumRefrigCondensers; ++CondID) { // look at All cascade condenser loads on system
                        if (Condenser(CondID).CondenserType != DataHeatBalance::RefrigCondenserTypeCascade) continue;
                        if (RefrigSysNum != Condenser(CondID).CascadeSinkSystemID) continue; // this condenser is not a cascade load on this system
                        ++NumCascadeLoadsChecked;
                        if ((CaseLoads) && (!Condenser(CondID).CoilFlag) && (!System(RefrigSysNum).CoilFlag)) continue;
                        // all loads to date are case-type and properly flagged with consistent coilflags
                        //(note caseloads could be true if prev cascade load checked is serving a case-type system)
                        if (NumCascadeLoadsChecked == 1) {
                            if (Condenser(CondID).CoilFlag) {
                                System(RefrigSysNum).CoilFlag = true;
                                // setting system coilflag if 1st cascade condenser served has coils (system has no case-type loads up to this point)
                            } else { // condenser is not serving coils, but case-type loads
                                CaseLoads = true;
                                // system coilflag already set to false
                            }    // Condenser%CoilFlag
                        } else { // numcascadeloadschecked > 1
                            if (System(RefrigSysNum).CoilFlag != Condenser(CondID).CoilFlag) {
                                ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                                "\", Serves an inconsistent mixture of loads. Coil-type loads are served on a different time step "
                                                "than case or walkin loads. Compare loads on system served by cascade condenser \"" +
                                                Condenser(CondID).Name);
                                ErrorsFound = true;
                            }
                        } // numcascadeloadschecked > 1
                    }     // CondID
                }         //(System%coilflag)
            }             // Refrigeration systems checking coilflag consistency with cascade condenser loads

        } //(NumRefrigSystems > 0)

        // after the systems have been read, can finish the mechanical subcooler/system interactions
        // System%NumMechSCServed=0
        if (NumSimulationSubcoolers > 0) {
            for (int SubcoolerNum = 1; SubcoolerNum <= NumSimulationSubcoolers; ++SubcoolerNum) {
                if (Subcooler(SubcoolerNum).SubcoolerType == LiquidSuction) continue;
                Subcooler(SubcoolerNum).MechSourceSysID =
                    inputProcessor->getObjectItemNum("Refrigeration:System", Subcooler(SubcoolerNum).MechSourceSys);
                if (Subcooler(SubcoolerNum).MechSourceSysID == 0) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + Subcooler(SubcoolerNum).Name +
                                    "\", Mechanical Subcooler has an invalid Source Refrigeration:System=\"" + Subcooler(SubcoolerNum).MechSourceSys +
                                    "\".");
                    ErrorsFound = true;
                } else {
                    if (System(Subcooler(SubcoolerNum).MechSourceSysID).CoilFlag != Subcooler(SubcoolerNum).CoilFlag) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + System(RefrigSysNum).Name +
                                        "\", Serves an inconsistent mixture of loads. Coil-type loads are served on a different time step than case "
                                        "or walkin loads. Compare loads on system served by mechanical subcooler \"" +
                                        Subcooler(SubcoolerNum).Name);
                        ErrorsFound = true;
                    }
                } // error check
            }     // numsubcoolers

            for (RefrigSysNum = 1; RefrigSysNum <= DataHeatBalance::NumRefrigSystems; ++RefrigSysNum) {
                for (int SubcoolerNum = 1; SubcoolerNum <= NumSimulationSubcoolers; ++SubcoolerNum) {
                    if (Subcooler(SubcoolerNum).SubcoolerType == LiquidSuction) continue;
                    if (Subcooler(SubcoolerNum).MechSourceSysID == RefrigSysNum) {
                        ++System(RefrigSysNum).NumMechSCServed;
                    }
                }
                if (System(RefrigSysNum).NumMechSCServed > 0) {
                    if (!allocated(System(RefrigSysNum).MechSCLoad)) System(RefrigSysNum).MechSCLoad.allocate(NumSimulationSubcoolers);
                }
            }
        } // NumSimulationSubcoolers > 0

        // **********  READ TRANSCRITICAL REFRIGERATION SYSTEMS  **********

        if (NumTransRefrigSystems > 0) {
            CurrentModuleObject = "Refrigeration:TranscriticalSystem";
            for (int TransRefrigSysNum = 1; TransRefrigSysNum <= NumTransRefrigSystems; ++TransRefrigSysNum) {
                inputProcessor->getObjectItem(CurrentModuleObject,
                                              TransRefrigSysNum,
                                              Alphas,
                                              NumAlphas,
                                              Numbers,
                                              NumNumbers,
                                              IOStatus,
                                              lNumericBlanks,
                                              lAlphaBlanks,
                                              cAlphaFieldNames,
                                              cNumericFieldNames);
                UtilityRoutines::IsNameEmpty(Alphas(1), CurrentModuleObject, ErrorsFound);

                TransSystem(TransRefrigSysNum).Name = Alphas(1);

                // Read refrigerant for this system
                AlphaNum = 8;
                TransSystem(TransRefrigSysNum).RefrigerantName = Alphas(AlphaNum);
                // error messages for refrigerants already found in fluidproperties

                // Read Transcritical System Type:  SingleStage or TwoStage
                if (lAlphaBlanks(2)) {
                    // No system type specified
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                    "\", has no system type specified.");
                    ShowContinueError(R"(  System type must be specified as "SingleStage" or "TwoStage".)");
                    ErrorsFound = true;
                }
                if (UtilityRoutines::SameString(Alphas(2), "SingleStage")) {
                    TransSystem(TransRefrigSysNum).TransSysType = 1;
                } else if (UtilityRoutines::SameString(Alphas(2), "TwoStage")) {
                    TransSystem(TransRefrigSysNum).TransSysType = 2;
                } else {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                    "\", has an incorrect System Type specified as \"" + Alphas(2) + "\".");
                    ShowContinueError(R"(  System type must be specified as "SingleStage" or "TwoStage".)");
                    ErrorsFound = true;
                }

                // Read all loads (display cases and walk-ins) on this Transcritical System
                if (lAlphaBlanks(3) && lAlphaBlanks(4)) {
                    // No loads specified - display error
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name + "\", has no loads.");
                    ShowContinueError("  The system must have at least one of: " + cAlphaFieldNames(3) + " or " + cAlphaFieldNames(4) +
                                      " objects attached.");
                    ErrorsFound = true;
                } else if (lAlphaBlanks(3) && TransSystem(TransRefrigSysNum).TransSysType == 1) {
                    // No medium temperature loads specified for a SingleStage system - display error
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                    R"(", is a "SingleStage" system but no medium temperature loads are specified.)");
                    ShowContinueError("  The system must have at least one " + cAlphaFieldNames(3) + " object attached.");
                    ErrorsFound = true;
                } else if (lAlphaBlanks(4) && TransSystem(TransRefrigSysNum).TransSysType == 2) {
                    // No low temperature loads specified for a TwoStage system - display error
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                    R"(", is a "TwoStage" system but no low temperature loads are specified.)");
                    ShowContinueError("  The system must have at least one " + cAlphaFieldNames(4) + " object attached.");
                    ErrorsFound = true;
                }

                int NumCasesMT = 0;
                TransSystem(TransRefrigSysNum).NumCasesMT = 0;
                int NumCasesLT = 0;
                TransSystem(TransRefrigSysNum).NumCasesLT = 0;
                int NumWalkInsMT = 0;
                TransSystem(TransRefrigSysNum).NumWalkInsMT = 0;
                int NumWalkInsLT = 0;
                TransSystem(TransRefrigSysNum).NumWalkInsLT = 0;
                Real64 NominalTotalCaseCapMT = 0.0;
                Real64 NominalTotalCaseCapLT = 0.0;
                Real64 NominalTotalWalkInCapMT = 0.0;
                Real64 NominalTotalWalkInCapLT = 0.0;
                Real64 NominalTotalCoolingCap;
                TransSystem(TransRefrigSysNum).RefInventory = 0.0;

                //   Check for Medium Temperature Case or Walk-In or CaseAndWalkInList names
                AlphaNum = 3;

                if (!lAlphaBlanks(AlphaNum)) {

                    // Entry for Alphas(AlphaNum) can be either a Case, WalkIn or CaseAndWalkInList name
                    int CaseAndWalkInListNum = 0;
                    int CaseNum = 0;
                    int WalkInNum = 0;
                    if (NumSimulationCaseAndWalkInLists > 0)
                        CaseAndWalkInListNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), CaseAndWalkInList);
                    if (NumSimulationCases > 0) CaseNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), RefrigCase);
                    if (NumSimulationWalkIns > 0) WalkInNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), WalkIn);
                    int NumNameMatches = 0;
                    if (CaseAndWalkInListNum != 0) ++NumNameMatches;
                    if (CaseNum != 0) ++NumNameMatches;
                    if (WalkInNum != 0) ++NumNameMatches;

                    if (NumNameMatches != 1) { // name must uniquely point to a list or a single case or walkin or coil
                        ErrorsFound = true;
                        if (NumNameMatches == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name + "\", has an invalid " +
                                            cAlphaFieldNames(AlphaNum) + ": " + Alphas(AlphaNum));
                        } else if (NumNameMatches > 1) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                            "\",  has a non-unique name that could be either a " + cAlphaFieldNames(AlphaNum) + ": " +
                                            Alphas(AlphaNum));
                        }                                   // num matches = 0 or > 1
                    } else if (CaseAndWalkInListNum != 0) { // Name points to a CaseAndWalkInList
                        NumCasesMT = CaseAndWalkInList(CaseAndWalkInListNum).NumCases;
                        NumWalkInsMT = CaseAndWalkInList(CaseAndWalkInListNum).NumWalkIns;
                        TransSystem(TransRefrigSysNum).NumCasesMT = NumCasesMT;
                        TransSystem(TransRefrigSysNum).NumWalkInsMT = NumWalkInsMT;
                        if (NumCasesMT > 0) {
                            if (!allocated(TransSystem(TransRefrigSysNum).CaseNumMT)) TransSystem(TransRefrigSysNum).CaseNumMT.allocate(NumCasesMT);
                            TransSystem(TransRefrigSysNum).CaseNumMT({1, NumCasesMT}) =
                                CaseAndWalkInList(CaseAndWalkInListNum).CaseItemNum({1, NumCasesMT});
                        }
                        if (NumWalkInsMT > 0) {
                            if (!allocated(TransSystem(TransRefrigSysNum).WalkInNumMT))
                                TransSystem(TransRefrigSysNum).WalkInNumMT.allocate(NumWalkInsMT);
                            TransSystem(TransRefrigSysNum).WalkInNumMT({1, NumWalkInsMT}) =
                                CaseAndWalkInList(CaseAndWalkInListNum).WalkInItemNum({1, NumWalkInsMT});
                        }
                    } else if (CaseNum != 0) { // Name points to a case
                        NumCasesMT = 1;
                        TransSystem(TransRefrigSysNum).NumCasesMT = 1;
                        if (!allocated(TransSystem(TransRefrigSysNum).CaseNumMT)) TransSystem(TransRefrigSysNum).CaseNumMT.allocate(NumCasesMT);
                        TransSystem(TransRefrigSysNum).CaseNumMT(NumCases) = CaseNum;
                    } else if (WalkInNum != 0) { // Name points to a walkin
                        NumWalkInsMT = 1;
                        TransSystem(TransRefrigSysNum).NumWalkInsMT = 1;
                        if (!allocated(TransSystem(TransRefrigSysNum).WalkInNumMT)) TransSystem(TransRefrigSysNum).WalkInNumMT.allocate(NumWalkInsMT);
                        TransSystem(TransRefrigSysNum).WalkInNumMT(NumWalkIns) = WalkInNum;
                    } // NumNameMatches /= 1
                }     // blank input for cases, walkins, or caseandwalkinlist

                if (NumCasesMT > 0) {
                    // Find lowest design evap T
                    // Sum rated capacity of all MT cases on system
                    for (int caseIndex = 1; caseIndex <= NumCasesMT; ++caseIndex) {
                        // mark all cases on system as used by this system - checking for unused or non-unique cases
                        int CaseNum = TransSystem(TransRefrigSysNum).CaseNumMT(caseIndex);
                        ++RefrigCase(CaseNum).NumSysAttach;
                        NominalTotalCaseCapMT += RefrigCase(CaseNum).DesignRatedCap;
                        TransSystem(TransRefrigSysNum).RefInventory += RefrigCase(CaseNum).DesignRefrigInventory;
                        if (caseIndex == 1) { // look for lowest case design evap T for system
                            TransSystem(TransRefrigSysNum).TEvapDesignMT = RefrigCase(CaseNum).EvapTempDesign;
                        } else {
                            TransSystem(TransRefrigSysNum).TEvapDesignMT =
                                min(RefrigCase(CaseNum).EvapTempDesign, TransSystem(TransRefrigSysNum).TEvapDesignMT);
                        }
                    } // CaseIndex=1,NumCases
                }     // NumcasesMT > 0

                if (NumWalkInsMT > 0) {
                    for (int WalkInIndex = 1; WalkInIndex <= NumWalkInsMT; ++WalkInIndex) {
                        int WalkInID = TransSystem(TransRefrigSysNum).WalkInNumMT(WalkInIndex);
                        // mark all WalkIns on rack as used by this system (checking for unused or non-unique WalkIns)
                        ++WalkIn(WalkInID).NumSysAttach;
                        NominalTotalWalkInCapMT += WalkIn(WalkInID).DesignRatedCap;
                        TransSystem(TransRefrigSysNum).RefInventory += WalkIn(WalkInID).DesignRefrigInventory;
                        // Defrost capacity is treated differently by compressor racks and detailed systems,
                        //  so this value may be adjusted (or warnings issued) after the walkin is assigned
                        //  to either the rack or system.
                        // for walkins served by detailed system, need capacity for both fluid and electric types.
                        if (WalkIn(WalkInID).DefrostCapacity <= -98.0) {
                            // - 99 used as a flag for blank input error message for detailed systems
                            ShowSevereError(RoutineName + "Refrigeration:WalkIn=\"" + WalkIn(WalkInID).Name +
                                            "\", Defrost capacity must be greater than or equal to 0 W for electric and hotfluid defrost types");
                            ErrorsFound = true;
                        }
                        // Find design evaporating temperature for system by getting min design evap for ALL loads
                        if ((WalkInIndex == 1) && (TransSystem(TransRefrigSysNum).NumCasesMT == 0)) {
                            // note use walk in index, not walkinid here to get
                            // first walkin on this suction group/system
                            TransSystem(TransRefrigSysNum).TEvapDesignMT = WalkIn(WalkInID).TEvapDesign;
                        } else {
                            TransSystem(TransRefrigSysNum).TEvapDesignMT =
                                min(WalkIn(WalkInID).TEvapDesign, TransSystem(TransRefrigSysNum).TEvapDesignMT);
                        }
                    } // WalkInIndex=1,NumWalkIns
                }     // NumWalkInsMT > 0

                //   Check for Low Temperature Case or Walk-In or CaseAndWalkInList names
                AlphaNum = 4;
                if (!lAlphaBlanks(AlphaNum)) {

                    // Entry for Alphas(AlphaNum) can be either a Case, WalkIn or CaseAndWalkInList name
                    int CaseAndWalkInListNum = 0;
                    int CaseNum = 0;
                    int WalkInNum = 0;
                    if (NumSimulationCaseAndWalkInLists > 0)
                        CaseAndWalkInListNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), CaseAndWalkInList);
                    if (NumSimulationCases > 0) CaseNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), RefrigCase);
                    if (NumSimulationWalkIns > 0) WalkInNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), WalkIn);
                    int NumNameMatches = 0;
                    if (CaseAndWalkInListNum != 0) ++NumNameMatches;
                    if (CaseNum != 0) ++NumNameMatches;
                    if (WalkInNum != 0) ++NumNameMatches;

                    if (NumNameMatches != 1) { // name must uniquely point to a list or a single case or walkin or coil
                        ErrorsFound = true;
                        if (NumNameMatches == 0) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name + "\", has an invalid " +
                                            cAlphaFieldNames(AlphaNum) + ": " + Alphas(AlphaNum));
                        } else if (NumNameMatches > 1) {
                            ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                            "\",  has a non-unique name that could be either a " + cAlphaFieldNames(AlphaNum) + ": " +
                                            Alphas(AlphaNum));
                        }                                   // num matches = 0 or > 1
                    } else if (CaseAndWalkInListNum != 0) { // Name points to a CaseAndWalkInList
                        NumCasesLT = CaseAndWalkInList(CaseAndWalkInListNum).NumCases;
                        NumWalkInsLT = CaseAndWalkInList(CaseAndWalkInListNum).NumWalkIns;
                        TransSystem(TransRefrigSysNum).NumCasesLT = NumCasesLT;
                        TransSystem(TransRefrigSysNum).NumWalkInsLT = NumWalkInsLT;
                        if (NumCasesLT > 0) {
                            if (!allocated(TransSystem(TransRefrigSysNum).CaseNumLT)) TransSystem(TransRefrigSysNum).CaseNumLT.allocate(NumCasesLT);
                            TransSystem(TransRefrigSysNum).CaseNumLT({1, NumCasesLT}) =
                                CaseAndWalkInList(CaseAndWalkInListNum).CaseItemNum({1, NumCasesLT});
                        }
                        if (NumWalkInsLT > 0) {
                            if (!allocated(TransSystem(TransRefrigSysNum).WalkInNumLT))
                                TransSystem(TransRefrigSysNum).WalkInNumLT.allocate(NumWalkInsLT);
                            TransSystem(TransRefrigSysNum).WalkInNumLT({1, NumWalkInsLT}) =
                                CaseAndWalkInList(CaseAndWalkInListNum).WalkInItemNum({1, NumWalkInsLT});
                        }
                    } else if (CaseNum != 0) { // Name points to a case
                        NumCasesLT = 1;
                        TransSystem(TransRefrigSysNum).NumCasesLT = 1;
                        if (!allocated(TransSystem(TransRefrigSysNum).CaseNumLT)) TransSystem(TransRefrigSysNum).CaseNumLT.allocate(NumCasesLT);
                        TransSystem(TransRefrigSysNum).CaseNumLT(NumCases) = CaseNum;
                    } else if (WalkInNum != 0) { // Name points to a walkin
                        NumWalkInsLT = 1;
                        TransSystem(TransRefrigSysNum).NumWalkInsLT = 1;
                        if (!allocated(TransSystem(TransRefrigSysNum).WalkInNumLT)) TransSystem(TransRefrigSysNum).WalkInNumLT.allocate(NumWalkInsLT);
                        TransSystem(TransRefrigSysNum).WalkInNumLT(NumWalkIns) = WalkInNum;
                    } // NumNameMatches /= 1
                }     // blank input for cases, walkins, or caseandwalkinlist

                if (NumCasesLT > 0) {
                    // Find lowest design evap T
                    // Sum rated capacity of all LT cases on system
                    for (int caseIndex = 1; caseIndex <= NumCasesLT; ++caseIndex) {
                        // mark all cases on system as used by this system - checking for unused or non-unique cases
                        int CaseNum = TransSystem(TransRefrigSysNum).CaseNumLT(caseIndex);
                        ++RefrigCase(CaseNum).NumSysAttach;
                        NominalTotalCaseCapLT += RefrigCase(CaseNum).DesignRatedCap;
                        TransSystem(TransRefrigSysNum).RefInventory += RefrigCase(CaseNum).DesignRefrigInventory;
                        if (caseIndex == 1) { // look for lowest case design evap T for system
                            TransSystem(TransRefrigSysNum).TEvapDesignLT = RefrigCase(CaseNum).EvapTempDesign;
                        } else {
                            TransSystem(TransRefrigSysNum).TEvapDesignLT =
                                min(RefrigCase(CaseNum).EvapTempDesign, TransSystem(TransRefrigSysNum).TEvapDesignLT);
                        }
                    } // CaseIndex=1,NumCases
                }     // NumcasesLT > 0

                if (NumWalkInsLT > 0) {
                    for (int WalkInIndex = 1; WalkInIndex <= NumWalkInsLT; ++WalkInIndex) {
                        int WalkInID = TransSystem(TransRefrigSysNum).WalkInNumLT(WalkInIndex);
                        // mark all WalkIns on rack as used by this system (checking for unused or non-unique WalkIns)
                        ++WalkIn(WalkInID).NumSysAttach;
                        NominalTotalWalkInCapLT += WalkIn(WalkInID).DesignRatedCap;
                        TransSystem(TransRefrigSysNum).RefInventory += WalkIn(WalkInID).DesignRefrigInventory;
                        // Defrost capacity is treated differently by compressor racks and detailed systems,
                        //  so this value may be adjusted (or warnings issued) after the walkin is assigned
                        //  to either the rack or system.
                        // for walkins served by detailed system, need capacity for both fluid and electric types.
                        if (WalkIn(WalkInID).DefrostCapacity <= -98.0) {
                            // - 99 used as a flag for blank input error message for detailed systems
                            ShowSevereError(RoutineName + "Refrigeration:WalkIn=\"" + WalkIn(WalkInID).Name +
                                            "\", Defrost capacity must be greater than or equal to 0 W for electric and hotfluid defrost types");
                            ErrorsFound = true;
                        }
                        // Find design evaporating temperature for system by getting min design evap for ALL loads
                        if ((WalkInIndex == 1) && (TransSystem(TransRefrigSysNum).NumCasesLT == 0)) {
                            // note use walk in index, not walkinid here to get
                            // first walkin on this suction group/system
                            TransSystem(TransRefrigSysNum).TEvapDesignLT = WalkIn(WalkInID).TEvapDesign;
                        } else {
                            TransSystem(TransRefrigSysNum).TEvapDesignLT =
                                min(WalkIn(WalkInID).TEvapDesign, TransSystem(TransRefrigSysNum).TEvapDesignLT);
                        }
                    } // WalkInIndex=1,NumWalkIns
                }     // NumWalkInsMT > 0

                NominalTotalCoolingCap = NominalTotalCaseCapMT + NominalTotalCaseCapLT + NominalTotalWalkInCapMT + NominalTotalWalkInCapLT;

                // Read Gas Cooler
                // currently assumes one gas cooler per refrigeration system and but multiple systems allowed per gas cooler
                AlphaNum = 5;
                int NumGasCoolers = 1;
                if (!allocated(TransSystem(TransRefrigSysNum).GasCoolerNum)) TransSystem(TransRefrigSysNum).GasCoolerNum.allocate(NumGasCoolers);
                TransSystem(TransRefrigSysNum).NumGasCoolers = 1;
                // Find gascooler number
                int GCNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), GasCooler);

                if (GCNum == 0) { //  Invalid Gas Cooler attached to Transcritical Refrigeration System
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name + "\", has an invalid " +
                                    cAlphaFieldNames(AlphaNum) + " defined as \"" + Alphas(AlphaNum) + "\".");
                    ErrorsFound = true;
                } else if (GCNum != 0) { //  Gas Cooler attached to Transcritical Refrigeration System
                    TransSystem(TransRefrigSysNum).GasCoolerNum(NumGasCoolers) = GCNum;
                    TransSystem(TransRefrigSysNum).NumGasCoolers = 1;
                    // Now take care of case where multiple systems share a gas cooler
                    ++GasCooler(GCNum).NumSysAttach;
                    GasCooler(GCNum).SysNum(GasCooler(GCNum).NumSysAttach) = TransRefrigSysNum;
                    TransSystem(TransRefrigSysNum).RefInventory +=
                        GasCooler(GCNum).RefReceiverInventory + GasCooler(GCNum).RefPipingInventory + GasCooler(GCNum).RefOpCharge;
                    if (GasCooler(GCNum).GasCoolerRejectHeatToZone) TransSystem(TransRefrigSysNum).SystemRejectHeatToZone = true;
                }

                // Read High Pressure Compressor
                AlphaNum = 6;
                int NumCompressorsSys = 0;
                if (lAlphaBlanks(AlphaNum)) {
                    // blank input where must have compressor or compressor list input.
                    ShowSevereError(RoutineName + CurrentModuleObject + ' ' + cAlphaFieldNames(AlphaNum) + "\" : must be input.");
                    ErrorsFound = true;
                } else { //     Entry for Alphas(AlphaNum) can be either a compressor name or a compressorlist name
                    int ListNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), CompressorLists);
                    int CompNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), Compressor);
                    if ((ListNum == 0) && (CompNum == 0)) { // name doesn't match either a compressor or a compressor list
                        ShowSevereError(RoutineName + CurrentModuleObject + ", \"" + cAlphaFieldNames(AlphaNum) +
                                        "\", has an invalid or undefined value=\"" + Alphas(AlphaNum) + "\".");
                        ErrorsFound = true;
                    } else if ((ListNum != 0) && (CompNum != 0)) { // have compressor list and compressor with same name
                        ShowSevereError(RoutineName + CurrentModuleObject + ' ' + cAlphaFieldNames(AlphaNum) +
                                        ", has a non-unique name used for both Compressor and CompressorList name: \"" + Alphas(AlphaNum) + "\".");
                        ErrorsFound = true;
                    } else if (ListNum != 0) {
                        NumCompressorsSys = CompressorLists(ListNum).NumCompressors;
                        TransSystem(TransRefrigSysNum).NumCompressorsHP = NumCompressorsSys;
                        if (!allocated(TransSystem(TransRefrigSysNum).CompressorNumHP))
                            TransSystem(TransRefrigSysNum).CompressorNumHP.allocate(NumCompressorsSys);
                        TransSystem(TransRefrigSysNum).CompressorNumHP({1, NumCompressorsSys}) =
                            CompressorLists(ListNum).CompItemNum({1, NumCompressorsSys});
                    } else if (CompNum != 0) {
                        NumCompressorsSys = 1;
                        TransSystem(TransRefrigSysNum).NumCompressorsHP = 1;
                        if (!allocated(TransSystem(TransRefrigSysNum).CompressorNumHP))
                            TransSystem(TransRefrigSysNum).CompressorNumHP.allocate(NumCompressorsSys);
                        TransSystem(TransRefrigSysNum).CompressorNumHP(NumCompressorsSys) = CompNum;
                    }
                    // Sum rated capacity of all HP compressors on system
                    NominalTotalCompCapHP = 0.0;
                    for (int CompIndex = 1; CompIndex <= NumCompressorsSys; ++CompIndex) {
                        CompNum = TransSystem(TransRefrigSysNum).CompressorNumHP(CompIndex);

                        if (Compressor(CompNum).TransFlag) { //  Calculate nominal capacity of transcritical Compressor
                            Real64 GCOutletH =
                                FluidProperties::GetSupHeatEnthalpyRefrig(TransSystem(TransRefrigSysNum).RefrigerantName,
                                                                 GasCooler(TransSystem(TransRefrigSysNum).GasCoolerNum(1)).RatedOutletT,
                                                                 GasCooler(TransSystem(TransRefrigSysNum).GasCoolerNum(1)).RatedOutletP,
                                                                 RefrigIndex,
                                                                 RoutineNameNoColon);
                            Compressor(CompNum).NomCap = CurveManager::CurveValue(
                                Compressor(CompNum).TransCapacityCurvePtr, TransSystem(TransRefrigSysNum).TEvapDesignMT, GCOutletH);
                            NominalTotalCompCapHP += Compressor(CompNum).NomCap;
                            ++Compressor(CompNum).NumSysAttach;
                        } else { //  Subcritical compressor attached to transcritical system - show error
                            ShowSevereError(RoutineName + CurrentModuleObject +
                                            ", No transcritical CO2 compressors are attached to the transcritical refrigeration system, \"" +
                                            TransSystem(TransRefrigSysNum).Name + "\".");
                            ErrorsFound = true;
                        }
                    }
                }

                // Read Low Pressure Compressor
                AlphaNum = 7;
                NumCompressorsSys = 0;

                if ((lAlphaBlanks(AlphaNum)) && (TransSystem(TransRefrigSysNum).TransSysType == 2)) {
                    // TwoStage system type is specified but low pressure compressor input is blank
                    ShowSevereError(RoutineName + CurrentModuleObject + ", The transcritical refrigeration system, \"" +
                                    TransSystem(TransRefrigSysNum).Name + R"(", is specified to be "TwoStage", however, the ")" +
                                    cAlphaFieldNames(AlphaNum) + "\" is not given.");
                    ErrorsFound = true;
                } else if ((!(lAlphaBlanks(AlphaNum))) && (TransSystem(TransRefrigSysNum).TransSysType == 1)) {
                    // SingleStage system type with low pressure compressors specified. Ignore low pressure compressors
                    ShowWarningError(RoutineName + CurrentModuleObject + ", The transcritical refrigeration system, \"" +
                                     TransSystem(TransRefrigSysNum).Name + R"(", is specified to be \"SingleStage", however, a")" +
                                     cAlphaFieldNames(AlphaNum) +
                                     "\" was found.  The low pressure compressors will be ignored and will not simulated.");
                } else if ((!(lAlphaBlanks(AlphaNum))) && (TransSystem(TransRefrigSysNum).TransSysType == 2)) {
                    // TwoStage system with low pressure compressors specified
                    int ListNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), CompressorLists);
                    int CompNum = UtilityRoutines::FindItemInList(Alphas(AlphaNum), Compressor);
                    if ((ListNum == 0) && (CompNum == 0)) { // name doesn't match either a compressor or a compressor list
                        ShowSevereError(RoutineName + CurrentModuleObject + ", \"" + cAlphaFieldNames(AlphaNum) +
                                        "\", has an invalid or undefined value=\"" + Alphas(AlphaNum) + "\".");
                        ErrorsFound = true;
                    } else if ((ListNum != 0) && (CompNum != 0)) { // have compressor list and compressor with same name
                        ShowSevereError(RoutineName + CurrentModuleObject + ' ' + cAlphaFieldNames(AlphaNum) +
                                        ", has a non-unique name used for both Compressor and CompressorList name: \"" + Alphas(AlphaNum) + "\".");
                        ErrorsFound = true;
                    } else if (ListNum != 0) {
                        NumCompressorsSys = CompressorLists(ListNum).NumCompressors;
                        TransSystem(TransRefrigSysNum).NumCompressorsLP = NumCompressorsSys;
                        if (!allocated(TransSystem(TransRefrigSysNum).CompressorNumLP))
                            TransSystem(TransRefrigSysNum).CompressorNumLP.allocate(NumCompressorsSys);
                        TransSystem(TransRefrigSysNum).CompressorNumLP({1, NumCompressorsSys}) =
                            CompressorLists(ListNum).CompItemNum({1, NumCompressorsSys});
                    } else if (CompNum != 0) {
                        NumCompressorsSys = 1;
                        TransSystem(TransRefrigSysNum).NumCompressorsLP = 1;
                        if (!allocated(TransSystem(TransRefrigSysNum).CompressorNumLP))
                            TransSystem(TransRefrigSysNum).CompressorNumLP.allocate(NumCompressorsSys);
                        TransSystem(TransRefrigSysNum).CompressorNumLP(NumCompressorsSys) = CompNum;
                    }
                    // Sum rated capacity of all LP compressors on system
                    NominalTotalCompCapLP = 0.0;
                    for (int CompIndex = 1; CompIndex <= NumCompressorsSys; ++CompIndex) {
                        CompNum = TransSystem(TransRefrigSysNum).CompressorNumLP(CompIndex);
                        if (TransSystem(TransRefrigSysNum).TransSysType == 2) { //  Calculate capacity of LP compressors
                            Compressor(CompNum).NomCap = CurveManager::CurveValue(Compressor(CompNum).CapacityCurvePtr,
                                                                    TransSystem(TransRefrigSysNum).TEvapDesignLT,
                                                                    TransSystem(TransRefrigSysNum).TEvapDesignMT);
                            NominalTotalCompCapLP += Compressor(CompNum).NomCap;
                            ++Compressor(CompNum).NumSysAttach;
                        }
                    }
                }

                // Read Receiver Pressure
                if (!lNumericBlanks(1)) {
                    TransSystem(TransRefrigSysNum).PReceiver = Numbers(1);
                } else { // Default value receiver pressure = 4000000 Pa
                    TransSystem(TransRefrigSysNum).PReceiver = 4.0e6;
                }

                // Check receiver temperature against minimum condensing temperature (from gas cooler input) and design evaporator temperatures
                TransSystem(TransRefrigSysNum).TReceiver = FluidProperties::GetSatTemperatureRefrig(
                    TransSystem(TransRefrigSysNum).RefrigerantName, TransSystem(TransRefrigSysNum).PReceiver, RefrigIndex, RoutineNameNoColon);
                if (TransSystem(TransRefrigSysNum).TReceiver > GasCooler(TransSystem(TransRefrigSysNum).GasCoolerNum(NumGasCoolers)).MinCondTemp) {
                    ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                     ": The receiver temperature (" + General::RoundSigDigits(TransSystem(TransRefrigSysNum).TReceiver, 2) +
                                     "C) is greater than the minimum condensing temperature specified for subcritical operation (" +
                                     General::RoundSigDigits(GasCooler(TransSystem(TransRefrigSysNum).GasCoolerNum(NumGasCoolers)).MinCondTemp, 2) +
                                     "C).");
                    ShowContinueError("  The minimum condensing temperature will be set at 5C greater than the receiver temperature.");
                    GasCooler(TransSystem(TransRefrigSysNum).GasCoolerNum(NumGasCoolers)).MinCondTemp =
                        TransSystem(TransRefrigSysNum).TReceiver + 5.0;
                }
                if (NominalTotalCompCapLP > 0.0) {
                    if (TransSystem(TransRefrigSysNum).TReceiver <= TransSystem(TransRefrigSysNum).TEvapDesignLT) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                        ": The receiver temperature (" + General::RoundSigDigits(TransSystem(TransRefrigSysNum).TReceiver, 2) +
                                        "C) is less than the design evaporator temperature for the low temperature loads (" +
                                        General::RoundSigDigits(TransSystem(TransRefrigSysNum).TEvapDesignLT, 2) + "C).");
                        ShowContinueError("  Ensure that the receiver temperature is sufficiently greater than the design evaporator temperature for "
                                          "the low temperature loads.");
                        ShowContinueError(
                            "  A receiver pressure between 3.0 MPa to 4.0 MPa will typically result in an adequate receiver temperature.");
                        ErrorsFound = true;
                    }
                }
                if (NominalTotalCompCapHP > 0.0) {
                    if (TransSystem(TransRefrigSysNum).TReceiver <= TransSystem(TransRefrigSysNum).TEvapDesignMT) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                        ": The receiver temperature (" + General::RoundSigDigits(TransSystem(TransRefrigSysNum).TReceiver, 2) +
                                        "C) is less than the design evaporator temperature for the medium temperature loads (" +
                                        General::RoundSigDigits(TransSystem(TransRefrigSysNum).TEvapDesignMT, 2) + "C).");
                        ShowContinueError("  Ensure that the receiver temperature is sufficiently greater than the design evaporator temperature for "
                                          "the medium temperature loads.");
                        ShowContinueError(
                            "  A receiver pressure between 3.0 MPa to 4.0 MPa will typically result in an adequate receiver temperature.");
                        ErrorsFound = true;
                    }
                }

                // Read subcooler effectiveness
                if (!lNumericBlanks(2)) {
                    TransSystem(TransRefrigSysNum).SCEffectiveness = Numbers(2);
                } else { // Default value effectiveness = 0.4
                    TransSystem(TransRefrigSysNum).PReceiver = 0.4;
                }
                // Check subcooler effectiveness value, must be value between 0 and 1
                if ((TransSystem(TransRefrigSysNum).SCEffectiveness < 0) || (TransSystem(TransRefrigSysNum).SCEffectiveness > 1)) {
                    ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                    ": The value for subcooler effectivness is invalid.  The subcooler effectivenss must be a value greater than or "
                                    "equal to zero and less than or equal to one.");
                    ErrorsFound = true;
                }

                // Suction piping heat gain - optional
                //  Input UA and identify the Zone containing the bulk of the suction piping
                //  This Zone ID will be used to determine the temperature used for suction piping heat gain.
                //  The pipe heat gains are also counted as cooling credit for the zone.
                //  Zone Id is only required if Sum UA Suction Piping >0.0
                //  Get the Zone and zone node numbers from the zone name entered by the user
                AlphaNum = 9; // Medium temperature suction piping
                TransSystem(TransRefrigSysNum).SumUASuctionPipingMT = 0.0;
                if (!lNumericBlanks(3) && !lAlphaBlanks(AlphaNum)) {
                    TransSystem(TransRefrigSysNum).SumUASuctionPipingMT = Numbers(3);
                    TransSystem(TransRefrigSysNum).SuctionPipeActualZoneNumMT =
                        UtilityRoutines::FindItemInList(Alphas(AlphaNum), DataHeatBalance::Zone);
                    TransSystem(TransRefrigSysNum).SuctionPipeZoneNodeNumMT = DataZoneEquipment::GetSystemNodeNumberForZone(state, Alphas(AlphaNum));
                    if (TransSystem(TransRefrigSysNum).SuctionPipeZoneNodeNumMT == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                        "\", System Node Number not found for " + cAlphaFieldNames(AlphaNum) + " = \"" + Alphas(AlphaNum) +
                                        "\" even though " + cNumericFieldNames(3) + " is greater than zero.");
                        ShowContinueError("  The medium temperature suction piping heat gain cannot be calculated unless a Zone is defined to "
                                          "deterimine the environmental temperature surrounding the piping.");
                        ErrorsFound = true;
                    } else {
                        RefrigPresentInZone(TransSystem(TransRefrigSysNum).SuctionPipeActualZoneNumMT) = true;
                    }
                } else if (!lNumericBlanks(3) && lAlphaBlanks(AlphaNum)) {
                    ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name + "\" " +
                                     cAlphaFieldNames(AlphaNum) + " not found even though " + cNumericFieldNames(3) + " is greater than zero.");
                    ShowContinueError("  The medium temperature suction piping heat gain will not be calculated unless a Zone is defined to "
                                      "determine the environmental temperature surrounding the piping.");
                } else if (lNumericBlanks(3) && !lAlphaBlanks(AlphaNum)) {
                    ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name + "\" " +
                                     cAlphaFieldNames(AlphaNum) + " will not be used and suction piping heat gain will not be calculated because " +
                                     cNumericFieldNames(3) + " was blank.");
                } // Medium temperature suction piping heat gains

                AlphaNum = 10; // Low temperature suction piping
                TransSystem(TransRefrigSysNum).SumUASuctionPipingLT = 0.0;
                if (!lNumericBlanks(4) && !lAlphaBlanks(AlphaNum)) {
                    TransSystem(TransRefrigSysNum).SumUASuctionPipingLT = Numbers(4);
                    TransSystem(TransRefrigSysNum).SuctionPipeActualZoneNumLT =
                        UtilityRoutines::FindItemInList(Alphas(AlphaNum), DataHeatBalance::Zone);
                    TransSystem(TransRefrigSysNum).SuctionPipeZoneNodeNumLT = DataZoneEquipment::GetSystemNodeNumberForZone(state, Alphas(AlphaNum));
                    if (TransSystem(TransRefrigSysNum).SuctionPipeZoneNodeNumLT == 0) {
                        ShowSevereError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                        "\", System Node Number not found for " + cAlphaFieldNames(AlphaNum) + " = \"" + Alphas(AlphaNum) +
                                        "\" even though " + cNumericFieldNames(4) + " is greater than zero.");
                        ShowContinueError("  The low temperature suction piping heat gain cannot be calculated unless a Zone is defined to "
                                          "deterimine the environmental temperature surrounding the piping.");
                        ErrorsFound = true;
                    } else {
                        RefrigPresentInZone(TransSystem(TransRefrigSysNum).SuctionPipeActualZoneNumLT) = true;
                    }
                } else if (!lNumericBlanks(4) && lAlphaBlanks(AlphaNum)) {
                    ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name + "\" " +
                                     cAlphaFieldNames(AlphaNum) + " not found even though " + cNumericFieldNames(4) + " is greater than zero.");
                    ShowContinueError("  The low temperature suction piping heat gain will not be calculated unless a Zone is defined to determine "
                                      "the environmental temperature surrounding the piping.");
                } else if (lNumericBlanks(4) && !lAlphaBlanks(AlphaNum)) {
                    ShowWarningError(RoutineName + CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name + "\" " +
                                     cAlphaFieldNames(AlphaNum) + " will not be used and suction piping heat gain will not be calculated because " +
                                     cNumericFieldNames(4) + " was blank.");
                } // Low temperature suction piping heat gains

                AlphaNum = 11;
                if (!lAlphaBlanks(AlphaNum)) TransSystem(TransRefrigSysNum).EndUseSubcategory = Alphas(AlphaNum);

                // Compare the rated capacity of compressor, condenser, and cases.
                // Note, rated capacities can be far off from operating capacities, but rough check.
                Real64 NominalCondCap = GasCooler(TransSystem(TransRefrigSysNum).GasCoolerNum(1)).RatedCapacity;
                Real64 NominalTotalCompCap = NominalTotalCompCapHP + NominalTotalCompCapLP;
                if ((NominalTotalCompCap < (0.7 * NominalTotalCoolingCap)) || (NominalCondCap < (1.3 * NominalTotalCoolingCap))) {
                    ShowWarningError(CurrentModuleObject + "=\"" + TransSystem(TransRefrigSysNum).Name +
                                     "\", You may wish to check the system sizing.");
                    ShowContinueError("Total nominal cooling capacity is " + General::RoundSigDigits(NominalTotalCoolingCap, 0) +
                                      "W. Condenser capacity is " + General::RoundSigDigits(NominalCondCap, 0) +
                                      "W. Nominal compressor capacity is " + General::RoundSigDigits(NominalTotalCompCap, 0) + "W.");
                }

            } // Transcritical refrigeration systems

        } //(NumTransRefrigSystems > 0)

        DayValues.deallocate();
        Alphas.deallocate();
        Numbers.deallocate();
        cAlphaFieldNames.deallocate();
        cNumericFieldNames.deallocate();
        lAlphaBlanks.deallocate();
        lNumericBlanks.deallocate();

        if (NumSimulationCases > 0) {
            // Find unused and non-unique display case objects to report in eio and err file and sum
            //    all HVAC RA fractions and write error message if greater than 1 for any zone
            for (int ZoneIndex = 1; ZoneIndex <= DataGlobals::NumOfZones; ++ZoneIndex) { // numofzones from dataglobals
                Real64 TempRAFraction = CaseRAFraction(ZoneIndex).TotalCaseRAFraction;
                for (int CaseNum = 1; CaseNum <= NumSimulationCases; ++CaseNum) {
                    // TempRaFraction already includes contributions from ALL cases in zone
                    // Want to delete portion from unused cases (numsysattach = 0)that will never be simulated
                    if (RefrigCase(CaseNum).ActualZoneNum != ZoneIndex || RefrigCase(CaseNum).NumSysAttach > 0) continue;
                    TempRAFraction -= RefrigCase(CaseNum).RAFrac;
                } // NumSimulationCases
                if (TempRAFraction > 1.0) {
                    ShowSevereError(RoutineName + ": Refrigeration:Case, Refrigerated case return air fraction for all cases in zone=\"" +
                                    CaseRAFraction(ZoneIndex).ZoneName + "\" is greater than 1.0.");
                    // check in comment, can't use "currentModuleObject" because not in get input subroutine where that is known
                    ErrorsFound = true;
                }
            } // ZoneIndex=1,DataGlobals::NumOfZones

            CaseRAFraction.deallocate(); // only used for input check just completed
            // check for cases not connected to systems and cases connected
            // more than once (twice in a system or to more than one system)

            NumUnusedRefrigCases = 0;
            for (int CaseNum = 1; CaseNum <= NumSimulationCases; ++CaseNum) {
                if (RefrigCase(CaseNum).NumSysAttach == 1) continue;
                if (RefrigCase(CaseNum).NumSysAttach < 1) {
                    ++NumUnusedRefrigCases;
                    if (DataGlobals::DisplayExtraWarnings) {
                        //  individual case names listed if DataGlobals::DisplayExtraWarnings option selected
                        ShowWarningError(RoutineName + ": Refrigeration:Case=\"" + RefrigCase(CaseNum).Name + "\" unused. ");
                    } // display extra warnings - give a list of unused cases
                }     // unused case
                if (RefrigCase(CaseNum).NumSysAttach > 1) {
                    ErrorsFound = true;
                    ShowSevereError(RoutineName + ": Refrigeration:Case=\"" + RefrigCase(CaseNum).Name +
                                    "\", Same refrigerated case name referenced ");
                    ShowContinueError(" by more than one refrigeration system and/or compressor rack.");
                } // if looking for same case attached to multiple systems/racks
            }     // NumSimulationCases

            if ((NumUnusedRefrigCases > 0) && (!DataGlobals::DisplayExtraWarnings)) {
                //  write to error file,
                //  summary number of unused cases given if DataGlobals::DisplayExtraWarnings option not selected
                ShowWarningError("Refrigeration:Case -> " + General::RoundSigDigits(NumUnusedRefrigCases) +
                                 " unused refrigerated case(s) found during input processing.");
                ShowContinueError("  These refrigerated cases are in the input file but are not connected to a ");
                ShowContinueError("  Refrigeration:CompressorRack, Refrigeration:System, or Refrigeration:SecondarySystem object.");
                ShowContinueError("  These unused refrigeration cases will not be simulated.");
                ShowContinueError("  Use Output:Diagnostics,DisplayUnusedObjects; to see them. ");
            } // NumUnusedRefrigCases
        }     // numsimulation cases > 0

        if (NumSimulationCompressors > 0) {
            // check for compressors not connected to systems and compressors connected more than once
            // (twice in a system or to more than one system)
            NumUnusedCompressors = 0;
            for (int CompNum = 1; CompNum <= NumSimulationCompressors; ++CompNum) {
                if (Compressor(CompNum).NumSysAttach == 1) continue;
                if (Compressor(CompNum).NumSysAttach < 1) {
                    ++NumUnusedCompressors;
                    if (DataGlobals::DisplayExtraWarnings) {
                        //  individual compressor names listed if DataGlobals::DisplayExtraWarnings option selected
                        ShowWarningError(RoutineName + ": Refrigeration:Compressor=\"" + Compressor(CompNum).Name + "\" unused. ");
                    } // display extra warnings - give a list of unused compressors
                }     // unused compressor
                if (Compressor(CompNum).NumSysAttach > 1) {
                    ErrorsFound = true;
                    ShowSevereError(RoutineName + ": Refrigeration:Compressor=\"" + Compressor(CompNum).Name +
                                    "\", Same refrigeration compressor name referenced");
                    ShowContinueError(" by more than one refrigeration system.");
                } // looking for same compressor attached to multiple systems/racks
            }     // NumSimulationCompressors

            if ((NumUnusedCompressors > 0) && (!DataGlobals::DisplayExtraWarnings)) {
                //  write to error file,
                //  summary number of unused compressors given if DataGlobals::DisplayExtraWarnings option not selected
                ShowWarningError("Refrigeration:Compressor -> " + General::RoundSigDigits(NumUnusedCompressors) +
                                 " unused refrigeration compressor(s) found during input processing.");
                ShowContinueError("  Those refrigeration compressors are in the input file but are not connected to a Refrigeration:System object.");
                ShowContinueError("   These unused refrigeration compressors will not be simulated.");
                ShowContinueError("   Use Output:Diagnostics,DisplayUnusedObjects; to see them. ");
            } // NumUnusedCompressors
        }     // NumSimulationCompressors > 0

        int NumUnusedWalkIns = 0;
        if (NumSimulationWalkIns > 0) {
            // check for refrigeration WalkIns not connected to any systems and
            //  refrigeration WalkIns connected more than once
            for (int WalkInNum = 1; WalkInNum <= NumSimulationWalkIns; ++WalkInNum) {
                if (WalkIn(WalkInNum).NumSysAttach == 1) continue;
                if (WalkIn(WalkInNum).NumSysAttach < 1) {
                    ++NumUnusedWalkIns;
                    if (DataGlobals::DisplayExtraWarnings) {
                        //  individual walkin names listed if DataGlobals::DisplayExtraWarnings option selected
                        ShowWarningError(RoutineName + ": Refrigeration:WalkIn=\"" + WalkIn(WalkInNum).Name + "\" unused. ");
                    } // display extra warnings - give a list of unused WalkIns
                }     // unused walkin
                if (WalkIn(WalkInNum).NumSysAttach > 1) {
                    ErrorsFound = true;
                    ShowSevereError(RoutineName + ": Refrigeration:WalkIn=\"" + WalkIn(WalkInNum).Name +
                                    "\", Same Refrigeration WalkIn name referenced");
                    ShowContinueError(" by more than one refrigeration system and/or compressor rack.");
                } // if looking for same walk in attached to multiple systems/racks
            }     // NumSimulationWalkIns

            if ((NumUnusedWalkIns > 0) && (!DataGlobals::DisplayExtraWarnings)) {
                //  write to error file,
                //  summary number of unused walkins given if DataGlobals::DisplayExtraWarnings option not selected
                ShowWarningError(RoutineName + "Refrigeration:WalkIn -> " + General::RoundSigDigits(NumUnusedWalkIns) +
                                 " unused refrigeration WalkIns found during input processing.");
                ShowContinueError("   Those refrigeration WalkIns are in the input file but are not connected to a ");
                ShowContinueError("   Refrigeration:CompressorRack, Refrigeration:System or Refrigeration:SecondarySystem object.");
                ShowContinueError("   These unused refrigeration WalkIns will not be simulated.");
                ShowContinueError("   Use Output:Diagnostics,DisplayUnusedObjects; to see them. ");
            } // NumUnusedWalkIns
        }     // NumSimulationWalkIns > 0

        if (NumSimulationRefrigAirChillers > 0) {
            // check for air chillers not connected to any systems and
            //  air chillers connected more than once
            NumUnusedCoils = 0;
            for (int CoilNum = 1; CoilNum <= NumSimulationRefrigAirChillers; ++CoilNum) {
                if (WarehouseCoil(CoilNum).NumSysAttach == 1) continue;
                if (WarehouseCoil(CoilNum).NumSysAttach < 1) {
                    ++NumUnusedWalkIns;
                    if (DataGlobals::DisplayExtraWarnings) {
                        //  individual walkin names listed if DataGlobals::DisplayExtraWarnings option selected
                        ShowWarningError(RoutineName + ": Refrigeration:AirChiller=\"" + WarehouseCoil(CoilNum).Name + "\" unused. ");
                    } // display extra warnings - give a list of unused chillers
                }     // unused chiller
                if (WarehouseCoil(CoilNum).NumSysAttach > 1) {
                    ErrorsFound = true;
                    ShowSevereError(RoutineName + ": Refrigeration:AirChiller=\"" + WarehouseCoil(CoilNum).Name +
                                    "\", Same Refrigeration Air Chiller name referenced");
                    ShowContinueError(" by more than one refrigeration system and/or compressor rack.");
                } // if looking for same walk in attached to multiple systems/racks
            }     // NumSimulationRefrigAirchillers

            if ((NumUnusedCoils > 0) && (!DataGlobals::DisplayExtraWarnings)) {
                //  write to error file,
                //  summary number of unused air chillers given if DataGlobals::DisplayExtraWarnings option not selected
                ShowWarningError(RoutineName + "Refrigeration:AirChiller -> " + General::RoundSigDigits(NumUnusedCoils) +
                                 " unused refrigeration air chillers found during input processing.");
                ShowContinueError("   Those refrigeration air chillers are in the input file but are not connected to a ");
                ShowContinueError("   Refrigeration:CompressorRack, Refrigeration:System or Refrigeration:SecondarySystem object.");
                ShowContinueError("   These unused refrigeration air chillers will not be simulated.");
                ShowContinueError("   Use Output:Diagnostics,DisplayUnusedObjects; to see them. ");
            } // NumUnusedAirChllerss
        }     // NumSimulationAirChillers > 0

        if (NumSimulationSecondarySystems > 0) {
            // check for refrigeration Secondarys not connected to detailed systems and
            //  refrigeration Secondarys connected more than once
            NumUnusedSecondarys = 0;
            for (int SecondaryNum = 1; SecondaryNum <= NumSimulationSecondarySystems; ++SecondaryNum) {
                if (Secondary(SecondaryNum).NumSysAttach == 1) continue;
                if (Secondary(SecondaryNum).NumSysAttach < 1) {
                    ++NumUnusedSecondarys;
                    if (DataGlobals::DisplayExtraWarnings) {
                        //  individual secondary names listed if DataGlobals::DisplayExtraWarnings option selected
                        ShowWarningError(RoutineName + ": Refrigeration:Secondary=\"" + Secondary(SecondaryNum).Name + "\" unused. ");
                    } // display extra warnings - give a list of unused Secondaries
                }     // unused secondary
                if (Secondary(SecondaryNum).NumSysAttach > 1) {
                    ErrorsFound = true;
                    ShowSevereError(RoutineName + ": Refrigeration:Secondary=\"" + Secondary(SecondaryNum).Name +
                                    "\", Same Refrigeration Secondary name referenced");
                    ShowContinueError("   by more than one refrigeration system");
                } // looking for same secondary loop attached to multiple systems/racks
            }     // NumSimulationSecondarys

            if ((NumUnusedSecondarys > 0) && (!DataGlobals::DisplayExtraWarnings)) {
                //  write to error file,
                //  summary number of unused secondaries given if DataGlobals::DisplayExtraWarnings option not selected
                ShowWarningError(RoutineName + "Refrigeration:Secondary -> " + General::RoundSigDigits(NumUnusedSecondarys) +
                                 " unused refrigeration Secondary Loops found during input processing.");
                ShowContinueError("  Those refrigeration Secondary Loops are in the input file but are not connected to a refrigeration system.");
                ShowContinueError("   These unused refrigeration secondaries will not be simulated.");
                ShowContinueError("   Use Output:Diagnostics,DisplayUnusedObjects; to see them. ");
            } // NumUnusedSecondarys
        }     // NumSimulationSecondarySystems > 0

        if (DataHeatBalance::NumRefrigCondensers > 0) {
            // Check for presence of shared condensers and for unused condensers
            //     - determines number of loops through refrigeration simulation
            //       because of dependence of performance on total condenser load
            NumSimulationSharedCondensers = 0;
            NumUnusedCondensers = 0;
            for (int CondNum = 1; CondNum <= DataHeatBalance::NumRefrigCondensers; ++CondNum) {
                if (Condenser(CondNum).NumSysAttach == 1) continue;
                if (Condenser(CondNum).NumSysAttach < 1) {
                    ++NumUnusedCondensers;
                    if (DataGlobals::DisplayExtraWarnings) {
                        //  individual condenser names listed if DataGlobals::DisplayExtraWarnings option selected
                        ShowWarningError(RoutineName + ": Refrigeration:Condenser=\"" + Condenser(CondNum).Name + "\" unused. ");
                    } // display extra warnings - give a list of unused condensers
                }     // unused condenser
                if (Condenser(CondNum).NumSysAttach > 1) {
                    ++NumSimulationSharedCondensers;
                } // looking for shared condensers
            }     // CondNum

            if ((NumUnusedCondensers > 0) && (!DataGlobals::DisplayExtraWarnings)) {
                //  write to error file,
                //  summary number of unused condensers given if DataGlobals::DisplayExtraWarnings option not selected
                ShowWarningError(RoutineName + "Refrigeration condenser -> " + General::RoundSigDigits(NumUnusedCondensers) +
                                 " unused refrigeration condensers found during input processing.");
                ShowContinueError("  Those refrigeration condensers are in the input file but are not connected to a refrigeration system.");
                ShowContinueError("   These unused refrigeration condensers will not be simulated.");
                ShowContinueError("   Use Output:Diagnostics,DisplayUnusedObjects; to see them. ");
            } // NumUnusedCondensers and displayextra warnings
        }     // DataHeatBalance::NumRefrigCondensers > 0

        if (NumSimulationGasCooler > 0) {
            // Check for presence of shared gas coolers and for unused gas coolers
            NumSimulationSharedGasCoolers = 0;
            NumUnusedGasCoolers = 0;
            for (int GCNum = 1; GCNum <= NumSimulationGasCooler; ++GCNum) {
                if (GasCooler(GCNum).NumSysAttach == 1) continue;
                if (GasCooler(GCNum).NumSysAttach < 1) {
                    ++NumUnusedGasCoolers;
                    if (DataGlobals::DisplayExtraWarnings) {
                        //  individual gas cooler names listed if DataGlobals::DisplayExtraWarnings option selected
                        ShowWarningError(RoutineName + ": Refrigeration:GasCooler=\"" + GasCooler(GCNum).Name + "\" unused. ");
                    } // display extra warnings - give a list of unused gas coolers
                }     // unused gas cooler
                if (GasCooler(GCNum).NumSysAttach > 1) {
                    ++NumSimulationSharedGasCoolers;
                } // looking for shared gas coolers
            }     // GCNum

            if ((NumUnusedGasCoolers > 0) && (!DataGlobals::DisplayExtraWarnings)) {
                //  write to error file,
                //  summary number of unused gas coolers given if DataGlobals::DisplayExtraWarnings option not selected
                ShowWarningError(RoutineName + "Refrigeration gas cooler -> " + General::RoundSigDigits(NumUnusedGasCoolers) +
                                 " unused refrigeration gas cooler(s) found during input processing.");
                ShowContinueError("  These refrigeration gas coolers are in the input file but are not connected to a refrigeration system.");
                ShowContinueError("  These unused refrigeration gas coolers will not be simulated.");
                ShowContinueError("  Use Output:Diagnostics,DisplayUnusedObjects; to see them. ");
            } // NumUnusedGasCoolers and displayextra warnings
        }     // NumSimulationGasCooler > 0

        // echo input to eio file.
        ReportRefrigerationComponents(state.files);

        if (ErrorsFound) {
            ShowFatalError(RoutineName + " Previous errors cause program termination");
        }
    }

    void SetupReportInput()
    {
        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   Oct/Nov 2004
        //       MODIFIED       Hudson, ORNL July 2007, Stovall, ORNL, 2008 and 09
        //       MODIFIED       Fricke, ORNL, Fall 2011, added transcritical CO2 refrigeration system variables
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Set up the report variables.

        static std::string Walkin_and_zone_name; // concat name for walk-in/zone credit reporting

        if (NumSimulationCases > 0) {
            // Setup Report Variables for simulated Refrigerated Case (do not report unused cases)
            // CurrentModuleObject='Refrigeration:Case'
            for (int caseNum = 1; caseNum <= NumSimulationCases; ++caseNum) {
                if (RefrigCase(caseNum).NumSysAttach == 1) {
                    SetupOutputVariable("Refrigeration Case Evaporator Total Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).TotalCoolingLoad,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Evaporator Total Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).TotalCoolingEnergy,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name,
                                        _,
                                        "ENERGYTRANSFER",
                                        "REFRIGERATION",
                                        _,
                                        "Building",
                                        RefrigCase(caseNum).ZoneName);
                    SetupOutputVariable("Refrigeration Case Evaporator Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).SensCoolingEnergyRate,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Evaporator Sensible Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).SensCoolingEnergy,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Evaporator Latent Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).LatCoolingEnergyRate,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Evaporator Latent Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).LatCoolingEnergy,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name);

                    SetupOutputVariable("Refrigeration Case Zone Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).SensZoneCreditCoolRate,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Zone Sensible Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).SensZoneCreditCool,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Zone Sensible Heating Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).SensZoneCreditHeatRate,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Zone Sensible Heating Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).SensZoneCreditHeat,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name);

                    SetupOutputVariable("Refrigeration Case Zone Latent Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).LatZoneCreditRate,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Zone Latent Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).LatZoneCredit,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name);

                    SetupOutputVariable("Refrigeration Case Return Air Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).SensHVACCreditCoolRate,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Return Air Sensible Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).SensHVACCreditCool,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Return Air Sensible Heating Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).SensHVACCreditHeatRate,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Return Air Sensible Heating Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).SensHVACCreditHeat,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name);

                    SetupOutputVariable("Refrigeration Case Return Air Latent Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).LatHVACCreditRate,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Return Air Latent Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).LatHVACCredit,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name);

                    SetupOutputVariable("Refrigeration Case Evaporator Fan Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).ElecFanPower,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Evaporator Fan Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).ElecFanConsumption,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        "General",
                                        "Building",
                                        RefrigCase(caseNum).ZoneName);
                    SetupOutputVariable("Refrigeration Case Lighting Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigCase(caseNum).ElecLightingPower,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);
                    SetupOutputVariable("Refrigeration Case Lighting Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigCase(caseNum).ElecLightingConsumption,
                                        "Zone",
                                        "Sum",
                                        RefrigCase(caseNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        "General",
                                        "Building",
                                        RefrigCase(caseNum).ZoneName);

                    // Report defrost energy curve value only for cases having electric or hot-gas defrost with temperature termination
                    if (RefrigCase(caseNum).DefrostType == DefElectricTerm || RefrigCase(caseNum).DefrostType == DefHotFluidTerm) {
                        SetupOutputVariable("Refrigeration Case Defrost Energy Correction Curve Value",
                                            OutputProcessor::Unit::None,
                                            RefrigCase(caseNum).DefEnergyCurveValue,
                                            "Zone",
                                            "Average",
                                            RefrigCase(caseNum).Name);
                    }

                    SetupOutputVariable("Refrigeration Case Latent Credit Curve Value",
                                        OutputProcessor::Unit::None,
                                        RefrigCase(caseNum).LatEnergyCurveValue,
                                        "Zone",
                                        "Average",
                                        RefrigCase(caseNum).Name);

                    // Report only for cases having anti-sweat heaters
                    if (RefrigCase(caseNum).AntiSweatControlType > ASNone) {
                        SetupOutputVariable("Refrigeration Case Anti Sweat Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            RefrigCase(caseNum).ElecAntiSweatPower,
                                            "Zone",
                                            "Average",
                                            RefrigCase(caseNum).Name);
                        SetupOutputVariable("Refrigeration Case Anti Sweat Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            RefrigCase(caseNum).ElecAntiSweatConsumption,
                                            "Zone",
                                            "Sum",
                                            RefrigCase(caseNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            "General",
                                            "Building",
                                            RefrigCase(caseNum).ZoneName);
                    }

                    // Report only for cases using electric defrost

                    if (RefrigCase(caseNum).DefrostType == DefElectric || RefrigCase(caseNum).DefrostType == DefElectricOnDemand ||
                        RefrigCase(caseNum).DefrostType == DefElectricTerm) {
                        SetupOutputVariable("Refrigeration Case Defrost Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            RefrigCase(caseNum).ElecDefrostPower,
                                            "Zone",
                                            "Average",
                                            RefrigCase(caseNum).Name);
                        SetupOutputVariable("Refrigeration Case Defrost Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            RefrigCase(caseNum).ElecDefrostConsumption,
                                            "Zone",
                                            "Sum",
                                            RefrigCase(caseNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            "General",
                                            "Building",
                                            RefrigCase(caseNum).ZoneName);
                    }

                    // register refrigeration case credits as internal gains
                    if (RefrigCase(caseNum).ActualZoneNum > 0) {
                        SetupZoneInternalGain(RefrigCase(caseNum).ActualZoneNum,
                                              "Refrigeration:Case",
                                              RefrigCase(caseNum).Name,
                                              DataHeatBalance::IntGainTypeOf_RefrigerationCase,
                                              &RefrigCase(caseNum).SensZoneCreditRate,
                                              &RefrigCase(caseNum).SensHVACCreditRate,
                                              nullptr,
                                              &RefrigCase(caseNum).LatZoneCreditRate,
                                              &RefrigCase(caseNum).LatHVACCreditRate,
                                              nullptr,
                                              nullptr,
                                              RefrigCase(caseNum).ZoneRANode);
                    }
                } // END IF (.NOT. RefrigCase(CaseNum)%unusedCase)
            }
        } // NumSimulationCases > 0

        if (NumSimulationWalkIns > 0) {
            // Setup Report Variables for simulated  Walk In (do not report unused WalkIns)
            // CurrentModuleObject='Refrigeration:WalkIn'
            for (int walkInNum = 1; walkInNum <= NumSimulationWalkIns; ++walkInNum) {
                if (WalkIn(walkInNum).NumSysAttach == 1) { // ensure no unuseds reported
                    SetupOutputVariable("Refrigeration Walk In Evaporator Total Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        WalkIn(walkInNum).TotalCoolingLoad,
                                        "Zone",
                                        "Average",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Evaporator Total Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        WalkIn(walkInNum).TotalCoolingEnergy,
                                        "Zone",
                                        "Sum",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Evaporator Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        WalkIn(walkInNum).TotSensCoolingEnergyRate,
                                        "Zone",
                                        "Average",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Evaporator Sensible Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        WalkIn(walkInNum).TotSensCoolingEnergy,
                                        "Zone",
                                        "Sum",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Evaporator Latent Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        WalkIn(walkInNum).TotLatCoolingEnergyRate,
                                        "Zone",
                                        "Average",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Evaporator Latent Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        WalkIn(walkInNum).TotLatCoolingEnergy,
                                        "Zone",
                                        "Sum",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Ancillary Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        WalkIn(walkInNum).TotalElecPower,
                                        "Zone",
                                        "Average",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Ancillary Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        WalkIn(walkInNum).TotalElecConsumption,
                                        "Zone",
                                        "Sum",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Fan Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        WalkIn(walkInNum).ElecFanPower,
                                        "Zone",
                                        "Average",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Fan Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        WalkIn(walkInNum).ElecFanConsumption,
                                        "Zone",
                                        "Sum",
                                        WalkIn(walkInNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        "General",
                                        "Building");
                    SetupOutputVariable("Refrigeration Walk In Lighting Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        WalkIn(walkInNum).ElecLightingPower,
                                        "Zone",
                                        "Average",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Lighting Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        WalkIn(walkInNum).ElecLightingConsumption,
                                        "Zone",
                                        "Sum",
                                        WalkIn(walkInNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        "General",
                                        "Building");
                    SetupOutputVariable("Refrigeration Walk In Heater Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        WalkIn(walkInNum).ElecHeaterPower,
                                        "Zone",
                                        "Average",
                                        WalkIn(walkInNum).Name);
                    SetupOutputVariable("Refrigeration Walk In Heater Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        WalkIn(walkInNum).ElecHeaterConsumption,
                                        "Zone",
                                        "Sum",
                                        WalkIn(walkInNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        "General",
                                        "Building");

                    // Report only for WalkIns using electric defrost
                    if (WalkIn(walkInNum).DefrostType == WalkInDefrostElec) {
                        SetupOutputVariable("Refrigeration Walk In Defrost Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            WalkIn(walkInNum).ElecDefrostPower,
                                            "Zone",
                                            "Average",
                                            WalkIn(walkInNum).Name);
                        SetupOutputVariable("Refrigeration Walk In Defrost Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            WalkIn(walkInNum).ElecDefrostConsumption,
                                            "Zone",
                                            "Sum",
                                            WalkIn(walkInNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            "General",
                                            "Building");
                    }

                    // Report walkin variables that are specified for each zone exposed to the walkin
                    // For "IDOut" variable in SetupOutputVariable, need to create a single name that includes
                    //    both the walk-in name and the zone name - see "Walkin_and_zone_name" concatination
                    //    This new variable name is important if using an rvi file!
                    for (int zoneId = 1; zoneId <= WalkIn(walkInNum).NumZones; ++zoneId) {

                        Walkin_and_zone_name = WalkIn(walkInNum).Name + "InZone" + WalkIn(walkInNum).ZoneName(zoneId);

                        SetupOutputVariable("Refrigeration Walk In Zone Sensible Cooling Rate",
                                            OutputProcessor::Unit::W,
                                            WalkIn(walkInNum).SensZoneCreditCoolRate(zoneId),
                                            "Zone",
                                            "Average",
                                            Walkin_and_zone_name);
                        SetupOutputVariable("Refrigeration Walk In Zone Sensible Cooling Energy",
                                            OutputProcessor::Unit::J,
                                            WalkIn(walkInNum).SensZoneCreditCool(zoneId),
                                            "Zone",
                                            "Sum",
                                            Walkin_and_zone_name);
                        SetupOutputVariable("Refrigeration Walk In Zone Sensible Heating Rate",
                                            OutputProcessor::Unit::W,
                                            WalkIn(walkInNum).SensZoneCreditHeatRate(zoneId),
                                            "Zone",
                                            "Average",
                                            Walkin_and_zone_name);
                        SetupOutputVariable("Refrigeration Walk In Zone Sensible Heating Energy",
                                            OutputProcessor::Unit::J,
                                            WalkIn(walkInNum).SensZoneCreditHeat(zoneId),
                                            "Zone",
                                            "Sum",
                                            Walkin_and_zone_name);
                        SetupOutputVariable("Refrigeration Walk In Zone Latent Rate",
                                            OutputProcessor::Unit::W,
                                            WalkIn(walkInNum).LatZoneCreditRate(zoneId),
                                            "Zone",
                                            "Average",
                                            Walkin_and_zone_name);
                        SetupOutputVariable("Refrigeration Walk In Zone Latent Energy",
                                            OutputProcessor::Unit::J,
                                            WalkIn(walkInNum).LatZoneCredit(zoneId),
                                            "Zone",
                                            "Sum",
                                            Walkin_and_zone_name);

                        if (WalkIn(walkInNum).ZoneNum(zoneId) > 0)
                            SetupZoneInternalGain(WalkIn(walkInNum).ZoneNum(zoneId),
                                                  "Refrigeration:WalkIn",
                                                  Walkin_and_zone_name,
                                                  DataHeatBalance::IntGainTypeOf_RefrigerationWalkIn,
                                                  &WalkIn(walkInNum).SensZoneCreditRate(zoneId),
                                                  nullptr,
                                                  nullptr,
                                                  &WalkIn(walkInNum).LatZoneCreditRate(zoneId));

                    } // ZoneID
                }     //(.NOT.  WalkIn( WalkInNum)%unusedWalkIn)
            }         // NumSimulationWalkIns
        }             // NumSimulationWalkIns > 0

        if (NumSimulationRefrigAirChillers > 0) {
            // Setup Report Variables for simulated Warehouse coils (do not report unused warehouse coils)
            // CurrentModuleObject='Refrigeration:AirChiller'
            for (int coilNum = 1; coilNum <= NumSimulationRefrigAirChillers; ++coilNum) {
                if (WarehouseCoil(coilNum).NumSysAttach == 1) { // ensure no unuseds reported
                    SetupOutputVariable("Refrigeration Zone Air Chiller Total Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        WarehouseCoil(coilNum).TotalCoolingLoad,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Total Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        WarehouseCoil(coilNum).TotalCoolingEnergy,
                                        "HVAC",
                                        "Sum",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        WarehouseCoil(coilNum).SensCoolingEnergyRate,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Sensible Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        WarehouseCoil(coilNum).SensCoolingEnergy,
                                        "HVAC",
                                        "Sum",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Latent Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        WarehouseCoil(coilNum).LatCreditRate,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Latent Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        WarehouseCoil(coilNum).LatCreditEnergy,
                                        "HVAC",
                                        "Sum",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Water Removed Mass Flow Rate",
                                        OutputProcessor::Unit::kg_s,
                                        WarehouseCoil(coilNum).LatKgPerS_ToZone,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Total Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        WarehouseCoil(coilNum).TotalElecPower,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Total Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        WarehouseCoil(coilNum).TotalElecConsumption,
                                        "HVAC",
                                        "Sum",
                                        WarehouseCoil(coilNum).Name); // components are metered seperately
                    SetupOutputVariable("Refrigeration Zone Air Chiller Fan Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        WarehouseCoil(coilNum).ElecFanPower,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Fan Electric Energy",
                                        OutputProcessor::Unit::J,
                                        WarehouseCoil(coilNum).ElecFanConsumption,
                                        "HVAC",
                                        "Sum",
                                        WarehouseCoil(coilNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        "General",
                                        "Building");
                    SetupOutputVariable("Refrigeration Zone Air Chiller Heater Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        WarehouseCoil(coilNum).ElecHeaterPower,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Heater Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        WarehouseCoil(coilNum).ElecHeaterConsumption,
                                        "HVAC",
                                        "Sum",
                                        WarehouseCoil(coilNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        "General",
                                        "Building");
                    SetupOutputVariable("Refrigeration Zone Air Chiller Sensible Heat Ratio",
                                        OutputProcessor::Unit::None,
                                        WarehouseCoil(coilNum).SensHeatRatio,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Frost Accumulation Mass",
                                        OutputProcessor::Unit::kg,
                                        WarehouseCoil(coilNum).KgFrost,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Zone Total Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        WarehouseCoil(coilNum).ReportTotalCoolCreditRate,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Zone Total Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        WarehouseCoil(coilNum).ReportTotalCoolCreditEnergy,
                                        "HVAC",
                                        "Sum",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Zone Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        WarehouseCoil(coilNum).ReportSensCoolCreditRate,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Zone Sensible Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        WarehouseCoil(coilNum).ReportSensCoolCreditEnergy,
                                        "HVAC",
                                        "Sum",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Zone Heating Rate",
                                        OutputProcessor::Unit::W,
                                        WarehouseCoil(coilNum).ReportHeatingCreditRate,
                                        "HVAC",
                                        "Average",
                                        WarehouseCoil(coilNum).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Zone Heating Energy",
                                        OutputProcessor::Unit::J,
                                        WarehouseCoil(coilNum).ReportHeatingCreditEnergy,
                                        "HVAC",
                                        "Sum",
                                        WarehouseCoil(coilNum).Name);

                    // Report only for Warehouse coils using electric defrost
                    if (WarehouseCoil(coilNum).DefrostType == DefrostElec) {
                        SetupOutputVariable("Refrigeration Zone Air Chiller Defrost Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            WarehouseCoil(coilNum).ElecDefrostPower,
                                            "HVAC",
                                            "Average",
                                            WarehouseCoil(coilNum).Name);
                        SetupOutputVariable("Refrigeration Zone Air Chiller Defrost Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            WarehouseCoil(coilNum).ElecDefrostConsumption,
                                            "HVAC",
                                            "Sum",
                                            WarehouseCoil(coilNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            "General",
                                            "Building");
                    } // electric defrost coil
                }     //(.NOT.  WarehouseCoil(CoilNum)%unusedWarehouseCoil)
            }         // NumSimulationWarehouseCoils
        }             // NumSimulationRefrigAirChillers > 0

        // There are no report variables for Chiller sets because they are
        // used to pass the demand to the coils, but are NOT used to provide the
        // cooling energy to the zone (because more than one set may cool a zone)

        // Report sum of all refrigeration interactions with each zone

        for (int zoneID = 1; zoneID <= DataGlobals::NumOfZones; ++zoneID) {
            if (RefrigPresentInZone(zoneID)) {
                if (HaveCasesOrWalkins) {
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Total Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        DataHeatBalance::RefrigCaseCredit(zoneID).SenCaseCreditToZone,
                                        "Zone",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Total Sensible Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        CaseWIZoneReport(zoneID).SenCaseCreditToZoneEnergy,
                                        "Zone",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Heating Rate",
                                        OutputProcessor::Unit::W,
                                        CaseWIZoneReport(zoneID).HeatingToZoneRate,
                                        "Zone",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Heating Energy",
                                        OutputProcessor::Unit::J,
                                        CaseWIZoneReport(zoneID).HeatingToZoneEnergy,
                                        "Zone",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        CaseWIZoneReport(zoneID).SenCoolingToZoneRate,
                                        "Zone",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Sensible Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        CaseWIZoneReport(zoneID).SenCoolingToZoneEnergy,
                                        "Zone",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Total Latent Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        CaseWIZoneReport(zoneID).LatCoolingToZoneRate,
                                        "Zone",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Total Latent Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        CaseWIZoneReport(zoneID).LatCoolingToZoneEnergy,
                                        "Zone",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Total Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        CaseWIZoneReport(zoneID).TotCoolingToZoneRate,
                                        "Zone",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Total Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        CaseWIZoneReport(zoneID).TotCoolingToZoneEnergy,
                                        "Zone",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Total Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        CaseWIZoneReport(zoneID).TotHtXferToZoneRate,
                                        "Zone",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Case and Walk In Total Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        CaseWIZoneReport(zoneID).TotHtXferToZoneEnergy,
                                        "Zone",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                } // HaveCasesOrWalkIns

                if (HaveChillers) {
                    SetupOutputVariable("Refrigeration Zone Air Chiller Sensible Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        CoilSysCredit(zoneID).SenCreditToZoneRate,
                                        "HVAC",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Sensible Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        CoilSysCredit(zoneID).SenCreditToZoneEnergy,
                                        "HVAC",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        CoilSysCredit(zoneID).ReportSenCoolingToZoneRate,
                                        "HVAC",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Sensible Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        CoilSysCredit(zoneID).ReportSenCoolingToZoneEnergy,
                                        "HVAC",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Latent Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        CoilSysCredit(zoneID).ReportLatCreditToZoneRate,
                                        "HVAC",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Latent Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        CoilSysCredit(zoneID).ReportLatCreditToZoneEnergy,
                                        "HVAC",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Water Removed Mass Flow Rate",
                                        OutputProcessor::Unit::kg_s,
                                        CoilSysCredit(zoneID).ReportH2ORemovedKgPerS_FromZoneRate,
                                        "HVAC",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Total Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        CoilSysCredit(zoneID).ReportTotCoolingToZoneRate,
                                        "HVAC",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Total Cooling Energy",
                                        OutputProcessor::Unit::J,
                                        CoilSysCredit(zoneID).ReportTotCoolingToZoneEnergy,
                                        "HVAC",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Heating Rate",
                                        OutputProcessor::Unit::W,
                                        CoilSysCredit(zoneID).ReportHeatingToZoneRate,
                                        "HVAC",
                                        "Average",
                                        DataHeatBalance::Zone(zoneID).Name);
                    SetupOutputVariable("Refrigeration Zone Air Chiller Heating Energy",
                                        OutputProcessor::Unit::J,
                                        CoilSysCredit(zoneID).ReportHeatingToZoneEnergy,
                                        "HVAC",
                                        "Sum",
                                        DataHeatBalance::Zone(zoneID).Name);
                } // HaveChillers
            }     // RefrigPresentInZone(ZoneID)
        }         // ZoneID

        if (NumSimulationSecondarySystems > 0) {
            // CurrentModuleObject='Refrigeration:SecondarySystem'
            for (int secondNum = 1; secondNum <= NumSimulationSecondarySystems; ++secondNum) {
                if (Secondary(secondNum).NumSysAttach == 1) {
                    if (Secondary(secondNum).CoilFlag) { // secondary system serves chillers and is solved on HVAC time step
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Pump Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Secondary(secondNum).PumpPowerTotal,
                                            "HVAC",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Pump Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Secondary(secondNum).PumpElecEnergyTotal,
                                            "HVAC",
                                            "Sum",
                                            Secondary(secondNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Secondary(secondNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Load Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Secondary(secondNum).TotalRefrigLoad,
                                            "HVAC",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Load Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Secondary(secondNum).TotalRefrigEnergy,
                                            "HVAC",
                                            "Sum",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Total Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Secondary(secondNum).TotalCoolingLoad,
                                            "HVAC",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Total Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Secondary(secondNum).TotalCoolingEnergy,
                                            "HVAC",
                                            "Sum",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Estimated Refrigerant Inventory Mass",
                                            OutputProcessor::Unit::kg,
                                            Secondary(secondNum).RefInventory,
                                            "HVAC",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Volume Flow Rate",
                                            OutputProcessor::Unit::m3_s,
                                            Secondary(secondNum).FlowVolActual,
                                            "HVAC",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Pipe Heat Gain Rate",
                                            OutputProcessor::Unit::W,
                                            Secondary(secondNum).DistPipeHeatGain,
                                            "HVAC",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Pipe Heat Gain Energy",
                                            OutputProcessor::Unit::J,
                                            Secondary(secondNum).DistPipeHeatGainEnergy,
                                            "HVAC",
                                            "Sum",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Receiver Heat Gain Rate",
                                            OutputProcessor::Unit::W,
                                            Secondary(secondNum).ReceiverHeatGain,
                                            "HVAC",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Secondary Loop Receiver Heat Gain Energy",
                                            OutputProcessor::Unit::J,
                                            Secondary(secondNum).ReceiverHeatGainEnergy,
                                            "HVAC",
                                            "Sum",
                                            Secondary(secondNum).Name);
                    } else { // Secondary loop serves cases and walk-ins on zone(load) time step
                        SetupOutputVariable("Refrigeration Secondary Loop Pump Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Secondary(secondNum).PumpPowerTotal,
                                            "Zone",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Secondary Loop Pump Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Secondary(secondNum).PumpElecEnergyTotal,
                                            "Zone",
                                            "Sum",
                                            Secondary(secondNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Secondary(secondNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Secondary Loop Load Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Secondary(secondNum).TotalRefrigLoad,
                                            "Zone",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Secondary Loop Load Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Secondary(secondNum).TotalRefrigEnergy,
                                            "Zone",
                                            "Sum",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Secondary Loop Total Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Secondary(secondNum).TotalCoolingLoad,
                                            "Zone",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Secondary Loop Total Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Secondary(secondNum).TotalCoolingEnergy,
                                            "Zone",
                                            "Sum",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Secondary Loop Estimated Refrigerant Inventory Mass",
                                            OutputProcessor::Unit::kg,
                                            Secondary(secondNum).RefInventory,
                                            "Zone",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Secondary Loop Volume Flow Rate",
                                            OutputProcessor::Unit::m3_s,
                                            Secondary(secondNum).FlowVolActual,
                                            "Zone",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Secondary Loop Pipe Heat Gain Rate",
                                            OutputProcessor::Unit::W,
                                            Secondary(secondNum).DistPipeHeatGain,
                                            "Zone",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Secondary Loop Pipe Heat Gain Energy",
                                            OutputProcessor::Unit::J,
                                            Secondary(secondNum).DistPipeHeatGainEnergy,
                                            "Zone",
                                            "Sum",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Secondary Loop Receiver Heat Gain Rate",
                                            OutputProcessor::Unit::W,
                                            Secondary(secondNum).ReceiverHeatGain,
                                            "Zone",
                                            "Average",
                                            Secondary(secondNum).Name);
                        SetupOutputVariable("Refrigeration Secondary Loop Receiver Heat Gain Energy",
                                            OutputProcessor::Unit::J,
                                            Secondary(secondNum).ReceiverHeatGainEnergy,
                                            "Zone",
                                            "Sum",
                                            Secondary(secondNum).Name);
                    } // NOT coilflag so on Zone timestep
                    if (Secondary(secondNum).ReceiverZoneNum > 0) {
                        SetupZoneInternalGain(Secondary(secondNum).ReceiverZoneNum,
                                              "Refrigeration:SecondarySystem:Receiver",
                                              Secondary(secondNum).Name,
                                              DataHeatBalance::IntGainTypeOf_RefrigerationSecondaryReceiver,
                                              &Secondary(secondNum).ReceiverZoneHeatGain);
                    }
                    if (Secondary(secondNum).DistPipeZoneNum > 0) {
                        SetupZoneInternalGain(Secondary(secondNum).DistPipeZoneNum,
                                              "Refrigeration:SecondarySystem:Pipe",
                                              Secondary(secondNum).Name,
                                              DataHeatBalance::IntGainTypeOf_RefrigerationSecondaryPipe,
                                              &Secondary(secondNum).DistPipeZoneHeatGain);
                    }
                } // not an unused
            }     // NumSimulationSecondarySystems
        }         // NumSimulationSecondarySystems > 0

        // Setup Report Variables for Refrigeration Compressor Rack
        if (DataHeatBalance::NumRefrigeratedRacks > 0) {
            // CurrentModuleObject='Refrigeration:CompressorRack'
            for (int rackNum = 1; rackNum <= DataHeatBalance::NumRefrigeratedRacks; ++rackNum) {
                if (RefrigRack(rackNum).CoilFlag) { // rack serves chillers and is solved on HVAC time step
                    SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigRack(rackNum).RackCompressorPower,
                                        "HVAC",
                                        "Average",
                                        RefrigRack(rackNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigRack(rackNum).RackElecConsumption,
                                        "HVAC",
                                        "Sum",
                                        RefrigRack(rackNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        RefrigRack(rackNum).EndUseSubcategory,
                                        "Plant");
                    SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Condenser Fan Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigRack(rackNum).ActualCondenserFanPower,
                                        "HVAC",
                                        "Average",
                                        RefrigRack(rackNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Condenser Fan Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigRack(rackNum).CondenserFanConsumption,
                                        "HVAC",
                                        "Sum",
                                        RefrigRack(rackNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        RefrigRack(rackNum).EndUseSubcategory,
                                        "Plant");
                    SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Total Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigRack(rackNum).RackCapacity,
                                        "HVAC",
                                        "Average",
                                        RefrigRack(rackNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Total Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigRack(rackNum).RackCoolingEnergy,
                                        "HVAC",
                                        "Sum",
                                        RefrigRack(rackNum).Name,
                                        _,
                                        "ENERGYTRANSFER",
                                        "REFRIGERATION",
                                        RefrigRack(rackNum).EndUseSubcategory,
                                        "Plant");
                    SetupOutputVariable("Refrigeration Air Chiller Compressor Rack COP",
                                        OutputProcessor::Unit::W_W,
                                        RefrigRack(rackNum).RackCompressorCOP,
                                        "HVAC",
                                        "Average",
                                        RefrigRack(rackNum).Name);

                    if (RefrigRack(rackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) {
                        SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Evaporative Condenser Pump Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            RefrigRack(rackNum).ActualEvapPumpPower,
                                            "HVAC",
                                            "Average",
                                            RefrigRack(rackNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Evaporative Condenser Pump Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            RefrigRack(rackNum).EvapPumpConsumption,
                                            "HVAC",
                                            "Sum",
                                            RefrigRack(rackNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            RefrigRack(rackNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Evaporative Condenser Basin Heater Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            RefrigRack(rackNum).BasinHeaterPower,
                                            "HVAC",
                                            "Average",
                                            RefrigRack(rackNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Evaporative Condenser Basin Heater Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            RefrigRack(rackNum).BasinHeaterConsumption,
                                            "HVAC",
                                            "Sum",
                                            RefrigRack(rackNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            RefrigRack(rackNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Evaporative Condenser Water Volume Flow Rate",
                                            OutputProcessor::Unit::m3_s,
                                            RefrigRack(rackNum).EvapWaterConsumpRate,
                                            "HVAC",
                                            "Average",
                                            RefrigRack(rackNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Evaporative Condenser Water Volume",
                                            OutputProcessor::Unit::m3,
                                            RefrigRack(rackNum).EvapWaterConsumption,
                                            "HVAC",
                                            "Sum",
                                            RefrigRack(rackNum).Name,
                                            _,
                                            "Water",
                                            "REFRIGERATION",
                                            RefrigRack(rackNum).EndUseSubcategory,
                                            "Plant");
                    } // Evap condenser

                    if (RefrigRack(rackNum).HeatRejectionLocation == LocationZone) {
                        SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Zone Sensible Heating Rate",
                                            OutputProcessor::Unit::W,
                                            RefrigRack(rackNum).SensZoneCreditHeatRate,
                                            "HVAC",
                                            "Average",
                                            RefrigRack(rackNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Zone Sensible Heating Energy",
                                            OutputProcessor::Unit::J,
                                            RefrigRack(rackNum).SensZoneCreditHeat,
                                            "HVAC",
                                            "Sum",
                                            RefrigRack(rackNum).Name);

                        SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Return Air Sensible Heating Rate",
                                            OutputProcessor::Unit::W,
                                            RefrigRack(rackNum).SensHVACCreditHeatRate,
                                            "HVAC",
                                            "Average",
                                            RefrigRack(rackNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller Compressor Rack Return Air Sensible Heating Energy",
                                            OutputProcessor::Unit::J,
                                            RefrigRack(rackNum).SensHVACCreditHeat,
                                            "HVAC",
                                            "Sum",
                                            RefrigRack(rackNum).Name);

                        SetupZoneInternalGain(RefrigCase(RefrigRack(rackNum).CaseNum(1)).ActualZoneNum,
                                              "Refrigeration:CompressorRack",
                                              RefrigRack(rackNum).Name,
                                              DataHeatBalance::IntGainTypeOf_RefrigerationCompressorRack,
                                              &RefrigRack(rackNum).SensZoneCreditHeatRate,
                                              &RefrigRack(rackNum).SensHVACCreditHeatRate);

                    } // LocationZone

                } else { // Rack serves cases and walkins on zone (load) time step

                    SetupOutputVariable("Refrigeration Compressor Rack Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigRack(rackNum).RackCompressorPower,
                                        "Zone",
                                        "Average",
                                        RefrigRack(rackNum).Name);
                    SetupOutputVariable("Refrigeration Compressor Rack Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigRack(rackNum).RackElecConsumption,
                                        "Zone",
                                        "Sum",
                                        RefrigRack(rackNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        RefrigRack(rackNum).EndUseSubcategory,
                                        "Plant");
                    SetupOutputVariable("Refrigeration Compressor Rack Condenser Fan Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigRack(rackNum).ActualCondenserFanPower,
                                        "Zone",
                                        "Average",
                                        RefrigRack(rackNum).Name);
                    SetupOutputVariable("Refrigeration Compressor Rack Condenser Fan Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigRack(rackNum).CondenserFanConsumption,
                                        "Zone",
                                        "Sum",
                                        RefrigRack(rackNum).Name,
                                        _,
                                        "ELECTRICITY",
                                        "REFRIGERATION",
                                        RefrigRack(rackNum).EndUseSubcategory,
                                        "Plant");
                    SetupOutputVariable("Refrigeration Compressor Rack Total Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigRack(rackNum).RackCapacity,
                                        "Zone",
                                        "Average",
                                        RefrigRack(rackNum).Name);
                    SetupOutputVariable("Refrigeration Compressor Rack Total Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigRack(rackNum).RackCoolingEnergy,
                                        "Zone",
                                        "Sum",
                                        RefrigRack(rackNum).Name,
                                        _,
                                        "ENERGYTRANSFER",
                                        "REFRIGERATION",
                                        RefrigRack(rackNum).EndUseSubcategory,
                                        "Plant");
                    SetupOutputVariable("Refrigeration Compressor Rack COP",
                                        OutputProcessor::Unit::W_W,
                                        RefrigRack(rackNum).RackCompressorCOP,
                                        "Zone",
                                        "Average",
                                        RefrigRack(rackNum).Name);

                    if (RefrigRack(rackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) {
                        SetupOutputVariable("Refrigeration Compressor Rack Evaporative Condenser Pump Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            RefrigRack(rackNum).ActualEvapPumpPower,
                                            "Zone",
                                            "Average",
                                            RefrigRack(rackNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Rack Evaporative Condenser Pump Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            RefrigRack(rackNum).EvapPumpConsumption,
                                            "Zone",
                                            "Sum",
                                            RefrigRack(rackNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            RefrigRack(rackNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Compressor Rack Evaporative Condenser Basin Heater Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            RefrigRack(rackNum).BasinHeaterPower,
                                            "Zone",
                                            "Average",
                                            RefrigRack(rackNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Rack Evaporative Condenser Basin Heater Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            RefrigRack(rackNum).BasinHeaterConsumption,
                                            "Zone",
                                            "Sum",
                                            RefrigRack(rackNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            RefrigRack(rackNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Compressor Rack Evaporative Condenser Water Volume Flow Rate",
                                            OutputProcessor::Unit::m3_s,
                                            RefrigRack(rackNum).EvapWaterConsumpRate,
                                            "Zone",
                                            "Average",
                                            RefrigRack(rackNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Rack Evaporative Condenser Water Volume",
                                            OutputProcessor::Unit::m3,
                                            RefrigRack(rackNum).EvapWaterConsumption,
                                            "Zone",
                                            "Sum",
                                            RefrigRack(rackNum).Name,
                                            _,
                                            "Water",
                                            "REFRIGERATION",
                                            RefrigRack(rackNum).EndUseSubcategory,
                                            "Plant");
                    } // condenser evap

                    if (RefrigRack(rackNum).HeatRejectionLocation == LocationZone) {
                        SetupOutputVariable("Refrigeration Compressor Rack Zone Sensible Heating Rate",
                                            OutputProcessor::Unit::W,
                                            RefrigRack(rackNum).SensZoneCreditHeatRate,
                                            "Zone",
                                            "Average",
                                            RefrigRack(rackNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Rack Zone Sensible Heating Energy",
                                            OutputProcessor::Unit::J,
                                            RefrigRack(rackNum).SensZoneCreditHeat,
                                            "Zone",
                                            "Sum",
                                            RefrigRack(rackNum).Name);

                        SetupOutputVariable("Refrigeration Compressor Rack Return Air Sensible Heating Rate",
                                            OutputProcessor::Unit::W,
                                            RefrigRack(rackNum).SensHVACCreditHeatRate,
                                            "Zone",
                                            "Average",
                                            RefrigRack(rackNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Rack Return Air Sensible Heating Energy",
                                            OutputProcessor::Unit::J,
                                            RefrigRack(rackNum).SensHVACCreditHeat,
                                            "Zone",
                                            "Sum",
                                            RefrigRack(rackNum).Name);
                        SetupZoneInternalGain(RefrigCase(RefrigRack(rackNum).CaseNum(1)).ActualZoneNum,
                                              "Refrigeration:CompressorRack",
                                              RefrigRack(rackNum).Name,
                                              DataHeatBalance::IntGainTypeOf_RefrigerationCompressorRack,
                                              &RefrigRack(rackNum).SensZoneCreditHeatRate,
                                              &RefrigRack(rackNum).SensHVACCreditHeatRate);

                    } // location zone
                }     // Serves coils or case/walkin loads

                if (RefrigRack(rackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeWater) { // on HVAC time step no matter what
                    SetupOutputVariable("Refrigeration Compressor Rack Condenser Mass Flow Rate",
                                        OutputProcessor::Unit::kg_s,
                                        RefrigRack(rackNum).MassFlowRate,
                                        "HVAC",
                                        "Average",
                                        RefrigRack(rackNum).Name);

                    SetupOutputVariable("Refrigeration Compressor Rack Condenser Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        RefrigRack(rackNum).CondLoad,
                                        "HVAC",
                                        "Average",
                                        RefrigRack(rackNum).Name);

                    SetupOutputVariable("Refrigeration Compressor Rack Condenser Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        RefrigRack(rackNum).CondEnergy,
                                        "HVAC",
                                        "Sum",
                                        RefrigRack(rackNum).Name,
                                        _,
                                        "ENERGYTRANSFER",
                                        "Heating",
                                        _,
                                        "Plant");

                } // Condenser cooling water
            }     // Refrigerated Racks
        }         // NumRefrigeratedRacks > 0

        if (DataHeatBalance::NumRefrigSystems > 0) {
            // CurrentModuleObject='Refrigeration:System'
            for (int refrigSysNum = 1; refrigSysNum <= DataHeatBalance::NumRefrigSystems; ++refrigSysNum) {
                if (System(refrigSysNum).CoilFlag) { // system serves chillers and is solved on HVAC time step
                    if (System(refrigSysNum).NumStages == 1) {
                        SetupOutputVariable("Refrigeration Air Chiller System Total Compressor Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotCompPower,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Total Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotCompElecConsump,
                                            "HVAC",
                                            "Sum",
                                            System(refrigSysNum).Name);
                    } else if (System(refrigSysNum).NumStages == 2) {
                        SetupOutputVariable("Refrigeration Air Chiller System Total Low Stage Compressor Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotCompPower,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Total Low Stage Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotCompElecConsump,
                                            "HVAC",
                                            "Sum",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Total High Stage Compressor Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotHiStageCompPower,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Total High Stage Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotHiStageCompElecConsump,
                                            "HVAC",
                                            "Sum",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Total Low and High Stage Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotCompElecConsumpTwoStage,
                                            "HVAC",
                                            "Sum",
                                            System(refrigSysNum).Name);
                    } // NumStages
                    SetupOutputVariable("Refrigeration Air Chiller System Average Compressor COP",
                                        OutputProcessor::Unit::W_W,
                                        System(refrigSysNum).AverageCompressorCOP,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Total Air Chiller Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        System(refrigSysNum).TotalCoolingLoad,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Total Case and Walk In Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        System(refrigSysNum).TotalCoolingEnergy,
                                        "HVAC",
                                        "Sum",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Total Transferred Load Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        System(refrigSysNum).TotTransferLoad,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Total Transferred Load Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        System(refrigSysNum).TotTransferEnergy,
                                        "HVAC",
                                        "Sum",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Total Suction Pipe Heat Gain Rate",
                                        OutputProcessor::Unit::W,
                                        System(refrigSysNum).PipeHeatLoad,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Total Suction Pipe Heat Gain Energy",
                                        OutputProcessor::Unit::J,
                                        System(refrigSysNum).PipeHeatEnergy,
                                        "HVAC",
                                        "Sum",
                                        System(refrigSysNum).Name);
                    if (System(refrigSysNum).NumStages == 1) {
                        SetupOutputVariable("Refrigeration Air Chiller System Total Compressor Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotCompCapacity,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Total Compressor Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotCompCoolingEnergy,
                                            "HVAC",
                                            "Sum",
                                            System(refrigSysNum).Name); // indiv compressors go to meter, not system sum
                    } else if (System(refrigSysNum).NumStages == 2) {
                        SetupOutputVariable("Refrigeration Air Chiller System Total Low Stage Compressor Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotCompCapacity,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Total Low Stage Compressor Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotCompCoolingEnergy,
                                            "HVAC",
                                            "Sum",
                                            System(refrigSysNum).Name); // indiv compressors go to meter, not system sum
                        SetupOutputVariable("Refrigeration Air Chiller System Total High Stage Compressor Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotHiStageCompCapacity,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Total High Stage Compressor Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotHiStageCompCoolingEnergy,
                                            "HVAC",
                                            "Sum",
                                            System(refrigSysNum).Name); // indiv compressors go to meter, not system sum
                    }                                                   // NumStages
                    SetupOutputVariable("Refrigeration Air Chiller System Net Rejected Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        System(refrigSysNum).NetHeatRejectLoad,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Net Rejected Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        System(refrigSysNum).NetHeatRejectEnergy,
                                        "HVAC",
                                        "Sum",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Estimated Refrigerant Inventory Mass",
                                        OutputProcessor::Unit::kg,
                                        System(refrigSysNum).RefInventory,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    if (System(refrigSysNum).NumStages == 1) {
                        SetupOutputVariable("Refrigeration Air Chiller System Estimated Refrigerant Mass Flow Rate",
                                            OutputProcessor::Unit::kg_s,
                                            System(refrigSysNum).RefMassFlowComps,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                    } else if (System(refrigSysNum).NumStages == 2) {
                        SetupOutputVariable("Refrigeration Air Chiller System Estimated Low Stage Refrigerant Mass Flow Rate",
                                            OutputProcessor::Unit::kg_s,
                                            System(refrigSysNum).RefMassFlowComps,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Estimated High Stage Refrigerant Mass Flow Rate",
                                            OutputProcessor::Unit::kg_s,
                                            System(refrigSysNum).RefMassFlowHiStageComps,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                    } // NumStages
                    if (System(refrigSysNum).NumStages == 2) {
                        SetupOutputVariable("Refrigeration Air Chiller System Intercooler Temperature",
                                            OutputProcessor::Unit::C,
                                            System(refrigSysNum).TIntercooler,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Intercooler Pressure",
                                            OutputProcessor::Unit::Pa,
                                            System(refrigSysNum).PIntercooler,
                                            "HVAC",
                                            "Average",
                                            System(refrigSysNum).Name);
                    }
                    SetupOutputVariable("Refrigeration Air Chiller System Condensing Temperature",
                                        OutputProcessor::Unit::C,
                                        System(refrigSysNum).TCondense,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Evaporating Temperature",
                                        OutputProcessor::Unit::C,
                                        System(refrigSysNum).TEvapNeeded,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Suction Temperature",
                                        OutputProcessor::Unit::C,
                                        System(refrigSysNum).TCompIn,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System TXV Liquid Temperature",
                                        OutputProcessor::Unit::C,
                                        System(refrigSysNum).TLiqInActual,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Liquid Suction Subcooler Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        System(refrigSysNum).LSHXTrans,
                                        "HVAC",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Liquid Suction Subcooler Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        System(refrigSysNum).LSHXTransEnergy,
                                        "HVAC",
                                        "Sum",
                                        System(refrigSysNum).Name);
                } else { // NOT System(SysNum)%CoilFlag, so serving loads on zone timestep
                    if (System(refrigSysNum).NumStages == 1) {
                        SetupOutputVariable("Refrigeration System Total Compressor Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotCompPower,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration System Total Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotCompElecConsump,
                                            "Zone",
                                            "Sum",
                                            System(refrigSysNum).Name);
                    } else if (System(refrigSysNum).NumStages == 2) {
                        SetupOutputVariable("Refrigeration System Total Low Stage Compressor Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotCompPower,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration System Total Low Stage Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotCompElecConsump,
                                            "Zone",
                                            "Sum",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration System Total High Stage Compressor Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotHiStageCompPower,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration System Total High Stage Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotHiStageCompElecConsump,
                                            "Zone",
                                            "Sum",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration System Total Low and High Stage Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotCompElecConsumpTwoStage,
                                            "Zone",
                                            "Sum",
                                            System(refrigSysNum).Name);
                    } // NumStages
                    SetupOutputVariable("Refrigeration System Average Compressor COP",
                                        OutputProcessor::Unit::W_W,
                                        System(refrigSysNum).AverageCompressorCOP,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Total Cases and Walk Ins Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        System(refrigSysNum).TotalCoolingLoad,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Total Cases and Walk Ins Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        System(refrigSysNum).TotalCoolingEnergy,
                                        "Zone",
                                        "Sum",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Total Transferred Load Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        System(refrigSysNum).TotTransferLoad,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Total Transferred Load Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        System(refrigSysNum).TotTransferEnergy,
                                        "Zone",
                                        "Sum",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Total Suction Pipe Heat Gain Rate",
                                        OutputProcessor::Unit::W,
                                        System(refrigSysNum).PipeHeatLoad,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Total Suction Pipe Heat Gain Energy",
                                        OutputProcessor::Unit::J,
                                        System(refrigSysNum).PipeHeatEnergy,
                                        "Zone",
                                        "Sum",
                                        System(refrigSysNum).Name);
                    if (System(refrigSysNum).NumStages == 1) {
                        SetupOutputVariable("Refrigeration System Total Compressor Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotCompCapacity,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration System Total Compressor Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotCompCoolingEnergy,
                                            "Zone",
                                            "Sum",
                                            System(refrigSysNum).Name); // indiv compressors go to meter, not system sum
                    } else if (System(refrigSysNum).NumStages == 2) {
                        SetupOutputVariable("Refrigeration System Total Low Stage Compressor Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotCompCapacity,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration System Total Low Stage Compressor Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotCompCoolingEnergy,
                                            "Zone",
                                            "Sum",
                                            System(refrigSysNum).Name); // indiv compressors go to meter, not system sum
                        SetupOutputVariable("Refrigeration System Total High Stage Compressor Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            System(refrigSysNum).TotHiStageCompCapacity,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration System Total High Stage Compressor Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            System(refrigSysNum).TotHiStageCompCoolingEnergy,
                                            "Zone",
                                            "Sum",
                                            System(refrigSysNum).Name); // indiv compressors go to meter, not system sum
                    }                                                   // NumStages
                    SetupOutputVariable("Refrigeration System Net Rejected Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        System(refrigSysNum).NetHeatRejectLoad,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Net Rejected Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        System(refrigSysNum).NetHeatRejectEnergy,
                                        "Zone",
                                        "Sum",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Estimated Refrigerant Inventory Mass",
                                        OutputProcessor::Unit::kg,
                                        System(refrigSysNum).RefInventory,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    if (System(refrigSysNum).NumStages == 1) {
                        SetupOutputVariable("Refrigeration System Estimated Refrigerant Mass Flow Rate",
                                            OutputProcessor::Unit::kg_s,
                                            System(refrigSysNum).RefMassFlowComps,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                    } else if (System(refrigSysNum).NumStages == 2) {
                        SetupOutputVariable("Refrigeration System Estimated Low Stage Refrigerant Mass Flow Rate",
                                            OutputProcessor::Unit::kg_s,
                                            System(refrigSysNum).RefMassFlowComps,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration System Estimated High Stage Refrigerant Mass Flow Rate",
                                            OutputProcessor::Unit::kg_s,
                                            System(refrigSysNum).RefMassFlowHiStageComps,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                    } // NumStages
                    if (System(refrigSysNum).NumStages == 2) {
                        SetupOutputVariable("Refrigeration System Intercooler Temperature",
                                            OutputProcessor::Unit::C,
                                            System(refrigSysNum).TIntercooler,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                        SetupOutputVariable("Refrigeration System Intercooler Pressure",
                                            OutputProcessor::Unit::Pa,
                                            System(refrigSysNum).PIntercooler,
                                            "Zone",
                                            "Average",
                                            System(refrigSysNum).Name);
                    }
                    SetupOutputVariable("Refrigeration System Condensing Temperature",
                                        OutputProcessor::Unit::C,
                                        System(refrigSysNum).TCondense,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Evaporating Temperature",
                                        OutputProcessor::Unit::C,
                                        System(refrigSysNum).TEvapNeeded,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Suction Pipe Suction Temperature",
                                        OutputProcessor::Unit::C,
                                        System(refrigSysNum).TCompIn,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Thermostatic Expansion Valve Liquid Temperature",
                                        OutputProcessor::Unit::C,
                                        System(refrigSysNum).TLiqInActual,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Liquid Suction Subcooler Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        System(refrigSysNum).LSHXTrans,
                                        "Zone",
                                        "Average",
                                        System(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration System Liquid Suction Subcooler Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        System(refrigSysNum).LSHXTransEnergy,
                                        "Zone",
                                        "Sum",
                                        System(refrigSysNum).Name);
                } // System(coilflag)

                if (System(refrigSysNum).SystemRejectHeatToZone) {
                    if (Condenser(System(refrigSysNum).CondenserNum(1)).InletAirZoneNum > 0)
                        SetupZoneInternalGain(Condenser(System(refrigSysNum).CondenserNum(1)).InletAirZoneNum,
                                              "Refrigeration:System:Condenser:AirCooled",
                                              System(refrigSysNum).Name,
                                              DataHeatBalance::IntGainTypeOf_RefrigerationSystemAirCooledCondenser,
                                              &System(refrigSysNum).NetHeatRejectLoad);

                    if (System(refrigSysNum).SuctionPipeActualZoneNum > 0)
                        SetupZoneInternalGain(System(refrigSysNum).SuctionPipeActualZoneNum,
                                              "Refrigeration:System:SuctionPipe",
                                              System(refrigSysNum).Name,
                                              DataHeatBalance::IntGainTypeOf_RefrigerationSystemSuctionPipe,
                                              &System(refrigSysNum).PipeHeatLoad);
                }
            } // numrefrigsystems

            // Report Compressor ENERGY here, not on system level for meters.
            for (int compNum = 1; compNum <= NumSimulationCompressors; ++compNum) {
                // CurrentModuleObject='Refrigeration:Compressor'
                if (Compressor(compNum).NumSysAttach == 1) { // only set up reports for compressors that are used once and only once
                    if (Compressor(compNum).CoilFlag) {      // Compressor serving system with chillers on HVAC time step
                        SetupOutputVariable("Refrigeration Air Chiller System Compressor Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Compressor(compNum).Power,
                                            "HVAC",
                                            "Average",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Compressor(compNum).ElecConsumption,
                                            "HVAC",
                                            "Sum",
                                            Compressor(compNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Compressor(compNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Air Chiller System Compressor Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Compressor(compNum).Capacity,
                                            "HVAC",
                                            "Average",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Compressor Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Compressor(compNum).CoolingEnergy,
                                            "HVAC",
                                            "Sum",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Compressor Runtime Fraction",
                                            OutputProcessor::Unit::None,
                                            Compressor(compNum).LoadFactor,
                                            "HVAC",
                                            "Average",
                                            Compressor(compNum).Name);
                    } else { // serve cases/walkins on zone time step
                        SetupOutputVariable("Refrigeration Compressor Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Compressor(compNum).Power,
                                            "Zone",
                                            "Average",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Compressor(compNum).ElecConsumption,
                                            "Zone",
                                            "Sum",
                                            Compressor(compNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Compressor(compNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Compressor Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Compressor(compNum).Capacity,
                                            "Zone",
                                            "Average",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Compressor(compNum).CoolingEnergy,
                                            "Zone",
                                            "Sum",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Runtime Fraction",
                                            OutputProcessor::Unit::None,
                                            Compressor(compNum).LoadFactor,
                                            "Zone",
                                            "Average",
                                            Compressor(compNum).Name);
                    } // Serve coils on HVAC time step or cases/walkins on Zone time step
                }     // NumSysAttach
            }         // CompNum on NumSimulationCompressors

            // Report Variables for Refrigeration Condensers
            for (int condNum = 1; condNum <= DataHeatBalance::NumRefrigCondensers; ++condNum) {
                // CurrentModuleObject='Refrigeration:Condenser:*'
                if (Condenser(condNum).CoilFlag) { // Condenser serving system with chillers on HVAC time step
                    SetupOutputVariable("Refrigeration Air Chiller System Condenser Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        Condenser(condNum).CondLoad,
                                        "HVAC",
                                        "Average",
                                        Condenser(condNum).Name);
                    SetupOutputVariable("Refrigeration Air Chiller System Condenser Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        Condenser(condNum).CondEnergy,
                                        "HVAC",
                                        "Sum",
                                        Condenser(condNum).Name);

                    if (Condenser(condNum).CondenserType != DataHeatBalance::RefrigCondenserTypeCascade) {
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Total Recovered Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).TotalHeatRecoveredLoad,
                                            "HVAC",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Total Recovered Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).TotalHeatRecoveredEnergy,
                                            "HVAC",
                                            "Sum",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Non Refrigeration Recovered Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).ExternalHeatRecoveredLoad,
                                            "HVAC",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Non Refrigeration Recovered Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).ExternalEnergyRecovered,
                                            "HVAC",
                                            "Sum",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Defrost Recovered Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).InternalHeatRecoveredLoad,
                                            "HVAC",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Defrost Recovered Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).InternalEnergyRecovered,
                                            "HVAC",
                                            "Sum",
                                            Condenser(condNum).Name);
                    } // not cascade because recovered energy on cascade systems passed up to higher temperature system

                    if (Condenser(condNum).CondenserType == DataHeatBalance::RefrigCondenserTypeAir) {
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Fan Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).ActualFanPower,
                                            "HVAC",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Fan Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).FanElecEnergy,
                                            "HVAC",
                                            "Sum",
                                            Condenser(condNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Condenser(condNum).EndUseSubcategory,
                                            "Plant");
                    } // Air cooled

                    if (Condenser(condNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) {
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Fan Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).ActualFanPower,
                                            "HVAC",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Fan Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).FanElecEnergy,
                                            "HVAC",
                                            "Sum",
                                            Condenser(condNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Condenser(condNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Pump Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).ActualEvapPumpPower,
                                            "HVAC",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Pump Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).EvapPumpConsumption,
                                            "HVAC",
                                            "Sum",
                                            Condenser(condNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Condenser(condNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Basin Heater Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).BasinHeaterPower,
                                            "HVAC",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Basin Heater Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).BasinHeaterConsumption,
                                            "HVAC",
                                            "Sum",
                                            Condenser(condNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Condenser(condNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Evaporated Water Volume Flow Rate",
                                            OutputProcessor::Unit::m3_s,
                                            Condenser(condNum).EvapWaterConsumpRate,
                                            "HVAC",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Evaporated Water Volume",
                                            OutputProcessor::Unit::m3,
                                            Condenser(condNum).EvapWaterConsumption,
                                            "HVAC",
                                            "Sum",
                                            Condenser(condNum).Name,
                                            _,
                                            "Water",
                                            "REFRIGERATION",
                                            Condenser(condNum).EndUseSubcategory,
                                            "Plant");
                    } // Evaporative Condenser Variables

                    if (Condenser(condNum).CondenserType == DataHeatBalance::RefrigCondenserTypeWater) {
                        SetupOutputVariable("Refrigeration Air Chiller System Condenser Fluid Mass Flow Rate",
                                            OutputProcessor::Unit::kg_s,
                                            Condenser(condNum).MassFlowRate,
                                            "HVAC",
                                            "Average",
                                            Condenser(condNum).Name);

                    } // Water-cooled Condenser variables

                } else { // Serving loads/systems with cases and walkins on zone time step

                    SetupOutputVariable("Refrigeration System Condenser Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        Condenser(condNum).CondLoad,
                                        "Zone",
                                        "Average",
                                        Condenser(condNum).Name);
                    SetupOutputVariable("Refrigeration System Condenser Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        Condenser(condNum).CondEnergy,
                                        "Zone",
                                        "Sum",
                                        Condenser(condNum).Name);

                    if (Condenser(condNum).CondenserType != DataHeatBalance::RefrigCondenserTypeCascade) {
                        SetupOutputVariable("Refrigeration System Condenser Total Recovered Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).TotalHeatRecoveredLoad,
                                            "Zone",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration System Condenser Total Recovered Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).TotalHeatRecoveredEnergy,
                                            "Zone",
                                            "Sum",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration System Condenser Non Refrigeration Recovered Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).ExternalHeatRecoveredLoad,
                                            "Zone",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration System Condenser Non Refrigeration Recovered Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).ExternalEnergyRecovered,
                                            "Zone",
                                            "Sum",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration System Condenser Defrost Recovered Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).InternalHeatRecoveredLoad,
                                            "Zone",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration System Condenser Defrost Recovered Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).InternalEnergyRecovered,
                                            "Zone",
                                            "Sum",
                                            Condenser(condNum).Name);
                    } // not cascade because recovered energy on cascade systems passed up to higher temperature system

                    if (Condenser(condNum).CondenserType == DataHeatBalance::RefrigCondenserTypeAir) {
                        SetupOutputVariable("Refrigeration System Condenser Fan Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).ActualFanPower,
                                            "Zone",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration System Condenser Fan Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).FanElecEnergy,
                                            "Zone",
                                            "Sum",
                                            Condenser(condNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Condenser(condNum).EndUseSubcategory,
                                            "Plant");
                    } // Air cooled

                    if (Condenser(condNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) {
                        SetupOutputVariable("Refrigeration System Condenser Fan Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).ActualFanPower,
                                            "Zone",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration System Condenser Fan Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).FanElecEnergy,
                                            "Zone",
                                            "Sum",
                                            Condenser(condNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Condenser(condNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration System Condenser Pump Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).ActualEvapPumpPower,
                                            "Zone",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration System Condenser Pump Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).EvapPumpConsumption,
                                            "Zone",
                                            "Sum",
                                            Condenser(condNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Condenser(condNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration System Condenser Basin Heater Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Condenser(condNum).BasinHeaterPower,
                                            "Zone",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration System Condenser Basin Heater Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Condenser(condNum).BasinHeaterConsumption,
                                            "Zone",
                                            "Sum",
                                            Condenser(condNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Condenser(condNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration System Condenser Evaporated Water Volume Flow Rate",
                                            OutputProcessor::Unit::m3_s,
                                            Condenser(condNum).EvapWaterConsumpRate,
                                            "Zone",
                                            "Average",
                                            Condenser(condNum).Name);
                        SetupOutputVariable("Refrigeration System Condenser Evaporated Water Volume",
                                            OutputProcessor::Unit::m3,
                                            Condenser(condNum).EvapWaterConsumption,
                                            "Zone",
                                            "Sum",
                                            Condenser(condNum).Name,
                                            _,
                                            "Water",
                                            "REFRIGERATION",
                                            Condenser(condNum).EndUseSubcategory,
                                            "Plant");
                    } // Evaporative Condenser Variables

                    if (Condenser(condNum).CondenserType == DataHeatBalance::RefrigCondenserTypeWater) {
                        SetupOutputVariable("Refrigeration System Condenser Water Mass Flow Rate",
                                            OutputProcessor::Unit::kg_s,
                                            Condenser(condNum).MassFlowRate,
                                            "HVAC",
                                            "Average",
                                            Condenser(condNum).Name);

                    } // Water-cooled Condenser variables
                }     // Condenser%CoilFlag to distinguish HVAC vs Zone time steps
            }         // CondNum on DataHeatBalance::NumRefrigCondensers

            if (NumSimulationSubcoolers > 0) {
                for (int subcoolNum = 1; subcoolNum <= NumSimulationSubcoolers; ++subcoolNum) {
                    // CurrentModuleObject='Refrigeration:Subcooler'
                    if (Subcooler(subcoolNum).CoilFlag) { // Subcooler serving system with chillers on HVAC time step
                        if (Subcooler(subcoolNum).SubcoolerType == Mechanical) {
                            SetupOutputVariable("Refrigeration Air Chiller System Mechanical Subcooler Heat Transfer Rate",
                                                OutputProcessor::Unit::W,
                                                Subcooler(subcoolNum).MechSCTransLoad,
                                                "Zone",
                                                "Average",
                                                Subcooler(subcoolNum).Name);
                            SetupOutputVariable("Refrigeration Air Chiller System Mechanical Subcooler Heat Transfer Energy",
                                                OutputProcessor::Unit::J,
                                                Subcooler(subcoolNum).MechSCTransEnergy,
                                                "Zone",
                                                "Sum",
                                                Subcooler(subcoolNum).Name);
                        }
                    } else { // Subcooler on system serving cases and/or walkins
                        if (Subcooler(subcoolNum).SubcoolerType == Mechanical) {
                            SetupOutputVariable("Refrigeration System Mechanical Subcooler Heat Transfer Rate",
                                                OutputProcessor::Unit::W,
                                                Subcooler(subcoolNum).MechSCTransLoad,
                                                "HVAC",
                                                "Average",
                                                Subcooler(subcoolNum).Name);
                            SetupOutputVariable("Refrigeration System Mechanical Subcooler Heat Transfer Energy",
                                                OutputProcessor::Unit::J,
                                                Subcooler(subcoolNum).MechSCTransEnergy,
                                                "HVAC",
                                                "Sum",
                                                Subcooler(subcoolNum).Name);
                        }
                    } // Subcoolers on system serving chillers
                }     // Subcoolnum on NumSimulationSubcoolers
            }         // NumSimulationSubcoolers > 0

        } // NumRefrigSystems > 0

        if (NumTransRefrigSystems > 0) {
            // CurrentModuleObject='Refrigeration:TranscriticalSystem'
            for (int refrigSysNum = 1; refrigSysNum <= NumTransRefrigSystems; ++refrigSysNum) {
                // for both SingleStage and TwoStage systems (medium temperature loads present)
                SetupOutputVariable("Refrigeration Transcritical System Total High Pressure Compressor Electricity Rate",
                                    OutputProcessor::Unit::W,
                                    TransSystem(refrigSysNum).TotCompPowerHP,
                                    "Zone",
                                    "Average",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Total High Pressure Compressor Electricity Energy",
                                    OutputProcessor::Unit::J,
                                    TransSystem(refrigSysNum).TotCompElecConsumpHP,
                                    "Zone",
                                    "Sum",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Total Compressor Electricity Energy",
                                    OutputProcessor::Unit::J,
                                    TransSystem(refrigSysNum).TotCompElecConsump,
                                    "Zone",
                                    "Sum",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Average COP",
                                    OutputProcessor::Unit::W_W,
                                    TransSystem(refrigSysNum).AverageCompressorCOP,
                                    "Zone",
                                    "Average",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Medium Temperature Cases and Walk Ins Heat Transfer Rate",
                                    OutputProcessor::Unit::W,
                                    TransSystem(refrigSysNum).TotalCoolingLoadMT,
                                    "Zone",
                                    "Average",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Medium Temperature Cases and Walk Ins Heat Transfer Energy",
                                    OutputProcessor::Unit::J,
                                    TransSystem(refrigSysNum).TotalCoolingEnergyMT,
                                    "Zone",
                                    "Sum",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Total Cases and Walk Ins Heat Transfer Energy",
                                    OutputProcessor::Unit::J,
                                    TransSystem(refrigSysNum).TotalCoolingEnergy,
                                    "Zone",
                                    "Sum",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Medium Temperature Suction Pipe Heat Transfer Rate",
                                    OutputProcessor::Unit::W,
                                    TransSystem(refrigSysNum).PipeHeatLoadMT,
                                    "Zone",
                                    "Average",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Medium Temperature Suction Pipe Heat Transfer Energy",
                                    OutputProcessor::Unit::J,
                                    TransSystem(refrigSysNum).PipeHeatEnergyMT,
                                    "Zone",
                                    "Sum",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System High Pressure Compressor Heat Transfer Rate",
                                    OutputProcessor::Unit::W,
                                    TransSystem(refrigSysNum).TotCompCapacityHP,
                                    "Zone",
                                    "Average",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System High Pressure Compressor Heat Transfer Energy",
                                    OutputProcessor::Unit::J,
                                    TransSystem(refrigSysNum).TotCompCoolingEnergyHP,
                                    "Zone",
                                    "Sum",
                                    TransSystem(refrigSysNum).Name); // indiv compressors go to meter, not system sum
                SetupOutputVariable("Refrigeration Transcritical System Net Rejected Heat Transfer Rate",
                                    OutputProcessor::Unit::W,
                                    TransSystem(refrigSysNum).NetHeatRejectLoad,
                                    "Zone",
                                    "Average",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Net Rejected Heat Transfer Energy",
                                    OutputProcessor::Unit::J,
                                    TransSystem(refrigSysNum).NetHeatRejectEnergy,
                                    "Zone",
                                    "Sum",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Estimated Refrigerant Inventory Mass",
                                    OutputProcessor::Unit::kg,
                                    TransSystem(refrigSysNum).RefInventory,
                                    "Zone",
                                    "Average",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Refrigerant Mass Flow Rate",
                                    OutputProcessor::Unit::kg_s,
                                    TransSystem(refrigSysNum).RefMassFlowComps,
                                    "Zone",
                                    "Average",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Medium Temperature Evaporating Temperature",
                                    OutputProcessor::Unit::C,
                                    TransSystem(refrigSysNum).TEvapNeededMT,
                                    "Zone",
                                    "Average",
                                    TransSystem(refrigSysNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Medium Temperature Suction Temperature",
                                    OutputProcessor::Unit::C,
                                    TransSystem(refrigSysNum).TCompInHP,
                                    "Zone",
                                    "Average",
                                    TransSystem(refrigSysNum).Name);
                if (TransSystem(refrigSysNum).TransSysType == 2) { // for TwoStage system only (low temperature loads present)
                    SetupOutputVariable("Refrigeration Transcritical System Low Pressure Compressor Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        TransSystem(refrigSysNum).TotCompPowerLP,
                                        "Zone",
                                        "Average",
                                        TransSystem(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Transcritical System Low Pressure Compressor Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        TransSystem(refrigSysNum).TotCompElecConsumpLP,
                                        "Zone",
                                        "Sum",
                                        TransSystem(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Transcritical System Low Temperature Cases and Walk Ins Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        TransSystem(refrigSysNum).TotalCoolingLoadLT,
                                        "Zone",
                                        "Average",
                                        TransSystem(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Transcritical System Low Temperature Cases and Walk Ins Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        TransSystem(refrigSysNum).TotalCoolingEnergyLT,
                                        "Zone",
                                        "Sum",
                                        TransSystem(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Transcritical System Low Temperature Suction Pipe Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        TransSystem(refrigSysNum).PipeHeatLoadLT,
                                        "Zone",
                                        "Average",
                                        TransSystem(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Transcritical System Low Temperature Suction Pipe Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        TransSystem(refrigSysNum).PipeHeatEnergyLT,
                                        "Zone",
                                        "Sum",
                                        TransSystem(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Transcritical System Low Pressure Compressor Heat Transfer Rate",
                                        OutputProcessor::Unit::W,
                                        TransSystem(refrigSysNum).TotCompCapacityLP,
                                        "Zone",
                                        "Average",
                                        TransSystem(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Transcritical System Low Pressure Compressor Heat Transfer Energy",
                                        OutputProcessor::Unit::J,
                                        TransSystem(refrigSysNum).TotCompCoolingEnergyLP,
                                        "Zone",
                                        "Sum",
                                        TransSystem(refrigSysNum).Name); // indiv compressors go to meter, not system sum
                    SetupOutputVariable("Refrigeration Transcritical System Low Temperature Evaporating Temperature",
                                        OutputProcessor::Unit::C,
                                        TransSystem(refrigSysNum).TEvapNeededLT,
                                        "Zone",
                                        "Average",
                                        TransSystem(refrigSysNum).Name);
                    SetupOutputVariable("Refrigeration Transcritical System Low Temperature Suction Temperature",
                                        OutputProcessor::Unit::C,
                                        TransSystem(refrigSysNum).TCompInLP,
                                        "Zone",
                                        "Average",
                                        TransSystem(refrigSysNum).Name);
                } // (TransSystem(RefrigSysNum)%TransSysType == 2)

                if (TransSystem(refrigSysNum).SystemRejectHeatToZone) {
                    if (GasCooler(TransSystem(refrigSysNum).GasCoolerNum(1)).InletAirZoneNum > 0)
                        SetupZoneInternalGain(GasCooler(TransSystem(refrigSysNum).GasCoolerNum(1)).InletAirZoneNum,
                                              "Refrigeration:TranscriticalSystem:GasCooler:AirCooled",
                                              TransSystem(refrigSysNum).Name,
                                              DataHeatBalance::IntGainTypeOf_RefrigerationTransSysAirCooledGasCooler,
                                              &TransSystem(refrigSysNum).NetHeatRejectLoad);
                } // (TransSystem(RefrigSysNum)%SystemRejectHeatToZone)
                if (TransSystem(refrigSysNum).SuctionPipeActualZoneNumMT > 0) {
                    SetupZoneInternalGain(TransSystem(refrigSysNum).SuctionPipeActualZoneNumMT,
                                          "Refrigeration:TranscriticalSystem:SuctionPipeMT",
                                          TransSystem(refrigSysNum).Name,
                                          DataHeatBalance::IntGainTypeOf_RefrigerationTransSysSuctionPipeMT,
                                          &TransSystem(refrigSysNum).PipeHeatLoadMT);
                } // TransSystem(RefrigSysNum)%SuctionPipeActualZoneNumMT > 0
                if (TransSystem(refrigSysNum).SuctionPipeActualZoneNumLT > 0) {
                    SetupZoneInternalGain(TransSystem(refrigSysNum).SuctionPipeActualZoneNumLT,
                                          "Refrigeration:TranscriticalSystem:SuctionPipeLT",
                                          TransSystem(refrigSysNum).Name,
                                          DataHeatBalance::IntGainTypeOf_RefrigerationTransSysSuctionPipeLT,
                                          &TransSystem(refrigSysNum).PipeHeatLoadLT);
                } // TransSystem(RefrigSysNum)%SuctionPipeActualZoneNumLT > 0

                // Report Compressor ENERGY here, not on system level for meters.
                // LP compressors
                for (int compIndex = 1; compIndex <= TransSystem(refrigSysNum).NumCompressorsLP; ++compIndex) {
                    int compNum = TransSystem(refrigSysNum).CompressorNumLP(compIndex);
                    // CurrentModuleObject='Refrigeration:Compressor'
                    if (Compressor(compNum).NumSysAttach == 1) { // only set up reports for compressors that are used once and only once
                        SetupOutputVariable("Refrigeration Compressor Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Compressor(compNum).Power,
                                            "Zone",
                                            "Average",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Compressor(compNum).ElecConsumption,
                                            "Zone",
                                            "Sum",
                                            Compressor(compNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Compressor(compNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Compressor Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Compressor(compNum).Capacity,
                                            "Zone",
                                            "Average",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Compressor(compNum).CoolingEnergy,
                                            "Zone",
                                            "Sum",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Runtime Fraction",
                                            OutputProcessor::Unit::None,
                                            Compressor(compNum).LoadFactor,
                                            "Zone",
                                            "Average",
                                            Compressor(compNum).Name);
                    } // NumSysAttach
                }     // TransSystem(RefrigSysNum)%NumCompressorsLP

                // HP compressors
                for (int compIndex = 1; compIndex <= TransSystem(refrigSysNum).NumCompressorsHP; ++compIndex) {
                    int compNum = TransSystem(refrigSysNum).CompressorNumHP(compIndex);
                    // CurrentModuleObject='Refrigeration:Compressor'
                    if (Compressor(compNum).NumSysAttach == 1) { // only set up reports for compressors that are used once and only once
                        SetupOutputVariable("Refrigeration Compressor Electricity Rate",
                                            OutputProcessor::Unit::W,
                                            Compressor(compNum).Power,
                                            "Zone",
                                            "Average",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            Compressor(compNum).ElecConsumption,
                                            "Zone",
                                            "Sum",
                                            Compressor(compNum).Name,
                                            _,
                                            "ELECTRICITY",
                                            "REFRIGERATION",
                                            Compressor(compNum).EndUseSubcategory,
                                            "Plant");
                        SetupOutputVariable("Refrigeration Compressor Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            Compressor(compNum).Capacity,
                                            "Zone",
                                            "Average",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Heat Transfer Energy",
                                            OutputProcessor::Unit::J,
                                            Compressor(compNum).CoolingEnergy,
                                            "Zone",
                                            "Sum",
                                            Compressor(compNum).Name);
                        SetupOutputVariable("Refrigeration Compressor Runtime Fraction",
                                            OutputProcessor::Unit::None,
                                            Compressor(compNum).LoadFactor,
                                            "Zone",
                                            "Average",
                                            Compressor(compNum).Name);
                    } // NumSysAttach
                }     // TransSystem(RefrigSysNum)%NumCompressorsHP

            } // NumTransRefrigSystems
        }     // (NumTransRefrigSystems > 0)

        if (NumSimulationGasCooler > 0) {
            for (int GCNum = 1; GCNum <= NumSimulationGasCooler; ++GCNum) {
                // CurrentModuleObject='Refrigeration:GasCooler:AirCooled'
                SetupOutputVariable("Refrigeration Transcritical System Gas Cooler Heat Transfer Rate",
                                    OutputProcessor::Unit::W,
                                    GasCooler(GCNum).GasCoolerLoad,
                                    "Zone",
                                    "Average",
                                    GasCooler(GCNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Gas Cooler Heat Transfer Energy",
                                    OutputProcessor::Unit::J,
                                    GasCooler(GCNum).GasCoolerEnergy,
                                    "Zone",
                                    "Sum",
                                    GasCooler(GCNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Gas Cooler Fan Electricity Rate",
                                    OutputProcessor::Unit::W,
                                    GasCooler(GCNum).ActualFanPower,
                                    "Zone",
                                    "Average",
                                    GasCooler(GCNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Gas Cooler Fan Electricity Energy",
                                    OutputProcessor::Unit::J,
                                    GasCooler(GCNum).FanElecEnergy,
                                    "Zone",
                                    "Sum",
                                    GasCooler(GCNum).Name,
                                    _,
                                    "ELECTRICITY",
                                    "REFRIGERATION",
                                    GasCooler(GCNum).EndUseSubcategory,
                                    "Plant");
                SetupOutputVariable("Refrigeration Transcritical System Gas Cooler Outlet Temperature",
                                    OutputProcessor::Unit::C,
                                    GasCooler(GCNum).TGasCoolerOut,
                                    "Zone",
                                    "Average",
                                    GasCooler(GCNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Gas Cooler Outlet Pressure",
                                    OutputProcessor::Unit::Pa,
                                    GasCooler(GCNum).PGasCoolerOut,
                                    "Zone",
                                    "Average",
                                    GasCooler(GCNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Gas Cooler Defrost Recovered Heat Transfer Rate",
                                    OutputProcessor::Unit::W,
                                    GasCooler(GCNum).InternalHeatRecoveredLoad,
                                    "Zone",
                                    "Average",
                                    GasCooler(GCNum).Name);
                SetupOutputVariable("Refrigeration Transcritical System Gas Cooler Defrost Recovered Heat Transfer Energy",
                                    OutputProcessor::Unit::J,
                                    GasCooler(GCNum).InternalEnergyRecovered,
                                    "Zone",
                                    "Sum",
                                    GasCooler(GCNum).Name);
            } // GCNum on NumSimulationGasCooler
        }     // (NumSimulationGasCooler >0)
    }

    void InitRefrigeration()
    {
        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   Oct/Nov 2004
        //       MODIFIED       Hudson, ORNL July 2007, Stovall, ORNL, 2008
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Initialize (zero) global variables before simulating compressor racks and refrigerated cases
        // Several variables in this module are accumulative.  For example, unmet compressor loads are carried over
        // to the next time step. Ice loads are accumulated until melted by a defrost.  Because this module can be
        // called multiple times during any single time step, these summations need to be saved ONLY on the last time
        // through any given time step.

        // It is necessary to decrease the condenser load by the amount of heat used elsewhere
        //   via desuperheating water heaters and heating coils.
        //   Because the refrigeration system is solved before the HVAC time step loops, the
        //   refrigeration system must use the values lagged from the previous time step. In
        //   terms of energy, this should balance out and is preferable to not making the correction,
        //   in which case the condenser cooling water/air/fan energy are charged with energy
        //   loads that have been accounted elsewhere.  For consistency, the lagged value must be used,
        //   even if the Zone time step is repeated.  Therefore, the lagged variables are saved
        //   here for use during successive iterations of same zone/load time step.

        // METHODOLOGY EMPLOYED:
        // Global variables for Case Credit are located in DataHeatBalance. To Zone variables are used in the Air Heat
        // Balance in ZoneTempPredictorCorrector to calculate the zone load. To HVAC variables are used in
        // ZoneEquipmentManager to add the portion of case credits attributed to the HVAC system to the zone return air node.

        // Because we can't know apriori whether or not the time step will be repeated, we save the most recent
        // addition/subtraction to/from each accumulating variable.  If the time step is repeated,
        // this most recent addition/subtraction is reversed before the rest of the refrigeration simulation begins.

        // Used to adjust accumulative variables when time step is repeated
        static Real64 MyCurrentTimeSaved(0.0);   // Used to determine whether the zone time step is a repetition
        static Real64 MyStepStartTimeSaved(0.0); // Used to determine whether the system time step is a repetition
        static Real64 TimeStepFraction(0.0);     // Used to calculate my current time

        // Zero display case, air-coil, and walk-in cooler credits (summed by zone)
        // to 0 each zone or sys time step
        // These 'casecredit' variables are also used to transfer energy from zone-located
        // compressor-rack condenser heat rejection, heat absorption by distribution piping,
        // suction piping, and receiver shells to zone
        if (DataGlobals::NumOfZones > 0) {
            if (UseSysTimeStep) {
                for (int i = CoilSysCredit.l(), e = CoilSysCredit.u(); i <= e; ++i) {
                    CoilSysCredit(i).reset();
                }
            } // UseSysTimeStep = true

            // Can arrive here when load call to refrigeration looks for cases/walkin systems and usetimestep is false
            if ((!UseSysTimeStep) && ((NumSimulationCases > 0) || (NumSimulationWalkIns > 0))) {
                for (int i = DataHeatBalance::RefrigCaseCredit.l(), e = DataHeatBalance::RefrigCaseCredit.u(); i <= e; ++i) {
                    DataHeatBalance::RefrigCaseCredit(i).reset();
                }
                for (int i = CaseWIZoneReport.l(), e = CaseWIZoneReport.u(); i <= e; ++i) {
                    CaseWIZoneReport(i).reset();
                }
            }
        }

        if (NumSimulationCases > 0) {
            // RefrigCase ALLOCATED to NumSimulationCases
            for (int i = RefrigCase.l(), e = RefrigCase.u(); i <= e; ++i) {
                RefrigCase(i).reset_init();
            }
        } // NumSimulationCases

        if (NumSimulationWalkIns > 0) {
            // WalkIn ALLOCATED to NumSimulationWalkIns
            for (int i = WalkIn.l(), e = WalkIn.u(); i <= e; ++i) {
                WalkIn(i).reset_init();
            }
        }

        if (HaveChillers) {
            // HaveChillers is TRUE when NumSimulationRefrigAirChillers > 0
            // WarehouseCoil ALLOCATED to NumSimulationRefrigAirChillers
            for (int i = WarehouseCoil.l(), e = WarehouseCoil.u(); i <= e; ++i) {
                WarehouseCoil(i).reset_init();
            }
        }

        if (HaveRefrigRacks) {
            // HaveRefrigRacks TRUE when NumRefrigeratedRacks > 0
            // RefrigRack ALLOCATED to NumRefrigeratedRacks
            for (int i = RefrigRack.l(), e = RefrigRack.u(); i <= e; ++i) {
                RefrigRack(i).reset_init();
            }
            for (auto &e : DataHeatBalance::HeatReclaimRefrigeratedRack)
                e.AvailCapacity = 0.0;
            // Note don't reset basin heat to zero when no load because heater would remain on
            // RefrigRack.BasinHeaterPower = 0.0;
            // RefrigRack.BasinHeaterConsumption = 0.0;
        }

        if (DataHeatBalance::NumRefrigCondensers > 0) {
            // Condenser ALLOCATED to DataHeatBalance::NumRefrigCondensers
            for (int i = Condenser.l(), e = Condenser.u(); i <= e; ++i) {
                Condenser(i).reset_init();
            }
            // N don't reset basin heat to zero when no load because heater would remain on
            for (auto &e : DataHeatBalance::HeatReclaimRefrigCondenser) {
                e.AvailCapacity = 0.0;
                e.AvailTemperature = 0.0;
            }
        }

        if (NumSimulationGasCooler > 0) {
            // GasCooler ALLOCATED to NumSimulationGasCooler
            for (int i = GasCooler.l(), e = GasCooler.u(); i <= e; ++i) {
                GasCooler(i).reset_init();
            }
        }

        if (NumSimulationCompressors > 0) {
            // Compressor ALLOCATED to NumSimulationCompressors
            for (int i = Compressor.l(), e = Compressor.u(); i <= e; ++i) {
                Compressor(i).reset_init();
            }
        }

        if (HaveDetailedRefrig) {
            // HaveDetailedRefrig is TRUE when NumRefrigSystems > 0
            // System is ALLOCATED to NumRefrigSystems
            for (int i = System.l(), e = System.u(); i <= e; ++i) {
                System(i).reset_init();
            }
        }

        if (HaveDetailedTransRefrig) {
            // HaveDetailedTransRefrig is TRUE when NumTransRefrigSystems > 0
            // TransSystem is ALLOCATED to NumTransRefrigSystems
            for (int i = TransSystem.l(), e = TransSystem.u(); i <= e; ++i) {
                TransSystem(i).reset_init();
            }
        }

        if (NumSimulationSecondarySystems > 0) {
            // Secondary is ALLOCATED to NumSimulationSecondarySystems
            for (int i = Secondary.l(), e = Secondary.u(); i <= e; ++i) {
                Secondary(i).reset_init();
            }
        }

        // Accumulative and carry-over variables are not zeroed at start of each time step, only at begining of environment
        if (DataGlobals::BeginEnvrnFlag && InitRefrigerationMyBeginEnvrnFlag) {
            if (NumSimulationCases > 0) {
                for (int i = RefrigCase.l(), e = RefrigCase.u(); i <= e; ++i) {
                    RefrigCase(i).reset_init_accum();
                }
            }
            if (DataHeatBalance::NumRefrigSystems > 0) {
                for (auto &e : System)
                    e.UnmetEnergy = 0.0;
            }
            if (NumSimulationWalkIns > 0) {
                for (auto &e : WalkIn) {
                    e.KgFrost = 0.0;
                    e.StoredEnergy = 0.0;
                }
                for (int walkInID = 1; walkInID <= NumSimulationWalkIns; ++walkInID) {
                    WalkIn(walkInID).IceTemp = WalkIn(walkInID).TEvapDesign;
                }
            }
            if (NumSimulationRefrigAirChillers > 0) {
                for (auto &e : WarehouseCoil) {
                    e.KgFrost = 0.0;
                    e.KgFrostSaved = 0.0;
                }
                for (int coilID = 1; coilID <= NumSimulationRefrigAirChillers; ++coilID) {
                    WarehouseCoil(coilID).IceTemp = WarehouseCoil(coilID).TEvapDesign;
                    WarehouseCoil(coilID).IceTempSaved = WarehouseCoil(coilID).TEvapDesign;
                }
            }
            if (NumSimulationSecondarySystems > 0) {
                for (auto &e : Secondary)
                    e.UnmetEnergy = 0.0;
            }
            if (DataHeatBalance::NumRefrigeratedRacks > 0) {
                for (auto &e : DataHeatBalance::HeatReclaimRefrigeratedRack) {
                    e.HVACDesuperheaterReclaimedHeatTotal = 0.0;
                    e.WaterHeatingDesuperheaterReclaimedHeatTotal = 0.0;
                }
                for (auto &e : RefrigRack) {
                    e.LaggedUsedWaterHeater = 0.0;
                    e.LaggedUsedHVACCoil = 0.0;
                }
            }
            if (DataHeatBalance::NumRefrigCondensers > 0) {
                for (auto &e : DataHeatBalance::HeatReclaimRefrigCondenser) {
                    e.HVACDesuperheaterReclaimedHeatTotal = 0.0;
                    e.WaterHeatingDesuperheaterReclaimedHeatTotal = 0.0;
                }
                for (auto &e : Condenser) {
                    e.LaggedUsedWaterHeater = 0.0;
                    e.LaggedUsedHVACCoil = 0.0;
                }
            }
            for (int systemId = 1; systemId <= DataHeatBalance::NumRefrigSystems; ++systemId) {
                if (allocated(System(systemId).MechSCLoad)) System(systemId).MechSCLoad = 0.0;
                System(systemId).LSHXTrans = 0.0;
                System(systemId).LSHXTransEnergy = 0.0;
            }

            if (DataGlobals::NumOfTimeStepInHour > 0.0) TimeStepFraction = 1.0 / double(DataGlobals::NumOfTimeStepInHour);
            InitRefrigerationMyBeginEnvrnFlag = false;

        } // ( DataGlobals::BeginEnvrnFlag && MyBeginEnvrnFlag )

        if (!DataGlobals::BeginEnvrnFlag) InitRefrigerationMyBeginEnvrnFlag = true;

        // Avoid multiplying accumulation if go through zone/load time step more than once.
        if (!DataGlobals::WarmupFlag) { // because no accumulation is done during warm up
            // Can arrive here when load call to refrigeration looks for cases/walkin systems and usetimestep is .FALSE.
            if ((!UseSysTimeStep) && ((NumSimulationCases > 0) || (NumSimulationWalkIns > 0))) {
                // Used to determine whether the zone time step is a repetition
                Real64 MyCurrentTime = (DataGlobals::HourOfDay - 1) + DataGlobals::TimeStep * TimeStepFraction;
                if (std::abs(MyCurrentTime - MyCurrentTimeSaved) < MySmallNumber) {
                    // If the time step is repeated, need to return to correct values at start of time step
                    if (NumSimulationCases > 0) {
                        for (int caseID = 1; caseID <= NumSimulationCases; ++caseID) {
                            RefrigCase(caseID).DefrostEnergy = RefrigCase(caseID).DefrostEnergySaved;
                            RefrigCase(caseID).StockingEnergy = RefrigCase(caseID).StockingEnergySaved;
                            RefrigCase(caseID).WarmEnvEnergy = RefrigCase(caseID).WarmEnvEnergySaved;
                            RefrigCase(caseID).KgFrost = RefrigCase(caseID).KgFrostSaved;
                            RefrigCase(caseID).StoredEnergy = RefrigCase(caseID).StoredEnergySaved;
                        } // CaseID
                    }     // NumSimulationCases
                    if (NumSimulationWalkIns > 0) {
                        for (int walkInID = 1; walkInID <= NumSimulationWalkIns; ++walkInID) {
                            WalkIn(walkInID).KgFrost = WalkIn(walkInID).KgFrostSaved;
                            WalkIn(walkInID).StoredEnergy = WalkIn(walkInID).StoredEnergySaved;
                            WalkIn(walkInID).IceTemp = WalkIn(walkInID).IceTempSaved;
                        }
                    }
                    if (DataHeatBalance::NumRefrigSystems > 0) {
                        for (int systemID = 1; systemID <= DataHeatBalance::NumRefrigSystems; ++systemID) {
                            if (System(systemID).CoilFlag) continue;
                            System(systemID).UnmetEnergy = System(systemID).UnmetEnergySaved;
                        }
                    }
                    if (NumTransRefrigSystems > 0) {
                        for (int systemID = 1; systemID <= NumTransRefrigSystems; ++systemID) {
                            TransSystem(systemID).UnmetEnergyMT = TransSystem(systemID).UnmetEnergySavedMT;
                            TransSystem(systemID).UnmetEnergyLT = TransSystem(systemID).UnmetEnergySavedLT;
                        }
                    }
                    if (NumSimulationSecondarySystems > 0) {
                        for (int secondID = 1; secondID <= NumSimulationSecondarySystems; ++secondID) {
                            if (Secondary(secondID).CoilFlag) continue;
                            Secondary(secondID).UnmetEnergy = Secondary(secondID).UnmetEnergySaved;
                        }
                    }

                } else {
                    // First time through this Zone time step, so set saved values to those in place at start of this time step
                    MyCurrentTimeSaved = MyCurrentTime;
                    if (NumSimulationCases > 0) {
                        for (int caseID = 1; caseID <= NumSimulationCases; ++caseID) {
                            RefrigCase(caseID).DefrostEnergySaved = RefrigCase(caseID).DefrostEnergy;
                            RefrigCase(caseID).StockingEnergySaved = RefrigCase(caseID).StockingEnergy;
                            RefrigCase(caseID).WarmEnvEnergySaved = RefrigCase(caseID).WarmEnvEnergy;
                            RefrigCase(caseID).KgFrostSaved = RefrigCase(caseID).KgFrost;
                            RefrigCase(caseID).StoredEnergySaved = RefrigCase(caseID).StoredEnergy;
                        } // caseid
                    }     // numsimulationcases
                    if (NumSimulationWalkIns > 0) {
                        for (int walkInID = 1; walkInID <= NumSimulationWalkIns; ++walkInID) {
                            WalkIn(walkInID).KgFrostSaved = WalkIn(walkInID).KgFrost;
                            WalkIn(walkInID).StoredEnergySaved = WalkIn(walkInID).StoredEnergy;
                            WalkIn(walkInID).IceTempSaved = WalkIn(walkInID).IceTemp;
                        }
                    }
                    if (DataHeatBalance::NumRefrigSystems > 0) {
                        for (int systemID = 1; systemID <= DataHeatBalance::NumRefrigSystems; ++systemID) {
                            if (System(systemID).CoilFlag) continue;
                            System(systemID).UnmetEnergySaved = System(systemID).UnmetEnergy;
                        }
                    }
                    if (NumTransRefrigSystems > 0) {
                        for (int systemID = 1; systemID <= NumTransRefrigSystems; ++systemID) {
                            TransSystem(systemID).UnmetEnergySavedMT = TransSystem(systemID).UnmetEnergyMT;
                            TransSystem(systemID).UnmetEnergySavedLT = TransSystem(systemID).UnmetEnergyLT;
                        }
                    }
                    if (NumSimulationSecondarySystems > 0) {
                        for (int secondID = 1; secondID <= NumSimulationSecondarySystems; ++secondID) {
                            if (Secondary(secondID).CoilFlag) continue;
                            Secondary(secondID).UnmetEnergySaved = Secondary(secondID).UnmetEnergy;
                        }
                    }
                    // Following lagged variables set for consistency to value calculated prev time through HVAC time step loops
                    if (allocated(DataHeatBalance::HeatReclaimRefrigeratedRack)) {
                        for (int IRack = 1; IRack <= DataHeatBalance::NumRefrigeratedRacks; ++IRack) {
                            RefrigRack(IRack).LaggedUsedHVACCoil = DataHeatBalance::HeatReclaimRefrigeratedRack(IRack).HVACDesuperheaterReclaimedHeatTotal;
                            RefrigRack(IRack).LaggedUsedWaterHeater = DataHeatBalance::HeatReclaimRefrigeratedRack(IRack).WaterHeatingDesuperheaterReclaimedHeatTotal;
                        }
                    }
                    if (allocated(DataHeatBalance::HeatReclaimRefrigCondenser)) {
                        for (int ICond = 1; ICond <= DataHeatBalance::NumRefrigCondensers; ++ICond) {
                            Condenser(ICond).LaggedUsedHVACCoil = DataHeatBalance::HeatReclaimRefrigCondenser(ICond).HVACDesuperheaterReclaimedHeatTotal;
                            Condenser(ICond).LaggedUsedWaterHeater = DataHeatBalance::HeatReclaimRefrigCondenser(ICond).WaterHeatingDesuperheaterReclaimedHeatTotal;
                        }
                    }
                } // repeating same time step

            } else { // using UseSysTimeStep as a flag for a chiller system

                // Used to determine whether the system time step is a repetition
                Real64 MyStepStartTime = DataGlobals::CurrentTime - DataGlobals::TimeStepZone + DataHVACGlobals::SysTimeElapsed;
                if (std::abs(MyStepStartTime - MyStepStartTimeSaved) < MySmallNumber) {
                    // If the time step is repeated, need to return to correct values at start of time step
                    if (NumSimulationRefrigAirChillers > 0) {
                        for (int coilID = 1; coilID <= NumSimulationRefrigAirChillers; ++coilID) {
                            WarehouseCoil(coilID).KgFrost = WarehouseCoil(coilID).KgFrostSaved;
                            WarehouseCoil(coilID).IceTemp = WarehouseCoil(coilID).IceTempSaved;
                        }
                    }
                } else { // First time through this system time step or hvac loop,
                    // so set saved values to those in place at start of this time step
                    MyStepStartTimeSaved = MyStepStartTime;
                    if (NumSimulationRefrigAirChillers > 0) {
                        for (int coilID = 1; coilID <= NumSimulationRefrigAirChillers; ++coilID) {
                            WarehouseCoil(coilID).KgFrostSaved = WarehouseCoil(coilID).KgFrost;
                            WarehouseCoil(coilID).IceTempSaved = WarehouseCoil(coilID).IceTemp;
                        }
                    }
                    // Following lagged variables set for consistency to value calculated prev time through HVAC time step loops
                    if (allocated(DataHeatBalance::HeatReclaimRefrigeratedRack)) {
                        for (int IRack = 1; IRack <= DataHeatBalance::NumRefrigeratedRacks; ++IRack) {
                            RefrigRack(IRack).LaggedUsedHVACCoil = DataHeatBalance::HeatReclaimRefrigeratedRack(IRack).HVACDesuperheaterReclaimedHeatTotal;
                            RefrigRack(IRack).LaggedUsedWaterHeater = DataHeatBalance::HeatReclaimRefrigeratedRack(IRack).WaterHeatingDesuperheaterReclaimedHeatTotal;
                        }
                    }
                    if (allocated(DataHeatBalance::HeatReclaimRefrigCondenser)) {
                        for (int ICond = 1; ICond <= DataHeatBalance::NumRefrigCondensers; ++ICond) {
                            Condenser(ICond).LaggedUsedHVACCoil = DataHeatBalance::HeatReclaimRefrigCondenser(ICond).HVACDesuperheaterReclaimedHeatTotal;
                            Condenser(ICond).LaggedUsedWaterHeater = DataHeatBalance::HeatReclaimRefrigCondenser(ICond).WaterHeatingDesuperheaterReclaimedHeatTotal;
                        }
                    }
                } // if first time
            }     //(.NOT. UseSysTimeStep)

        } // warm up flag

        if (DataGlobals::AnyEnergyManagementSystemInModel) {
            if (DataHeatBalance::NumRefrigSystems > 0) {
                for (int systemID = 1; systemID <= DataHeatBalance::NumRefrigSystems; ++systemID) {
                    if (System(systemID).EMSOverrideOnTCondenseMin) {
                        System(systemID).TCondenseMin = System(systemID).EMSOverrideValueTCondenseMin;
                    } else {
                        System(systemID).TCondenseMin = System(systemID).TCondenseMinInput;
                    }
                }
            }
        }
    }

    void InitRefrigerationPlantConnections(BranchInputManagerData &dataBranchInputManager)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         B. Griffith
        //       DATE WRITTEN   Dec 2010
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // do inits that should only occur when component model routines
        // are entered from plant, for water cooled Condensers and Refrigeration Racks

        static std::string const RoutineName("InitRefrigerationPlantConnections");

        // initialize plant topology information, if applicable
        if (MyReferPlantScanFlag && allocated(DataPlant::PlantLoop)) {
            for (int RefCondLoop = 1; RefCondLoop <= DataHeatBalance::NumRefrigCondensers; ++RefCondLoop) {
                if (Condenser(RefCondLoop).CondenserType != DataHeatBalance::RefrigCondenserTypeWater) continue;

                bool errFlag = false;
                PlantUtilities::ScanPlantLoopsForObject(dataBranchInputManager,
                                                        Condenser(RefCondLoop).Name,
                                                        DataPlant::TypeOf_RefrigSystemWaterCondenser,
                                                        Condenser(RefCondLoop).PlantLoopNum,
                                                        Condenser(RefCondLoop).PlantLoopSideNum,
                                                        Condenser(RefCondLoop).PlantBranchNum,
                                                        Condenser(RefCondLoop).PlantCompNum,
                                                        errFlag,
                                                        _,
                                                        _,
                                                        _,
                                                        _,
                                                        _);
                if (errFlag) {
                    ShowFatalError("InitRefrigerationPlantConnections: Program terminated due to previous condition(s).");
                }

                Real64 rho = FluidProperties::GetDensityGlycol(DataPlant::PlantLoop(Condenser(RefCondLoop).PlantLoopNum).FluidName,
                                       20.0,
                                                               DataPlant::PlantLoop(Condenser(RefCondLoop).PlantLoopNum).FluidIndex,
                                       RoutineName);

                if (Condenser(RefCondLoop).FlowType == ConstantFlow) {
                    Condenser(RefCondLoop).MassFlowRateMax = Condenser(RefCondLoop).DesVolFlowRate * rho;
                } else if (Condenser(RefCondLoop).FlowType == VariableFlow) {
                    Condenser(RefCondLoop).MassFlowRateMax = Condenser(RefCondLoop).VolFlowRateMax * rho;
                }
            }

            for (int RefCompRackLoop = 1; RefCompRackLoop <= DataHeatBalance::NumRefrigeratedRacks; ++RefCompRackLoop) {
                if (RefrigRack(RefCompRackLoop).CondenserType != DataHeatBalance::RefrigCondenserTypeWater) continue;

                bool errFlag = false;
                PlantUtilities::ScanPlantLoopsForObject(dataBranchInputManager,
                                                        RefrigRack(RefCompRackLoop).Name,
                                                        DataPlant::TypeOf_RefrigerationWaterCoolRack,
                                                        RefrigRack(RefCompRackLoop).PlantLoopNum,
                                                        RefrigRack(RefCompRackLoop).PlantLoopSideNum,
                                                        RefrigRack(RefCompRackLoop).PlantBranchNum,
                                                        RefrigRack(RefCompRackLoop).PlantCompNum,
                                                        errFlag,
                                                        _,
                                                        _,
                                                        _,
                                                        _,
                                                        _);
                if (errFlag) {
                    ShowFatalError("InitRefrigerationPlantConnections: Program terminated due to previous condition(s).");
                }

                Real64 rho = FluidProperties::GetDensityGlycol(DataPlant::PlantLoop(RefrigRack(RefCompRackLoop).PlantLoopNum).FluidName,
                                       20.0,
                                                               DataPlant::PlantLoop(RefrigRack(RefCompRackLoop).PlantLoopNum).FluidIndex,
                                       RoutineName);

                if (RefrigRack(RefCompRackLoop).FlowType == ConstantFlow) {
                    RefrigRack(RefCompRackLoop).MassFlowRateMax = RefrigRack(RefCompRackLoop).DesVolFlowRate * rho;
                } else if (RefrigRack(RefCompRackLoop).FlowType == VariableFlow) {
                    RefrigRack(RefCompRackLoop).MassFlowRateMax = RefrigRack(RefCompRackLoop).VolFlowRateMax * rho;
                }
            }

            MyReferPlantScanFlag = false;
        } else if (MyReferPlantScanFlag && !DataGlobals::AnyPlantInModel) {
            MyReferPlantScanFlag = false;
        }

        if (DataGlobals::BeginEnvrnFlag && InitRefrigerationPlantConnectionsMyBeginEnvrnFlag) {

            // do plant inits, if applicable
            if (!MyReferPlantScanFlag) {
                for (int RefCondLoop = 1; RefCondLoop <= DataHeatBalance::NumRefrigCondensers; ++RefCondLoop) {
                    if (Condenser(RefCondLoop).CondenserType != DataHeatBalance::RefrigCondenserTypeWater) continue;

                    Real64 rho = FluidProperties::GetDensityGlycol(DataPlant::PlantLoop(Condenser(RefCondLoop).PlantLoopNum).FluidName,
                                           20.0,
                                                                   DataPlant::PlantLoop(Condenser(RefCondLoop).PlantLoopNum).FluidIndex,
                                           RoutineName);

                    if (Condenser(RefCondLoop).FlowType == ConstantFlow) {
                        Condenser(RefCondLoop).MassFlowRateMax = Condenser(RefCondLoop).DesVolFlowRate * rho;
                    } else if (Condenser(RefCondLoop).FlowType == VariableFlow) {
                        Condenser(RefCondLoop).MassFlowRateMax = Condenser(RefCondLoop).VolFlowRateMax * rho;
                    }

                    PlantUtilities::InitComponentNodes(0.0,
                                       Condenser(RefCondLoop).MassFlowRateMax,
                                       Condenser(RefCondLoop).InletNode,
                                       Condenser(RefCondLoop).OutletNode,
                                       Condenser(RefCondLoop).PlantLoopNum,
                                       Condenser(RefCondLoop).PlantLoopSideNum,
                                       Condenser(RefCondLoop).PlantBranchNum,
                                       Condenser(RefCondLoop).PlantCompNum);
                }
                for (int RefCompRackLoop = 1; RefCompRackLoop <= DataHeatBalance::NumRefrigeratedRacks; ++RefCompRackLoop) {
                    if (RefrigRack(RefCompRackLoop).CondenserType != DataHeatBalance::RefrigCondenserTypeWater) continue;

                    Real64 rho = FluidProperties::GetDensityGlycol(DataPlant::PlantLoop(RefrigRack(RefCompRackLoop).PlantLoopNum).FluidName,
                                           20.0,
                                                                   DataPlant::PlantLoop(RefrigRack(RefCompRackLoop).PlantLoopNum).FluidIndex,
                                           RoutineName);

                    if (RefrigRack(RefCompRackLoop).FlowType == ConstantFlow) {
                        RefrigRack(RefCompRackLoop).MassFlowRateMax = RefrigRack(RefCompRackLoop).DesVolFlowRate * rho;
                    } else if (RefrigRack(RefCompRackLoop).FlowType == VariableFlow) {
                        RefrigRack(RefCompRackLoop).MassFlowRateMax = RefrigRack(RefCompRackLoop).VolFlowRateMax * rho;
                    }

                    PlantUtilities::InitComponentNodes(0.0,
                                       RefrigRack(RefCompRackLoop).MassFlowRateMax,
                                       RefrigRack(RefCompRackLoop).InletNode,
                                       RefrigRack(RefCompRackLoop).OutletNode,
                                       RefrigRack(RefCompRackLoop).PlantLoopNum,
                                       RefrigRack(RefCompRackLoop).PlantLoopSideNum,
                                       RefrigRack(RefCompRackLoop).PlantBranchNum,
                                       RefrigRack(RefCompRackLoop).PlantCompNum);
                }
            }
            InitRefrigerationPlantConnectionsMyBeginEnvrnFlag = false;

        } //(DataGlobals::BeginEnvrnFlag .AND. MyBeginEnvrnFlag)

        if (!DataGlobals::BeginEnvrnFlag) InitRefrigerationPlantConnectionsMyBeginEnvrnFlag = true;
    }

    void RefrigRackData::CalcRackSystem()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   Oct/Nov 2004
        //       MODIFIED       Shirey, FSEC Dec 2004; Hudson, ORNL Feb 2007, July 2007
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Calculate compressor rack load, power, energy consumption, and condenser fan/pump power and consumption

        // METHODOLOGY EMPLOYED:
        // Loop through cases attached to each rack and determine total load on compressor rack

        // REFERENCES:
        // "Impact of ASHRAE Standard 62-1989 on Florida Supermarkets",
        //  Florida Solar Energy Center, FSEC-CR-910-96, Final Report, Oct. 1996

        Real64 COPFTempOutput;            // Curve value for COPFTemp curve object
        Real64 CondenserFrac;             // Fraction of condenser power as a function of outdoor temperature
        Real64 TotalHeatRejectedToZone;   // Total compressor and condenser fan heat rejected to zone (based on CaseRAFactor)
        int HeatRejectZoneNum;            // Index to zone where heat is rejected
        int HeatRejectZoneNodeNum;        // Index to zone where heat is rejected
        Real64 OutWbTemp;                 // Outdoor wet bulb temp at condenser air inlet node [C]
        Real64 OutDbTemp;                 // Outdoor dry bulb temp at condenser air inlet node [C]
        Real64 EffectTemp;                // Effective outdoor temp when using evap condenser cooling [C]
        Real64 HumRatIn;                  // Humidity ratio of inlet air to condenser [kg/kg]
        Real64 HumRatOut;                 // Humidity ratio of outlet air from condenser (assumed saturated) [kg/kg]
        Real64 BPress;                    // Barometric pressure at condenser air inlet node [Pa]
        bool EvapAvail;                   // Control for evap condenser availability

        TotalRackDeliveredCapacity = 0.0;
        CompressorCOPactual = 0.0;
        TotalCompressorPower = 0.0;
        TotalCondenserFanPower = 0.0;
        TotalCondenserPumpPower = 0.0;
        TotalBasinHeatPower = 0.0;
        TotalCondenserHeat = 0.0;
        TotalHeatRejectedToZone = 0.0;
        TotalEvapWaterUseRate = 0.0;
        RackSenCreditToZone = 0.0;
        RackSenCreditToHVAC = 0.0;
        CondenserFrac = 0.0;
        EvapAvail = true;
        HeatRejectZoneNum = 0;
        HeatRejectZoneNodeNum = 0;

        // Loads for chiller sets are set in call to zone equipment element "SimAirChillerSet"
        // (all chiller coils within a set are located in the same zone)
        // (note non-zone, such as refrigeration, and zone equip, such as airchillersets, called at diff times)
        // Loads are then defined for each chiller coil within the set in "CalculateAirChillerSet"
        // In that subroutine, dispatch coils within each set in order specified for each zone
        //  Below will assign loads to refrigeration system or secondary loop
        // Note that this routine will go through all refrigeration systems, but loads for multiple systems
        // with interactions will not be known for the intital calls with first HVAC time step. They will,
        // however, be repeated when the last chiller set is called from ZoneEquipmentManager
        // that's why important where init goes, don't want to zero out data should keep
        if (UseSysTimeStep) {
            for (int CoilSetIndex = 1; CoilSetIndex <= DataHeatBalance::NumRefrigChillerSets; ++CoilSetIndex) {
                AirChillerSet(CoilSetIndex).CalculateAirChillerSets();
            }
        }

        if (this->NumCoils > 0) {
            for (int CoilIndex = 1; CoilIndex <= this->NumCoils; ++CoilIndex) {
                int CoilID = this->CoilNum(CoilIndex);
                // already CALLed CalculateCoil(CoilID) in CoilSet specified order
                // increment TotalCoolingLoad for Compressors/condenser on each system
                TotalRackDeliveredCapacity += WarehouseCoil(CoilID).TotalCoolingLoad;
                //      System(SysNum)%TotalCondDefrostCredit=System(SysNum)%TotalCondDefrostCredit + WarehouseCoil(CoilID)%HotDefrostCondCredit
            } // NumCoils systems
        }     // System(SysNum)%NumCoils > 0

        if (this->NumCases > 0) {
            for (int caseNum = 1; caseNum <= this->NumCases; ++caseNum) {
                int CaseID = this->CaseNum(caseNum);
                RefrigCase(CaseID).CalculateCase();

                //   add evaporator load for all cases connected to rack
                TotalRackDeliveredCapacity += RefrigCase(CaseID).TotalCoolingLoad;

                //   sensible and latent case credits already calculated in "CalculateCase"
                //   Now need to calculate amount of condenser heat rejection that should be applied to zone
                //                                     (used when HeatRejectionLocation = LocationZone)
                //   if walk-ins are served by rack, user must specify heat rejection zone and 100% of heat
                //   rejection goes to that zone - that is, no heat rejection goes to the HVAC return air
                if (this->HeatRejectionLocation == LocationZone) {
                    if (this->NumWalkIns == 0) {
                        TotalHeatRejectedToZone += RefrigCase(CaseID).TotalCoolingLoad * (1.0 - CaseRAFactor);
                        //  CaseRAFactor is a module variable calculated in CalculateCase
                        //   find zone number of first case on rack (all cases are in the same zone
                        //  if HeatRejectionLocation = LocationZone and no walk-ins)
                        HeatRejectZoneNum = RefrigCase(this->CaseNum(1)).ActualZoneNum;
                        HeatRejectZoneNodeNum = RefrigCase(this->CaseNum(1)).ZoneNodeNum;
                    } else { // have walk ins so no reduction in condenser heat rejection for caseRA factor
                        TotalHeatRejectedToZone += RefrigCase(CaseID).TotalCoolingLoad;
                    } // no walk ins
                }
            } // NumCases
        }     // Numcases on rack > 0

        if (this->NumWalkIns > 0) {
            for (int WalkInIndex = 1; WalkInIndex <= this->NumWalkIns; ++WalkInIndex) {
                int WalkInID = this->WalkInNum(WalkInIndex);
                WalkIn(WalkInID).CalculateWalkIn();
                TotalRackDeliveredCapacity += WalkIn(WalkInID).TotalCoolingLoad;
                if (this->HeatRejectionLocation == LocationZone) {
                    TotalHeatRejectedToZone += WalkIn(WalkInID).TotalCoolingLoad;
                    HeatRejectZoneNum = this->HeatRejectionZoneNum;
                    HeatRejectZoneNodeNum = this->HeatRejectionZoneNodeNum;
                } // reject heat to zone
            }     // WalkInIndex
        }         // NumWalkIns>0

        if (this->HeatRejectionLocation == LocationZone) {
            COPFTempOutput = CurveManager::CurveValue(this->COPFTempPtr, DataLoopNode::Node(HeatRejectZoneNodeNum).Temp);
            EvapAvail = false;
        } else {
            if (this->OutsideAirNodeNum != 0) {
                OutDbTemp = DataLoopNode::Node(this->OutsideAirNodeNum).Temp;
                BPress = DataLoopNode::Node(this->OutsideAirNodeNum).Press;
            } else {
                OutDbTemp = DataEnvironment::OutDryBulbTemp;
                BPress = DataEnvironment::OutBaroPress;
            }
            EffectTemp = OutDbTemp;

            // IF schedule exists, evap condenser can be scheduled OFF
            // Check schedule to determine evap condenser availability
            if (this->EvapSchedPtr > 0 && ScheduleManager::GetCurrentScheduleValue(this->EvapSchedPtr) == 0) EvapAvail = false;

            // Evaporative condensers will have their water flow shut off in cold months to avoid
            //  'spectacular' icing problems.  Ideally, the user will use the evaporative schedule input
            //  to set such a schedule.  However, sometimes, users will use a single input deck to model
            //  one building in multiple climates, and may not think to put in such a schedule in the colder
            //  climates.  To accommodate such applications, the variable EvapCutOutTdb is used as an extra
            //  check.
            if (OutDbTemp < EvapCutOutTdb) EvapAvail = false;

            if (this->CondenserType == DataHeatBalance::RefrigCondenserTypeEvap && EvapAvail) {
                // determine temps for evap cooling
                if (this->OutsideAirNodeNum != 0) {
                    HumRatIn = DataLoopNode::Node(this->OutsideAirNodeNum).HumRat;
                } else {
                    HumRatIn = DataEnvironment::OutHumRat;
                } // outsideairnode
                OutWbTemp = Psychrometrics::PsyTwbFnTdbWPb(OutDbTemp, HumRatIn, BPress);
                EffectTemp = OutWbTemp + (1.0 - this->EvapEffect) * (OutDbTemp - OutWbTemp);
            } // evapAvail

            // Obtain water-cooled condenser inlet/outlet temps
            if (this->CondenserType == DataHeatBalance::RefrigCondenserTypeWater) {
                this->InletTemp = DataLoopNode::Node(this->InletNode).Temp;
                EffectTemp = DataLoopNode::Node(this->InletNode).Temp + 5.0; // includes approach temp
                if (this->InletTemp < this->InletTempMin) {
                    if (this->LowTempWarnIndex == 0) {
                        ShowWarningMessage("Refrigeration:CompressorRack: " + this->Name);
                        ShowContinueError("Water-cooled condenser inlet temp lower than minimum allowed temp. Check returning water temperature "
                                          "and/or minimum temperature setpoints.");
                    } // LowTempWarnIndex
                    ShowRecurringWarningErrorAtEnd("Refrigeration Compressor Rack " + this->Name +
                                                       " - Condenser inlet temp lower than minimum allowed ... continues",
                                                   this->LowTempWarnIndex);
                    // END IF  !LowTempWarn
                } // InletTempMin
            }     // DataHeatBalance::RefrigCondenserTypeWater

            COPFTempOutput = CurveManager::CurveValue(this->COPFTempPtr, EffectTemp);
        } // Location Zone

        CompressorCOPactual = this->RatedCOP * COPFTempOutput;

        if (CompressorCOPactual > 0.0) {
            TotalCompressorPower = TotalRackDeliveredCapacity / CompressorCOPactual;
            TotalCondenserHeat = TotalCompressorPower + TotalRackDeliveredCapacity;
        } else {
            if (this->ShowCOPWarning) {
                ShowWarningError("Refrigeration:CompressorRack: " + this->Name);
                ShowContinueError(" The calculated COP has a value of zero or is negative. Refer to Engineering Documentation for");
                ShowContinueError(" further explanation of Compressor Rack COP as a Function of Temperature Curve.");
                this->ShowCOPWarning = false;
            }
        }

        // calculate condenser fan usage here if not water-cooled; if water-cooled, fan is in separate tower object
        // fan loads > 0 only if the connected cases are operating
        if (TotalRackDeliveredCapacity > 0.0 && this->CondenserType != DataHeatBalance::RefrigCondenserTypeWater) {
            if (this->TotCondFTempPtr != 0) {
                if (this->HeatRejectionLocation == LocationZone) {
                    CondenserFrac =
                        max(0.0, min(1.0, CurveManager::CurveValue(this->TotCondFTempPtr, DataLoopNode::Node(HeatRejectZoneNodeNum).Temp)));
                    TotalCondenserFanPower = this->CondenserFanPower * CondenserFrac;
                    DataHeatBalance::RefrigCaseCredit(HeatRejectZoneNum).SenCaseCreditToZone += this->CondenserFanPower * CondenserFrac;
                } else {
                    CondenserFrac = max(0.0, min(1.0, CurveManager::CurveValue(this->TotCondFTempPtr, EffectTemp)));
                    TotalCondenserFanPower = this->CondenserFanPower * CondenserFrac;
                } // location zone
            } else {
                CondenserFrac = 1.0;
                TotalCondenserFanPower = this->CondenserFanPower * CondenserFrac;
            } // TotCondFTempPtr
        }     // Cooling Water type

        // calculate evap water use and water pump power, if applicable
        // assumes pump runs whenever evap cooling is available to minimize scaling
        if (this->CondenserType == DataHeatBalance::RefrigCondenserTypeEvap && EvapAvail) {
            TotalCondenserPumpPower = this->EvapPumpPower;
            HumRatOut = Psychrometrics::PsyWFnTdbTwbPb(EffectTemp, OutWbTemp, BPress);
            TotalEvapWaterUseRate = this->CondenserAirFlowRate * CondenserFrac * Psychrometrics::PsyRhoAirFnPbTdbW(BPress, OutDbTemp, HumRatIn) *
                                    (HumRatOut - HumRatIn) / Psychrometrics::RhoH2O(EffectTemp);
        } // evapAvail
        // calculate basin water heater load
        if (this->CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) {
            if ((TotalRackDeliveredCapacity == 0.0) && (EvapAvail) && (OutDbTemp < this->BasinHeaterSetPointTemp)) {
                TotalBasinHeatPower = max(0.0, this->BasinHeaterPowerFTempDiff * (this->BasinHeaterSetPointTemp - OutDbTemp));
                // provide warning if no heater power exists
                if (TotalBasinHeatPower == 0.0) {
                    if (this->EvapFreezeWarnIndex == 0) {
                        ShowWarningMessage("Refrigeration Compressor Rack " + this->Name +
                                           " - Evap cooling of condenser underway with no basin heater power");
                        ShowContinueError("and condenser inlet air dry-bulb temp at or below the basin heater setpoint temperature.");
                        ShowContinueErrorTimeStamp("Continuing simulation.");
                    } // EvapFreezeWarnIndex == 0
                    ShowRecurringWarningErrorAtEnd("Refrigeration Compressor Rack " + this->Name +
                                                       " - Evap cooling of condenser underway with no basin heater power ... continues",
                                                   this->EvapFreezeWarnIndex);
                    // END IF
                } // TotalBasinHeatPower == 0 when at outdoor freezing conditions
            }     // cap
        }         // evap condenser type

        // add in compressor and condenser fan power to rack heat rejection variables if the heat rejection location is to the zone
        //   if walk-ins are served by rack, user must specify heat rejection zone and 100% of heat
        //   rejection goes to that zone - that is, no condenser heat rejection goes to the HVAC return air
        if (this->HeatRejectionLocation == LocationZone) {
            TotalCondenserHeat = TotalRackDeliveredCapacity + TotalCompressorPower + TotalCondenserFanPower;
            if (HeatRejectZoneNum > 0 && TotalRackDeliveredCapacity > 0.0) {
                if (this->NumWalkIns == 0) {
                    //       rack report variables for condenser heat to Zone and/or HVAC
                    //       The difference between TotalHeatRejectedToZone and TotalRackDeliveredCapacity is the heat sent to return air
                    RackSenCreditToZone = TotalCondenserHeat * (TotalHeatRejectedToZone / TotalRackDeliveredCapacity);
                    RackSenCreditToHVAC = TotalCondenserHeat - RackSenCreditToZone;
                } else { // walkins present and no rack heat rejection goes to return air
                    RackSenCreditToZone = TotalCondenserHeat;
                    RackSenCreditToHVAC = 0.0;
                } // walkins present
                //     Update globals for use in Air Heat Balance and Zone Equipment Manager
                DataHeatBalance::RefrigCaseCredit(HeatRejectZoneNum).SenCaseCreditToZone += RackSenCreditToZone;

                DataHeatBalance::RefrigCaseCredit(HeatRejectZoneNum).SenCaseCreditToHVAC += RackSenCreditToHVAC;
            } // zone # > 0 and tot del cap > 0
        }     // rack heat rejection to zone
    }

    void RefrigRackData::ReportRackSystem(int const RackNum)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   Oct/Nov 2004
        //       MODIFIED       Hudson, ORNL Feb 2007, July 2007
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // To report compressor rack variables

        Real64 LocalTimeStep = DataGlobals::TimeStepZone;
        if (UseSysTimeStep) LocalTimeStep = DataHVACGlobals::TimeStepSys;

        this->RackCompressorPower = TotalCompressorPower;
        this->RackElecConsumption = TotalCompressorPower * LocalTimeStep * DataGlobals::SecInHour;
        this->ActualCondenserFanPower = TotalCondenserFanPower;
        this->CondenserFanConsumption = TotalCondenserFanPower * LocalTimeStep * DataGlobals::SecInHour;
        this->RackCapacity = TotalRackDeliveredCapacity;
        this->RackCoolingEnergy = TotalRackDeliveredCapacity * LocalTimeStep * DataGlobals::SecInHour;
        this->RackCompressorCOP = CompressorCOPactual;
        this->SensHVACCreditHeatRate = RackSenCreditToHVAC;
        this->SensHVACCreditHeat = RackSenCreditToHVAC * LocalTimeStep * DataGlobals::SecInHour;
        this->SensZoneCreditHeatRate = RackSenCreditToZone;
        this->SensZoneCreditHeat = RackSenCreditToZone * LocalTimeStep * DataGlobals::SecInHour;
        this->EvapWaterConsumpRate = TotalEvapWaterUseRate;
        this->EvapWaterConsumption = TotalEvapWaterUseRate * LocalTimeStep * DataGlobals::SecInHour;
        this->ActualEvapPumpPower = TotalCondenserPumpPower;
        this->EvapPumpConsumption = TotalCondenserPumpPower * LocalTimeStep * DataGlobals::SecInHour;
        this->BasinHeaterPower = TotalBasinHeatPower;
        this->BasinHeaterConsumption = TotalBasinHeatPower * LocalTimeStep * DataGlobals::SecInHour;
        this->CondLoad = TotalCondenserHeat;
        this->CondEnergy = TotalCondenserHeat * LocalTimeStep * DataGlobals::SecInHour;
        // Set total rack heat rejection used for heat reclaim. Do not allow heat reclaim on stand alone (indoor) display cases.
        if (this->HeatRejectionLocation == LocationZone) {
            DataHeatBalance::HeatReclaimRefrigeratedRack(RackNum).AvailCapacity = 0.0;
        } else {
            DataHeatBalance::HeatReclaimRefrigeratedRack(RackNum).AvailCapacity = TotalRackDeliveredCapacity * (1.0 + 1.0 / CompressorCOPactual);
        }

        // set water system demand request (if needed)
        if (this->EvapWaterSupplyMode == WaterSupplyFromTank) {
            int DemandARRID = this->EvapWaterTankDemandARRID;
            int RackTankID = this->EvapWaterSupTankID;
            DataWater::WaterStorage(RackTankID).VdotRequestDemand(DemandARRID) = this->EvapWaterConsumpRate;
        }

        SumZoneImpacts();
    }

    void RefrigCaseData::CalculateCase() // Absolute pointer to refrigerated case
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad and Don Shirey, FSEC
        //       DATE WRITTEN   Oct/Nov 2004
        //       MODIFIED       Therese Stovall, ORNL, May 2008
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // To model refrigerated cases.

        // METHODOLOGY EMPLOYED:
        // Case performance is based on a latent component calculated using a user input curve object. The sensible
        // component is made up of all equipment loads (fan, light, anti-sweat) and the sensible case credit
        // calculated during initialization. A master schedule is used for the refrigerated case operation and
        // additional schedules control the lights and defrost operation.
        // The fan is assumed to be off for Hot-Gas and Electric defrost.

        // Unmet loads are accumulated to be met the following time step.  This usually occurs only during the
        // defrost period, so the case calls for full capacity at the end of defrost to make up for the sensible
        // case gains during the defrost period. This feature is also used if needed for restocking loads.

        // REFERENCES:

        // "Calculation of Humidity Effects on Energy Requirements of Refrigerated Display Cases",
        //  R. H. Howell, Ph. D., P.E., ASHRAE Paper, 3687 (CH-93-16-4) (RP-596)

        // "Effects of Store Relative Humidity on Refrigerated Display Case Performance",
        //  R. H. Howell, Ph. D., P.E., ASHRAE Paper, 3686 (CH-93-16-1) (RP-596)

        // "Analysis of Supermarket Dehumidification Alternatives",
        //  Electric Power Research Institute, EPRI TR-100352, Project 2891-03 Final Report, Nov. 1992.

        // "Impact of ASHRAE Standard 62-1989 on Florida Supermarkets",
        //  Florida Solar Energy Center, FSEC-CR-910-96, Final Report, Oct. 1996

        Real64 CaseCreditFraction(0.0);      // Reduction in case credits due to e.g., reduced door openings at night
        Real64 DefrostSchedule(0.0);         // Display case defrost schedule
        Real64 DefrostDripDownSchedule(0.0); // Display case drip-down schedule (allows coil to drain after defrost)
        Real64 DefrostRatio(0.0);            // ratio of defrost energy at current zone temp/humrat to defrost
        //    capacity at design condition
        Real64 LatentRatio(0.0); // ratio of latent capacity at current zone temp/humrat to
        //    latent capacity at design condition
        Real64 LatentCap_Actual(0.0);   // Refrigerated case latent capacity at specific operating conditions
        Real64 LatentCaseCredit(0.0);   // Latent case credit delivered to zone (W)
        Real64 SensibleCap_Actual(0.0); // Refrigerated case sensible capacity at specific operating conditions
        Real64 SensibleLoadPrime(0.0);  // Sensible load due to cond, conv, rad, infil (W)
        Real64 TotalCap_Actual(0.0);    // Refrigerated case total capacity at specific operating conditions
        Real64 TotalLightingLoad(0.0);  // Total lighting energy rate (W)
        Real64 TotalFan(0.0);           // Total fan energy rate (W)
        Real64 TotalAntiSweat(0.0);     // Total anti-sweat heater energy rate (W)

        // Refrigerated display case defrost type (parameters)
        // DefNone             = 0
        // DefOffCycle         = 1
        // DefHotFluid           = 2
        // DefHotFluidOnDemand   = 3 (not available)
        // DefHotFluidTerm       = 4
        // DefElectric         = 5
        // DefElectricOnDemand = 6 (not available)
        // DefElectricTerm     = 7

        CaseRAFactor = 0.0;

        // Zone relative humidity (%)
        Real64 ZoneRHPercent = Psychrometrics::PsyRhFnTdbWPb(DataLoopNode::Node(this->ZoneNodeNum).Temp,
                                                             DataLoopNode::Node(this->ZoneNodeNum).HumRat,
                                                             DataEnvironment::OutBaroPress) *
                               100.0;

        // Zone dew point (C)
        Real64 ZoneDewPoint = Psychrometrics::PsyTdpFnWPb(DataLoopNode::Node(this->ZoneNodeNum).HumRat, DataEnvironment::OutBaroPress);

        // Display case operating temperature
        Real64 TCase = this->Temperature;

        // GET ALL SCHEDULES (note all schedules can be fractions if on/off a portion of time step)
        // case schedule should be coincident with the zone time step otherwise the simulation proceeds

        // Current value of case operating (availability) schedule
        Real64 CaseSchedule = ScheduleManager::GetCurrentScheduleValue(this->SchedPtr);
        if (CaseSchedule <= 0) return;
        // get defrost schedule
        if (this->DefrostType > DefNone) {
            DefrostSchedule = ScheduleManager::GetCurrentScheduleValue(this->DefrostSchedPtr);
            DefrostDripDownSchedule = ScheduleManager::GetCurrentScheduleValue(this->DefrostDripDownSchedPtr);
            // next statement In case user doesn't understand concept of drip down schedule
            DefrostDripDownSchedule = max(DefrostDripDownSchedule, DefrostSchedule);
        } else {
            DefrostSchedule = 0.0;
            DefrostDripDownSchedule = 0.0;
        }

        Real64 StockingSchedule(0.0); // Current value of product stocking schedule (W/m)

        // get product stocking schedule and load due to product stocking, if no schedule exists load is 0
        if (this->StockingSchedPtr > 0) {
            StockingSchedule = ScheduleManager::GetCurrentScheduleValue(this->StockingSchedPtr);
        } else {
            StockingSchedule = 0.0;
        }
        // get lighting schedule and total load due to lighting
        Real64 LightingSchedule = ScheduleManager::GetCurrentScheduleValue(this->LightingSchedPtr);

        // if case credit reduction fraction schedule exists, modify both sensible and latent case credits
        // according to schedule - used to account for variable case envelope, such as night covers.
        if (this->CaseCreditFracSchedPtr != 0) {
            CaseCreditFraction = ScheduleManager::GetCurrentScheduleValue(this->CaseCreditFracSchedPtr);
        } else {
            CaseCreditFraction = 1.0;
        }

        // CALCULATE AUX LOADS DUE TO LIGHTS, FAN AND STOCKING
        TotalLightingLoad = this->DesignLighting * LightingSchedule;

        // Lighting energy to case
        Real64 TotalLightToCase = TotalLightingLoad * this->LightingFractionToCase;

        // Lighting energy to zone
        Real64 TotalLightToZone = TotalLightingLoad - TotalLightToCase;
        // cycle fan according to defrost schedule
        // turn fan on for none or off-cycle defrost types
        if (this->DefrostType == DefNone || this->DefrostType == DefOffCycle) {
            TotalFan = this->DesignFanPower;
        } else {
            TotalFan = this->DesignFanPower * (1.0 - DefrostDripDownSchedule);
        }
        // get  load due to product stocking
        // accumulate stocking loads for reporting to help evaluate any cumulative unmet loads problems
        // only accumulate energy during actual simulation (so same if DD's are switched)

        // Total load due to stocking case product (W)
        Real64 StockingLoad = StockingSchedule * this->Length;
        if (!DataGlobals::WarmupFlag) {
            Real64 DeltaStockingEnergy = (StockingLoad * DataGlobals::TimeStepZoneSec);
            this->StockingEnergy += DeltaStockingEnergy;
        } // warm up
        // CALCULTE ALL LOADS INFLUENCED BY ZONE TEMPERATURE AND RH
        // Anti-sweat heater capacity
        {
            auto const SELECT_CASE_var(this->AntiSweatControlType);
            if (SELECT_CASE_var == ASNone) {
                TotalAntiSweat = 0.0;
            } else if (SELECT_CASE_var == ASConstant) {
                TotalAntiSweat = this->AntiSweatPower;
            } else if (SELECT_CASE_var == ASLinear) {
                TotalAntiSweat = this->AntiSweatPower *
                                 min(1.0, max(0.0, 1.0 - (this->RatedAmbientRH - ZoneRHPercent) / (this->RatedAmbientRH - this->HumAtZeroAS)));
                TotalAntiSweat = max(this->MinimumASPower, TotalAntiSweat);
            } else if (SELECT_CASE_var == ASDewPoint) {
                TotalAntiSweat = this->AntiSweatPower * min(1.0, max(0.0, (ZoneDewPoint - TCase) / (this->RatedAmbientDewPoint - TCase)));
                TotalAntiSweat = max(this->MinimumASPower, TotalAntiSweat);
            } else if (SELECT_CASE_var == ASHeatBalance) {
                if (this->Rcase > 0.0) {
                    TotalAntiSweat = (((ZoneDewPoint - DataLoopNode::Node(this->ZoneNodeNum).Temp) * this->Height / Rair) +
                                      ((ZoneDewPoint - TCase) * this->Height / this->Rcase));
                    TotalAntiSweat = min(this->AntiSweatPower, max(this->MinimumASPower, TotalAntiSweat));
                } else {
                    TotalAntiSweat = 0.0;
                }
            } else {
                // should never execute this CASE statement
                TotalAntiSweat = 0.0;
            }
        }
        TotalAntiSweat *= this->Length;

        // Anti-sweat heater energy to case
        Real64 TotalASHeaterToCase = this->ASHeaterFractionToCase * TotalAntiSweat;

        // Anti-sweat heater energy to zone
        Real64 TotalASHeaterToZone = TotalAntiSweat - TotalASHeaterToCase;

        // latent capacity correction term at off-design conditions
        {
            auto const SELECT_CASE_var(this->LatentEnergyCurveType);
            if (SELECT_CASE_var == CaseTemperatureMethod) {
                Real64 LatCapModFrac = CurveManager::CurveValue(this->LatCapCurvePtr, TCase);
                LatentRatio = max(0.0, (1.0 - (this->RatedAmbientRH - ZoneRHPercent) * LatCapModFrac));
            } else if (SELECT_CASE_var == RHCubic) {
                LatentRatio = max(0.0, CurveManager::CurveValue(this->LatCapCurvePtr, ZoneRHPercent));
            } else if (SELECT_CASE_var == DPCubic) {
                LatentRatio = max(0.0, CurveManager::CurveValue(this->LatCapCurvePtr, ZoneDewPoint));
            }
        }

        // calculate latent case load (assumes no moisture load due to stocking)
        // assume sensible case credits continue to accumulate in case during defrost/dripdown,
        //    but latent credits/load and capacity only applied outside dripdownschedule

        // Latent load placed on case at actual zone conditions (W)
        Real64 LatentLoad = this->DesignLatentCap * LatentRatio * CaseCreditFraction * (1.0 - DefrostDripDownSchedule);
        LatentCaseCredit = -LatentLoad;
        // adjust sensible loads and case credit for actual zone temperature
        // If zone temp rises above rated ambient temperature, total load can exceed case design capacity,
        // so unmet cooling loads are accumulated to meet in the next time step. (Case credit fraction allows
        //  extra insulation, e.g. night covers, or imitating a better insulated walk-in cooler)

        // used to look at extra sensible load due to excursions in zone T
        Real64 ZoneTempFactor = (DataLoopNode::Node(ZoneNodeNum).Temp - TCase) / (this->RatedAmbientTemp - TCase);
        SensibleLoadPrime = this->DesignSensCaseCredit * ZoneTempFactor * CaseCreditFraction;

        // Sensible load due to heaters, lighting (W)
        Real64 SensibleLoadAux = TotalLightToCase + TotalASHeaterToCase + TotalFan + StockingLoad;

        // Total sensible load on case, may not = capacity applied (W)
        Real64 SensibleLoadTotal = SensibleLoadPrime + SensibleLoadAux;
        // include lighting and anti-sweat power not attributed to case load to sensible case credit

        // Sensible case credit delivered to zone (W)
        Real64 SensibleCaseCredit = TotalLightToZone + TotalASHeaterToZone - SensibleLoadPrime;

        // FROST:  keep track of frost build up on evaporator coil
        // avoid accumulation during warm-up to avoid reverse dd test problem
        if (!DataGlobals::WarmupFlag) {
            Real64 DeltaFreezeKgFrost = LatentLoad * DataGlobals::TimeStepZoneSec / IcetoVaporEnthalpy;
            this->KgFrost += DeltaFreezeKgFrost;
        }

        if (TCase > TempTooHotToFrost) this->KgFrost = 0.0;

        Real64 DefrostLoad_Actual(0.0); // heat load on case due to defrost (W)
        Real64 DefrostCap_Actual(0.0);  // power used to defrost (W)

        // DEFROST CALCULATIONS
        if (DefrostSchedule > 0.0) {
            if (this->DefrostType != DefNone && this->DefrostType != DefOffCycle) {
                DefrostCap_Actual = this->DesignDefrostCap * DefrostSchedule;
                if (this->DefrostType == DefElectricTerm || this->DefrostType == DefHotFluidTerm) {
                    // calculate correction term for temperature termination defrost control
                    {
                        auto const SELECT_CASE_var(this->DefrostEnergyCurveType);
                        if (SELECT_CASE_var == CaseTemperatureMethod) {
                            Real64 DefCapModFrac = CurveManager::CurveValue(this->DefCapCurvePtr, TCase);
                            DefrostRatio = max(0.0, (1.0 - (this->RatedAmbientRH - ZoneRHPercent) * DefCapModFrac));
                        } else if (SELECT_CASE_var == RHCubic) {
                            DefrostRatio = max(0.0, CurveManager::CurveValue(this->DefCapCurvePtr, ZoneRHPercent));
                        } else if (SELECT_CASE_var == DPCubic) {
                            DefrostRatio = max(0.0, CurveManager::CurveValue(this->DefCapCurvePtr, ZoneDewPoint));
                        } else if (SELECT_CASE_var == None) {
                            DefrostRatio = 1.0;
                        }
                    }
                    DefrostCap_Actual *= DefrostRatio;
                }

                // frost load at start of time step (kg of ice)
                Real64 StartFrostKg = this->KgFrost;

                // Energy form of defrost capacity (J)
                Real64 defrostEnergy = DefrostCap_Actual * DataGlobals::TimeStepZoneSec;

                // Frost melted by defrost during a time step (kg)
                Real64 FrostMeltedKg = min(defrostEnergy / IceMeltEnthalpy, StartFrostKg);
                this->KgFrost -= FrostMeltedKg;

                // Reduce defrost heat load on case by amount of ice melted during time step
                // However, don't reduce the defrost capacity applied

                DefrostLoad_Actual = DefrostCap_Actual - FrostMeltedKg * IceMeltEnthalpy / DataGlobals::TimeStepZone / DataGlobals::SecInHour;

                if (!DataGlobals::WarmupFlag) { // avoid reverse dd test problems
                    // keep running total of defrost energy above that needed to melt frost for use in evaluating
                    //      problems of excessive unmet loads
                    this->DeltaDefrostEnergy = max(0.0, (defrostEnergy - (FrostMeltedKg * IceMeltEnthalpy)));
                    this->DefrostEnergy += this->DeltaDefrostEnergy;
                }
                // If hot brine or hot gas is used for defrost, need to reduce condenser load
                // Note this condenser credit is not applied in compressor-rack systems.
                if (this->DefrostType != DefElectric && this->DefrostType != DefElectricOnDemand && this->DefrostType != DefElectricTerm)
                    this->HotDefrostCondCredit = DefrostCap_Actual * DefrostSchedule;
            } else { // no defrost or off-cycle defrost
                DefrostCap_Actual = 0.0;
                DefrostLoad_Actual = 0.0;
                this->KgFrost = 0.0;
                // Off-Cycle defrost is assumed to melt all the ice
            } // defrost type

        } else { // DefrostSchedule = 0, so no defrost load or capacity
            DefrostLoad_Actual = 0.0;
            DefrostCap_Actual = 0.0;
        } // Defrost calculations

        //*** See if capacity meets load and manage accumulated stored energy ***********************************
        // total load on case at zone conditions (W)
        Real64 TotalLoad_Actual = SensibleLoadTotal + LatentLoad + DefrostLoad_Actual;

        // Rate needed to serve all stored energy during single time step (W)
        Real64 StoredEnergyRate = this->StoredEnergy / DataGlobals::TimeStepZone / DataGlobals::SecInHour;
        Real64 LoadRequested = TotalLoad_Actual + StoredEnergyRate;

        // prorate available cooling capacity for portion of time off due to drip down.
        Real64 CapAvail = this->DesignRatedCap * (1.0 - DefrostDripDownSchedule);
        if (CapAvail >= LoadRequested) {
            // Have more at least as much capacity available as needed, even counting stored energy
            TotalCap_Actual = LoadRequested;
            SensibleCap_Actual = SensibleLoadTotal + StoredEnergyRate;
            LatentCap_Actual = LatentLoad;
            this->StoredEnergy = 0.0;
        } else {
            // Don't have as much capacity as needed (during dripdown or period following dripdown)
            TotalCap_Actual = CapAvail;
            LatentCap_Actual = min(LatentLoad, CapAvail); // Latent load should never be > capavail, but just in case...
            SensibleCap_Actual = TotalCap_Actual - LatentCap_Actual;
            if (!DataGlobals::WarmupFlag) this->StoredEnergy += (TotalLoad_Actual - CapAvail) * DataGlobals::TimeStepZoneSec;
        } // CapAvail vs Load requested

        // Reset DefrostLoad_Actual to zero for non-electric defrost types, for reporting purposes
        if (this->DefrostType != DefElectric && this->DefrostType != DefElectricOnDemand && this->DefrostType != DefElectricTerm)
            DefrostCap_Actual = 0.0;

        Real64 caseRAFraction = min(0.8, this->RAFrac);
        CaseRAFactor = (1.0 - ((0.8 - caseRAFraction) / 0.8)) * 0.5;

        // Update globals for use in ZoneTemperaturePredictorCorrector (Air Heat Balance) and
        //   Zone Equipment Manager. Sum case credits to zone and case credits to HVAC

        //** this needs a moisture variable NonAirSystemMoistureResponse (equivalent of NonAirSystemResponse) to properly
        //** allocate moisture to the zone when the HVAC system is off.

        // Amount of sensible case credit applied to zone load (W)
        Real64 CaseSenCreditToZone = SensibleCaseCredit * (1.0 - CaseRAFactor);

        // Amount of latent case credit applied to zone load (W)
        Real64 CaseLatCreditToZone = LatentCaseCredit * (1.0 - CaseRAFactor);

        // Amount of sensible case credit applied to HVAC RA duct (W)
        Real64 CaseSenCreditToHVAC = SensibleCaseCredit * CaseRAFactor;

        // Amount of latent case credit applied to HVAC RA duct (W)
        Real64 CaseLatCreditToHVAC = LatentCaseCredit * CaseRAFactor;

        DataHeatBalance::RefrigCaseCredit(this->ActualZoneNum).SenCaseCreditToZone += CaseSenCreditToZone;
        DataHeatBalance::RefrigCaseCredit(this->ActualZoneNum).LatCaseCreditToZone += CaseLatCreditToZone;
        DataHeatBalance::RefrigCaseCredit(this->ActualZoneNum).SenCaseCreditToHVAC += CaseSenCreditToHVAC;
        DataHeatBalance::RefrigCaseCredit(this->ActualZoneNum).LatCaseCreditToHVAC += CaseLatCreditToHVAC;

        // ReportRefrigeratedCase(CaseID)
        this->TotalCoolingLoad = TotalCap_Actual;
        this->TotalCoolingEnergy = TotalCap_Actual * DataGlobals::TimeStepZoneSec;
        this->SensCoolingEnergyRate = SensibleCap_Actual;
        this->SensCoolingEnergy = SensibleCap_Actual * DataGlobals::TimeStepZoneSec;
        this->LatCoolingEnergyRate = LatentCap_Actual;
        this->LatCoolingEnergy = LatentCap_Actual * DataGlobals::TimeStepZoneSec;

        this->SensZoneCreditRate = CaseSenCreditToZone; // both positive or negative
        // This rate can be positive or negative, split into separate output variables and always report positive value
        if (CaseSenCreditToZone <= 0.0) {
            this->SensZoneCreditCoolRate = -CaseSenCreditToZone;
            this->SensZoneCreditCool = -CaseSenCreditToZone * DataGlobals::TimeStepZoneSec;
            this->SensZoneCreditHeatRate = 0.0;
            this->SensZoneCreditHeat = 0.0;
        } else {
            this->SensZoneCreditHeatRate = CaseSenCreditToZone;
            this->SensZoneCreditHeat = CaseSenCreditToZone * DataGlobals::TimeStepZoneSec;
            this->SensZoneCreditCoolRate = 0.0;
            this->SensZoneCreditCool = 0.0;
        }

        // This rate should always be negative
        this->LatZoneCreditRate = CaseLatCreditToZone;
        this->LatZoneCredit = CaseLatCreditToZone * DataGlobals::TimeStepZoneSec;

        this->SensHVACCreditRate = CaseSenCreditToHVAC;
        // This rate can be positive or negative, split into separate output variables and always report positive value
        if (CaseSenCreditToHVAC <= 0.0) {
            this->SensHVACCreditCoolRate = -CaseSenCreditToHVAC;
            this->SensHVACCreditCool = -CaseSenCreditToHVAC * DataGlobals::TimeStepZoneSec;
            this->SensHVACCreditHeatRate = 0.0;
            this->SensHVACCreditHeat = 0.0;
        } else {
            this->SensHVACCreditHeatRate = CaseSenCreditToHVAC;
            this->SensHVACCreditHeat = CaseSenCreditToHVAC * DataGlobals::TimeStepZoneSec;
            this->SensHVACCreditCoolRate = 0.0;
            this->SensHVACCreditCool = 0.0;
        }

        // This rate should always be negative
        this->LatHVACCreditRate = CaseLatCreditToHVAC;
        this->LatHVACCredit = CaseLatCreditToHVAC * DataGlobals::TimeStepZoneSec;

        this->ElecFanPower = TotalFan;
        this->ElecFanConsumption = TotalFan * DataGlobals::TimeStepZoneSec;
        this->ElecAntiSweatPower = TotalAntiSweat;
        this->ElecAntiSweatConsumption = TotalAntiSweat * DataGlobals::TimeStepZoneSec;
        this->ElecLightingPower = TotalLightingLoad;
        this->ElecLightingConsumption = TotalLightingLoad * DataGlobals::TimeStepZoneSec;
        this->ElecDefrostPower = DefrostCap_Actual;
        this->ElecDefrostConsumption = DefrostCap_Actual * DataGlobals::TimeStepZoneSec;

        this->DefEnergyCurveValue = DefrostRatio;
        this->LatEnergyCurveValue = LatentRatio;

        //**************************************************************************************************
        // Cap Energy and Kg Frost to avoid floating overflow errors
        // 1-time warning is issued. It should be rare but could happen with unrealistic inputs.

        // Collect extra sensible load above design for possible warning if that is determining factor in
        // excessively large stored energy
        if ((ZoneTempFactor * CaseCreditFraction) > 1.0) {
            if (!DataGlobals::WarmupFlag) {
                Real64 DeltaWarmEnvEnergy = (SensibleLoadPrime - this->DesignSensCaseCredit) * DataGlobals::TimeStepZoneSec;
                this->WarmEnvEnergy += DeltaWarmEnvEnergy;
            }
        }

        if (this->DefrostEnergy > MyLargeNumber) this->DefrostEnergy = MyLargeNumber;
        if (this->WarmEnvEnergy > MyLargeNumber) this->WarmEnvEnergy = MyLargeNumber;
        if (this->StockingEnergy > MyLargeNumber) this->StockingEnergy = MyLargeNumber;
        if (this->StoredEnergy > MyLargeNumber) {
            this->StoredEnergy = MyLargeNumber;
            if (this->ShowStoreEnergyWarning) {
                ShowWarningError("Refrigeration:Case: " + this->Name);
                if (this->StockingEnergy >= this->DefrostEnergy) {
                    if (this->StockingEnergy >= this->WarmEnvEnergy) {
                        ShowContinueError(" This case has insufficient capacity to meet excess energy associated with stocking.");
                        ShowContinueError(" Refer to documentation for further explanation of product stocking requirements and");
                        ShowContinueError(" Total Cooling Capacity.");
                    } else {
                        ShowContinueError(" This case has insufficient capacity to meet excess energy associated with a zone enviroment temperature "
                                          "greater than the design ambient for the case.");
                        ShowContinueError(" Refer to documentation for further explanation of ");
                        ShowContinueError(" Total Cooling Capacity.");
                    } // Stocking energy > warm environment energy
                } else {
                    if (this->DefrostEnergy >= this->WarmEnvEnergy) {
                        ShowContinueError(" This case has insufficient capacity to meet excess energy associated with defrost.");
                        ShowContinueError(" Refer to documentation for further explanation of defrost control requirements and");
                        ShowContinueError(" recommendations regarding Total Cooling Capacity, Sensible Heat Ratio, and Defrost Capacity.");
                    } else {
                        ShowContinueError(" This case has insufficient capacity to meet excess energy associated with a zone enviroment temperature "
                                          "greater than the design ambient for the case.");
                        ShowContinueError(" Refer to documentation for further explanation of ");
                        ShowContinueError(" Total Cooling Capacity.");
                    }                                   // defrost energy > warm environment energy
                }                                       // stock > defrost ELSE
                this->ShowStoreEnergyWarning = false; // only give this warning once for any one case
            }                                           // showstoreenergy warning true
        }                                               // stored energy > large number

        if (this->KgFrost > MyLargeNumber) {
            this->KgFrost = MyLargeNumber;
            if (this->ShowFrostWarning) {
                ShowWarningError("Refrigeration:Case: " + this->Name);
                ShowContinueError(" This case has insufficient defrost capacity to remove the excess frost accumulation.");
                ShowContinueError(" Refer to documentation for further explanation of product stocking requirements and");
                ShowContinueError(" recommendations regarding Total Cooling Capacity, Sensible Heat Ratio, and Latent Heat Ratio.");
                this->ShowFrostWarning = false;
            }
        }
    }

    PlantComponent *RefrigCondenserData::factory(EnergyPlusData &state, std::string const &objectName)
    {
        // Process the input data for boilers if it hasn't been done already
        if (GetRefrigerationInputFlag) {
            CheckRefrigerationInput(state);
            GetRefrigerationInputFlag = false;
        }
        // Now look for this particular object in list
        for (auto &obj : Condenser) {
            if (obj.Name == objectName) {
                return &obj;
            }
        }
        // If we didn't find it, fatal
        ShowFatalError("LocalRefrigCondenserFactory: Error getting inputs for object named: " + objectName); // LCOV_EXCL_LINE
        // Shut up the compiler
        return nullptr; // LCOV_EXCL_LINE
    }

    void RefrigCondenserData::onInitLoopEquip(EnergyPlusData &state, const PlantLocation &EP_UNUSED(calledFromLocation))
    {
        InitRefrigeration();
        InitRefrigerationPlantConnections(state.dataBranchInputManager);
    }

    void RefrigCondenserData::simulate(EnergyPlusData &state, const PlantLocation &EP_UNUSED(calledFromLocation),
                                       bool const FirstHVACIteration,
                                       Real64 &EP_UNUSED(CurLoad),
                                       bool const EP_UNUSED(RunFlag))
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Randy Hudson, ORNL
        //       DATE WRITTEN   July 2007
        //       MODIFIED       Therese Stovall, ORNL May 2008
        //                      Brent Griffith, NREL Oct 2010, generalize fluid properties
        //                        plant upgrades, moved where called from to SimPlantEquip from ManageNonZoneEquipment
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Simulates the water-cooled refrigeration condenser object.
        // Modified to add condensers for detailed refrigeration systems and to
        // avoid double-counting heat rejection that has been used in desuperheater
        // hvac coils or water heaters.

        // METHODOLOGY EMPLOYED:
        // Called from SimPlantEquip in PlantLoopEquipment , previously was called from Non-Zone Equipment Manager
        // Flow is requested and the actual available flow is set.  The outlet temperature is calculated.

        static std::string const RoutineName("SimRefrigCondenser");
        int PlantInletNode(0);
        int PlantOutletNode(0);
        int PlantLoopIndex(0);
        int PlantLoopSideIndex(0);
        int PlantBranchIndex(0);
        int PlantCompIndex(0);

        InitRefrigerationPlantConnections(state.dataBranchInputManager);

        std::string TypeName;
        std::string ErrIntro;

        // set variables depending upon system type
        PlantInletNode = this->InletNode;
        PlantOutletNode = this->OutletNode;
        PlantLoopIndex = this->PlantLoopNum;
        PlantLoopSideIndex = this->PlantLoopSideNum;
        PlantBranchIndex = this->PlantBranchNum;
        PlantCompIndex = this->PlantCompNum;

        TotalCondenserHeat = this->CondLoad;
        TypeName = "Refrigeration:Condenser:WaterCooled";
        ErrIntro = "Condenser for refrigeration system ";

        // Current condenser is water cooled
        // Make demand request on first HVAC iteration

        // get cooling fluid properties
        Real64 rho = FluidProperties::GetDensityGlycol(
            DataPlant::PlantLoop(PlantLoopIndex).FluidName, this->InletTemp, DataPlant::PlantLoop(PlantLoopIndex).FluidIndex, RoutineName);
        Real64 Cp = FluidProperties::GetSpecificHeatGlycol(
            DataPlant::PlantLoop(PlantLoopIndex).FluidName, this->InletTemp, DataPlant::PlantLoop(PlantLoopIndex).FluidIndex, RoutineName);

        if (this->FlowType == VariableFlow && TotalCondenserHeat > 0.0) {

            this->OutletTemp = ScheduleManager::GetCurrentScheduleValue(this->OutletTempSchedPtr);

            if (this->OutletTemp == this->InletTemp) {

                if (this->HighInletWarnIndex == 0) {
                    ShowSevereError(ErrIntro + ", \"" + this->Name +
                                    "\" : has inlet water temp equal to desired outlet temp. Excessive flow resulting. ");
                    ShowContinueError("cooling water is not cold enough to reach desired outlet temperature");
                }
                ShowRecurringWarningErrorAtEnd(ErrIntro + ", \"" + this->Name +
                                                   "\" : has inlet water temp equal to desired outlet temp.... continues. ",
                                               this->HighInletWarnIndex);
                this->VolFlowRate = 9999.0;
                this->MassFlowRate = this->VolFlowRate * rho;
                } else {
                Real64 DeltaT = this->OutletTemp - this->InletTemp;
                this->MassFlowRate = TotalCondenserHeat / Cp / DeltaT;
                // Check for maximum flow in the component
                if (this->MassFlowRate > this->MassFlowRateMax) {
                    if (this->HighFlowWarnIndex == 0) {
                        ShowWarningMessage(TypeName + this->Name);
                        ShowContinueError("Requested condenser water mass flow rate greater than maximum allowed value. ");
                        ShowContinueError("Flow reset to maximum value.");
                    } // HighFlowWarnIndex
                    ShowRecurringWarningErrorAtEnd(ErrIntro + this->Name + " - Flow rate higher than maximum allowed ... continues",
                                                   this->HighFlowWarnIndex);
                    // END IF
                    this->MassFlowRate = this->MassFlowRateMax;
            }
            } // compare outlet T to inlet T

        } else if (this->FlowType == ConstantFlow && TotalCondenserHeat > 0.0) {
            // this part for constant flow condition
            this->VolFlowRate = this->DesVolFlowRate;
            this->MassFlowRate = this->VolFlowRate * rho;

        } else if (TotalCondenserHeat == 0.0) {
            this->MassFlowRate = 0.0;

        } // on flow type
        // check against plant, might get changed.
        PlantUtilities::SetComponentFlowRate(
            this->MassFlowRate, PlantInletNode, PlantOutletNode, PlantLoopIndex, PlantLoopSideIndex, PlantBranchIndex, PlantCompIndex);

        this->VolFlowRate = this->MassFlowRate / rho;

        if (this->MassFlowRate > 0) {
            this->OutletTemp = TotalCondenserHeat / (this->MassFlowRate * Cp) + DataLoopNode::Node(PlantInletNode).Temp;
        } else {
            this->OutletTemp = this->InletTemp;
            if ((TotalCondenserHeat > 0.0) && (!FirstHVACIteration)) {

                ShowRecurringWarningErrorAtEnd(
                    TypeName + this->Name +
                        "Water-cooled condenser has no cooling water flow. Heat is not being rejected from compressor rack condenser.",
                    this->FlowType);
            }
                    }
        // Check outlet water temp for max value
        if (this->OutletTemp > this->OutletTempMax) {
            if (this->HighTempWarnIndex == 0) {
                ShowWarningMessage(TypeName + this->Name);
                ShowContinueError(
                    "Water-cooled condenser outlet temp higher than maximum allowed temp. Check flow rates and/or temperature setpoints.");
                        }
            ShowRecurringWarningErrorAtEnd(ErrIntro + this->Name + " - Condenser outlet temp higher than maximum allowed ... continues",
                                           this->HighTempWarnIndex);
                    }

        this->UpdateCondenser();
                    }

    PlantComponent *RefrigRackData::factory(EnergyPlusData &state, std::string const &objectName)
    {
        // Process the input data for boilers if it hasn't been done already
        if (GetRefrigerationInputFlag) {
            CheckRefrigerationInput(state);
            GetRefrigerationInputFlag = false;
                    }
        // Now look for this particular object in list
        for (auto &obj : RefrigRack) {
            if (obj.Name == objectName) {
                return &obj;
                }
            }
        // If we didn't find it, fatal
        ShowFatalError("LocalRefrigRackFactory: Error getting inputs for object named: " + objectName); // LCOV_EXCL_LINE
        // Shut up the compiler
        return nullptr; // LCOV_EXCL_LINE
        }

    void RefrigRackData::onInitLoopEquip(EnergyPlusData &state, const PlantLocation &EP_UNUSED(calledFromLocation))
    {
            InitRefrigeration();
            InitRefrigerationPlantConnections(state.dataBranchInputManager);
        }

    void RefrigRackData::simulate(EnergyPlusData &state, const PlantLocation &EP_UNUSED(calledFromLocation),
                                  bool const FirstHVACIteration,
                                  Real64 &EP_UNUSED(CurLoad),
                                  bool const EP_UNUSED(RunFlag))
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Randy Hudson, ORNL
        //       DATE WRITTEN   July 2007
        //       MODIFIED       Therese Stovall, ORNL May 2008
        //                      Brent Griffith, NREL Oct 2010, generalize fluid properties
        //                        plant upgrades, moved where called from to SimPlantEquip from ManageNonZoneEquipment
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Simulates the water-cooled refrigeration condenser object.
        // Modified to add condensers for detailed refrigeration systems and to
        // avoid double-counting heat rejection that has been used in desuperheater
        // hvac coils or water heaters.

        // METHODOLOGY EMPLOYED:
        // Called from SimPlantEquip in PlantLoopEquipment , previously was called from Non-Zone Equipment Manager
        // Flow is requested and the actual available flow is set.  The outlet temperature is calculated.

        static std::string const RoutineName("SimRefrigCondenser");
        int PlantInletNode(0);
        int PlantOutletNode(0);
        int PlantLoopIndex(0);
        int PlantLoopSideIndex(0);
        int PlantBranchIndex(0);
        int PlantCompIndex(0);

        InitRefrigerationPlantConnections(state.dataBranchInputManager);

        std::string TypeName;
        std::string ErrIntro;

        // set variables depending upon system type
        PlantInletNode = this->InletNode;
        PlantOutletNode = this->OutletNode;
        PlantLoopIndex = this->PlantLoopNum;
        PlantLoopSideIndex = this->PlantLoopSideNum;
        PlantBranchIndex = this->PlantBranchNum;
        PlantCompIndex = this->PlantCompNum;

                TotalCondenserHeat =
            DataHeatBalance::HeatReclaimRefrigeratedRack(this->MyIdx).AvailCapacity - this->LaggedUsedWaterHeater - this->LaggedUsedHVACCoil;
                TypeName = "Refrigeration:CompressorRack:";
                ErrIntro = "Condenser for refrigeration rack ";

        // Current condenser is water cooled
        // Make demand request on first HVAC iteration

        // get cooling fluid properties
        Real64 rho = FluidProperties::GetDensityGlycol(
            DataPlant::PlantLoop(PlantLoopIndex).FluidName, this->InletTemp, DataPlant::PlantLoop(PlantLoopIndex).FluidIndex, RoutineName);
        Real64 Cp = FluidProperties::GetSpecificHeatGlycol(
            DataPlant::PlantLoop(PlantLoopIndex).FluidName, this->InletTemp, DataPlant::PlantLoop(PlantLoopIndex).FluidIndex, RoutineName);

        if (this->FlowType == VariableFlow && TotalCondenserHeat > 0.0) {
            this->OutletTemp = ScheduleManager::GetCurrentScheduleValue(this->OutletTempSchedPtr);

            if (this->OutletTemp == this->InletTemp) {

                if (this->HighInletWarnIndex == 0) {
                    ShowSevereError(ErrIntro + ", \"" + this->Name +
                                    "\" : has inlet water temp equal to desired outlet temp. Excessive flow resulting. ");
                    ShowContinueError("cooling water is not cold enough to reach desired outlet temperature");
                }
                ShowRecurringWarningErrorAtEnd(ErrIntro + ", \"" + this->Name +
                                                   "\" : has inlet water temp equal to desired outlet temp.... continues. ",
                                               this->HighInletWarnIndex);
                this->VolFlowRate = 9999.0;
                this->MassFlowRate = this->VolFlowRate * rho;
            } else {
                Real64 DeltaT = this->OutletTemp - this->InletTemp;
                this->MassFlowRate = TotalCondenserHeat / Cp / DeltaT;
                // Check for maximum flow in the component
                if (this->MassFlowRate > this->MassFlowRateMax) {
                    if (this->HighFlowWarnIndex == 0) {
                        ShowWarningMessage(TypeName + this->Name);
                        ShowContinueError("Requested condenser water mass flow rate greater than maximum allowed value. ");
                        ShowContinueError("Flow reset to maximum value.");
                    } // HighFlowWarnIndex
                    ShowRecurringWarningErrorAtEnd(ErrIntro + this->Name + " - Flow rate higher than maximum allowed ... continues",
                                                   this->HighFlowWarnIndex);
                    // END IF
                    this->MassFlowRate = this->MassFlowRateMax;
                }
            } // compare outlet T to inlet T

        } else if (this->FlowType == ConstantFlow && TotalCondenserHeat > 0.0) {
            // this part for constant flow condition
            this->VolFlowRate = this->DesVolFlowRate;
            this->MassFlowRate = this->VolFlowRate * rho;

        } else if (TotalCondenserHeat == 0.0) {
            this->MassFlowRate = 0.0;

        } // on flow type
        // check against plant, might get changed.
        PlantUtilities::SetComponentFlowRate(
            this->MassFlowRate, PlantInletNode, PlantOutletNode, PlantLoopIndex, PlantLoopSideIndex, PlantBranchIndex, PlantCompIndex);

        this->VolFlowRate = this->MassFlowRate / rho;

        if (this->MassFlowRate > 0) {
            this->OutletTemp = TotalCondenserHeat / (this->MassFlowRate * Cp) + DataLoopNode::Node(PlantInletNode).Temp;
        } else {
            this->OutletTemp = this->InletTemp;
            if ((TotalCondenserHeat > 0.0) && (!FirstHVACIteration)) {

                ShowRecurringWarningErrorAtEnd(
                    TypeName + this->Name +
                        "Water-cooled condenser has no cooling water flow. Heat is not being rejected from compressor rack condenser.",
                    this->NoFlowWarnIndex);
            }
        }
        // Check outlet water temp for max value
        if (this->OutletTemp > this->OutletTempMax) {
            if (this->HighTempWarnIndex == 0) {
                ShowWarningMessage(TypeName + this->Name);
                ShowContinueError(
                    "Water-cooled condenser outlet temp higher than maximum allowed temp. Check flow rates and/or temperature setpoints.");
            }
            ShowRecurringWarningErrorAtEnd(ErrIntro + this->Name + " - Condenser outlet temp higher than maximum allowed ... continues",
                                           HighTempWarnIndex);
        }

        this->UpdateCondenser();
        }

    void RefrigCondenserData::UpdateCondenser()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Randy Hudson, ORNL
        //       DATE WRITTEN   July 2007
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Updates the node variables with local variables.

        // Pass all variables from inlet to outlet node
        PlantUtilities::SafeCopyPlantNode(this->InletNode, this->OutletNode);

        // Set outlet node variables that are possibly changed
        DataLoopNode::Node(this->OutletNode).Temp = this->OutletTemp;
    }

    void RefrigRackData::UpdateCondenser()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Randy Hudson, ORNL
        //       DATE WRITTEN   July 2007
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Updates the node variables with local variables.

        // Pass all variables from inlet to outlet node
        PlantUtilities::SafeCopyPlantNode(this->InletNode, this->OutletNode);

        // Set outlet node variables that are possibly changed
        DataLoopNode::Node(this->OutletNode).Temp = this->OutletTemp;
        }

    void SimulateDetailedRefrigerationSystems()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL, Assisted by Hugh Henderson
        //       DATE WRITTEN   Spring 2008
        //       Based upon ManageRefrigeratedCaseRacks by Richard Raustad, FSEC
        //          Oct/Nov 2004, and MODIFIED by Shirey, FSEC Dec 2004
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine is called to simulate detailed refrigeration systems

        // METHODOLOGY EMPLOYED:
        // Each refrigeration system is modeled by first simulating the attached refrigerated cases.  The sum
        // of the total heat transfer for all attached cases determines the load on the compressor rack.
        // Iterations are used here to account for load transfer between independent refrigeration systems
        // via mechanical subcoolers.
        // The logical variable, UseSysTimeStep, determines whether we are evaluating only systems driven by
        // ZoneEquipmentManager on the system time step, or only system driven by HVACManager on the zone time step.

        static std::string const RoutineName("SimulateDetailedRefrigerationSystems");
        Real64 const MaxDelTFloatFrac(0.5); // max fraction allowed for difference between case and evaporator temperature

        Real64 LocalTimeStep = DataGlobals::TimeStepZone;
        if (UseSysTimeStep) LocalTimeStep = DataHVACGlobals::TimeStepSys;

        // Cascade condenser assumes a constant approach delta T (Tcond - Tevap), not f(load)

        // Loads for chiller sets are set in call to zone equipment element "SimAirChillerSet"
        // (all chiller coils within a set are located in the same zone)
        // (note non-zone, such as refrigeration, and zone equip, such as airchillersets, called at diff times)
        // Loads are then defined for each chiller coil within the set in "CalculateAirChillerSet"
        // In that subroutine, dispatch coils within each set in order specified for each zone
        //  Below will assign loads to refrigeration system or secondary loop
        // Note that this routine will go through all refrigeration systems, but loads for multiple systems
        // with interactions will not be known for the intital calls with first HVAC time step. They will,
        // however, be repeated when the last chiller set is called from ZoneEquipmentManager
        // that's why important where init goes, don't want to zero out data should keep
        if (UseSysTimeStep) {
            for (int CoilSetIndex = 1; CoilSetIndex <= DataHeatBalance::NumRefrigChillerSets; ++CoilSetIndex) {
                AirChillerSet(CoilSetIndex).CalculateAirChillerSets();
            }
        }

        // Do refrigeration system loop outside of iterative solution to initialize time step and
        //  calculate case, walk-in, and secondary loop loads (that won't change during balance
        //  of refrigeration system iterations) and prepare initial estimates for the iterative system solution
        for (int SysNum = 1; SysNum <= DataHeatBalance::NumRefrigSystems; ++SysNum) {
            // Only do those systems appropriate for this analysis, supermarket type on load time step or coil type on sys time step
            if (((!UseSysTimeStep) && (!System(SysNum).CoilFlag)) || ((UseSysTimeStep) && (System(SysNum).CoilFlag))) {
                if (System(SysNum).NumCases > 0) {
                    for (int CaseIndex = 1; CaseIndex <= System(SysNum).NumCases; ++CaseIndex) {
                        int CaseID = System(SysNum).CaseNum(CaseIndex);
                        RefrigCase(CaseID).CalculateCase();
                        //  TevapDesign calc in Get Input to meet lowest evap temp of any load on the system.
                        //  Tevap needed is either fixed at this design value,
                        //  or allowed to float to meet lowest T needed among all loads served by the system
                        //  (Floating Tevap = Design Tevap unless load <= Design cap)
                        if (System(SysNum).CompSuctControl == ConstantSuctionTemperature) {
                            System(SysNum).TEvapNeeded = System(SysNum).TEvapDesign;
                        } else { // calculate floating T evap
                            Real64 LoadFrac = min(1.0, (RefrigCase(CaseID).TotalCoolingLoad / RefrigCase(CaseID).DesignRatedCap));
                            Real64 MaxTEvap = RefrigCase(CaseID).Temperature -
                                       (RefrigCase(CaseID).Temperature - RefrigCase(CaseID).EvapTempDesign) * max(LoadFrac, MaxDelTFloatFrac);
                            // Compare Tevap for this case to max allowed for all previous cases on this suction group and set at the MINIMUM of the
                            // two
                            if (CaseIndex == 1) { // note use case index, not caseid here to get first case on this suction group/system
                                System(SysNum).TEvapNeeded = MaxTEvap;
                            } else {
                                System(SysNum).TEvapNeeded = min(MaxTEvap, System(SysNum).TEvapNeeded);
                            }
                        } // floating or constant evap temperature
                        // increment TotalCoolingLoad for Compressors/condenser on each system and defrost condenser credits for heat recovery
                        System(SysNum).TotalCoolingLoad += RefrigCase(CaseID).TotalCoolingLoad;
                        System(SysNum).TotalCondDefrostCredit += RefrigCase(CaseID).HotDefrostCondCredit;
                    } // NumCases
                }     // Num of cases > 0

                if (System(SysNum).NumWalkIns > 0) {
                    for (int WalkInIndex = 1; WalkInIndex <= System(SysNum).NumWalkIns; ++WalkInIndex) {
                        int WalkInID = System(SysNum).WalkInNum(WalkInIndex);
                        WalkIn(WalkInID).CalculateWalkIn();
                        if (System(SysNum).CompSuctControl == ConstantSuctionTemperature) {
                            System(SysNum).TEvapNeeded = System(SysNum).TEvapDesign;
                        } else { // calculate floating T evap
                            Real64 LoadFrac = min(1.0, (WalkIn(WalkInID).TotalCoolingLoad / WalkIn(WalkInID).DesignRatedCap));
                            Real64 MaxTEvap = WalkIn(WalkInID).Temperature -
                                       (WalkIn(WalkInID).Temperature - WalkIn(WalkInID).TEvapDesign) * max(LoadFrac, MaxDelTFloatFrac);
                            //  Compare maxTevap for this walk in to max allowed for cases and for all
                            //  previous walk ins on this suction group and set at the MINIMUM of the two
                            if (WalkInIndex == 1 && System(SysNum).NumCases == 0) {
                                System(SysNum).TEvapNeeded = MaxTEvap;
                            } else {
                                System(SysNum).TEvapNeeded = min(MaxTEvap, System(SysNum).TEvapNeeded);
                            }
                        } // floating or constant evap temperature
                        // increment TotalCoolingLoad for Compressors/condenser on each system
                        System(SysNum).TotalCoolingLoad += WalkIn(WalkInID).TotalCoolingLoad;
                        System(SysNum).TotalCondDefrostCredit += WalkIn(WalkInID).HotDefrostCondCredit;
                    } // NumWalkIns systems
                }     // System(SysNum)%NumWalkIns > 0

                if (System(SysNum).NumCoils > 0) {
                    for (int CoilIndex = 1; CoilIndex <= System(SysNum).NumCoils; ++CoilIndex) {
                        int CoilID = System(SysNum).CoilNum(CoilIndex);
                        // already CALLed CalculateCoil(CoilID) in CoilSet specified order
                        if (System(SysNum).CompSuctControl == ConstantSuctionTemperature) {
                            System(SysNum).TEvapNeeded = System(SysNum).TEvapDesign;
                        } else { // calculate floating T evap
                            // for now, override floating Tevap if coils on system, warning was printed in input to let user know
                            System(SysNum).TEvapNeeded = System(SysNum).TEvapDesign;
                        } // floating or constant evap temperature
                        // increment TotalCoolingLoad for Compressors/condenser on each system
                        System(SysNum).TotalCoolingLoad += WarehouseCoil(CoilID).TotalCoolingLoad;
                        System(SysNum).TotalCondDefrostCredit += WarehouseCoil(CoilID).HotDefrostCondCredit;
                    } // NumCoils systems
                }     // System(SysNum)%NumCoils > 0

                if (System(SysNum).NumSecondarys > 0) {
                    for (int SecondIndex = 1; SecondIndex <= System(SysNum).NumSecondarys; ++SecondIndex) {
                        int SecondID = System(SysNum).SecondaryNum(SecondIndex);
                        Secondary(SecondID).CalculateSecondary(SecondID);
                        if (System(SysNum).CompSuctControl == ConstantSuctionTemperature) {
                            System(SysNum).TEvapNeeded = System(SysNum).TEvapDesign;
                        } else { // check for lowest T evap design among the secondary systems and
                            //  Compare Tevap for this second to max allowed for cases, walk ins, and
                            //  for all previous secondary loops on this suction group and set
                            //  at the MINIMUM (note secondary loops control capacity with
                            //  brine flow rate, so don't float above their design evap temperature)
                            if (SecondIndex == 1 && System(SysNum).NumNonCascadeLoads == 0) {
                                System(SysNum).TEvapNeeded = Secondary(SecondID).TEvapDesign;
                            } else {
                                System(SysNum).TEvapNeeded = min(Secondary(SecondID).TEvapDesign, System(SysNum).TEvapNeeded);
                            }
                        } // floating or constant evap temperature
                        // increment TotalCoolingLoad for Compressors/condenser on each system
                        System(SysNum).SumSecondaryLoopLoad += Secondary(SecondID).TotalCoolingLoad;
                        System(SysNum).TotalCondDefrostCredit += Secondary(SecondID).HotDefrostCondCredit;
                    } // NumSecondarys systems
                }     // System(SysNum)%NumSecondarys > 0

                // add suction pipe heat gains (W) if input by user
                // Suction pipe heat gains aren't included in the reported total system load, but are heat gains that must be met in
                //  condenser and compressor loads. However, secondary dist piping and receiver gains are included
                //  in the total secondary system loads.
                System(SysNum).PipeHeatLoad = 0.0;
                if (System(SysNum).SumUASuctionPiping > MySmallNumber) {
                    Real64 SuctionPipeZoneTemp = DataLoopNode::Node(System(SysNum).SuctionPipeZoneNodeNum)
                                                     .Temp; // Temperature for zone identified as environment for suction pipe heat gains, C
                    System(SysNum).PipeHeatLoad = System(SysNum).SumUASuctionPiping * (SuctionPipeZoneTemp - System(SysNum).TEvapNeeded);
                    // pipe heat load is a positive number (ie. heat absorbed by pipe, so needs to be subtracted
                    //     from refrigcasecredit (- for cooling zone, + for heating zone)
                    int SuctionPipeActualZoneNum = System(SysNum).SuctionPipeActualZoneNum;
                    if (UseSysTimeStep) {
                        CoilSysCredit(SuctionPipeActualZoneNum).SenCreditToZoneRate -= System(SysNum).PipeHeatLoad;
                        CoilSysCredit(SuctionPipeActualZoneNum).ReportSenCoolingToZoneRate =
                            -CoilSysCredit(SuctionPipeActualZoneNum).SenCreditToZoneRate;
                    }
                    // Can arrive here when load call to refrigeration looks for cases/walkin systems and usetimestep is .FALSE.
                    if ((!UseSysTimeStep) && ((NumSimulationCases > 0) || (NumSimulationWalkIns > 0))) {
                        DataHeatBalance::RefrigCaseCredit(SuctionPipeActualZoneNum).SenCaseCreditToZone -= System(SysNum).PipeHeatLoad;
                    } // UseSysTimeStep
                }
            } //(((.NOT. UseSysTimeStep).AND.(.NOT. System(SysNum)%CoilFlag)).OR.((UseSysTimeStep).AND.(System(SysNum)%CoilFlag)))
        }     // SysNum

        // Need to know if mechanical subcoolers or cascade condensers or shared condensers
        //    are present. If so, energy transfer between
        //    detailed refrigeration systems requires additional iteration at this level.

        int StartMechSubcoolLoop(3); // if no mechanical subcoolers transfer energy between system,
        if ((NumSimulationMechSubcoolers > 0) || (NumSimulationCascadeCondensers > 0) || (NumSimulationSharedCondensers > 0) ||
            (NumSimulationRefrigAirChillers > 0))
            StartMechSubcoolLoop = 1;

        bool FirstSCLoop = true; // Flag first time through multi-system loop used when mech subcoolers present

        for (int LoopNum = StartMechSubcoolLoop; LoopNum <= 3;
             ++LoopNum) { // Note, for cascade cond loads compared requiring 5 iterations to 3, no difference.

            for (int SysNum = 1; SysNum <= DataHeatBalance::NumRefrigSystems; ++SysNum) {
                // Only do those systems appropriate for this analysis, supermarket type on load time step or coil type on sys time step
                if (((!UseSysTimeStep) && (!System(SysNum).CoilFlag)) || ((UseSysTimeStep) && (System(SysNum).CoilFlag))) {
                    System(SysNum).SumMechSCLoad = 0.0;
                    System(SysNum).SumCascadeLoad = 0.0;
                    System(SysNum).SumCascadeCondCredit = 0.0;
                    System(SysNum).SumMechSCBenefit = 0.0;

                    if ((NumSimulationMechSubcoolers > 0) && (!FirstSCLoop)) {
                        // This loop places load on system providing mechanical subcooling
                        for (int SubcoolID = 1; SubcoolID <= NumSimulationSubcoolers; ++SubcoolID) {
                            if (Subcooler(SubcoolID).SubcoolerType == LiquidSuction) continue;
                            if (Subcooler(SubcoolID).MechSourceSysID != SysNum) continue;
                            // don't have summechscload until second subcooler pass, set to zero on first pass
                            System(SysNum).SumMechSCLoad += System(SysNum).MechSCLoad(SubcoolID);
                            // subcooler should not drive Tevap for supplying system,
                            //    but check to see if T controlled can be met or if Tevap is at a higher temperature
                            if (Subcooler(SubcoolID).MechControlTliqOut < System(SysNum).TEvapNeeded) {
                                ShowWarningError("Refrigeration:System: " + System(SysNum).Name);
                                ShowContinueError(" Evaporating temperature greater than the controlled ");
                                ShowContinueError(" liquid outlet temperature for SUBCOOLER:" + Subcooler(SubcoolID).Name);
                            }
                        } // SubcoolId

                        if (System(SysNum).NumSubcoolers > 0) {
                            for (int SubcoolerIndex = 1; SubcoolerIndex <= System(SysNum).NumSubcoolers; ++SubcoolerIndex) {
                                int SubcoolID = System(SysNum).SubcoolerNum(SubcoolerIndex);
                                if (Subcooler(SubcoolID).SubcoolerType == LiquidSuction) continue;
                                System(SysNum).SumMechSCBenefit = Subcooler(SubcoolID).MechSCTransLoad;
                            } // subcoolerindex
                        }     // System(sysid)%numsubcoolers > 0
                    }         // NumSimulationMechSubcoolers > 0 and not first loop

                    // This loop places load on system absorbing heat from cascade condenser and &
                    //     condenser heat reclaim credits from hot gas/brine defrosts
                    if ((System(SysNum).NumCascadeLoads > 0) && (!FirstSCLoop)) {
                        for (int CascadeLoadIndex = 1; CascadeLoadIndex <= System(SysNum).NumCascadeLoads; ++CascadeLoadIndex) {
                            int CascadeLoadID = System(SysNum).CascadeLoadNum(CascadeLoadIndex);
                            if (System(SysNum).CompSuctControl == ConstantSuctionTemperature) {
                                System(SysNum).TEvapNeeded = System(SysNum).TEvapDesign;
                            } else { // check for lowest T evap design among the CascadeLoad systems and
                                //  Compare Tevap for this Cascade to max allowed for cases, walk ins, and
                                //  for all previous CascadeLoad loops on this suction group and set
                                //  at the MINIMUM
                                if (Condenser(CascadeLoadID).CascadeTempControl == CascadeTempSet) {
                                    // if float then set tevap based upon other loads
                                    if (CascadeLoadIndex == 1 && System(SysNum).NumNonCascadeLoads == 0) {
                                        System(SysNum).TEvapNeeded = Condenser(CascadeLoadID).CascadeRatedEvapTemp;
                                    } else {
                                        System(SysNum).TEvapNeeded = min(Condenser(CascadeLoadID).CascadeRatedEvapTemp, System(SysNum).TEvapNeeded);
                                    }
                                }
                            } // floating or constant system evap temperature
                            // increment Cascade condenser Loads for Compressors/condenser on each system
                            // place any defrost credits on the same system absorbing the cascade condenser load
                            // (CascadeSysID identifies the condenser producing the defrost credits, that is, the lower temp system)
                            System(SysNum).SumCascadeLoad += Condenser(CascadeLoadID).CondLoad;
                            System(SysNum).SumCascadeCondCredit += System(Condenser(CascadeLoadID).CascadeSysID).TotalCondDefrostCredit;

                        } // NumCascadeLoads
                    }     // System(SysNum)%NumCascadeLoads > 0

                    // only calc detailed system if have load (could be zero first time through if only load is cascade condenser)
                    System(SysNum).TotalSystemLoad = System(SysNum).TotalCoolingLoad + System(SysNum).SumSecondaryLoopLoad +
                                                     System(SysNum).SumMechSCLoad + System(SysNum).SumCascadeLoad;
                    if (System(SysNum).TotalSystemLoad > 0.0) {
                        System(SysNum).CpSatVapEvap = FluidProperties::GetSatSpecificHeatRefrig(
                            System(SysNum).RefrigerantName, System(SysNum).TEvapNeeded, 1.0, System(SysNum).RefIndex, RoutineName);
                        System(SysNum).HCaseOut =
                            FluidProperties::GetSatEnthalpyRefrig(
                                System(SysNum).RefrigerantName, System(SysNum).TEvapNeeded, 1.0, System(SysNum).RefIndex, RoutineName) +
                            System(SysNum).CpSatVapEvap * CaseSuperheat;
                        // Establish estimates to start solution loop
                        {
                            auto const SELECT_CASE_var(Condenser(System(SysNum).CondenserNum(1)).CondenserType); // only one condenser allowed now
                            if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeAir) {
                                System(SysNum).TCondense = DataEnvironment::OutDryBulbTemp + 16.7;
                                // 16.7C is delta T at rating point for air-cooled condensers, just estimate, so ok for zone-located condensers
                            } else if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeEvap) {
                                System(SysNum).TCondense = DataEnvironment::OutDryBulbTemp + 15.0;
                                // 15C is delta T at rating point for evap-cooled condensers
                            } else if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeWater) {
                                // define starting estimate at temperature of water exiting condenser
                                System(SysNum).TCondense = DataLoopNode::Node(Condenser(System(SysNum).CondenserNum(1)).OutletNode).Temp;
                            } else if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeCascade) {
                                //?Don't need estimate for cascade condenser because it doesn't iterate?
                            }
                        }

                        // Produce first time step estimates, assume no subcoolers
                        System(SysNum).HSatLiqCond = FluidProperties::GetSatEnthalpyRefrig(
                            System(SysNum).RefrigerantName, System(SysNum).TCondense, 0.0, System(SysNum).RefIndex, RoutineName);
                        System(SysNum).CpSatLiqCond = FluidProperties::GetSatSpecificHeatRefrig(
                            System(SysNum).RefrigerantName, System(SysNum).TCondense, 0.0, System(SysNum).RefIndex, RoutineName);
                        System(SysNum).HCaseIn =
                            System(SysNum).HSatLiqCond - System(SysNum).CpSatLiqCond * Condenser(System(SysNum).CondenserNum(1)).RatedSubcool;
                        System(SysNum).RefMassFlowtoLoads = System(SysNum).TotalSystemLoad / (System(SysNum).HCaseOut - System(SysNum).HCaseIn);
                        System(SysNum).RefMassFlowComps = System(SysNum).RefMassFlowtoLoads;

                        if (System(SysNum).NumStages == 2) { // Two-stage compression system
                            // Initial guess for high-stage mass flow rate in two-stage compression systems
                            System(SysNum).RefMassFlowHiStageComps = System(SysNum).RefMassFlowComps / 0.65;
                        }

                        System(SysNum).CalcDetailedSystem(SysNum);

                        bool DeRate; // If true, need to derate aircoils because load can't be met by system

                        // With air chiller coils, don't use unmet energy, instead reduce capacity on coils to match avail compressor/cond capacity
                        // current loads on compressor, exclusive of unmet loads from prev time steps
                        Real64 CurrentLoads =
                            System(SysNum).TotalSystemLoad + System(SysNum).LSHXTrans; // because compressor capacity rated from txv to comp inlet
                        if ((System(SysNum).CoilFlag) && (CurrentLoads > (System(SysNum).TotCompCapacity * 1.001))) {
                            DeRate = true;
                            FinalRateCoils(DeRate, DetailedSystem, SysNum, CurrentLoads, System(SysNum).TotCompCapacity);
                            System(SysNum).TotalCoolingLoad = 0.0;
                            System(SysNum).TotalCondDefrostCredit = 0.0;
                            for (int CoilIndex = 1; CoilIndex <= System(SysNum).NumCoils; ++CoilIndex) {
                                int CoilID = System(SysNum).CoilNum(CoilIndex);
                                // already CALLed CalculateCoil(CoilID) in CoilSet specified order
                                if (System(SysNum).CompSuctControl == ConstantSuctionTemperature) {
                                    System(SysNum).TEvapNeeded = System(SysNum).TEvapDesign;
                                } else { // calculate floating T evap
                                    System(SysNum).TEvapNeeded = System(SysNum).TEvapDesign;
                                    ShowWarningError("Refrigeration:System: " + System(SysNum).Name);
                                    ShowContinueError(" Floating evaporator temperature model not yet available for warehouse coil systems. ");
                                } // floating or constant evap temperature
                                // increment TotalCoolingLoad for Compressors/condenser on each system
                                System(SysNum).TotalCoolingLoad += WarehouseCoil(CoilID).TotalCoolingLoad;
                                System(SysNum).TotalCondDefrostCredit += WarehouseCoil(CoilID).HotDefrostCondCredit;
                            } // NumCoils systems
                            if (System(SysNum).NumStages == 2 &&
                                System(SysNum).TotHiStageCompCapacity <
                                    (System(SysNum).TotalCoolingLoad + System(SysNum).LSHXTrans + System(SysNum).TotCompPower)) {
                                ShowRecurringWarningErrorAtEnd("Refrigeration:System: " + System(SysNum).Name +
                                                                   ":The specified high-stage compressors for this system are unable to meet the sum "
                                                                   "of the refrigeration loads, ",
                                                               System(SysNum).HiStageWarnIndex1);
                                ShowRecurringContinueErrorAtEnd(" subcooler loads (if any), and low-stage compressor loads for this sytem.",
                                                                System(SysNum).HiStageWarnIndex2);
                            } // Hi-stage capacity<(load+LSHX load + lo-stage compressor load)
                        }     // CoilFlag (Numcoils > 0) and load > capacity

                    } // System(SysNum)%TotalSystemLoad > 0
                }     //(((.NOT. UseSysTimeStep).AND.(.NOT. System(SysNum)%CoilFlag)).OR.((UseSysTimeStep).AND.(System(SysNum)%CoilFlag)))
            }         // SysNum over NumRefrigSystems
            FirstSCLoop = false;
        } // LoopNum, three times for buildings with multiple detailed systems connected with mechanical subcoolers
        // or cascade condensers or shared condensers or warehouse coils that might need to be de-rated

        // Dealing with unmet load has to be done outside iterative loop
        for (int SysNum = 1; SysNum <= DataHeatBalance::NumRefrigSystems; ++SysNum) {
            // Only do those systems appropriate for this analysis, supermarket type on load time step or coil type on sys time step
            if ((((!UseSysTimeStep) && (!System(SysNum).CoilFlag)) || ((UseSysTimeStep) && (System(SysNum).CoilFlag))) &&
                (!DataGlobals::WarmupFlag)) {
                Real64 CurrentLoads =
                    System(SysNum).TotalSystemLoad + System(SysNum).LSHXTrans; // because compressor capacity rated from txv to comp inlet
                Real64 CurrentHiStageLoads(0.0); // Current loads on high-stage compressor, exclusive of unmet loads from
                if (System(SysNum).NumStages == 2) {
                    CurrentHiStageLoads = CurrentLoads + System(SysNum).TotCompPower;
                } // NumStages==2
                if (System(SysNum).CoilFlag) {
                    // don't use 'unmet energy' with air chillers, see 'derate'
                    System(SysNum).UnmetEnergy = 0.0;
                    System(SysNum).UnmetHiStageEnergy = 0.0;
                } else {
                    // Meeting current and possibly some portion of the previously unmet energy
                    // perhaps future interest in reporting percent of installed capacity used(or number of compressors) ?
                    // If the system compressors were unable to meet the current loads, save energy to be met in succeeding time step
                    // Note the unmet energy is turned into a rate and applied to the system load at the start of calccompressor
                    System(SysNum).UnmetEnergy += (CurrentLoads - System(SysNum).TotCompCapacity) * DataGlobals::TimeStepZoneSec;
                    if (System(SysNum).NumStages == 2) {
                        System(SysNum).UnmetHiStageEnergy +=
                            (CurrentHiStageLoads - System(SysNum).TotHiStageCompCapacity) * DataGlobals::TimeStepZoneSec;
                    }
                    if (System(SysNum).UnmetEnergy > MyLargeNumber) {
                        System(SysNum).UnmetEnergy = MyLargeNumber;
                        if (ShowUnmetEnergyWarning(SysNum)) {
                            ShowWarningError("Refrigeration:System: " + System(SysNum).Name);
                            ShowContinueError(" The specified compressors for this system are unable to meet ");
                            ShowContinueError(" the sum of the refrigerated case loads and subcooler loads (if any) for this sytem.");
                            ShowUnmetEnergyWarning(SysNum) = false;
                        } // show warning
                    }     // > mylarge number
                    if (System(SysNum).UnmetHiStageEnergy > MyLargeNumber) {
                        System(SysNum).UnmetHiStageEnergy = MyLargeNumber;
                        if (ShowHiStageUnmetEnergyWarning(SysNum)) {
                            ShowWarningError("Refrigeration:System: " + System(SysNum).Name);
                            ShowContinueError(" The specified high-stage compressors for this system are unable to meet ");
                            ShowContinueError(" the sum of the refrigerated case loads, subcooler loads (if any) and ");
                            ShowContinueError(" low-stage compressor loads for this sytem.");
                            ShowHiStageUnmetEnergyWarning(SysNum) = false;
                        } // show warning
                    }     // > mylarge number
                }         // numcoils > 0

                // Zone-located air-cooled condenser reject heat also has to be outside iterative loop
                if (System(SysNum).SystemRejectHeatToZone) {
                    int CondInletAirZoneNum = Condenser(System(SysNum).CondenserNum(1)).InletAirZoneNum;
                    if (UseSysTimeStep) {
                        CoilSysCredit(CondInletAirZoneNum).SenCreditToZoneRate += System(SysNum).NetHeatRejectLoad; // Adding heat is positive
                        CoilSysCredit(CondInletAirZoneNum).ReportSenCoolingToZoneRate = -CoilSysCredit(CondInletAirZoneNum).SenCreditToZoneRate;
                    }
                    // Can arrive here when load call to refrigeration looks for cases/walkin systems and usetimestep is .FALSE.
                    if ((!UseSysTimeStep) && ((NumSimulationCases > 0) || (NumSimulationWalkIns > 0))) {
                        DataHeatBalance::RefrigCaseCredit(CondInletAirZoneNum).SenCaseCreditToZone +=
                            System(SysNum).NetHeatRejectLoad; // Adding heat is positive
                    }                                                                                                  // UseSystimestep
                }                                                                                                      // Reject heat to zone

                // Report variables
                System(SysNum).TotTransferLoad = System(SysNum).SumMechSCLoad - System(SysNum).SumMechSCBenefit +
                                                 System(SysNum).SumSecondaryLoopLoad + System(SysNum).SumCascadeLoad;
                System(SysNum).TotTransferEnergy = System(SysNum).TotTransferLoad * LocalTimeStep * DataGlobals::SecInHour;
                System(SysNum).PipeHeatEnergy = System(SysNum).PipeHeatLoad * LocalTimeStep * DataGlobals::SecInHour;
                System(SysNum).TotalCoolingEnergy = System(SysNum).TotalCoolingLoad * LocalTimeStep * DataGlobals::SecInHour;
            } //(((.NOT. UseSysTimeStep).AND.(.NOT. System(SysNum)%CoilFlag)).OR.((UseSysTimeStep).AND.(System(SysNum)%CoilFlag))).and.not
              //DataGlobals::WarmupFlag
        }     // SysNum = 1,NumRefrigSystems

        // Update for sending to zone equipment manager. (note report variables are summed elsewhere)
        //   LatOutputProvided = CoilSysCredit(ZoneNum)%LatKgPerS_ToZoneRate
        //   SysOutputProvided = CoilSysCredit(ZoneNum)%SenCreditToZoneRate
        // Note that case credit is negative for cooling, thus subtract positive value calculated for coil
        //   Note this is done whether or not the coils are derated.
        if (UseSysTimeStep) {
            for (int ZoneNum = 1; ZoneNum <= DataGlobals::NumOfZones; ++ZoneNum) {
                for (int CoilID = 1; CoilID <= NumSimulationRefrigAirChillers; ++CoilID) {
                    if (WarehouseCoil(CoilID).ZoneNum != ZoneNum) continue;
                    CoilSysCredit(ZoneNum).SenCreditToZoneRate -= WarehouseCoil(CoilID).SensCreditRate;
                    CoilSysCredit(ZoneNum).SenCreditToZoneEnergy =
                        CoilSysCredit(ZoneNum).SenCreditToZoneRate * LocalTimeStep * DataGlobals::SecInHour;
                    CoilSysCredit(ZoneNum).LatKgPerS_ToZoneRate -= WarehouseCoil(CoilID).LatKgPerS_ToZone;
                    CoilSysCredit(ZoneNum).LatCreditToZoneRate -= WarehouseCoil(CoilID).LatCreditRate;
                    CoilSysCredit(ZoneNum).LatCreditToZoneEnergy -= WarehouseCoil(CoilID).LatCreditEnergy;
                }
            }
        }

        SumZoneImpacts();
    }

    void SimulateDetailedTransRefrigSystems()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Brian A. Fricke, ORNL
        //       DATE WRITTEN   Fall 2011
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine is called to simulate detailed transcritical CO2 refrigeration systems

        // METHODOLOGY EMPLOYED:
        // Each refrigeration system is modeled by first simulating the attached refrigerated cases and
        // walk-ins. The sum of the total heat transfer for all attached cases and walk-ins determines
        // the load on the compressors. Iterations are used here to account for sharing of gas coolers
        // between independent refrigeration systems.

        static std::string const RoutineName("SimulateDetailedTransRefrigSystems");

        int LocalTimeStep = DataGlobals::TimeStepZone;
        if (UseSysTimeStep) LocalTimeStep = DataHVACGlobals::TimeStepSys;

        //  Do transcritical CO2 refrigeration system loop outside of iterative solution to initialize time step and
        //  calculate case and and walk-ins (that won't change during balance of refrigeration system iterations)
        //  and prepare initial estimates for the iterative system solution

        //  TransCritSysFlag = .TRUE.
        for (int SysNum = 1; SysNum <= NumTransRefrigSystems; ++SysNum) {
            // Only do those systems appropriate for this analysis, supermarket type on load time step
            if (TransSystem(SysNum).NumCasesMT > 0) {
                for (int CaseIndex = 1; CaseIndex <= TransSystem(SysNum).NumCasesMT; ++CaseIndex) {
                    int CaseID = TransSystem(SysNum).CaseNumMT(CaseIndex);
                    RefrigCase(CaseID).CalculateCase();
                    //  TEvapDesignMT calc in Get Input to meet lowest evap temp of any MT load on the system.
                    //  TEvapNeededMT is fixed at this design value.
                    TransSystem(SysNum).TEvapNeededMT = TransSystem(SysNum).TEvapDesignMT;
                    // increment TotalCoolingLoad for Compressors/gas cooler on each system and defrost gas cooler credits for heat recovery
                    TransSystem(SysNum).TotalCoolingLoadMT += RefrigCase(CaseID).TotalCoolingLoad;
                    TransSystem(SysNum).TotalCondDefrostCredit += RefrigCase(CaseID).HotDefrostCondCredit;
                } // NumCasesMT
            }     // Num of MT cases > 0

            if (TransSystem(SysNum).NumCasesLT > 0) {
                for (int CaseIndex = 1; CaseIndex <= TransSystem(SysNum).NumCasesLT; ++CaseIndex) {
                    int CaseID = TransSystem(SysNum).CaseNumLT(CaseIndex);
                    RefrigCase(CaseID).CalculateCase();
                    //  TEvapDesignLT calc in Get Input to meet lowest evap temp of any LT load on the system.
                    //  TEvapNeededLT is fixed at this design value.
                    TransSystem(SysNum).TEvapNeededLT = TransSystem(SysNum).TEvapDesignLT;
                    // increment TotalCoolingLoad for Compressors/gas cooler on each system and defrost gas cooler credits for heat recovery
                    TransSystem(SysNum).TotalCoolingLoadLT += RefrigCase(CaseID).TotalCoolingLoad;
                    TransSystem(SysNum).TotalCondDefrostCredit += RefrigCase(CaseID).HotDefrostCondCredit;
                } // NumCasesLT
            }     // Num of LT cases > 0

            if (TransSystem(SysNum).NumWalkInsMT > 0) {
                for (int WalkInIndex = 1; WalkInIndex <= TransSystem(SysNum).NumWalkInsMT; ++WalkInIndex) {
                    int WalkInID = TransSystem(SysNum).WalkInNumMT(WalkInIndex);
                    WalkIn(WalkInID).CalculateWalkIn();
                    //  TEvapDesignMT calc in Get Input to meet lowest evap temp of any MT load on the system.
                    //  TEvapNeededMT is fixed at this design value.
                    TransSystem(SysNum).TEvapNeededMT = TransSystem(SysNum).TEvapDesignMT;
                    // increment TotalCoolingLoad for Compressors/gas cooler on each system
                    TransSystem(SysNum).TotalCoolingLoadMT += WalkIn(WalkInID).TotalCoolingLoad;
                    TransSystem(SysNum).TotalCondDefrostCredit += WalkIn(WalkInID).HotDefrostCondCredit;
                } // NumWalkInsMT systems
            }     // TransSystem(SysNum)%NumWalkInsMT > 0

            if (TransSystem(SysNum).NumWalkInsLT > 0) {
                for (int WalkInIndex = 1; WalkInIndex <= TransSystem(SysNum).NumWalkInsLT; ++WalkInIndex) {
                    int WalkInID = TransSystem(SysNum).WalkInNumLT(WalkInIndex);
                    WalkIn(WalkInID).CalculateWalkIn();
                    //  TEvapDesignLT calc in Get Input to meet lowest evap temp of any LT load on the system.
                    //  TEvapNeeded is fixed at this design value.
                    TransSystem(SysNum).TEvapNeededLT = TransSystem(SysNum).TEvapDesignLT;
                    // increment TotalCoolingLoad for Compressors/gas cooler on each system
                    TransSystem(SysNum).TotalCoolingLoadLT += WalkIn(WalkInID).TotalCoolingLoad;
                    TransSystem(SysNum).TotalCondDefrostCredit += WalkIn(WalkInID).HotDefrostCondCredit;
                } // NumWalkInsLT systems
            }     // TransSystem(SysNum)%NumWalkInsLT > 0

            // add suction pipe heat gains (W) if input by user
            // Suction pipe heat gains aren't included in the reported total system load, but are heat gains that must be met in
            //  gas cooler and compressor loads.
            TransSystem(SysNum).PipeHeatLoadMT = 0.0;
            if (TransSystem(SysNum).SumUASuctionPipingMT > MySmallNumber) {
                Real64 SuctionPipeZoneTemp = DataLoopNode::Node(TransSystem(SysNum).SuctionPipeZoneNodeNumMT).Temp;
                TransSystem(SysNum).PipeHeatLoadMT =
                    TransSystem(SysNum).SumUASuctionPipingMT * (SuctionPipeZoneTemp - TransSystem(SysNum).TEvapNeededMT);
                // pipe heat load is a positive number (ie. heat absorbed by pipe, so needs to be subtracted
                //   from refrigcasecredit (- for cooling zone, + for heating zone)
                int SuctionPipeActualZoneNum = TransSystem(SysNum).SuctionPipeActualZoneNumMT;
                // Can arrive here when load call to refrigeration looks for cases/walkin systems and usetimestep is .FALSE.
                if ((!UseSysTimeStep) && ((NumSimulationCases > 0) || (NumSimulationWalkIns > 0))) {
                    DataHeatBalance::RefrigCaseCredit(SuctionPipeActualZoneNum).SenCaseCreditToZone -= TransSystem(SysNum).PipeHeatLoadMT;
                } // UseSysTimeStep
            }

            TransSystem(SysNum).PipeHeatLoadLT = 0.0;
            if (TransSystem(SysNum).SumUASuctionPipingLT > MySmallNumber) {
                Real64 SuctionPipeZoneTemp = DataLoopNode::Node(TransSystem(SysNum).SuctionPipeZoneNodeNumLT).Temp;
                TransSystem(SysNum).PipeHeatLoadLT =
                    TransSystem(SysNum).SumUASuctionPipingLT * (SuctionPipeZoneTemp - TransSystem(SysNum).TEvapNeededLT);
                // pipe heat load is a positive number (ie. heat absorbed by pipe, so needs to be subtracted
                //   from refrigcasecredit (- for cooling zone, + for heating zone)
                int SuctionPipeActualZoneNum = TransSystem(SysNum).SuctionPipeActualZoneNumLT;
                // Can arrive here when load call to refrigeration looks for cases/walkin systems and usetimestep is .FALSE.
                if ((!UseSysTimeStep) && ((NumSimulationCases > 0) || (NumSimulationWalkIns > 0))) {
                    DataHeatBalance::RefrigCaseCredit(SuctionPipeActualZoneNum).SenCaseCreditToZone -= TransSystem(SysNum).PipeHeatLoadLT;
                } // UseSysTimeStep
            }

        } // SysNum

        // Need to know if shared gas coolers are present. If so, energy
        // transfer between detailed transcritical refrigeration systems
        // requires additional iteration at this level.

        int StartMechSubcoolLoop(3); // if no mechanical subcoolers transfer energy between system, don't loop
        if (NumSimulationSharedGasCoolers > 0) StartMechSubcoolLoop = 1;

        for (int LoopNum = StartMechSubcoolLoop; LoopNum <= 3; ++LoopNum) {
            for (int SysNum = 1; SysNum <= NumTransRefrigSystems; ++SysNum) {
                // Only do those systems appropriate for this analysis, supermarket type on load time step or coil type on sys time step
                // only calc detailed system if have load
                TransSystem(SysNum).TotalSystemLoadMT = TransSystem(SysNum).TotalCoolingLoadMT;
                if (TransSystem(SysNum).TransSysType == 2) {
                    TransSystem(SysNum).TotalSystemLoadLT = TransSystem(SysNum).TotalCoolingLoadLT;
                }
                TransSystem(SysNum).TotalSystemLoad = TransSystem(SysNum).TotalSystemLoadLT + TransSystem(SysNum).TotalSystemLoadMT;
                if (TransSystem(SysNum).TotalSystemLoad > 0.0) {
                    if (TransSystem(SysNum).TransSysType == 2) {
                        TransSystem(SysNum).CpSatVapEvapLT = FluidProperties::GetSatSpecificHeatRefrig(
                            TransSystem(SysNum).RefrigerantName, TransSystem(SysNum).TEvapNeededLT, 1.0, TransSystem(SysNum).RefIndex, RoutineName);
                        TransSystem(SysNum).HCaseOutLT = FluidProperties::GetSatEnthalpyRefrig(TransSystem(SysNum).RefrigerantName,
                                                                              TransSystem(SysNum).TEvapNeededLT,
                                                                              1.0,
                                                                              TransSystem(SysNum).RefIndex,
                                                                              RoutineName) +
                                                         TransSystem(SysNum).CpSatVapEvapLT * TransCaseSuperheat;
                    }
                    TransSystem(SysNum).CpSatVapEvapMT = FluidProperties::GetSatSpecificHeatRefrig(
                        TransSystem(SysNum).RefrigerantName, TransSystem(SysNum).TEvapNeededMT, 1.0, TransSystem(SysNum).RefIndex, RoutineName);
                    TransSystem(SysNum).HCaseOutMT =
                        FluidProperties::GetSatEnthalpyRefrig(
                            TransSystem(SysNum).RefrigerantName, TransSystem(SysNum).TEvapNeededMT, 1.0, TransSystem(SysNum).RefIndex, RoutineName) +
                        TransSystem(SysNum).CpSatVapEvapMT * TransCaseSuperheat;

                    // Produce first time step estimates.
                    // Assume no subcoolers and neglect flow through bypass.
                    TransSystem(SysNum).TReceiver = FluidProperties::GetSatTemperatureRefrig(
                        TransSystem(SysNum).RefrigerantName, TransSystem(SysNum).PReceiver, TransSystem(SysNum).RefIndex, RoutineName);
                    TransSystem(SysNum).HSatLiqReceiver = FluidProperties::GetSatEnthalpyRefrig(
                        TransSystem(SysNum).RefrigerantName, TransSystem(SysNum).TReceiver, 0.0, TransSystem(SysNum).RefIndex, RoutineName);
                    TransSystem(SysNum).CpSatLiqReceiver = FluidProperties::GetSatSpecificHeatRefrig(
                        TransSystem(SysNum).RefrigerantName, TransSystem(SysNum).TReceiver, 0.0, TransSystem(SysNum).RefIndex, RoutineName);
                    TransSystem(SysNum).HCaseInMT = TransSystem(SysNum).HSatLiqReceiver;
                    TransSystem(SysNum).HCaseInLT = TransSystem(SysNum).HSatLiqReceiver;
                    TransSystem(SysNum).RefMassFlowtoLTLoads = 0.0;
                    TransSystem(SysNum).RefMassFlowCompsLP = 0.0;
                    TransSystem(SysNum).DelHSubcoolerDis = 0.0;
                    TransSystem(SysNum).DelHSubcoolerSuc = 0.0;
                    if (TransSystem(SysNum).TransSysType == 2) {
                        TransSystem(SysNum).RefMassFlowtoLTLoads =
                            TransSystem(SysNum).TotalSystemLoadLT / (TransSystem(SysNum).HCaseOutLT - TransSystem(SysNum).HCaseInLT);
                        TransSystem(SysNum).RefMassFlowCompsLP = TransSystem(SysNum).RefMassFlowtoLTLoads;
                    } // (TransSystem(SysNum)%TransSysType == 2)
                    TransSystem(SysNum).RefMassFlowtoMTLoads =
                        TransSystem(SysNum).TotalSystemLoadMT / (TransSystem(SysNum).HCaseOutMT - TransSystem(SysNum).HCaseInMT);
                    TransSystem(SysNum).RefMassFlowCompsHP = TransSystem(SysNum).RefMassFlowtoLTLoads + TransSystem(SysNum).RefMassFlowtoMTLoads;

                    TransSystem(SysNum).CalcDetailedTransSystem(SysNum);
                    //       TransCritSysFlag = .FALSE.

                } // TransSystem(SysNum)%TotalSystemLoad > 0
            }     // SysNum over NumRefrigSystems
        } // LoopNum, three times for buildings with multiple detailed systems connected with shared gas coolers

        // Unmet load is done outside iterative loop
        for (int SysNum = 1; SysNum <= NumTransRefrigSystems; ++SysNum) {
            // Only do those systems appropriate for this analysis, supermarket type on load time step or coil type on sys time step
            if ((!UseSysTimeStep) && (!DataGlobals::WarmupFlag)) {
                Real64 CurrentLoads = TransSystem(SysNum).TotalSystemLoad;
                // Meeting current and possibly some portion of the previously unmet energy
                // perhaps future interest in reporting percent of installed capacity used(or number of compressors) ?
                // If the system compressors were unable to meet the current loads, save energy to be met in succeeding time step
                // Note the unmet energy is turned into a rate and applied to the system load at the start of calccompressor
                TransSystem(SysNum).UnmetEnergy += (CurrentLoads - TransSystem(SysNum).TotCompCapacity) * DataGlobals::TimeStepZoneSec;

                if (TransSystem(SysNum).UnmetEnergy > MyLargeNumber) {
                    TransSystem(SysNum).UnmetEnergy = MyLargeNumber;
                    if (ShowUnmetEnergyWarningTrans(SysNum)) {
                        ShowWarningError("Refrigeration:TranscriticalSystem: " + TransSystem(SysNum).Name);
                        ShowContinueError(" The specified compressors for this system are unable to meet ");
                        ShowContinueError(" the sum of the refrigerated case loads and subcooler loads (if any) for this sytem.");
                        ShowUnmetEnergyWarningTrans(SysNum) = false;
                    } // show warning
                }     // > mylarge number

                // Zone-located air-cooled gas cooler reject heat also has to be outside iterative loop
                if (TransSystem(SysNum).SystemRejectHeatToZone) {
                    int CondInletAirZoneNum = GasCooler(TransSystem(SysNum).GasCoolerNum(1)).InletAirZoneNum;
                    // Can arrive here when load call to refrigeration looks for cases/walkin systems and usetimestep is .FALSE.
                    if ((!UseSysTimeStep) && ((NumSimulationCases > 0) || (NumSimulationWalkIns > 0))) {
                        DataHeatBalance::RefrigCaseCredit(CondInletAirZoneNum).SenCaseCreditToZone +=
                            TransSystem(SysNum).NetHeatRejectLoad; // Adding heat is positive
                    }                                                                                                       // UseSystimestep
                }                                                                                                           // Reject heat to zone

                // Report variables
                TransSystem(SysNum).PipeHeatEnergy =
                    (TransSystem(SysNum).PipeHeatLoadMT + TransSystem(SysNum).PipeHeatLoadLT) * LocalTimeStep * DataGlobals::SecInHour;
                TransSystem(SysNum).TotalCoolingEnergy =
                    (TransSystem(SysNum).TotalCoolingLoadMT + TransSystem(SysNum).TotalCoolingLoadMT) * LocalTimeStep * DataGlobals::SecInHour;
            } //(.NOT. UseSysTimeStep).AND. (.not. DataGlobals::WarmupFlag)
        }     // SysNum = 1,NumTransRefrigSystems

        // Update for sending to zone equipment manager. (note report variables are summed elsewhere)

        SumZoneImpacts();
    }

    void RefrigSystemData::CalcDetailedSystem(int const SysNum)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL, Assisted by Hugh Henderson
        //       DATE WRITTEN   Spring 2008
        //       Using condenser solution algorithms written by Richard Raustad, FSEC
        //          Oct/Nov 2004, and MODIFIED by Shirey, FSEC Dec 2004, and Hudson, ORNL in 2007
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Find the power and energy needed to meet the refrigeration loads for a particular detailed
        // refrigeration system comprised of multiple cases, one condenser, and multiple compressors.

        // METHODOLOGY EMPLOYED:
        // Sum the refrigeration loads on the system and determine the required evaporating temperature.
        // Using the initial estimate for condensing temperature, dispatch the compressors to
        // determine the needed power, energy consumption, and refrigerant mass flow.
        // Calculate the condenser fan/pump power and consumption.
        // Calculate the condensing temperature as a function of environment and load.
        // Resolve the impact of subcooler heat transfer between and among systems
        // Iterate until the calculated refrigerant mass flow through the compressors converges, which
        // typically requires less than 5 iterations. This was found to be more sensitive than converging
        // upon the calculated condensing temperature.

        // REFERENCES:
        // "Impact of ASHRAE Standard 62-1989 on Florida Supermarkets",
        //  Florida Solar Energy Center, FSEC-CR-910-96, Final Report, Oct. 1996

        // Kyle A. Manske, Performance Optimization of Industrial Refrigeration Systems,
        //  A thesis submitted in partial fulfillment of the requirements for the degree of
        //  Master of Science, University of Wisconsin-Madison, 1999

        Real64 const ErrorTol(0.001); // Iterative solution tolerance

        bool NotBalanced = true;
        int NumIter = 0;
        Real64 ErrorMassFlowComps(0.0);        // Error in calculated low stage compressor mass flow (single- or two-stage systems)
        Real64 ErrorMassFlowHiStageComps(0.0); // Error in calculated high-stage compressor mass flow (two-stage systems only)

        // Balance This Refrigeration System using calculated refrigerant flow
        Real64 MassFlowHiStageCompsStart(0.0); // Mass flow through high-stage compressors (two-stage systems only)

        while (NotBalanced) {
            // Set values for iteration convergence tolerance check
            ++NumIter;
            // Mass flow through (low-stage) compressors (single- or two-stage systems)
            Real64 MassFlowCompsStart = this->RefMassFlowComps;

            if (this->NumStages == 2) { // Two-stage systems
                MassFlowHiStageCompsStart = this->RefMassFlowHiStageComps;
            }

            if (this->NumSubcoolers > 0) this->CalculateSubcoolers();
            this->CalculateCompressors();
            this->CalculateCondensers(SysNum);
            this->RefMassFlowtoLoads = this->TotalSystemLoad / (this->HCaseOut - this->HCaseIn);
            if (NumIter < 2) continue;
            // Previously did error check on calculated Tcondense, but not sensitive enough
            if ((this->RefMassFlowtoLoads == 0.0) || (MassFlowCompsStart == 0.0)) { //.OR. (MassFlowCasesStart == 0.0)
                ShowWarningError("Refrigeration:System: " + this->Name + " showing zero refrigeration flow.");
            } else {
                ErrorMassFlowComps = std::abs(MassFlowCompsStart - this->RefMassFlowComps) / MassFlowCompsStart;
                if (this->NumStages == 2) { // Two-stage systems
                    ErrorMassFlowHiStageComps = std::abs(MassFlowHiStageCompsStart - this->RefMassFlowHiStageComps) / MassFlowCompsStart;
                }
            } // denominator zero check
            if (NumIter > 20) break;
            if (ErrorMassFlowComps < ErrorTol) {
                if (this->NumStages == 1) {
                    NotBalanced = false;
                } else if (this->NumStages == 2 && ErrorMassFlowHiStageComps < ErrorTol) {
                    NotBalanced = false;
                }
            }
        } // error check
    }

    void TransRefrigSystemData::CalcDetailedTransSystem(int const SysNum)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Brian A. Fricke, ORNL
        //       DATE WRITTEN   Fall 2011
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Find the power and energy needed to meet the refrigeration loads for a detailed transcritical
        // CO2 refrigeration system comprised of multiple cases and walk-ins, one gas cooler, and
        // multiple compressors.

        // METHODOLOGY EMPLOYED:
        // Sum the refrigeration loads on the system and determine the required evaporating temperature.
        // Dispatch the compressors to determine the needed power, energy consumption, and refrigerant
        // mass flow. Calculate the gas cooler fan power and consumption. Calculate the gas cooler
        // outlet temperature and pressure as a function of ambient temperature. Iterate until the
        // calculated refrigerant mass flow through the receiver bypass converges, which typically
        // requires less than 5 iterations.

        Real64 const ErrorTol(0.001); // Iterative solution tolerance

        int NumIter(0);            // Iteration counter
        bool NotBalanced(true);    // Flag to indicate convergence, based on system balance
        Real64 MassFlowStart(0.5); // Initial refrigerant mass flow through receiver bypass
        Real64 ErrorMassFlow;      // Error in calculated refrigerant mass flow through receiver bypass

        while (NotBalanced) {
            ++NumIter;

            if (this->NumGasCoolers >= 1) this->CalcGasCooler(SysNum);
            this->CalculateTransCompressors();
            if (NumIter < 2) continue;
            if ((this->RefMassFlowReceiverBypass == 0.0) || (MassFlowStart == 0.0)) {
                ShowSevereError("Refrigeration:TranscriticalSystem: " + this->Name + " showing zero refrigerant flow through receiver bypass.");
                ShowContinueError("Receiver Bypass Flow = " + General::RoundSigDigits(this->RefMassFlowReceiverBypass, 6));
                ShowContinueError("Check input file to ensure that refrigeration loads on this system are not zero.");
            } else {
                ErrorMassFlow = std::abs(MassFlowStart - this->RefMassFlowReceiverBypass) / MassFlowStart;
                MassFlowStart = this->RefMassFlowReceiverBypass;
            } // denominator zero check
            if (NumIter > 20) break;
            if (ErrorMassFlow < ErrorTol) NotBalanced = false;
        } // error check
    }

    void RefrigSystemData::CalculateCondensers(int const SysNum)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall and C. R. Hudson, ORNL, Assisted by Hugh Henderson
        //       DATE WRITTEN   Spring 2008
        //       Using condenser solution algorithms written by Richard Raustad, FSEC
        //          Oct/Nov 2004, and MODIFIED by Shirey, FSEC Dec 2004, and Hudson, ORNL in 2007
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Find the condenser heat rejection for a particular detailed
        // refrigeration system and condensing temperature (part of iterative soln for cond temp).

        // METHODOLOGY EMPLOYED:
        // Calculate the condenser fan/pump power and consumption
        // using manufacturer's rating data and fan power correlations
        // from ASHRAE and evaporative effectiveness based on enthalpy
        // similar to work done by Manske.

        // From Heejin Cho, Re variable frequency drive fans,
        // "From HVAC forums, I learned that it is common practice to set a
        // minimum frequency at 15 or 20 Hz to protect motors from overheating. The
        // full speed is at 60 Hz. The ratio of minimum and maximum frequencies
        // will correspond to the ratio of minimum and maximum flow rates."

        // REFERENCES:
        // "Impact of ASHRAE Standard 62-1989 on Florida Supermarkets",
        //  Florida Solar Energy Center, FSEC-CR-910-96, Final Report, Oct. 1996

        // Kyle A. Manske, Performance Optimization of Industrial Refrigeration Systems,
        //  A thesis submitted in partial fulfillment of the requirements for the degree of
        //  Master of Science, University of Wisconsin-Madison, 1999

        // Lawrence Berkeley Laboratory and Resource Dynamics, Improving Fan Systrem Performance,
        //   A Sourcebook for Industry, DOE/GO-102003-1294, April 2003

        Real64 const BleedRateConstant(5.0E-10); // water purge rate for evaporative
        //  condensers (m3/W-s) equal to 3 GPM per 100 tons (BAC Engineering Reference)

        int CondID;               // Condenser Number
        int CondCreditWarnIndex1; // Used to sum up warning count
        int CondCreditWarnIndex2; // Used to sum up warning count
        int CondCreditWarnIndex3; // Used to sum up warning count
        int CondCreditWarnIndex4; // Used to sum up warning count
        int CondCreditWarnIndex5; // Used to sum up warning count
        int CondCreditWarnIndex6; // Used to sum up warning count
        int CondCreditWarnIndex7; // Used to sum up warning count
        int Sysloop;              // counter over number of systems attached to this condenser
        int SystemID;             // System number rejecting heat to this condenser
        bool EvapAvail;           // Control for evap condenser availability

        Real64 AirVolRatio;            // Ratio of air volume needed to remove load relative to design load
        Real64 AirDensity;             // Density of air at condenser inlet [kg/m3]
        Real64 AirDensityDry;          // Density of dry air at condenser inlet temperature [kg/m3]
        Real64 ActualFanPower;         // Fan power after adjustments for partially loaded condenser [W]
        Real64 BPress;                 // Barometric pressure at condenser air inlet node [Pa]
        Real64 CapFac;                 // Capacity Factor
        Real64 Effectiveness;          // for evap condenser, =capacity/max cap, where max cap is cap if Tairout equal Tcondense
        Real64 EnthalpyAtTcond;        // enthalpy of saturated air at Tcondense
        Real64 EnthalpyAirIn;          // Enthalpy of air entering condenser [J/kg]
        Real64 EnthalpyAirOut;         // Enthalpy of air leaving condenser [J/kg]
        Real64 FanMinAirFlowRatio;     // Minimum fan air flow ratio
        Real64 FanPowerRatio;          // Calculated fan power ratio
        Real64 HRCF(0.0);              // Heat Rejection Capacity Factor (convention for evap condensers)
        Real64 HRCFFullFlow;           // Heat Rejection Capacity Factor at full air flow
        Real64 HumRatIn;               // Humidity ratio of inlet air to condenser [kg/kg]
        Real64 HumRatOut;              // Humidity ratio of outlet air from condenser (assumed saturated) [kg/kg]
        Real64 OutWbTemp(0.0);         // Outdoor wet bulb temp at condenser air inlet node [C]
        Real64 OutDbTemp;              // Outdoor dry bulb temp at condenser air inlet node [C]
        Real64 PurgeRate;                   // Rate of water blow-down/bleed/purge in evap condenser (m3/s)
        Real64 RatedFanPower;          // local variable equal to input condenser value
        Real64 RatedAirFlowRate;       // local variable equal to input condenser value
        Real64 SinkTemp;               // Heat sink temperature used to derate fan power at reduced loads [C]
        Real64 TCondCalc;              // Calculated Condensing temperature
        Real64 TotalCondDefrostCreditLocal; // total cond credit from hot gas/brine defr for cases etc. served
        //     directly by all systems served by this condenser [W]
        Real64 TotalCondDefCredfromSysID;    // cond credit for single system [W]
        Real64 TotalLoadFromThisSystem(0.0); // total heat rejection load from the detailed system id'd in subroutine call [W]
        Real64 TotalLoadFromSystems;         // total heat rejection load from all systems served by this condenser [W]

        Real64 LocalTimeStep = DataGlobals::TimeStepZone;
        if (UseSysTimeStep) LocalTimeStep = DataHVACGlobals::TimeStepSys;

        // Initialize this condenser for this time step
        TotalCondenserPumpPower = 0.0;
        TotalBasinHeatPower = 0.0;
        TotalCondenserHeat = 0.0;
        TotalEvapWaterUseRate = 0.0;
        ActualFanPower = 0.0;
        TotalCondDefrostCreditLocal = 0.0;
        TotalLoadFromSystems = 0.0;
        EvapAvail = true;
        CondID = this->CondenserNum(1);
        auto &condenser(Condenser(CondID));
        RatedFanPower = condenser.RatedFanPower;
        RatedAirFlowRate = condenser.RatedAirFlowRate;
        FanMinAirFlowRatio = condenser.FanMinAirFlowRatio;
        CondCreditWarnIndex1 = condenser.CondCreditWarnIndex1;
        CondCreditWarnIndex2 = condenser.CondCreditWarnIndex2;
        CondCreditWarnIndex3 = condenser.CondCreditWarnIndex3;
        CondCreditWarnIndex4 = condenser.CondCreditWarnIndex4;
        CondCreditWarnIndex5 = condenser.CondCreditWarnIndex5;
        CondCreditWarnIndex6 = condenser.CondCreditWarnIndex6;
        CondCreditWarnIndex7 = condenser.CondCreditWarnIndex7;

        // Sum total condenser load and defrost credits for all systems connected to this condenser
        //  The system values will match the last time that system was solved, so some of the values may be
        //  from the previous overall solution iteration.  However, solution goes through 3 iterations if
        //  there are any shared condensers, so that's ok.
        for (Sysloop = 1; Sysloop <= condenser.NumSysAttach; ++Sysloop) {
            SystemID = condenser.SysNum(Sysloop);
            TotalCondDefCredfromSysID = System(SystemID).TotalCondDefrostCredit + System(SystemID).SumCascadeCondCredit;
            TotalCondDefrostCreditLocal += TotalCondDefCredfromSysID;
            // total heat rejection load from a single detailed system [W]
            Real64 TotalLoadFromSysID = System(SystemID).TotalSystemLoad + System(SystemID).TotCompPower + System(SystemID).TotHiStageCompPower +
                                 System(SystemID).PipeHeatLoad;
            TotalLoadFromSystems += TotalLoadFromSysID;
            if (SystemID == SysNum) TotalLoadFromThisSystem = TotalLoadFromSysID;
        } // Sysloop over every system connected to this condenser

        // for cascade condensers, condenser defrost credit gets passed on to the primary system condenser
        if (condenser.CondenserType == DataHeatBalance::RefrigCondenserTypeCascade) TotalCondDefrostCreditLocal = 0.0;

        // Calculate Total Heat rejection needed.  Assume hermetic compressors - conservative assumption
        // Note that heat rejection load carried by desuperheater hvac coils or water heaters is the
        // lagged variable from the previous time step because these are calculated after the refrigeration
        // system is solved.
        condenser.ExternalHeatRecoveredLoad = condenser.LaggedUsedWaterHeater + condenser.LaggedUsedHVACCoil;
        condenser.InternalHeatRecoveredLoad = TotalCondDefrostCreditLocal;
        condenser.TotalHeatRecoveredLoad = condenser.ExternalHeatRecoveredLoad + TotalCondDefrostCreditLocal;

        TotalCondenserHeat = TotalLoadFromSystems - TotalCondDefrostCreditLocal - condenser.ExternalHeatRecoveredLoad;
        if (TotalCondenserHeat < 0.0) {

            TotalCondenserHeat = 0.0;
            if (!DataGlobals::WarmupFlag) {
                ShowRecurringWarningErrorAtEnd("Refrigeration:System: " + this->Name +
                                                   ":heat reclaimed(defrost,other purposes) >current condenser load. ",
                                               CondCreditWarnIndex1);
                ShowRecurringContinueErrorAtEnd("For heat recovered for defrost: ASHRAE rule of thumb: <= 25% of the load on a rack ",
                                                CondCreditWarnIndex2);
                ShowRecurringContinueErrorAtEnd("should be in defrost at the same time. Consider diversifying defrost schedules.",
                                                CondCreditWarnIndex3);
                ShowRecurringContinueErrorAtEnd(
                    "For heat recovered for other purposes: this warning may be an artifact of refrigeration calculation at the load",
                    CondCreditWarnIndex4);
                ShowRecurringContinueErrorAtEnd(
                    "time step and heat recovery at the system time step. In that case, and ONLY if it occurs a large number of times",
                    CondCreditWarnIndex5);
                ShowRecurringContinueErrorAtEnd("(relative to the number of time steps in the simulation), there may be a mis-match between the",
                                                CondCreditWarnIndex6);
                ShowRecurringContinueErrorAtEnd("operating schedules of the refrigeration system and the heat recovery load.", CondCreditWarnIndex7);
            } // not warmup
        }     // total condenser heat < 0

        // Water side of water-cooled condensers simulated in SimRefrigCondenser,
        //   Here, we just need load and condensing temperatures.
        //   Condensing temperature a fixed delta (the rated approach temperature) from inlet water temp so long as above minimum.
        //   Note, if condensing temperature falls below minimum, get warning and reset but no change in water-side calculations.
        if (condenser.CondenserType == DataHeatBalance::RefrigCondenserTypeWater) {
            // Obtain water-cooled condenser inlet/outlet temps
            condenser.InletTemp = DataLoopNode::Node(condenser.InletNode).Temp;
            TCondCalc = DataLoopNode::Node(condenser.InletNode).Temp + condenser.RatedApproachT;
            if ((condenser.InletTemp < condenser.InletTempMin) || (TCondCalc < this->TCondenseMin)) {
                this->TCondense = this->TCondenseMin;
                // condenser.LowTempWarn += 1;
                if (condenser.LowTempWarnIndex == 0) {
                    ShowWarningMessage("Refrigeration:Condenser:WaterCooled " + condenser.Name);
                    ShowContinueError("Water-cooled condenser inlet temp lower than minimum allowed temp. Check returning water temperature and/or "
                                      "minimum temperature setpoints relative to minimum allowed condensing temperature.");
                }
                ShowRecurringWarningErrorAtEnd("Refrigeration:Condenser:WaterCooled " + condenser.Name +
                                                   " - Condenser inlet temp lower than minimum allowed ... continues",
                                               condenser.LowTempWarnIndex);
                // END IF
            } else {
                this->TCondense = TCondCalc;
            }

        } else if ((condenser.CondenserType == DataHeatBalance::RefrigCondenserTypeAir) ||
                   (condenser.CondenserType == DataHeatBalance::RefrigCondenserTypeEvap)) {
            // Condensing Temp, fan and other aux loads for air-cooled or evap-cooled

            // The rated capacity of air-cooled condenser was adjusted for elevation in get input step
            CapFac = TotalCondenserHeat / condenser.RatedCapacity;
            // See whether condenser is at ground level or if other air conditions(ie node) have been specified.
            //    Note that air-cooled condensers can draw air from, and reject heat to, a conditioned zone
            //    But evaporative condensers cannot.
            // Provides effective condensing temperature for air-cooled condenser (or evap if evap is scheduled off)
            if (condenser.InletAirNodeNum != 0) {
                OutDbTemp = DataLoopNode::Node(condenser.InletAirNodeNum).Temp;
                BPress = DataLoopNode::Node(condenser.InletAirNodeNum).Press;
                HumRatIn = DataLoopNode::Node(condenser.InletAirNodeNum).HumRat;
            } else {
                OutDbTemp = DataEnvironment::OutDryBulbTemp;
                BPress = DataEnvironment::OutBaroPress;
                HumRatIn = DataEnvironment::OutHumRat;
            }
            AirDensity = Psychrometrics::PsyRhoAirFnPbTdbW(BPress, OutDbTemp, HumRatIn);
            AirDensityDry = Psychrometrics::PsyRhoAirFnPbTdbW(BPress, OutDbTemp, 0.0);
            // Evaporative condensers will have their water flow shut off in cold months to avoid
            //  'spectacular' icing problems.  Ideally, the user will use the evaporative schedule input
            //  to set such a schedule.  However, sometimes, users will use a single input deck to model
            //  one building in multiple climates, and may not think to put in such a schedule in the colder
            //  climates.  To accomodate such applications, the variable EvapCutOutTdb is used as an extra
            //  check.

            if (OutDbTemp < EvapCutOutTdb) EvapAvail = false;

            // Check schedule to determine evap condenser availability
            // IF schedule exists, evap condenser can be scheduled OFF
            if ((condenser.CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) && (condenser.EvapSchedPtr > 0) &&
                (ScheduleManager::GetCurrentScheduleValue(condenser.EvapSchedPtr) == 0))
                EvapAvail = false;

            // Calculate condensing temperatures for air-cooled and evap-cooled
            if (condenser.CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) {
                // Manufacturer's HRCF regressed to produce a function of the form:
                // (Tcondense-Twb)=A1 + A2*hrcf + A3/hrcf + A4*Twb
                // HRCF defined as rated capacity divided by load
                // Apply ARI490 elevation correction factor here for evap condenser, then apply hrcf limits
                if (CapFac > 0.0) {
                    HRCF = condenser.EvapElevFact / CapFac;
                    // Condenser(CondNum)%EvapElevFact=1.0d0-3.074D-5*DataEnvironment::Elevation
                } else {
                    HRCF = MyLargeNumber;
                }
                HRCF = min(HRCF, condenser.MaxCapFacEvap);
                HRCF = max(HRCF, condenser.MinCapFacEvap);
                if (EvapAvail) {
                    OutWbTemp = Psychrometrics::PsyTwbFnTdbWPb(OutDbTemp, HumRatIn, BPress);
                    SinkTemp = OutWbTemp;
                } else {         // evaporative condenser with water spray scheduled off so use Tdb
                    HRCF /= 3.0; // reference Menske, cap of evap cond operating dry about 1/3 of rated cap
                    HRCF = max(HRCF, condenser.MinCapFacEvap);
                    SinkTemp = OutDbTemp;
                } // evap avail, still in evap condenser
                TCondCalc =
                    condenser.EvapCoeff1 + condenser.EvapCoeff2 * HRCF + condenser.EvapCoeff3 / HRCF + (1.0 + condenser.EvapCoeff4) * SinkTemp;
            } else { // air-cooled condenser
                // MinCondLoad and TempSlope came from condenser capacity curve, using curve backwards
                TCondCalc = OutDbTemp + (TotalCondenserHeat - condenser.MinCondLoad) * condenser.TempSlope;
                SinkTemp = OutDbTemp;
            } // if evap-cooled condenser

            // Fan energy calculations apply to both air- and evap-cooled condensers
            // Compare calculated condensing temps to minimum allowed to determine fan power/operating mode
            if (TCondCalc >= this->TCondenseMin) {
                this->TCondense = TCondCalc;
                ActualFanPower = RatedFanPower;
                AirVolRatio = 1.0;

            } else { // need to reduce fan speed to reduce air flow and keep Tcond at or above Tcond min
                this->TCondense = this->TCondenseMin;
                TCondCalc = this->TCondenseMin;
                // recalculate CapFac at current delta T
                if (condenser.CondenserType == DataHeatBalance::RefrigCondenserTypeAir) {
                    // current maximum condenser capacity at delta T present for minimum condensing temperature [W]
                    Real64 CurMaxCapacity = CurveManager::CurveValue(condenser.CapCurvePtr, (this->TCondenseMin - OutDbTemp));
                    CapFac = TotalCondenserHeat / CurMaxCapacity;
                    AirVolRatio = max(FanMinAirFlowRatio, std::pow(CapFac, CondAirVolExponentDry)); // Fans limited by minimum air flow ratio
                    AirVolRatio = min(AirVolRatio, 1.0);
                } else { // condenser.CondenserType == DataHeatBalance::RefrigCondenserTypeEvap
                    HRCFFullFlow = HRCF;
                    // if evap condenser need to back calculate the operating capacity using HRCF relationship, given known Tcond
                    Real64 QuadBterm = condenser.EvapCoeff1 - (this->TCondense - SinkTemp) + condenser.EvapCoeff4 * SinkTemp;
                    Real64 Sqrtterm = pow_2(QuadBterm) - 4.0 * condenser.EvapCoeff2 * condenser.EvapCoeff3;
                    if (Sqrtterm < 0.0) { // only happens for very high wet bulb temps
                        HRCF = condenser.EvapElevFact * condenser.MaxCapFacEvap;
                        if (!EvapAvail) HRCF /= 3.0;
                        HRCF = max(HRCF, condenser.MinCapFacEvap);
                    } else {
                        HRCF = condenser.EvapElevFact * (-QuadBterm - std::sqrt(Sqrtterm)) / (2.0 * condenser.EvapCoeff2);
                        if (!EvapAvail) HRCF /= 3.0;
                        HRCF = min(HRCF, condenser.MaxCapFacEvap);
                        HRCF = max(HRCF, condenser.MinCapFacEvap);
                    }                             // sqrtterm
                    CapFac = HRCF / HRCFFullFlow; // note, HRCFFullFlow previously limited between min and max,so can't be zero
                    if (EvapAvail) {
                        AirVolRatio = max(FanMinAirFlowRatio, std::pow(CapFac, CondAirVolExponentEvap)); // Fans limited by minimum air flow ratio
                    } else {                                                                             // evap not available
                        AirVolRatio = max(FanMinAirFlowRatio, std::pow(CapFac, CondAirVolExponentDry));  // Fans limited by minimum air flow ratio
                    }                                                                                    // evap available
                    AirVolRatio = min(AirVolRatio, 1.0);
                } // condenser type = DataHeatBalance::RefrigCondenserTypeAir with else for evap

                {
                    auto const SELECT_CASE_var(condenser.FanSpeedControlType);
                    if (SELECT_CASE_var == FanVariableSpeed) { // fan power law, adjusted for reality, applies
                        FanPowerRatio = std::pow(AirVolRatio, 2.5);
                        ActualFanPower = FanPowerRatio * RatedFanPower;
                    } else if (SELECT_CASE_var == FanConstantSpeed) {
                        ActualFanPower = AirVolRatio * std::exp(1.0 - AirVolRatio) * RatedFanPower;
                    } else if (SELECT_CASE_var == FanConstantSpeedLinear) {
                        ActualFanPower = AirVolRatio * RatedFanPower;
                    } else if (SELECT_CASE_var == FanTwoSpeed) {
                        // low speed setting of 1/2 fan speed can give up to 60% of capacity.
                        // 1/2 speed corresonds to ~1/8 power consumption (FanHalfSpeedRatio = 1/(2**2.5) = 0.1768)
                        // dampers are used to control flow within those two ranges as in FanConstantSpeed
                        Real64 const air_vol_fan_power_fac(std::exp(1.0 - AirVolRatio) * RatedFanPower);
                        ActualFanPower = AirVolRatio * air_vol_fan_power_fac;
                        if (CapFac < CapFac60Percent) ActualFanPower = ((AirVolRatio + 0.4) * FanHalfSpeedRatio) * air_vol_fan_power_fac;
                    }
                } // fan speed control type
            }     // Tcondense >= Tcondense minimum

            if ((condenser.CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) && (EvapAvail)) {
                // calculate evap water use,  need to include bleed down/purge water as well as water
                // actually evaporated.  Use BAC Engineering Reference value of 3 gpm/100 tons because it's more
                // conservative than the ASHRAE value.
                //  Also, based on experience, running the evap water when outdoor T near freezing
                //  leads to 'spectacular' ice, so schedule evap off when Tdb <=4 C.
                // Calculate bleed/purge rate of water loss as a function of capacity, 3 gpm/100 tons refrigeration
                PurgeRate = TotalCondenserHeat * BleedRateConstant;
                EnthalpyAirIn = Psychrometrics::PsyHFnTdbW(OutDbTemp, HumRatIn);
                // calculate effectiveness at rated conditions, so use Tcondcalc)
                EnthalpyAtTcond = Psychrometrics::PsyHFnTdbRhPb(TCondCalc, 1.0, BPress);
                Effectiveness = TotalCondenserHeat / (RatedAirFlowRate * AirDensity * (EnthalpyAtTcond - EnthalpyAirIn));
                // need to limit max effectiveness for errors due to working beyond limits of HRCF in manuf data
                Effectiveness = min(Effectiveness, 0.9);
                EnthalpyAirOut = EnthalpyAirIn + Effectiveness * (EnthalpyAtTcond - EnthalpyAirIn);
                // Air leaving the evaporative condenser is saturated
                Real64 TAirOut = Psychrometrics::PsyTsatFnHPb(EnthalpyAirOut, BPress);
                HumRatOut = Psychrometrics::PsyWFnTdpPb(TAirOut, BPress);
                TotalEvapWaterUseRate =
                    PurgeRate + RatedAirFlowRate * AirVolRatio * AirDensityDry * (HumRatOut - HumRatIn) / Psychrometrics::RhoH2O(OutWbTemp);
                // assumes evap water pump runs whenever evap cooling is available to minimize scaling
                TotalCondenserPumpPower = condenser.EvapPumpPower;
                // calculate basin water heater load
                if (TotalCondenserHeat == 0.0 && OutDbTemp < condenser.BasinHeaterSetPointTemp) {
                    TotalBasinHeatPower = max(0.0, condenser.BasinHeaterPowerFTempDiff * (condenser.BasinHeaterSetPointTemp - OutDbTemp));
                    // provide warning if no heater power exists
                    if (TotalBasinHeatPower == 0.0) {
                        // condenser.EvapFreezeWarn = condenser.EvapFreezeWarn + 1;
                        if (condenser.EvapFreezeWarnIndex == 0) {
                            ShowWarningMessage("Refrigeration Condenser " + condenser.Name +
                                               " - Evap cooling of condenser underway with no basin heater power");
                            ShowContinueError("and condenser inlet air dry-bulb temp at or below the basin heater setpoint temperature.");
                            ShowContinueErrorTimeStamp("Continuing simulation.");
                        }
                        ShowRecurringWarningErrorAtEnd("Refrigeration Condenser " + condenser.Name +
                                                           " - Evap cooling of condenser underway with no basin heater power ... continues",
                                                       condenser.EvapFreezeWarnIndex);
                        // END IF  !freeze warnings <= 5
                    } // basin power == 0
                }     // no load and cold outside
            }         // EvapAvail

        } else if (condenser.CondenserType ==
                   DataHeatBalance::RefrigCondenserTypeCascade) { // continuing Condenser type = water, (evap or air), or cascade
            // Cascade condenser does not iterate.  Condensing temperature specified as a load on higher temp system
            //    or floats to meet other loads on that system
            // therese ** future - here and for new phase change heat exchanger - need to handle unmet loads!

            this->TCondense = condenser.RatedTCondense;

            if ((this->NumNonCascadeLoads > 0) && (condenser.CascadeTempControl == CascadeTempFloat)) {
                this->TCondense = System(condenser.CascadeSinkSystemID).TEvapNeeded + condenser.RatedApproachT;
                if (this->TCondense < this->TCondenseMin) {
                    this->TCondense = this->TCondenseMin;
                    ShowRecurringWarningErrorAtEnd("Refrigeration Condenser " + condenser.Name +
                                                       " - Cascade condenser floating condensing temperature less than specified minimum condensing "
                                                       "temperature. Minimum specified temperature used for system below cascade condenser. No "
                                                       "correction made for system absorbing heat rejected by the cascade condenser.",
                                                   condenser.EvapFreezeWarnIndex);
                } // floating condensing temperature less than specified min for system
            }     // floating temperature
        }         // Condenser type = water, (evap or air), or cascade

        condenser.ActualFanPower = ActualFanPower;
        condenser.FanElecEnergy = ActualFanPower * LocalTimeStep * DataGlobals::SecInHour;
        condenser.EvapWaterConsumpRate = TotalEvapWaterUseRate;
        condenser.EvapWaterConsumption = TotalEvapWaterUseRate * LocalTimeStep * DataGlobals::SecInHour;
        condenser.ActualEvapPumpPower = TotalCondenserPumpPower;
        condenser.EvapPumpConsumption = TotalCondenserPumpPower * LocalTimeStep * DataGlobals::SecInHour;
        condenser.BasinHeaterPower = TotalBasinHeatPower;
        condenser.BasinHeaterConsumption = TotalBasinHeatPower * LocalTimeStep * DataGlobals::SecInHour;
        condenser.CondLoad = TotalCondenserHeat;
        condenser.CondEnergy = TotalCondenserHeat * LocalTimeStep * DataGlobals::SecInHour;
        condenser.CondCreditWarnIndex1 = CondCreditWarnIndex1;
        condenser.CondCreditWarnIndex2 = CondCreditWarnIndex2;
        condenser.CondCreditWarnIndex3 = CondCreditWarnIndex3;
        condenser.CondCreditWarnIndex4 = CondCreditWarnIndex4;
        condenser.CondCreditWarnIndex5 = CondCreditWarnIndex5;
        condenser.CondCreditWarnIndex6 = CondCreditWarnIndex6;
        condenser.CondCreditWarnIndex7 = CondCreditWarnIndex7;
        condenser.ExternalEnergyRecovered = condenser.ExternalHeatRecoveredLoad * LocalTimeStep * DataGlobals::SecInHour;
        condenser.InternalEnergyRecovered = condenser.InternalHeatRecoveredLoad * LocalTimeStep * DataGlobals::SecInHour;
        condenser.TotalHeatRecoveredEnergy = condenser.TotalHeatRecoveredLoad * LocalTimeStep * DataGlobals::SecInHour;
        this->NetHeatRejectLoad = TotalCondenserHeat * TotalLoadFromThisSystem / TotalLoadFromSystems;
        this->NetHeatRejectEnergy = this->NetHeatRejectLoad * LocalTimeStep * DataGlobals::SecInHour;

        // set water system demand request (if needed)
        if (condenser.EvapWaterSupplyMode == WaterSupplyFromTank) {
            DataWater::WaterStorage(condenser.EvapWaterSupTankID).VdotRequestDemand(condenser.EvapWaterTankDemandARRID) =
                condenser.EvapWaterConsumpRate;
        }
    }

    void TransRefrigSystemData::CalcGasCooler(int const SysNum)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Brian A. Fricke, ORNL
        //       DATE WRITTEN   Fall 2011
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Find the gas cooler outlet temperature, the optimum gas cooler pressure, heat rejection,
        // fan power, and fan energy for a detailed transcritical CO2 refrigeration system.

        // METHODOLOGY EMPLOYED:
        // For a specified gas cooler outlet temperature in transcritical operation, there is an optimal gas cooler
        // pressure which produces the highest COP. A curve-fit equation similar to that presented by Ge and Tassou
        // (2011) and Sawalha (2008) is used to determine the optimum gas cooler pressure for a given gas cooler
        // outlet temperature. In subcritical operation, the condensing temperature and pressure are allowed to
        // float with ambient conditions, above the minimum condensing temperature.

        // REFERENCES:
        // Ge, Y.T., and S.A. Tassou. 2011. Performance evaluation and optimal design of supermarket refrigeration
        //     systems with supermarket model "SuperSim", Part I: Model description and validation. International
        //     Journal of Refrigeration 34: 527-539.
        // Ge, Y.T., and S.A. Tassou. 2011. Performance evaluation and optimal design of supermarket refrigeration
        //     systems with supermarket model "SuperSim", Part II: Model applications. International Journal of
        //     Refrigeration 34: 540-549.
        // Sawalha, S. 2008. Theoretical evaluation of trans-critical CO2 systems in supermarket refrigeration,
        //     Part I: Modeling, simulation and optimization of two system solutions. International Journal of
        //     Refrigeration 31: 516-524.
        // Sawalha, S. 2008. Theoretical evaluation of trans-critical CO2 systems in supermarket refrigeration,
        //     Part II: System modifications and comparisons of different solutions. International Journal of
        //     Refrigeration 31: 525-534.

        static std::string const RoutineName("RefrigeratedCase:CalcGasCooler");

        int GasCoolerCreditWarnIndex;     // Warning counter
        Real64 ActualFanPower;            // Fan power after adjustments for partially loaded gas cooler [W]
        Real64 AirVolRatio;               // Ratio of air volume needed to remove load relative to design load
        Real64 FanMinAirFlowRatio;        // Minimum fan air flow ratio
        Real64 FanPowerRatio;             // Calculated fan power ratio
        Real64 OutDbTemp;                 // Outdoor dry bulb temperature at gas cooler air inlet node [C]
        Real64 RatedFanPower;             // Rated fan power for this gas cooler [W]
        Real64 TotalCondDefCredfromSysID; // Gas cooler defrost credit for single system [W]
        Real64 TotalCondDefrostCreditLocal; // Total gas cooler credit from hot gas/brine defrost for cases etc. served
        //     directly by all systems served by this gas cooler [W]
        Real64 TotalGasCoolerHeat;           // Total gas cooler heat from system [W]
        Real64 TotalLoadFromSysID;           // Total heat rejection load from a single detailed system [W]
        Real64 TotalLoadFromSystems;         // Total heat rejection load from all systems served by this condenser [W]
        Real64 TotalLoadFromThisSystem(0.0); // Total heat rejection load from the detailed system identified in subroutine call [W]

        Real64 LocalTimeStep = DataGlobals::TimeStepZone;
        if (UseSysTimeStep) LocalTimeStep = DataHVACGlobals::TimeStepSys;

        // Initialize this gas cooler for this time step
        ActualFanPower = 0.0;
        TotalCondDefrostCreditLocal = 0.0;
        TotalLoadFromSystems = 0.0;
        int GasCoolerID = this->GasCoolerNum(1);
        RatedFanPower = GasCooler(GasCoolerID).RatedFanPower;
        FanMinAirFlowRatio = GasCooler(GasCoolerID).FanMinAirFlowRatio;
        GasCoolerCreditWarnIndex = GasCooler(GasCoolerID).GasCoolerCreditWarnIndex;

        for (int Sysloop = 1; Sysloop <= GasCooler(GasCoolerID).NumSysAttach; ++Sysloop) {
            int SystemID = GasCooler(GasCoolerID).SysNum(Sysloop);
            TotalCondDefCredfromSysID = TransSystem(SystemID).TotalCondDefrostCredit;
            TotalCondDefrostCreditLocal += TotalCondDefCredfromSysID;
            TotalLoadFromSysID = TransSystem(SystemID).TotalSystemLoadLT + TransSystem(SystemID).TotalSystemLoadMT +
                                 TransSystem(SystemID).TotCompPowerLP + TransSystem(SystemID).TotCompPowerHP + TransSystem(SystemID).PipeHeatLoadLT +
                                 TransSystem(SystemID).PipeHeatLoadMT;
            TotalLoadFromSystems += TotalLoadFromSysID;
            if (SystemID == SysNum) TotalLoadFromThisSystem = TotalLoadFromSysID;
        } // Sysloop over every system connected to this gas cooler

        // Calculate Total Heat rejection needed.
        GasCooler(GasCoolerID).InternalHeatRecoveredLoad = TotalCondDefrostCreditLocal;
        GasCooler(GasCoolerID).TotalHeatRecoveredLoad = TotalCondDefrostCreditLocal;
        TotalGasCoolerHeat = TotalLoadFromSystems - TotalCondDefrostCreditLocal;

        if (TotalGasCoolerHeat < 0.0) {
            TotalGasCoolerHeat = 0.0;
            if (!DataGlobals::WarmupFlag)
                ShowRecurringWarningErrorAtEnd("Refrigeration:TranscriticalSystem: " + this->Name +
                                                   ":heat reclaimed (defrost,other purposes) is greater than current gas cooler load. ASHRAE rule of "
                                                   "thumb: <= 25% of the load on a system should be in defrost at the same time. Consider "
                                                   "diversifying defrost schedules.",
                                               GasCoolerCreditWarnIndex);
        } // total gas cooler heat < 0

        // The rated capacity of air-cooled gas cooler was adjusted for elevation in get input step
        Real64 CapFac = TotalGasCoolerHeat / GasCooler(GasCoolerID).RatedCapacity;
        // See whether gas cooler is at ground level or if other air conditions (ie node) have been specified.
        // Note that air-cooled gas coolers can draw air from, and reject heat to, a conditioned zone.
        if (GasCooler(GasCoolerID).InletAirNodeNum != 0) {
            OutDbTemp = DataLoopNode::Node(GasCooler(GasCoolerID).InletAirNodeNum).Temp;
        } else {
            OutDbTemp = DataEnvironment::OutDryBulbTemp;
        }
        // Determine gas cooler outlet temperature and pressure
        // Transcritical:  Gas cooler outlet temperature based on ambient temperature and approach temperature.
        //                 Determine optimum gas cooler pressure to maximize COP.
        // Subcritical:  Allow condensing temperature and pressure to float between minimum condensing temperature and
        //               transition temperature.
        if (OutDbTemp > GasCooler(GasCoolerID).TransitionTemperature) { // Gas cooler in transcritical operation
            GasCooler(GasCoolerID).TGasCoolerOut = OutDbTemp + GasCooler(GasCoolerID).GasCoolerApproachT;
            GasCooler(GasCoolerID).PGasCoolerOut = 1.0e5 * (2.3083 * DataEnvironment::OutDryBulbTemp + 11.9);
            if (GasCooler(GasCoolerID).PGasCoolerOut < 7.5e6) { // Ensure gas cooler pressure is at least 7.5 MPa for transcritical operation
                GasCooler(GasCoolerID).PGasCoolerOut = 7.5e6;
            }
            GasCooler(GasCoolerID).HGasCoolerOut = FluidProperties::GetSupHeatEnthalpyRefrig(
                this->RefrigerantName, GasCooler(GasCoolerID).TGasCoolerOut, GasCooler(GasCoolerID).PGasCoolerOut, this->RefIndex, RoutineName);
            GasCooler(GasCoolerID).TransOpFlag = true;
        } else { // Gas cooler in subcritical operation
            GasCooler(GasCoolerID).TGasCoolerOut = OutDbTemp + GasCooler(GasCoolerID).SubcriticalTempDiff;
            if (GasCooler(GasCoolerID).TGasCoolerOut > 30.978) { //  Gas temperature should be less than critical temperature
                GasCooler(GasCoolerID).PGasCoolerOut = 7.2e6;    //  Fix the pressure to be subcritical
                GasCooler(GasCoolerID).TGasCoolerOut = FluidProperties::GetSatTemperatureRefrig(
                    this->RefrigerantName, GasCooler(GasCoolerID).PGasCoolerOut, this->RefIndex, RoutineName);
            } else if (GasCooler(GasCoolerID).TGasCoolerOut >
                       GasCooler(GasCoolerID).MinCondTemp) { //  Allow condensing temperature to float above the minimum
                GasCooler(GasCoolerID).PGasCoolerOut =
                    FluidProperties::GetSatPressureRefrig(this->RefrigerantName, GasCooler(GasCoolerID).TGasCoolerOut, this->RefIndex, RoutineName);
            } else { //  Don't allow condensing temperature to drop below minimum
                GasCooler(GasCoolerID).TGasCoolerOut = GasCooler(GasCoolerID).MinCondTemp;
                GasCooler(GasCoolerID).PGasCoolerOut =
                    FluidProperties::GetSatPressureRefrig(this->RefrigerantName, GasCooler(GasCoolerID).TGasCoolerOut, this->RefIndex, RoutineName);
            }
            GasCooler(GasCoolerID).HGasCoolerOut =
                FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, GasCooler(GasCoolerID).TGasCoolerOut, 0.0, this->RefIndex, RoutineName);
            GasCooler(GasCoolerID).TransOpFlag = false;
        } // (OutDbTemp > TransitionTemperature)

        if (GasCooler(GasCoolerID).TGasCoolerOut < 30.978) {
            GasCooler(GasCoolerID).CpGasCoolerOut = FluidProperties::GetSatSpecificHeatRefrig(
                this->RefrigerantName, GasCooler(GasCoolerID).TGasCoolerOut, 0.0, this->RefIndex, RoutineName);
        } else {
            GasCooler(GasCoolerID).CpGasCoolerOut = 0.0;
        }

        // Gas cooler fan energy calculations
        AirVolRatio = max(FanMinAirFlowRatio, std::pow(CapFac, CondAirVolExponentDry)); // Fans limited by minimum air flow ratio

        {
            auto const SELECT_CASE_var(GasCooler(GasCoolerID).FanSpeedControlType);
            if (SELECT_CASE_var == FanVariableSpeed) { // fan power law, adjusted for reality, applies
                FanPowerRatio = std::pow(AirVolRatio, 2.5);
                ActualFanPower = FanPowerRatio * RatedFanPower;
            } else if (SELECT_CASE_var == FanConstantSpeed) {
                ActualFanPower = AirVolRatio * std::exp(1.0 - AirVolRatio) * RatedFanPower;
            } else if (SELECT_CASE_var == FanConstantSpeedLinear) {
                ActualFanPower = AirVolRatio * RatedFanPower;
            } else if (SELECT_CASE_var == FanTwoSpeed) {
                // low speed setting of 1/2 fan speed can give up to 60% of capacity.
                // 1/2 speed corresonds to ~1/8 power consumption (FanHalfSpeedRatio = 1/(2**2.5) = 0.1768)
                // dampers are used to control flow within those two ranges as in FanConstantSpeed
                ActualFanPower = AirVolRatio * std::exp(1.0 - AirVolRatio) * RatedFanPower;
                if (CapFac < CapFac60Percent)
                    ActualFanPower = ((AirVolRatio + 0.4) * (FanHalfSpeedRatio)) * std::exp(1.0 - AirVolRatio) * RatedFanPower;
            }
        } // fan speed control type

        GasCooler(GasCoolerID).ActualFanPower = ActualFanPower;
        GasCooler(GasCoolerID).FanElecEnergy = ActualFanPower * LocalTimeStep * DataGlobals::SecInHour;
        GasCooler(GasCoolerID).GasCoolerLoad = TotalGasCoolerHeat;
        GasCooler(GasCoolerID).GasCoolerEnergy = TotalGasCoolerHeat * LocalTimeStep * DataGlobals::SecInHour;
        GasCooler(GasCoolerID).GasCoolerCreditWarnIndex = GasCoolerCreditWarnIndex;
        GasCooler(GasCoolerID).InternalEnergyRecovered = GasCooler(GasCoolerID).InternalHeatRecoveredLoad * LocalTimeStep * DataGlobals::SecInHour;
        GasCooler(GasCoolerID).TotalHeatRecoveredEnergy = GasCooler(GasCoolerID).TotalHeatRecoveredLoad * LocalTimeStep * DataGlobals::SecInHour;
        this->NetHeatRejectLoad = TotalGasCoolerHeat * TotalLoadFromThisSystem / TotalLoadFromSystems;
        this->NetHeatRejectEnergy = this->NetHeatRejectLoad * LocalTimeStep * DataGlobals::SecInHour;
    }

    void RefrigSystemData::CalculateCompressors()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL, Assisted by Hugh Henderson
        //       DATE WRITTEN   Spring 2008
        //       MODIFIED       Brian Fricke, ORNL, March 2012, added two-stage compression
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Find the Compressor power, energy, capacity, and efficiency for a particular detailed
        // refrigeration system.  Routine is capable of modeling single-stage and two-stage
        // compression refrigeration systems.

        // METHODOLOGY EMPLOYED:
        // USe ARI compressor performance curves, the evaporating temperature and condensing temperature

        // REFERENCES:
        // "Impact of ASHRAE Standard 62-1989 on Florida Supermarkets",
        //  Florida Solar Energy Center, FSEC-CR-910-96, Final Report, Oct. 1996

        // ARI Standard 540, 2004, Standard for Performance Rating of Positive Displacement Refrigerant
        //  Compressors and Compressor Units, Air-Conditioning & Refrigeration Institute,Arlington VA

        // SUBROUTINE PARAMETER DEFINITIONS:
        // Following constants approp for R22, R134a, R404a, R507, R410a, R407c, future allow input?
        //   May want to allow input to reflect larger pipes selected to reduce delta P and increase compressor efficiency.
        // NOTE, these DelT...Pipes reflect the decrease in Pressure in the pipes, NOT thermal transfer through the pipe walls.
        Real64 const DelTSuctPipes(1.0);  // Tsat drop corresponding to P drop in suction pipes, ASHRAE 2006 p 2.4 (C)
        Real64 const DelTDischPipes(0.5); // Tsat drop corresponding to P drop in discharge pipes, ASHRAE 2006 p 2.5 (C)

        static std::string const RoutineName("RefrigeratedCase:CalculateCompressors");
        Real64 CaseEnthalpyChangeRated;   // Enthalpy change in cases at compressor rated cond, J/kg
        Real64 CapacityCorrection;        // Capacity at existing subcool/superheat over cap at rated conditions
        Real64 CpSatVapCondense;          // Specific heat of vapor at cond temp J/kg-C
        Real64 DensityRated;              // Density of inlet gas at rated superheat, m3/kg
        Real64 DensityActual;             // Density of superheated gas at compressor inlet, m3/kg
        Real64 HCompInRated(0.0);         // Enthalpy entering compressor at rated superheat, J/kg //Autodesk:Init
        Real64 HCaseInRated(0.0);         // Enthalpy entering cases at rated subcooling, J/kg //Autodesk:Init
        Real64 HSatVapCondense;           // Enthalpy of saturated vapor at T condense, J/kg
        Real64 HsatVaporforTevapneeded;   // Enthalpy saturated vapor at temperature needed at evaporator
        Real64 LFLastComp;                // Load factor for last compressor dispatched
        Real64 MassCorrection;            // Mass flow at existing subcool/superheat over cap at rated conditions
        Real64 NeededCapacity;            // Sum of case loads and mech subcooler loads on suction group
        Real64 PSuction;                  // Suction Pressure
        Real64 PCond;                     // Condensing pressure
        Real64 PEvap;                     // Evaporating pressure
        Real64 TCompOutEstimate;          // Estimated temperature out of the compressor, used to flag whether heat reclaim is reasonable, C
        Real64 TempInRated(0.0);          // Temperature entering compressor at rated superheat, C //Autodesk:Init
        Real64 TotalEnthalpyChangeActual; // Actual enthalpy change in cases and cold side of LSHX, J/kg
        Real64 TsatforPsuct;              // Tsat for PSuction, C
        Real64 TsatforPdisch(0.0);        // Tsat for Pdischarge, c
        int NumComps;                     // Number of low-stage or high-stage compressors in system
        Real64 HHiStageCompIn;            // Enthalpy at inlet of high-stage compressor (J/kg)
        Real64 HCaseInRated_base(0.0), HCompInRated_base(0.0); // Autodesk:Tuned Intermediate values for performance tuning

        Real64 LocalTimeStep = DataGlobals::TimeStepZone;
        if (UseSysTimeStep) LocalTimeStep = DataHVACGlobals::TimeStepSys;
        Real64 const LocalTimeStepSec(LocalTimeStep * DataGlobals::SecInHour);

        int CondID = this->CondenserNum(1);
        auto const &Condenser1(Condenser(CondID));
        Real64 const AccumLoad = max(0.0, (this->UnmetEnergy / LocalTimeStepSec)); // Load due to previously unmet compressor loads
        Real64 const NeededCapacity_base(this->TotalSystemLoad + AccumLoad + this->PipeHeatLoad + this->LSHXTrans);

        // Before dispatching compressors, zero sum of compressor outputs and zero each compressor
        this->TotCompCapacity = 0.0;
        this->RefMassFlowComps = 0.0;
        this->TotCompPower = 0.0;
        if (this->NumStages == 2) {
            this->TotHiStageCompCapacity = 0.0;
            this->RefMassFlowHiStageComps = 0.0;
            this->TotHiStageCompPower = 0.0;
        }

        for (int CompIndex = 1; CompIndex <= this->NumCompressors; ++CompIndex) {
            int CompID = this->CompressorNum(CompIndex);
            auto &Compressor_CompID(Compressor(CompID));
            Compressor_CompID.Power = 0.0;
            Compressor_CompID.MassFlow = 0.0;
            Compressor_CompID.Capacity = 0.0;
            Compressor_CompID.ElecConsumption = 0.0;
            Compressor_CompID.CoolingEnergy = 0.0;
            Compressor_CompID.LoadFactor = 0.0;
        }
        if (this->NumStages == 2) {
            for (int CompIndex = 1; CompIndex <= this->NumHiStageCompressors; ++CompIndex) {
                int CompID = this->HiStageCompressorNum(CompIndex);
                auto &Compressor_CompID(Compressor(CompID));
                Compressor_CompID.Power = 0.0;
                Compressor_CompID.MassFlow = 0.0;
                Compressor_CompID.Capacity = 0.0;
                Compressor_CompID.ElecConsumption = 0.0;
                Compressor_CompID.CoolingEnergy = 0.0;
                Compressor_CompID.LoadFactor = 0.0;
            }
        }

        // Determine properties at case inlet and compressor inlet
        for (int StageIndex = 1; StageIndex <= min(2, this->NumStages); ++StageIndex) {
            if (StageIndex == 1) {                              // Do single-stage or low-stage calculations
                if (this->NumStages == 1) {                           // Single-stage system
                    NeededCapacity = NeededCapacity_base;       // because compressor capacity rated from txv to comp inlet
                    TsatforPdisch = this->TCondense + DelTDischPipes; // need (Psat of (Tcond + delT corresponding to delP disch Pipes))
                    TsatforPsuct = this->TEvapNeeded - DelTSuctPipes; // need (Psat of (Tevap - delT corresponding to del P suct Pipes))
                    HsatVaporforTevapneeded =
                        FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TEvapNeeded, 1.0, this->RefIndex, RoutineName);
                    this->HSatLiqCond =
                        FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TCondense, 0.0, this->RefIndex, RoutineName);
                    this->CpSatLiqCond =
                        FluidProperties::GetSatSpecificHeatRefrig(this->RefrigerantName, this->TCondense, 0.0, this->RefIndex, RoutineName);
                    // HCaseIn is a function of the condenser rated subcooling, not the compressor rated subcooling
                    // TCompIn needs to include case superheat as well as Temp change from lshx subcoolers
                    // Calculate both here unless set previously by subcooler subroutine
                    // HCaseOut corresponds to (tevapneeded + case superheat)
                    // future - visit how parameter 'casesuperheat' applies when using walk-ins or transfer loads
                    if (this->NumSubcoolers == 0) { // No subcooler on this system
                        this->HCaseIn = this->HSatLiqCond - this->CpSatLiqCond * Condenser1.RatedSubcool;
                        this->TCompIn = this->TEvapNeeded + CaseSuperheat; //+
                        this->TLiqInActual = this->TCondense - Condenser1.RatedSubcool;
                        this->HCompIn = this->HCaseOut;
                    } else { // subcooler subroutine has been called to calc TCompIn and HCaseIn
                        this->HCompIn = this->HCaseOut + this->CpSatVapEvap * (this->TCompIn - (this->TEvapNeeded + CaseSuperheat));
                    } // whether or not subcooler routine used
                    PSuction = FluidProperties::GetSatPressureRefrig(this->RefrigerantName, TsatforPsuct, this->RefIndex, RoutineName);
                    NumComps = this->NumCompressors;
                } else { // Low-stage side of two-stage system
                    PCond = FluidProperties::GetSatPressureRefrig(this->RefrigerantName, this->TCondense, this->RefIndex, RoutineName);
                    PEvap = FluidProperties::GetSatPressureRefrig(this->RefrigerantName, this->TEvapNeeded, this->RefIndex, RoutineName);
                    this->PIntercooler = std::sqrt(PCond * PEvap);
                    this->TIntercooler =
                        FluidProperties::GetSatTemperatureRefrig(this->RefrigerantName, this->PIntercooler, this->RefIndex, RoutineName);
                    NeededCapacity = NeededCapacity_base;          // because compressor capacity rated from txv to comp inlet
                    TsatforPdisch = this->TIntercooler + DelTDischPipes; // need (Psat of (Tinter + delT corresponding to delP disch Pipes))
                    TsatforPsuct = this->TEvapNeeded - DelTSuctPipes;    // need (Psat of (Tevap - delT corresponding to del P suct Pipes))
                    HsatVaporforTevapneeded =
                        FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TEvapNeeded, 1.0, this->RefIndex, RoutineName);
                    this->HSatLiqCond =
                        FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TCondense, 0.0, this->RefIndex, RoutineName);
                    this->CpSatLiqCond =
                        FluidProperties::GetSatSpecificHeatRefrig(this->RefrigerantName, this->TCondense, 0.0, this->RefIndex, RoutineName);
                    // HCaseIn is a function of the condenser rated subcooling, not the compressor rated subcooling
                    // TCompIn needs to include case superheat as well as Temp change from lshx subcoolers
                    // Calculate both here unless set previously by subcooler subroutine
                    // HCaseOut corresponds to (tevapneeded + case superheat)
                    if (this->NumSubcoolers == 0) {       // No subcooler on this system
                        if (this->IntercoolerType == 1) { // Flash Intercooler
                            this->HCaseIn =
                                FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TIntercooler, 0.0, this->RefIndex, RoutineName);
                            this->TLiqInActual = this->TIntercooler;
                        } else if (this->IntercoolerType == 2) { // Shell-and-Coil Intercooler
                            this->TLiqInActual = this->TCondense - Condenser1.RatedSubcool -
                                                 this->IntercoolerEffectiveness * (this->TCondense - Condenser1.RatedSubcool - this->TIntercooler);
                            this->HCaseIn = this->HSatLiqCond - this->CpSatLiqCond * (this->TCondense - this->TLiqInActual);
                        }                                                    // IntercoolerType
                        this->TCompIn = this->TEvapNeeded + CaseSuperheat; //+
                        this->HCompIn = this->HCaseOut;
                    } else { // subcooler subroutine has been called to calc TCompIn and HCaseIn
                        this->HCompIn = this->HCaseOut + this->CpSatVapEvap * (this->TCompIn - (this->TEvapNeeded + CaseSuperheat));
                    } // whether or not subcooler routine used
                    PSuction = FluidProperties::GetSatPressureRefrig(this->RefrigerantName, TsatforPsuct, this->RefIndex, RoutineName);
                    NumComps = this->NumCompressors;
                }    // NumStages
            } else { // Two-stage system, high-stage side
                NeededCapacity = NeededCapacity_base + this->TotCompPower;
                TsatforPdisch = this->TCondense + DelTDischPipes;
                TsatforPsuct = this->TIntercooler;
                HsatVaporforTevapneeded =
                    FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TIntercooler, 1.0, this->RefIndex, RoutineName);
                //				HSatLiqCond = FluidProperties::GetSatEnthalpyRefrig(RefrigerantName, TCondense, 0.0, RefIndex,
                // RoutineName
                //);
                ////Autodesk:Tuned These don't change for 2nd stage
                //				CpSatLiqCond = FluidProperties::GetSatSpecificHeatRefrig(RefrigerantName, TCondense, 0.0, RefIndex,
                //RoutineName );
                ////Autodesk:Tuned These don't change for 2nd stage
                this->HCaseIn = this->HSatLiqCond - this->CpSatLiqCond * Condenser1.RatedSubcool;
                this->TCompIn = this->TIntercooler;
                //      System(SysNum)%TLiqInActual = System(SysNum)%TCondense-Condenser(System(SysNum)%CondenserNum(1))%RatedSubcool
                this->HCompIn = HsatVaporforTevapneeded;
                PSuction = FluidProperties::GetSatPressureRefrig(this->RefrigerantName, TsatforPsuct, this->RefIndex, RoutineName);
                NumComps = this->NumHiStageCompressors;
            } // StageIndex

            // dispatch compressors to meet load, note they were listed in compressor list in dispatch order
            DensityActual = FluidProperties::GetSupHeatDensityRefrig(this->RefrigerantName,
                                                                     this->TCompIn,
                                                    PSuction,
                                                                     this->RefIndex,
                                                    RoutineName);                      // Autodesk:Tuned Hoisted out of CompIndex loop
            TotalEnthalpyChangeActual = this->HCompIn - this->HCaseIn;             // Autodesk:Tuned Hoisted out of CompIndex loop
            if (this->NumStages == 2) {                                            // Autodesk:Tuned Hoisted out of CompIndex loop
                if (StageIndex == 1) {
                    HCaseInRated_base =
                        FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TIntercooler, 0.0, this->RefIndex, RoutineName);
                } else if (StageIndex == 2) {
                    HCompInRated_base =
                        FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TIntercooler, 1.0, this->RefIndex, RoutineName);
                }
            }
            for (int CompIndex = 1; CompIndex <= NumComps; ++CompIndex) {
                int CompID;
                if (StageIndex == 1) {
                    CompID = this->CompressorNum(CompIndex);
                } else {
                    CompID = this->HiStageCompressorNum(CompIndex);
                } // StageIndex
                auto &Compressor_CompID(Compressor(CompID));

                // need to use indiv compressor's rated subcool and superheat to adjust capacity to actual conditions
                {
                    auto const SELECT_CASE_var(Compressor_CompID.SubcoolRatingType);
                    if (SELECT_CASE_var == RatedSubcooling) {
                        if (this->NumStages == 1) { // Single-stage system
                            HCaseInRated = this->HSatLiqCond - this->CpSatLiqCond * Compressor_CompID.RatedSubcool;
                        } else if (this->NumStages == 2 && StageIndex == 1) { // Two-stage system, low-stage side
                            HCaseInRated = HCaseInRated_base - this->CpSatLiqCond * Compressor_CompID.RatedSubcool;
                        } else if (this->NumStages == 2 && StageIndex == 2) { // Two-stage system, high-stage side
                            HCaseInRated = this->HSatLiqCond - this->CpSatLiqCond * Compressor_CompID.RatedSubcool;
                        }                                                   // NumStages
                    } else if (SELECT_CASE_var == RatedLiquidTemperature) { // have rated liquid temperature stored in "RatedSubcool"
                        if (this->NumStages == 1) {                         // Single-stage system
                            HCaseInRated = this->HSatLiqCond - this->CpSatLiqCond * (this->TCondense - Compressor_CompID.RatedSubcool);
                        } else if (this->NumStages == 2 && StageIndex == 1) { // Two-stage system, low-stage side
                            HCaseInRated = HCaseInRated_base - this->CpSatLiqCond * (this->TIntercooler - Compressor_CompID.RatedSubcool);
                        } else if (this->NumStages == 2 && StageIndex == 2) { // Two-stage system, high-stage side
                            HCaseInRated = this->HSatLiqCond - this->CpSatLiqCond * (this->TCondense - Compressor_CompID.RatedSubcool);
                        } // NumStages
                    }
                } // Compressor SubcoolRatingType
                {
                    auto const SELECT_CASE_var(Compressor_CompID.SuperheatRatingType);
                    if (SELECT_CASE_var == RatedSuperheat) {
                        if (this->NumStages == 1) { // Single-stage system
                            HCompInRated = HsatVaporforTevapneeded + this->CpSatVapEvap * Compressor_CompID.RatedSuperheat;
                            TempInRated = this->TEvapNeeded + Compressor_CompID.RatedSuperheat;
                        } else if (this->NumStages == 2 && StageIndex == 1) { // Two-stage system, low-stage side
                            HCompInRated = HsatVaporforTevapneeded + this->CpSatVapEvap * Compressor_CompID.RatedSuperheat;
                            TempInRated = this->TEvapNeeded + Compressor_CompID.RatedSuperheat;
                        } else if (this->NumStages == 2 && StageIndex == 2) { // Two-stage system, high-stage side
                            HCompInRated = HCompInRated_base + this->CpSatVapEvap * Compressor_CompID.RatedSuperheat;
                            TempInRated = this->TIntercooler + Compressor_CompID.RatedSuperheat;
                        }                                                      // NumStages
                    } else if (SELECT_CASE_var == RatedReturnGasTemperature) { // have rated compressor inlet temperature stored in "RatedSuperheat"
                        if (this->NumStages == 1) {                            // Single-stage system
                            TempInRated = Compressor_CompID.RatedSuperheat;
                            HCompInRated = HsatVaporforTevapneeded + this->CpSatVapEvap * (TempInRated - this->TEvapNeeded);
                        } else if (this->NumStages == 2 && StageIndex == 1) { // Two-stage system, low-stage side
                            TempInRated = Compressor_CompID.RatedSuperheat;
                            HCompInRated = HsatVaporforTevapneeded + this->CpSatVapEvap * (TempInRated - this->TEvapNeeded);
                        } else if (this->NumStages == 2 && StageIndex == 2) { // Two-stage system, high-stage side
                            TempInRated = Compressor_CompID.RatedSuperheat;
                            HCompInRated = HsatVaporforTevapneeded + this->CpSatVapEvap * (TempInRated - this->TIntercooler);
                        } // NumStages
                    }
                } // Compressor SuperheatRatingType

                CaseEnthalpyChangeRated = HCompInRated - HCaseInRated;
                DensityRated = FluidProperties::GetSupHeatDensityRefrig(this->RefrigerantName, TempInRated, PSuction, this->RefIndex, RoutineName);
                //  Adjust capacity and mass flow to reflect the specific volume change due to superheating and
                //  the increase in capacity due to extra subcooling
                MassCorrection = DensityActual / DensityRated;
                CapacityCorrection = MassCorrection * TotalEnthalpyChangeActual / CaseEnthalpyChangeRated;
                Compressor_CompID.Power = CurveManager::CurveValue(Compressor_CompID.ElecPowerCurvePtr, TsatforPsuct, TsatforPdisch);
                Compressor_CompID.Capacity =
                    CapacityCorrection * CurveManager::CurveValue(Compressor_CompID.CapacityCurvePtr, TsatforPsuct, TsatforPdisch);
                Compressor_CompID.MassFlow = Compressor_CompID.Capacity / TotalEnthalpyChangeActual;

                // calculate load factor for last compressor addded
                // assumes either cycling or part load eff = full load eff for last compressor
                if (StageIndex == 1) { // Single-stage or low-stage compressors
                    if ((this->TotCompCapacity + Compressor_CompID.Capacity) >= NeededCapacity) {
                        LFLastComp = (NeededCapacity - this->TotCompCapacity) / Compressor_CompID.Capacity;
                        Compressor_CompID.Power *= LFLastComp;
                        Compressor_CompID.MassFlow *= LFLastComp;
                        Compressor_CompID.Capacity *= LFLastComp;
                        this->TotCompCapacity += Compressor_CompID.Capacity;
                        this->RefMassFlowComps += Compressor_CompID.MassFlow;
                        this->TotCompPower += Compressor_CompID.Power;
                        Compressor_CompID.ElecConsumption = Compressor_CompID.Power * LocalTimeStepSec;
                        Compressor_CompID.CoolingEnergy = Compressor_CompID.Capacity * LocalTimeStepSec;
                        Compressor_CompID.LoadFactor = LFLastComp;
                        break; // numcomps do
                    } else {   //>= needed capacity
                        this->TotCompCapacity += Compressor_CompID.Capacity;
                        this->RefMassFlowComps += Compressor_CompID.MassFlow;
                        this->TotCompPower += Compressor_CompID.Power;
                    }    //>= needed capacity
                } else { // high-stage compressors (for two-stage systems only)
                    if ((this->TotHiStageCompCapacity + Compressor_CompID.Capacity) >= NeededCapacity) {
                        LFLastComp = (NeededCapacity - this->TotHiStageCompCapacity) / Compressor_CompID.Capacity;
                        Compressor_CompID.Power *= LFLastComp;
                        Compressor_CompID.MassFlow *= LFLastComp;
                        Compressor_CompID.Capacity *= LFLastComp;
                        this->TotHiStageCompCapacity += Compressor_CompID.Capacity;
                        this->RefMassFlowHiStageComps += Compressor_CompID.MassFlow;
                        this->TotHiStageCompPower += Compressor_CompID.Power;
                        this->FlowRatioIntercooler = this->RefMassFlowComps / this->RefMassFlowHiStageComps;
                        Compressor_CompID.ElecConsumption = Compressor_CompID.Power * LocalTimeStepSec;
                        Compressor_CompID.CoolingEnergy = Compressor_CompID.Capacity * LocalTimeStepSec;
                        Compressor_CompID.LoadFactor = LFLastComp;
                        break; // numcomps do
                    } else {   //>= needed capacity
                        this->TotHiStageCompCapacity += Compressor_CompID.Capacity;
                        this->RefMassFlowHiStageComps += Compressor_CompID.MassFlow;
                        this->TotHiStageCompPower += Compressor_CompID.Power;
                    } //>= needed capacity
                }     // StageIndex
                Compressor_CompID.ElecConsumption = Compressor_CompID.Power * LocalTimeStepSec;
                Compressor_CompID.CoolingEnergy = Compressor_CompID.Capacity * LocalTimeStepSec;
                Compressor_CompID.LoadFactor = 1.0;
            } // NumComps
        }

        // Calculate enthalpy at compressor discharge
        if (this->NumStages == 1) { // Single-stage or low-stage compressors
            this->HCompOut = this->HCompIn + this->TotCompPower / this->RefMassFlowComps;
            // error found 9/19/2011, was System(SysNum)%TotCompPower*LocalTimeStep*DataGlobals::SecInHour/System(SysNum)%RefMassFlowComps
        } else { // High-stage compressors (only for two-stage systems)
            HHiStageCompIn = FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TIntercooler, 1.0, this->RefIndex, RoutineName);
            this->HCompOut = HHiStageCompIn + this->TotHiStageCompPower / this->RefMassFlowHiStageComps;
        }

        // Calculate superheat energy available for desuperheaters
        HSatVapCondense = FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TCondense, 1.0, this->RefIndex, RoutineName);
        CpSatVapCondense = FluidProperties::GetSatSpecificHeatRefrig(this->RefrigerantName, this->TCondense, 1.0, this->RefIndex, RoutineName);
        if (this->NumStages == 1) { // Single-stage systems
            DataHeatBalance::HeatReclaimRefrigCondenser(CondID).AvailCapacity = this->RefMassFlowComps * (this->HCompOut - HSatVapCondense);
        } else { // Two-stage systems
            DataHeatBalance::HeatReclaimRefrigCondenser(CondID).AvailCapacity = this->RefMassFlowHiStageComps * (this->HCompOut - HSatVapCondense);
        } // NumStages

        // No function available to get Tout as f(Pout, Hout), so use estimate based on constant cp in superheat range...
        //  Use average of Tcondense and Tout of condenser as check for whether heat reclaim is reasonable.
        TCompOutEstimate = this->TCondense + (this->HCompOut - HSatVapCondense) / CpSatVapCondense;

        DataHeatBalance::HeatReclaimRefrigCondenser(CondID).AvailTemperature = (TsatforPdisch + TCompOutEstimate) / 2.0;
        this->AverageCompressorCOP = this->TotCompCapacity / (this->TotCompPower + this->TotHiStageCompPower);
        this->TotCompElecConsump = this->TotCompPower * LocalTimeStepSec;
        if (this->NumStages == 2) {
            this->TotHiStageCompElecConsump = this->TotHiStageCompPower * LocalTimeStepSec;
            this->TotCompElecConsumpTwoStage = this->TotCompElecConsump + this->TotHiStageCompElecConsump;
        }
        this->TotCompCoolingEnergy = this->TotCompCapacity * LocalTimeStepSec;
        this->TotHiStageCompCoolingEnergy = this->TotHiStageCompCapacity * LocalTimeStepSec;
    }

    void TransRefrigSystemData::CalculateTransCompressors()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Brian A. Fricke, ORNL
        //       DATE WRITTEN   Fall 2011
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Find the compressor power, energy, capacity, and efficiency for a detailed transcritical CO2
        // refrigeration system.

        // METHODOLOGY EMPLOYED:
        // Use AHRI compressor performance curves for subcritical compressor operation, AHRI-style compressor
        // performance curves for transcritical compressor operation, the evaporating temperature of the
        // medium- and low-temperature loads, and the gas cooler outlet conditions (temperature, pressure
        // and enthalpy).

        // REFERENCES:
        // ANSI/AHRI. 2004. Standard 540, Standard for Performance Rating of Positive Displacement Refrigerant
        //     Comprssors and Compressor Units. Arlington, VA: Air-Conditioning, Heating, and Refrigeration
        //     Institute.
        // Ge, Y.T., and S.A. Tassou. 2011. Performance evaluation and optimal design of supermarket refrigeration
        //     systems with supermarket model "SuperSim", Part I: Model description and validation. International
        //     Journal of Refrigeration 34: 527-539.
        // Ge, Y.T., and S.A. Tassou. 2011. Performance evaluation and optimal design of supermarket refrigeration
        //     systems with supermarket model "SuperSim", Part II: Model applications. International Journal of
        //     Refrigeration 34: 540-549.
        // Sawalha, S. 2008. Theoretical evaluation of trans-critical CO2 systems in supermarket refrigeration,
        //     Part I: Modeling, simulation and optimization of two system solutions. International Journal of
        //     Refrigeration 31: 516-524.
        // Sawalha, S. 2008. Theoretical evaluation of trans-critical CO2 systems in supermarket refrigeration,
        //     Part II: System modifications and comparisons of different solutions. International Journal of
        //     Refrigeration 31: 525-534.

        // SUBROUTINE PARAMETER DEFINITIONS:
        // Following constants approp for R22, R134a, R404a, R507, R410a, R407c.
        // For the same pressure drop, CO2 has a corresponding temperature penalty 5 to 10 times smaller than
        // ammonia and R-134a (ASHRAE Handbook of Refrigeration, 2010, p. 3.7).  Ignore pressure drop for CO2 calculations.
        // NOTE, these DelT...Pipes reflect the decrease in Pressure in the pipes, NOT thermal transfer through the pipe walls.

        Real64 const ErrorTol(0.001); // Iterative solution tolerance

        static std::string const RoutineName("RefrigeratedCase:CalculateTransCompressors");
        int Iter;                           // Iteration counter
        Real64 CapacityCorrectionMT;        // Capacity at existing subcool/superheat over cap at rated conditions for MT loads
        Real64 CaseEnthalpyChangeRatedMT;   // Enthalpy change in medium temperature cases at compressor rated cond, J/kg
        Real64 CaseEnthalpyChangeRatedLT;   // Enthalpy change in low temperature cases at compressor rated cond, J/kg
        Real64 DensityActualLT;             // Density of superheated gas at LP compressor inlet, m3/kg
        Real64 DensityActualMT;             // Density of superheated gas at HP compressor inlet, m3/kg
        Real64 DensityRatedHP;              // Density of high pressure compressor inlet gas at rated superheat, m3/kg
        Real64 DensityRatedLP;              // Density of low pressure compressor inlet gas at rated superheat, m3/kg
        Real64 HCaseInRatedLT;              // Enthalpy entering low temperature cases at rated subcooling, J/kg
        Real64 HCaseInRatedMT;              // Enthalpy entering medium temperature cases at rated subcooling, J/kg
        Real64 HCompInRatedHP(0.0);         // Enthalpy entering high pressure compressor at rated superheat, J/kg
        Real64 HCompInRatedLP;              // Enthalpy entering low pressure compressor at rated superheat, J/kg
        Real64 HGCOutlet;                   // Enthalpy at gas cooler outlet, J/kg
        Real64 HIdeal;                      // Ideal enthalpy at subcooler (for 100% effectiveness)
        Real64 HsatLiqforTevapNeededMT;     // Enthalpy of saturated liquid at MT evaporator, J/kg
        Real64 HsatVaporforTevapneededMT;   // Enthlapy of saturated vapor at MT evaporator (transcritical cycle), J/kg
        Real64 HsatVaporforTevapneededLT;   // Enthlapy of saturated vapor at LT evaporator (transcritical cycle), J/kg
        Real64 LFLastComp;                  // Load factor for last compressor dispatched
        Real64 MassCorrectionLT;            // Mass flow at existing subcool/superheat over cap at rated conditions for LT loads
        Real64 MassCorrectionMT;            // Mass flow at existing subcool/superheat over cap at rated conditions for MT loads
        Real64 NeededCapacityLT;            // Sum of LT case loads and mech subcooler loads (transcritical cycle), W
        Real64 NeededCapacityMT;            // Sum of MT case loads and mech subcooler loads (transcritical cycle), W
        Real64 PSuctionLT;                  // Suction pressure in low temperature cases, Pa
        Real64 PSuctionMT;                  // Suction pressure in medium temperature cases, Pa
        Real64 PGCOutlet;                   // Gas cooler outlet pressure, Pa
        Real64 QualityReceiver(0.0);        // Refrigerant quality in the receiver
        Real64 SubcoolEffect;               // Heat exchanger effectiveness of the subcooler
        Real64 TempInRatedHP;               // Temperature entering high pressure compressor at rated superheat, C
        Real64 TempInRatedLP;               // Temperature entering low pressure compressor at rated superheat, C
        Real64 TsatforPdisLT;               // Low temperature saturated discharge temperature (transcritical cycle), C
        Real64 TsatforPdisMT;               // Medium temperature saturated discharge temperature (transcritical cycle), C
        Real64 TsatforPsucLT;               // Low temperature saturated suction temperature (transcritical cycle), C
        Real64 TsatforPsucMT;               // Medium temperature saturated suction temperature (transcritical cycle), C
        Real64 TSubcoolerColdIn;            // Suction gas temperature at the inlet of the subcooler, C
        Real64 TotalEnthalpyChangeActualLT; // Actual enthalpy change in LT cases, J/kg
        Real64 TotalEnthalpyChangeActualMT; // Actual enthalpy change in MT cases, J/kg
        Real64 TotalRefMassFlow;            // Total mass flow through high pressure side of system, kg/s
        Real64 Xu;                          // Initial upper guess for iterative search
        Real64 Xl;                          // Initial lower guess for iterative search
        Real64 Xnew(0.0);                   // New guess for iterative search

        Real64 LocalTimeStep = DataGlobals::TimeStepZone;
        if (UseSysTimeStep) LocalTimeStep = DataHVACGlobals::TimeStepSys;

        // Determine refrigerating capacity needed
        // Load due to previously unmet low temperature compressor loads (transcritical system)
        Real64 AccumLoadLT;
        NeededCapacityLT = 0.0;
        if (this->TransSysType == 2) {
            AccumLoadLT = max(0.0, (this->UnmetEnergyLT / LocalTimeStep / DataGlobals::SecInHour));
            NeededCapacityLT = this->TotalSystemLoadLT + AccumLoadLT + this->PipeHeatLoadLT;
        } // (TransSystem(SysNum)%TransSysType == 2)

        // Load due to previously unmet medium temperature compressor loads (transcritical system)
        Real64 AccumLoadMT = max(0.0, (this->UnmetEnergyMT / LocalTimeStep / DataGlobals::SecInHour));
        NeededCapacityMT = this->TotalSystemLoadMT + AccumLoadMT + this->PipeHeatLoadMT;

        // Determine refrigerant properties at receiver
        this->CpSatLiqReceiver = FluidProperties::GetSatSpecificHeatRefrig(this->RefrigerantName, this->TReceiver, 0.0, this->RefIndex, RoutineName);

        // Enthalpy at the receiver bypass, J/kg
        Real64 HReceiverBypass = FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TReceiver, 1.0, this->RefIndex, RoutineName);

        // Determine refrigerant properties at low temperature (LT) loads (if present)
        // Dispatch low pressure (LP) compressors as necessary
        if (this->TransSysType == 2) { // LT side of TwoStage transcritical system
            this->HCaseInLT = this->HSatLiqReceiver;
            // TCompInLP and HCompInLP include case superheat plus effect of suction line heat gain
            this->TCompInLP = this->TEvapNeededLT + TransCaseSuperheat + this->PipeHeatLoadLT / (this->CpSatVapEvapLT * this->RefMassFlowtoLTLoads);
            this->HCompInLP = this->HCaseOutLT + this->PipeHeatLoadLT / this->RefMassFlowtoLTLoads;
            TsatforPsucLT = this->TEvapNeededLT;
            TsatforPdisLT = this->TEvapNeededMT;
            HsatVaporforTevapneededLT =
                FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TEvapNeededLT, 1.0, this->RefIndex, RoutineName);
            HsatLiqforTevapNeededMT =
                FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TEvapNeededMT, 0.0, this->RefIndex, RoutineName);
            PSuctionLT = FluidProperties::GetSatPressureRefrig(this->RefrigerantName, TsatforPsucLT, this->RefIndex, RoutineName);
            DensityActualLT =
                FluidProperties::GetSupHeatDensityRefrig(this->RefrigerantName, this->TCompInLP, PSuctionLT, this->RefIndex, RoutineName);
            TotalEnthalpyChangeActualLT = this->HCompInLP - this->HCaseInLT;

            // Dispatch low pressure (LP) compressors
            // Before dispatching LP compressors, zero sum of compressor outputs and zero each compressor
            this->TotCompCapacityLP = 0.0;
            this->RefMassFlowCompsLP = 0.0;
            this->TotCompPowerLP = 0.0;

            for (int CompIndex = 1; CompIndex <= this->NumCompressorsLP; ++CompIndex) {
                int CompID = this->CompressorNumLP(CompIndex);
                Compressor(CompID).Power = 0.0;
                Compressor(CompID).MassFlow = 0.0;
                Compressor(CompID).Capacity = 0.0;
                Compressor(CompID).ElecConsumption = 0.0;
                Compressor(CompID).CoolingEnergy = 0.0;
                Compressor(CompID).LoadFactor = 0.0;
            }

            for (int CompIndex = 1; CompIndex <= this->NumCompressorsLP; ++CompIndex) {
                int CompID = this->CompressorNumLP(CompIndex);
                // need to use indiv compressor's rated subcool and superheat to adjust capacity to actual conditions
                {
                    auto const SELECT_CASE_var(Compressor(CompID).SubcoolRatingType);
                    if (SELECT_CASE_var == RatedSubcooling) {
                        HCaseInRatedLT = HsatLiqforTevapNeededMT - this->CpSatLiqReceiver * Compressor(CompID).RatedSubcool;
                    } else if (SELECT_CASE_var == RatedLiquidTemperature) { // have rated liquid temperature stored in "RatedSubcool"
                        HCaseInRatedLT = FluidProperties::GetSatEnthalpyRefrig(
                            this->RefrigerantName, Compressor(CompID).RatedSubcool, 0.0, this->RefIndex, RoutineName);
                    }
                }
                {
                    auto const SELECT_CASE_var(Compressor(CompID).SuperheatRatingType);
                    if (SELECT_CASE_var == RatedSuperheat) {
                        HCompInRatedLP = HsatVaporforTevapneededLT + this->CpSatVapEvapLT * Compressor(CompID).RatedSuperheat;
                        TempInRatedLP = this->TEvapNeededLT + Compressor(CompID).RatedSuperheat;
                    } else if (SELECT_CASE_var == RatedReturnGasTemperature) { // have rated compressor inlet temperature stored in "RatedSuperheat"
                        TempInRatedLP = Compressor(CompID).RatedSuperheat;
                        HCompInRatedLP = FluidProperties::GetSupHeatEnthalpyRefrig(
                            this->RefrigerantName, Compressor(CompID).RatedSuperheat, PSuctionLT, this->RefIndex, RoutineName);
                    }
                }

                CaseEnthalpyChangeRatedLT = HCompInRatedLP - HCaseInRatedLT;
                DensityRatedLP =
                    FluidProperties::GetSupHeatDensityRefrig(this->RefrigerantName, TempInRatedLP, PSuctionLT, this->RefIndex, RoutineName);

                //  Adjust capacity and mass flow to reflect the specific volume change due to superheating and
                //  the increase in capacity due to extra subcooling
                MassCorrectionLT = DensityActualLT / DensityRatedLP;
                // Capacity at existing subcool/superheat over cap at rated conditions for LT loads
                Real64 CapacityCorrectionLT = MassCorrectionLT * TotalEnthalpyChangeActualLT / CaseEnthalpyChangeRatedLT;
                Compressor(CompID).Power = CurveManager::CurveValue(Compressor(CompID).ElecPowerCurvePtr, TsatforPsucLT, TsatforPdisLT);
                Compressor(CompID).Capacity =
                    CapacityCorrectionLT * CurveManager::CurveValue(Compressor(CompID).CapacityCurvePtr, TsatforPsucLT, TsatforPdisLT);
                Compressor(CompID).MassFlow = Compressor(CompID).Capacity / TotalEnthalpyChangeActualLT;
                Compressor(CompID).ElecConsumption = Compressor(CompID).Power * LocalTimeStep * DataGlobals::SecInHour;
                Compressor(CompID).CoolingEnergy = Compressor(CompID).Capacity * LocalTimeStep * DataGlobals::SecInHour;
                Compressor(CompID).LoadFactor = 1.0;
                if ((this->TotCompCapacityLP + Compressor(CompID).Capacity) >= NeededCapacityLT) {
                    LFLastComp = (NeededCapacityLT - this->TotCompCapacityLP) / Compressor(CompID).Capacity;
                    Compressor(CompID).Power *= LFLastComp;
                    Compressor(CompID).MassFlow *= LFLastComp;
                    Compressor(CompID).Capacity *= LFLastComp;
                    this->TotCompCapacityLP += Compressor(CompID).Capacity;
                    this->RefMassFlowCompsLP += Compressor(CompID).MassFlow;
                    this->TotCompPowerLP += Compressor(CompID).Power;
                    Compressor(CompID).ElecConsumption = Compressor(CompID).Power * LocalTimeStep * DataGlobals::SecInHour;
                    Compressor(CompID).CoolingEnergy = Compressor(CompID).Capacity * LocalTimeStep * DataGlobals::SecInHour;
                    Compressor(CompID).LoadFactor = LFLastComp;
                    break;
                } else {
                    this->TotCompCapacityLP += Compressor(CompID).Capacity;
                    this->RefMassFlowCompsLP += Compressor(CompID).MassFlow;
                    this->TotCompPowerLP += Compressor(CompID).Power;
                }
            } // NumCompressorsLP
            this->HCompOutLP = this->HCompInLP + this->TotCompPowerLP / this->RefMassFlowCompsLP;
        } // (TransSystem(SysNum)%TransSysType == 2)

        // Determine refrigerant properties at medium temperature (MT) loads
        // Dispatch high pressure (HP) compressors as necessary
        TsatforPsucMT = this->TEvapNeededMT;
        if (GasCooler(this->GasCoolerNum(1)).TransOpFlag) { // Transcritical system is operating in transcritical region
            HGCOutlet = GasCooler(this->GasCoolerNum(1)).HGasCoolerOut;
        } else { // Transcritical system is operating in subcritical region
            TsatforPdisMT = GasCooler(this->GasCoolerNum(1)).TGasCoolerOut;
        }
        PSuctionMT = FluidProperties::GetSatPressureRefrig(this->RefrigerantName, TsatforPsucMT, this->RefIndex, RoutineName);
        PGCOutlet = GasCooler(this->GasCoolerNum(1)).PGasCoolerOut;
        HsatVaporforTevapneededMT =
            FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TEvapNeededMT, 1.0, this->RefIndex, RoutineName);
        this->HCaseInMT = this->HSatLiqReceiver;
        // Enthalpy of refrigerant after leaving medium temperature loads and low pressure compressors

        // Combined enthalpy from the outlets of the LP compressor and MT loads, J/kg
        Real64 HCaseOutLTMT = (this->RefMassFlowtoLTLoads * this->HCompOutLP + this->RefMassFlowtoMTLoads * this->HCaseOutMT + this->PipeHeatLoadMT) /
                              (this->RefMassFlowtoLTLoads + this->RefMassFlowtoMTLoads);

        // Total refrigerant flow rate is total flow from LT and MT loads divided by (1-x) where x is the quality of the
        // refrigerant entering the receiver.  The receiver bypass flow rate is (x)*(Total Flow).
        // Iterate to find the quality of the refrigerant entering the receiver.
        Xu = 1.0; // upper bound on quality
        Xl = 0.0; // lower bound on quality
        if ((GasCooler(this->GasCoolerNum(1)).HGasCoolerOut + this->DelHSubcoolerDis) > this->HSatLiqReceiver) {
            for (Iter = 1; Iter <= 15; ++Iter) { // Maximum of 15 iterations to find receiver quality
                QualityReceiver = (Xu + Xl) / 2.0;
                Real64 Hnew =
                    FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TReceiver, QualityReceiver, this->RefIndex, RoutineName);

                // estimated QualityReceiver is too high
                if (Hnew > (GasCooler(this->GasCoolerNum(1)).HGasCoolerOut + this->DelHSubcoolerDis)) {
                    Xu = QualityReceiver;
                } else { // estimated QualityReceiver is too low
                    Xl = QualityReceiver;
                }
                if (std::abs((Hnew - (GasCooler(this->GasCoolerNum(1)).HGasCoolerOut + this->DelHSubcoolerDis)) / Hnew) < ErrorTol) break;
            }
            TotalRefMassFlow = (this->RefMassFlowtoLTLoads + this->RefMassFlowtoMTLoads) / (1.0 - QualityReceiver);
            this->RefMassFlowReceiverBypass = QualityReceiver * TotalRefMassFlow;
        } else {
            this->RefMassFlowReceiverBypass = 0.0;
            TotalRefMassFlow = (this->RefMassFlowtoLTLoads + this->RefMassFlowtoMTLoads);
        } // %HGasCoolerOut > TransSystem(SysNum)%HSatLiqReceiver)

        this->HCompInHP =
            (HCaseOutLTMT * (this->RefMassFlowtoLTLoads + this->RefMassFlowtoMTLoads) + HReceiverBypass * this->RefMassFlowReceiverBypass) /
            (this->RefMassFlowtoLTLoads + this->RefMassFlowtoMTLoads + this->RefMassFlowReceiverBypass);

        // Iterate to find the suction temperature entering subcooler
        Xl = FluidProperties::GetSatTemperatureRefrig(this->RefrigerantName, PSuctionMT, this->RefIndex, RoutineName);
        Xu = Xl + 50.0;
        for (Iter = 1; Iter <= 15; ++Iter) { // Maximum of 15 iterations
            Xnew = (Xu + Xl) / 2.0;
            Real64 Hnew = FluidProperties::GetSupHeatEnthalpyRefrig(this->RefrigerantName, Xnew, PSuctionMT, this->RefIndex, RoutineName);
            if (Hnew > this->HCompInHP) { // xnew is too high
                Xu = Xnew;
            } else { // xnew is too low
                Xl = Xnew;
            }
            if (std::abs((Hnew - this->HCompInHP) / Hnew) < ErrorTol) break;
        }
        TSubcoolerColdIn = Xnew;

        // Modify receiver inlet enthalpy and HP compressor inlet enthalpy to account for subcooler
        HIdeal = FluidProperties::GetSupHeatEnthalpyRefrig(
            this->RefrigerantName, GasCooler(this->GasCoolerNum(1)).TGasCoolerOut, PSuctionMT, this->RefIndex, RoutineName);
        // Only use subcooler if suction gas inlet temperature less than gas cooler outlet temperature
        if (TSubcoolerColdIn < GasCooler(this->GasCoolerNum(1)).TGasCoolerOut) {
            SubcoolEffect = this->SCEffectiveness;
        } else {
            SubcoolEffect = 0.0;
        } // (TSubcoolerColdIn < GasCooler(SysNum)%TGasCoolerOut)
        this->DelHSubcoolerSuc = SubcoolEffect * (HIdeal - this->HCompInHP);
        this->HCompInHP += this->DelHSubcoolerSuc;
        this->DelHSubcoolerDis = -this->DelHSubcoolerSuc;

        // Iterate to find the temperature at the inlet of the high pressure (HP) compressors
        Xl = FluidProperties::GetSatTemperatureRefrig(this->RefrigerantName, PSuctionMT, this->RefIndex, RoutineName);
        Xu = Xl + 50.0;
        for (Iter = 1; Iter <= 15; ++Iter) { // Maximum of 15 iterations
            Xnew = (Xu + Xl) / 2.0;
            Real64 Hnew = FluidProperties::GetSupHeatEnthalpyRefrig(this->RefrigerantName, Xnew, PSuctionMT, this->RefIndex, RoutineName);
            if (Hnew > this->HCompInHP) { // xnew is too high
                Xu = Xnew;
            } else { // xnew is too low
                Xl = Xnew;
            }
            if (std::abs((Hnew - this->HCompInHP) / Hnew) < ErrorTol) break;
        }
        this->TCompInHP = Xnew;

        //  For capacity correction of HP compressors, consider subcooler, receiver, MT loads, LT loads and LP compressors
        //  to constitute the "load".  The actual and rated conditions at the exit of the gas cooler and the inlet of the
        //  HP compressors are used for capacity correction calculations.
        DensityActualMT = FluidProperties::GetSupHeatDensityRefrig(this->RefrigerantName, this->TCompInHP, PSuctionMT, this->RefIndex, RoutineName);
        TotalEnthalpyChangeActualMT = this->HCompInHP - GasCooler(this->GasCoolerNum(1)).HGasCoolerOut;

        // Dispatch HP compressors
        // Before dispatching HP compressors, zero sum of compressor outputs and zero each compressor
        this->TotCompCapacityHP = 0.0;
        this->RefMassFlowCompsHP = 0.0;
        this->TotCompPowerHP = 0.0;

        for (int CompIndex = 1; CompIndex <= this->NumCompressorsHP; ++CompIndex) {
            int CompID = this->CompressorNumHP(CompIndex);
            Compressor(CompID).Power = 0.0;
            Compressor(CompID).MassFlow = 0.0;
            Compressor(CompID).Capacity = 0.0;
            Compressor(CompID).ElecConsumption = 0.0;
            Compressor(CompID).CoolingEnergy = 0.0;
            Compressor(CompID).LoadFactor = 0.0;
        }

        // Dispatch High Pressure compressors to meet load, note they were listed in compressor list in dispatch order
        for (int CompIndex = 1; CompIndex <= this->NumCompressorsHP; ++CompIndex) {
            int CompID = this->CompressorNumHP(CompIndex);

            // Need to use indiv compressor's rated subcool and superheat to adjust capacity to actual conditions
            // Transcritical operation requires rated superheat
            // Subcritical operation requires rated subcool and rated superheat
            {
                auto const SELECT_CASE_var(Compressor(CompID).SubcoolRatingType);
                if (SELECT_CASE_var == RatedSubcooling) {
                    if (!GasCooler(this->GasCoolerNum(1)).TransOpFlag) { // Subcritical operation
                        HCaseInRatedMT = GasCooler(this->GasCoolerNum(1)).HGasCoolerOut -
                                         GasCooler(this->GasCoolerNum(1)).CpGasCoolerOut * Compressor(CompID).RatedSubcool;
                    } else { // Transcritical operation
                        HCaseInRatedMT = GasCooler(this->GasCoolerNum(1)).HGasCoolerOut;
                    }                                                                  // (.NOT.GasCooler(SysNum)%TransOpFlag)
                } else if (SELECT_CASE_var == RatedLiquidTemperature) {                // have rated liquid temperature stored in "RatedSubcool"
                    if (!GasCooler(this->GasCoolerNum(1)).TransOpFlag) { // Subcritical operation
                        HCaseInRatedMT = FluidProperties::GetSatEnthalpyRefrig(
                            this->RefrigerantName, Compressor(CompID).RatedSubcool, 0.0, this->RefIndex, RoutineName);
                    } else { // Transcritical operation
                        HCaseInRatedMT = GasCooler(this->GasCoolerNum(1)).HGasCoolerOut;
                    } // (.NOT.GasCooler(SysNum)%TransOpFlag)
                }
            }
            {
                auto const SELECT_CASE_var(Compressor(CompID).SuperheatRatingType);
                if (SELECT_CASE_var == RatedSuperheat) {
                    HCompInRatedHP = HsatVaporforTevapneededMT + this->CpSatVapEvapMT * Compressor(CompID).RatedSuperheat;
                    TempInRatedHP = this->TEvapNeededMT + Compressor(CompID).RatedSuperheat;
                } else if (SELECT_CASE_var == RatedReturnGasTemperature) { // have rated compressor inlet temperature stored in "RatedSuperheat"
                    TempInRatedHP = Compressor(CompID).RatedSuperheat;
                    HCompInRatedHP = FluidProperties::GetSupHeatEnthalpyRefrig(
                        this->RefrigerantName, Compressor(CompID).RatedSuperheat, PSuctionMT, this->RefIndex, RoutineName);
                }
            }

            CaseEnthalpyChangeRatedMT = HCompInRatedHP - HCaseInRatedMT;
            DensityRatedHP = FluidProperties::GetSupHeatDensityRefrig(this->RefrigerantName, TempInRatedHP, PSuctionMT, this->RefIndex, RoutineName);
            //  Adjust capacity and mass flow to reflect the specific volume change due to superheating and
            //  the increase in capacity due to extra subcooling
            MassCorrectionMT = DensityActualMT / DensityRatedHP;
            CapacityCorrectionMT = MassCorrectionMT * TotalEnthalpyChangeActualMT / CaseEnthalpyChangeRatedMT;

            if (GasCooler(this->GasCoolerNum(1)).TransOpFlag) { // System is operating in transcritical region
                Compressor(CompID).Power = CurveManager::CurveValue(Compressor(CompID).TransElecPowerCurvePtr, TsatforPsucMT, PGCOutlet);
                Compressor(CompID).Capacity =
                    CapacityCorrectionMT * CurveManager::CurveValue(Compressor(CompID).TransCapacityCurvePtr, TsatforPsucMT, HGCOutlet);
            } else { // System is operating in subcritical region
                Compressor(CompID).Power = CurveManager::CurveValue(Compressor(CompID).ElecPowerCurvePtr, TsatforPsucMT, TsatforPdisMT);
                Compressor(CompID).Capacity =
                    CapacityCorrectionMT * CurveManager::CurveValue(Compressor(CompID).CapacityCurvePtr, TsatforPsucMT, TsatforPdisMT);
            } // (GasCooler(SysNum)%TransOpFlag)
            //  Mass flow through HP compressors is HP compressor refrigerating capacity divided by MT load, LT load and LP compressor power
            Compressor(CompID).MassFlow =
                TotalRefMassFlow * Compressor(CompID).Capacity / (NeededCapacityMT + NeededCapacityLT + this->TotCompPowerLP);
            Compressor(CompID).ElecConsumption = Compressor(CompID).Power * LocalTimeStep * DataGlobals::SecInHour;
            Compressor(CompID).CoolingEnergy = Compressor(CompID).Capacity * LocalTimeStep * DataGlobals::SecInHour;
            Compressor(CompID).LoadFactor = 1.0;
            // calculate load factor for last compressor added
            // assumes either cycling or part load eff = full load eff for last compressor
            if ((this->TotCompCapacityHP + Compressor(CompID).Capacity) >= (NeededCapacityMT + NeededCapacityLT + this->TotCompPowerLP)) {
                LFLastComp = ((NeededCapacityMT + NeededCapacityLT + this->TotCompPowerLP) - this->TotCompCapacityHP) / Compressor(CompID).Capacity;
                Compressor(CompID).Power *= LFLastComp;
                Compressor(CompID).MassFlow *= LFLastComp;
                Compressor(CompID).Capacity *= LFLastComp;
                this->TotCompCapacityHP += Compressor(CompID).Capacity;
                this->RefMassFlowCompsHP += Compressor(CompID).MassFlow;
                this->TotCompPowerHP += Compressor(CompID).Power;
                Compressor(CompID).ElecConsumption = Compressor(CompID).Power * LocalTimeStep * DataGlobals::SecInHour;
                Compressor(CompID).CoolingEnergy = Compressor(CompID).Capacity * LocalTimeStep * DataGlobals::SecInHour;
                Compressor(CompID).LoadFactor = LFLastComp;
                break;
            } else {
                this->TotCompCapacityHP += Compressor(CompID).Capacity;
                this->RefMassFlowCompsHP += Compressor(CompID).MassFlow;
                this->TotCompPowerHP += Compressor(CompID).Power;
            }

        } // NumCompressorsHP

        this->HCompOutHP = this->HCompInHP + this->TotCompPowerHP / this->RefMassFlowCompsHP;
        this->RefMassFlowComps = this->RefMassFlowCompsLP + this->RefMassFlowCompsHP;
        this->TotCompCapacity = this->TotCompCapacityHP + this->TotCompCapacityLP;
        this->AverageCompressorCOP = (this->TotCompCapacityHP - this->TotCompPowerLP) / (this->TotCompPowerLP + this->TotCompPowerHP);
        this->TotCompElecConsump = (this->TotCompPowerLP + this->TotCompPowerHP) * LocalTimeStep * DataGlobals::SecInHour;
        this->TotCompCoolingEnergy = (this->TotCompCapacityLP + this->TotCompCapacityHP) * LocalTimeStep * DataGlobals::SecInHour;
    }

    void RefrigSystemData::CalculateSubcoolers()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL, Assisted by Hugh Henderson
        //       DATE WRITTEN   Spring 2008
        //       MODIFIED       Brian Fricke, ORNL, March 2012, added two-stage compression
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Find the subcooler energy exchange and refrigerant states for a particular detailed
        // refrigeration system. Use the refrigerant property subroutines in FluidProperties.cc

        // METHODOLOGY EMPLOYED:
        // Use refrigerant properties and heat exchanger correlations.  NOTE:  Assumes any Mech subcooler
        // immediately follows condenser outlet (after pipe loss) and comes before any LSHX

        // REFERENCES:
        // ASHRAE 1006 Section 2: Refrigeration Accessories

        static std::string const RoutineName("CalculateSubcoolers");
        Real64 TLiqInActualLocal(0.0); // Liquid T in, after condenser, before any mechanical subcooler

        Real64 LocalTimeStep = DataGlobals::TimeStepZone;
        if (UseSysTimeStep) LocalTimeStep = DataHVACGlobals::TimeStepSys;

        // HCaseIn has to be recalculated as the starting point for the subcoolers here because
        //  of the multiple number of iterations through this subroutine and because Tcondense is evolving.
        if (this->NumStages == 1) { // Single-stage compression system
            this->HSatLiqCond = FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TCondense, 0.0, this->RefIndex, RoutineName);
            this->CpSatLiqCond = FluidProperties::GetSatSpecificHeatRefrig(this->RefrigerantName, this->TCondense, 0.0, this->RefIndex, RoutineName);
            this->HCaseIn = this->HSatLiqCond - this->CpSatLiqCond * Condenser(this->CondenserNum(1)).RatedSubcool;

            // Two-stage compression with flash intercooler
        } else if (this->NumStages == 2 && this->IntercoolerType == 1) {
            this->HSatLiqCond = FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TCondense, 0.0, this->RefIndex, RoutineName);
            this->CpSatLiqCond = FluidProperties::GetSatSpecificHeatRefrig(this->RefrigerantName, this->TCondense, 0.0, this->RefIndex, RoutineName);
            this->HCaseIn = FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TIntercooler, 0.0, this->RefIndex, RoutineName);

            // Two-stage compression with shell-and-coil intercooler
        } else if (this->NumStages == 2 && this->IntercoolerType == 2) {
            TLiqInActualLocal =
                this->TCondense - Condenser(this->CondenserNum(1)).RatedSubcool -
                this->IntercoolerEffectiveness * (this->TCondense - Condenser(this->CondenserNum(1)).RatedSubcool - this->TIntercooler);
            this->HSatLiqCond = FluidProperties::GetSatEnthalpyRefrig(this->RefrigerantName, this->TCondense, 0.0, this->RefIndex, RoutineName);
            this->CpSatLiqCond = FluidProperties::GetSatSpecificHeatRefrig(this->RefrigerantName, this->TCondense, 0.0, this->RefIndex, RoutineName);
            this->HCaseIn = this->HSatLiqCond - this->CpSatLiqCond * (this->TCondense - TLiqInActualLocal);
        } // NumStages and IntercoolerType

        for (int SubcoolerIndex = 1; SubcoolerIndex <= this->NumSubcoolers; ++SubcoolerIndex) {
            int SubcoolerID = this->SubcoolerNum(SubcoolerIndex);
            // set up local variables for convenience
            Real64 DelTLiqDes = Subcooler(SubcoolerID).LiqSuctDesignDelT;
            Real64 TVapInDes = Subcooler(SubcoolerID).LiqSuctDesignTvapIn;
            Real64 TLiqInDes = Subcooler(SubcoolerID).LiqSuctDesignTliqIn;
            Real64 ControlTLiqOut = Subcooler(SubcoolerID).MechControlTliqOut;
            Real64 CpLiquid = this->CpSatLiqCond;
            Real64 CpVapor = this->CpSatVapEvap;
            if (this->NumStages == 1) { // Single-stage compression system
                TLiqInActualLocal = this->TCondense - Condenser(this->CondenserNum(1)).RatedSubcool;

                // Two-stage compression with flash intercooler
            } else if (this->NumStages == 2 && this->IntercoolerType == 1) {
                TLiqInActualLocal = this->TIntercooler;

                // Two-stage compression with shell-and-coil intercooler
            } else if (this->NumStages == 2 && this->IntercoolerType == 2) {
                TLiqInActualLocal =
                    this->TCondense - Condenser(this->CondenserNum(1)).RatedSubcool -
                    this->IntercoolerEffectiveness * (this->TCondense - Condenser(this->CondenserNum(1)).RatedSubcool - this->TIntercooler);
            } // NumStages and IntercoolerType

            {
                auto const SELECT_CASE_var(Subcooler(SubcoolerID).SubcoolerType);
                // Mechanical subcoolers required to come first in order to take advantage of delT
                //  from lshx. taken care of because subcooler ID assigned in that order in input.

                if (SELECT_CASE_var == Mechanical) {
                    Real64 mechSCLoad = this->RefMassFlowtoLoads * CpLiquid * (TLiqInActualLocal - ControlTLiqOut);
                    this->HCaseIn -= CpLiquid * (TLiqInActualLocal - ControlTLiqOut);
                    // refrigeration benefit to System(sysnum)
                    // refrigeration load must be assigned properly according to input
                    int SysProvideID = Subcooler(SubcoolerID).MechSourceSysID;
                    System(SysProvideID).MechSCLoad(SubcoolerID) = mechSCLoad;
                    Subcooler(SubcoolerID).MechSCTransLoad = mechSCLoad;
                    Subcooler(SubcoolerID).MechSCTransEnergy = mechSCLoad * LocalTimeStep * DataGlobals::SecInHour;
                    // Reset inlet temperature for any LSHX that follows this mech subcooler
                    TLiqInActualLocal = ControlTLiqOut;
                    this->TCompIn = this->TEvapNeeded + CaseSuperheat;

                } else if (SELECT_CASE_var == LiquidSuction) {
                    Real64 LSHXeffectiveness = DelTLiqDes / (TLiqInDes - TVapInDes);
                    Real64 TVapInActual = this->TEvapNeeded + CaseSuperheat;
                    Real64 DelTempActual = LSHXeffectiveness * (TLiqInActualLocal - TVapInActual);
                    TLiqInActualLocal -= DelTempActual;
                    Real64 SubcoolLoad = this->RefMassFlowtoLoads * CpLiquid * DelTempActual;
                    Real64 SubcoolerSupHeat = SubcoolLoad / CpVapor / this->RefMassFlowComps;
                    this->TCompIn = TVapInActual + SubcoolerSupHeat;
                    this->HCaseIn -= SubcoolLoad / this->RefMassFlowtoLoads;
                    this->LSHXTrans = SubcoolLoad;
                    this->LSHXTransEnergy = SubcoolLoad * LocalTimeStep * DataGlobals::SecInHour;
                }
            }

            this->TLiqInActual = TLiqInActualLocal;
        }
    }

    void GetRefrigeratedRackIndex(EnergyPlusData &state, std::string const &Name,
                                  int &IndexPtr,
                                  int const SysType,
                                  bool &ErrorsFound,
                                  Optional_string_const ThisObjectType,
                                  const Optional_bool_const &SuppressWarning)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad
        //       DATE WRITTEN   June 2007
        //       MODIFIED       Therese Stovall May 2008
        //       RE-ENGINEERED  na
        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine sets an index for a given refrigerated rack or refrigeration condenser
        //  -- issues error message if the rack or condenser is not found.

        CheckRefrigerationInput(state);

        {
            auto const SELECT_CASE_var(SysType);
            if (SELECT_CASE_var == DataHeatBalance::RefrigSystemTypeRack) {
                IndexPtr = UtilityRoutines::FindItemInList(Name, RefrigRack);
                if (IndexPtr == 0) {
                    if (present(SuppressWarning)) {
                        //     No warning printed if only searching for the existence of a refrigerated rack
                    } else {
                        if (present(ThisObjectType)) {
                            ShowSevereError(ThisObjectType + ", GetRefrigeratedRackIndex: Rack not found=" + Name);
                        } else {
                            ShowSevereError("GetRefrigeratedRackIndex: Rack not found=" + Name);
                        }
                    }
                    ErrorsFound = true;
                }
            } else if (SELECT_CASE_var == DataHeatBalance::RefrigSystemTypeDetailed) {
                IndexPtr = UtilityRoutines::FindItemInList(Name, Condenser);
                if (IndexPtr == 0) {
                    if (present(SuppressWarning)) {
                        //     No warning printed if only searching for the existence of a refrigeration Condenser
                    } else {
                        if (present(ThisObjectType)) {
                            ShowSevereError(ThisObjectType + ", GetRefrigeratedRackIndex: Condenser not found=" + Name);
                        } else {
                            ShowSevereError("GetRefrigeratedRackIndex: Condenser not found=" + Name);
                        }
                    }
                    ErrorsFound = true;
                }
            }
        }
    }

    void ReportRefrigerationComponents(IOFiles &ioFiles)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   October 2004
        //       MODIFIED       Shirey, FSEC Dec 2004; Lawrie, Mar 2008 - Node names, not numbers.
        //       MODIFIED       Stovall - 2008 to 2010, new refrig variables and move orphan reporting to input.
        //       MODIFIED       Fricke, ORNL, Fall 2011, added transcritical CO2 refrigeration system variables
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // To report information from the input deck for refrigerated cases and racks to the eio and err file.

        std::string ChrOut;
        std::string ChrOut2;

        static constexpr auto Format_104("! <Refrigeration Compressor Rack>,Compressor Rack Name, # Refrigerated Cases Connected,# WalkIn Coolers "
                                         "Connected, Heat Rejection Location, Condenser Type, COP");
        static constexpr auto Format_105("!  <Refrigeration Case>,Refrigeration Case Number, Refrigeration Case Name,Zone Name,Zone Node #,Zone "
                                         "Node Name,Capacity (W/m),LHR,Temperature (C),Length (m),Fan (W/m),Installed Lighting (W/m),Anti-Sweat "
                                         "(W/m),Defrost (W/m)");
        static constexpr auto Format_108("!  <Refrigeration Compressor>,Compressor Number,Compressor Name,Nominal Capacity (W)");
        static constexpr auto Format_109("! <#Refrigeration Compressor Racks>,Number of Refrigeration Compressor Racks");
        static constexpr auto Format_117("! <#Detailed Refrigeration Systems>,Number of Detailed Refrigeration Systems");
        static constexpr auto Format_118(
            "! <Detailed Refrigeration System>,Refrigeration System Name,Refrigerant Used, # Refrigerated Cases "
            "Connected, # WalkInCoolers Connected, #Air Chillers Connected, # Secondary Loops Served, # Cascade Condensers "
            "Served, # Mechanical Subcoolers Served, # Compressors Connected, # Compression Stages, Intercooler Type, "
            "Intercooler Effectiveness, # Subcoolers Connected, Minimum Condensing Temperature (C)");
        static constexpr auto Format_119("!  <Refrigeration Walk In Cooler>, Walk In Number, Walk In Name,Capacity (W),Temperature (C),Coil Fan "
                                         "(W), Circulating Fan (W), Lighting (W),Heaters (W),Defrost (W), # Zones");
        static constexpr auto Format_120("! <#Detailed Transcritical Refrigeration Systems>,Number of Detailed Transcritical Refrigeration Systems");
        static constexpr auto Format_121(
            "! <Detailed Transcritical Refrigeration System>,Transcritical Refrigeration System Name,Refrigerant Used, # "
            "Medium Temperature Refrigerated Cases Connected, # Low Temperature Refrigerated Cases Connected, # Medium "
            "Temperature WalkInCoolers Connected, # Low Temperature WalkInCoolers Connected, # High Pressure Compressors "
            "Connected, # Low Pressure Compressors Connected, Minimum Condensing Temperature (C)");
        static constexpr auto Format_123("!  <Secondary Load>, Secondary System Served Name, Secondary Number");
        static constexpr auto Format_126("!  <Refrigeration Mechanical Subcooler>, Subcooler Number, Subcooler Name, Name of System Providing "
                                         "Cooling, Design Outlet Temperature (C)");
        static constexpr auto Format_127("!  <Refrigeration Liquid Suction Subcooler>, Subcooler Number, Subcooler Name, Design Subcooling "
                                         "(DeltaC),Design liquid inlet temperature (C), Design vapor inlet temperature (C)");
        static constexpr auto Format_128("!  <Cascade Load>, System Name Connected, Condenser Number, Condenser Name");
        static constexpr auto Format_129("!  <Refrigeration Condenser:Air-Cooled>,Condenser Number,Condenser Name,Rated Condensing Temperature "
                                         "(C),Rated Capacity (W), Rated Fan Power (W)");
        static constexpr auto Format_130("!  <Refrigeration Condenser:Water-Cooled>,Condenser Number,Condenser Name,Rated Condensing Temperature "
                                         "(C),Rated Capacity (W), Rated Water Inlet Temperature (C), Rated Water Flow Rate (m3/s)");
        static constexpr auto Format_131(
            "!  <Refrigeration Condenser:Evaporative-Cooled>,Condenser Number,Condenser Name,Rated Capacity (W), Rated Fan Power (W)");
        static constexpr auto Format_132("!  <Refrigeration Condenser:Cascade>, Condenser Number, Condenser Name, Condensing Temperature Control "
                                         "Type, Rated Condensing Temperature (C), Capacity (W), Approach Temperature Difference (DeltaC)");
        static constexpr auto Format_133("! <Secondary Refrigeration System: Fluid Always Liquid>, Secondary Number, Secondary Name, # Refrigerated "
                                         "Cases Connected, # WalkIn Coolers Connected, Fluid Name, Capacity (W),Evap Temperature in Secondary "
                                         "Evaporator (C), Approach Temperature Difference (DeltaC), Temperature Range (DeltaC), TotalPumpPower (W)");
        static constexpr auto Format_134("!      <Walk-In Surfaces Facing Zone>, ZoneName, Wall/Ceiling Area (m2), UValue (W/m2-C), AreaStockDoors "
                                         "(m2), HeightStockDoors, UValueStockDoors (W/m2-C), AreaGlassDoors (m2), HeightGlassDoors (m),  "
                                         "UValueGlassDoors (W/m2-C)");
        static constexpr auto Format_141("!  <Mechanical Subcooler Load>, Subcooler Number, Subcooler Name");
        static constexpr auto Format_142("! <#Secondary Refrigeration Systems>,Number of Secondary Refrigeration Systems");
        static constexpr auto Format_146(
            "! <Secondary Refrigeration System: Liquid Overfeed>, Secondary Number, Secondary Name, # Refrigerated Cases "
            "Connected, # WalkIn Coolers Connected, #Air Coils Connected Fluid Name, Capacity (W),Evap Temperature in "
            "Secondary Evaporator (C), Approach Temperature Difference (DeltaC), Circulating Rate, TotalPumpPower (W)");
        static constexpr auto Format_148("! <#ZoneHVAC/Refrigeration Air Chiller Sets>,Number of ZoneHVAC/Refrigeration Air Chiller Sets");
        static constexpr auto Format_149("! <ZoneHVAC/Refrigeration Air Chiller Set>,Chiller Set Name, # Air Chillers Connected, Zone Location");
        static constexpr auto Format_151(
            "!  <Refrigeration Air Chiller>,Refrigeration Chiller Number, Refrigeration Chiller Name,Zone Name,Zone "
            "Node #,Zone Node Name,Sensible Capacity (W/C),Sensible Capacity (W),Evaporating Temperature (C),DT1 (C),Fan "
            "Power (W),Heater (W),Defrost (W), Air Flow Rate (m3/s)");
        static constexpr auto Format_152("!  <Air Chiller Load>, Air Chiller Name, Air Chiller Number, Zone Name,");
        static constexpr auto Format_160(
            "!  <Refrigeration GasCooler:Air-Cooled>,Gas Cooler Number, Gas Cooler Name, Rated Outlet Pressure "
            "(Pa),Rated Outlet Temperature (C), Rated Approach Temperature (C), Rated Capacity (W), Rated Fan Power (W)");

        // write all headers applicable to this simulation
        if (DataHeatBalance::NumRefrigeratedRacks > 0) {
            print(ioFiles.eio, "{}\n", Format_109); // Intro to refrigeration case racks
            print(ioFiles.eio, "{}\n", Format_104); // Refrigeration Rack header
        }                                            //(NumRefrigeratedRacks > 0)
        if (DataHeatBalance::NumRefrigSystems > 0) {
            print(ioFiles.eio, "{}\n", Format_117); // Intro to detailed systems
            print(ioFiles.eio, "{}\n", Format_118); // Detailed system header
            print(ioFiles.eio, "{}\n", Format_108); // Compressor header (Always have compressor if have detailed system)
        }                                            //(NumRefrigSystems > 0)
        if (NumSimulationSecondarySystems > 0) {
            print(ioFiles.eio, "{}\n", Format_142); // Intro to Secondary systems
            int CountSecPhase = 0;
            int CountSecBrine = 0;
            for (int SecondaryID = 1; SecondaryID <= NumSimulationSecondarySystems; ++SecondaryID) {
                if ((Secondary(SecondaryID).FluidType == SecFluidTypeAlwaysLiquid) && (CountSecBrine == 0)) {
                    print(ioFiles.eio, "{}\n", Format_133); // Secondary system header for brine type systems
                    ++CountSecBrine;
                }
                if ((Secondary(SecondaryID).FluidType == SecFluidTypePhaseChange) && (CountSecPhase == 0)) {
                    print(ioFiles.eio, "{}\n", Format_146); // Secondary system header for liquid overfeed/phase change systems
                    ++CountSecPhase;
                }
            }
            print(ioFiles.eio, "{}\n", Format_123); //  Secondary system load header
        }                                            //(NumSimulationSecondarySystems > 0)
        if (DataHeatBalance::NumRefrigChillerSets > 0) {
            print(ioFiles.eio, "{}\n", Format_148); // Intro to Chiller set
            print(ioFiles.eio, "{}\n", Format_149); // Chiller set header
            print(ioFiles.eio, "{}\n", Format_151); // Intro to Air Chiller
            print(ioFiles.eio, "{}\n", Format_152); // Air chiller header
        }                                            //(NumRefrigSystems > 0)
        if (NumSimulationCases > 0) {
            print(ioFiles.eio, "{}\n", Format_105); //  Case header
        }                                            //(NumSimulationCases > 0)
        if (NumSimulationWalkIns > 0) {
            print(ioFiles.eio, "{}\n", Format_119); //  Walk-in header
            print(ioFiles.eio, "{}\n", Format_134); //  Walk-in zone-specific header
        }                                            //(NumSimulationWalkIns > 0)
        if (NumSimulationCondAir > 0) {
            print(ioFiles.eio, "{}\n", Format_129); //  Condenser, Air-Cooled header
        }                                            //(NumSimulationCondAir > 0)
        if (NumSimulationCondEvap > 0) {
            print(ioFiles.eio, "{}\n", Format_131); //  Condenser, Evaporative-Cooled header
        }                                            //(NumSimulationCondEvap > 0)
        if (NumSimulationCondWater > 0) {
            print(ioFiles.eio, "{}\n", Format_130); //  Condenser, Water-Cooled header
        }                                            //(NumSimulationCondWater > 0)
        if (NumSimulationCascadeCondensers > 0) {
            print(ioFiles.eio, "{}\n", Format_132); //  Condenser, Cascade header
            print(ioFiles.eio, "{}\n", Format_128); //  Cascade Load header
        }                                            //(NumSimulationCascadeCondensers > 0)
        if (NumSimulationMechSubcoolers > 0) {
            print(ioFiles.eio, "{}\n", Format_141); //  Mech subcooler loads served header
            print(ioFiles.eio, "{}\n", Format_126); //  Mechanical Subcooler header
        }                                            //(NumSimulationMechSubcoolers > 0)
        if ((NumSimulationSubcoolers - NumSimulationMechSubcoolers) > 0) {
            print(ioFiles.eio, "{}\n", Format_127); //  LSHX Subcooler header
        }                                            //((NumSimulationSubcoolers - NumSimulationMechSubcoolers) > 0)

        if (NumTransRefrigSystems > 0) {
            print(ioFiles.eio, "{}\n", Format_120); // Intro to detailed transcriticial refrigeration system
            print(ioFiles.eio, "{}\n", Format_121); // Detailed system header
            if (NumSimulationCases > 0) {
                print(ioFiles.eio, "{}\n", Format_105); //  Case header
            }                                            //(NumSimulationCases > 0)
            if (NumSimulationWalkIns > 0) {
                print(ioFiles.eio, "{}\n", Format_119); //  Walk-in header
                print(ioFiles.eio, "{}\n", Format_134); //  Walk-in zone-specific header
            }                                            //(NumSimulationWalkIns > 0)
            print(ioFiles.eio, "{}\n", Format_108);     // Compressor header (Always have compressor if have detailed system)
            if (NumSimulationGasCooler > 0) {
                print(ioFiles.eio, "{}\n", Format_160); //  Gas Cooler, Air-Cooled header
            }                                            //(NumSimulationGasCooler > 0)
        }                                                //(NumTransRefrigSystems > 0)

        if (DataHeatBalance::NumRefrigeratedRacks > 0) {
            print(ioFiles.eio, "#Refrigeration Compressor Racks, {}\n", DataHeatBalance::NumRefrigeratedRacks);
            for (int RackNum = 1; RackNum <= DataHeatBalance::NumRefrigeratedRacks; ++RackNum) {
                if (RefrigRack(RackNum).HeatRejectionLocation == LocationOutdoors) {
                    ChrOut = "Outdoors";
                } else {
                    ChrOut = "Zone";
                }
                {
                    auto const SELECT_CASE_var(RefrigRack(RackNum).CondenserType);
                    if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeAir) {
                        ChrOut2 = "Air-Cooled";
                    } else if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeEvap) {
                        ChrOut2 = "Evap-Cooled";
                    } else if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeWater) {
                        ChrOut2 = "Water-Cooled";
                    }
                }
                print(ioFiles.eio,
                      " Refrigeration Compressor Rack,{},{},{},{},{},{:.3R}\n",
                      RefrigRack(RackNum).Name,
                      RefrigRack(RackNum).NumCases,
                      RefrigRack(RackNum).NumWalkIns,
                      ChrOut,
                      ChrOut2,
                      RefrigRack(RackNum).RatedCOP);
                for (int CaseNum = 1; CaseNum <= RefrigRack(RackNum).NumCases; ++CaseNum) {
                    int CaseID = RefrigRack(RackNum).CaseNum(CaseNum);
                    if (RefrigCase(CaseID).ZoneNodeNum > 0) {
                        print(ioFiles.eio,
                              "   Refrigeration Case,{},{},{},{},{},{:.1R},{:.2R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R}\n",
                              CaseID,
                              RefrigCase(CaseID).Name,
                              RefrigCase(CaseID).ZoneName,
                              RefrigCase(CaseID).ZoneNodeNum,
                              DataLoopNode::NodeID(RefrigCase(CaseID).ZoneNodeNum),
                              RefrigCase(CaseID).RateTotCapPerLength,
                              RefrigCase(CaseID).RatedLHR,
                              RefrigCase(CaseID).Temperature,
                              RefrigCase(CaseID).Length,
                              RefrigCase(CaseID).OperatingFanPower,
                              RefrigCase(CaseID).LightingPower,
                              RefrigCase(CaseID).AntiSweatPower,
                              RefrigCase(CaseID).DefrostPower); // Installed lighting power, may not be rated power
                    }
                } // numcases

                for (int WalkInNum = 1; WalkInNum <= RefrigRack(RackNum).NumWalkIns; ++WalkInNum) {
                    int WalkInID = RefrigRack(RackNum).WalkInNum(WalkInNum);
                    print(ioFiles.eio,
                          "   Refrigeration Walk In Cooler,  {},{},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{}\n",
                          WalkInID,
                          WalkIn(WalkInID).Name,
                          WalkIn(WalkInID).DesignRatedCap,
                          WalkIn(WalkInID).Temperature,
                          WalkIn(WalkInID).CoilFanPower,
                          WalkIn(WalkInID).CircFanPower,
                          WalkIn(WalkInID).ElecFanPower,
                          WalkIn(WalkInID).DesignLighting,
                          WalkIn(WalkInID).HeaterPower,
                          WalkIn(WalkInID).DefrostCapacity,
                          WalkIn(WalkInID).NumZones);
                    for (int ZoneID = 1; ZoneID <= WalkIn(WalkInID).NumZones; ++ZoneID) {
                        print(ioFiles.eio,
                              "      Walk-In Surfaces Facing Zone, {},{:.1R},{:.4R},{:.2R},{:.2R},{:.4R},{:.2R},{:.2R},{:.4R}\n",
                              WalkIn(WalkInID).ZoneName(ZoneID),
                              WalkIn(WalkInID).SurfaceArea(ZoneID),
                              WalkIn(WalkInID).UValue(ZoneID),
                              WalkIn(WalkInID).AreaStockDr(ZoneID),
                              WalkIn(WalkInID).HeightStockDr(ZoneID),
                              WalkIn(WalkInID).UValueStockDr(ZoneID),
                              WalkIn(WalkInID).AreaGlassDr(ZoneID),
                              WalkIn(WalkInID).HeightGlassDr(ZoneID),
                              WalkIn(WalkInID).UValueGlassDr(ZoneID));
                    } // zones for walk ins on rack
                }     // walk ins on rack

                for (int CoilNum = 1; CoilNum <= RefrigRack(RackNum).NumCoils; ++CoilNum) {
                    int CoilID = RefrigRack(RackNum).CoilNum(CoilNum);
                    print(ioFiles.eio, "   Air Chiller Load,{},{},{}\n", WarehouseCoil(CoilID).Name, CoilID, WarehouseCoil(CoilID).ZoneName);
                } // numairchillers
            }     // numracks
        }         //(NumRefrigeratedRacks > 0)

        if (DataHeatBalance::NumRefrigSystems > 0) {
            print(ioFiles.eio, "#Detailed Refrigeration Systems,{}\n", DataHeatBalance::NumRefrigSystems);
            for (int SystemNum = 1; SystemNum <= DataHeatBalance::NumRefrigSystems; ++SystemNum) {
                print(ioFiles.eio,
                      " Detailed Refrigeration System,{},{},{},{},{},{},{},{},{},{},{},{:.2R},{},{:.1R}\n",
                      System(SystemNum).Name,
                      System(SystemNum).RefrigerantName,
                      System(SystemNum).NumCases,
                      System(SystemNum).NumWalkIns,
                      System(SystemNum).NumCoils,
                      System(SystemNum).NumSecondarys,
                      System(SystemNum).NumCascadeLoads,
                      System(SystemNum).NumMechSCServed,
                      System(SystemNum).NumCompressors + System(SystemNum).NumHiStageCompressors,
                      System(SystemNum).NumStages,
                      System(SystemNum).IntercoolerType,
                      System(SystemNum).IntercoolerEffectiveness,
                      System(SystemNum).NumSubcoolers,
                      System(SystemNum).TCondenseMin);

                for (int CaseNum = 1; CaseNum <= System(SystemNum).NumCases; ++CaseNum) {
                    int CaseID = System(SystemNum).CaseNum(CaseNum);
                    if (RefrigCase(CaseID).ZoneNodeNum > 0) {
                        print(ioFiles.eio,
                              "   Refrigeration Case,{},{},{},{},{},{:.1R},{:.2R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R}\n",
                              CaseID,
                              RefrigCase(CaseID).Name,
                              RefrigCase(CaseID).ZoneName,
                              RefrigCase(CaseID).ZoneNodeNum,
                              DataLoopNode::NodeID(RefrigCase(CaseID).ZoneNodeNum),
                              RefrigCase(CaseID).RateTotCapPerLength,
                              RefrigCase(CaseID).RatedLHR,
                              RefrigCase(CaseID).Temperature,
                              RefrigCase(CaseID).Length,
                              RefrigCase(CaseID).OperatingFanPower,
                              RefrigCase(CaseID).LightingPower,
                              RefrigCase(CaseID).AntiSweatPower,
                              RefrigCase(CaseID).DefrostPower);
                    }
                } // NumCases on system
                for (int WalkInNum = 1; WalkInNum <= System(SystemNum).NumWalkIns; ++WalkInNum) {
                    int WalkInID = System(SystemNum).WalkInNum(WalkInNum);
                    print(ioFiles.eio,
                          "   Refrigeration Walk In Cooler,{},{},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{}\n",
                          WalkInID,
                          WalkIn(WalkInID).Name,
                          WalkIn(WalkInID).DesignRatedCap,
                          WalkIn(WalkInID).Temperature,
                          WalkIn(WalkInID).CoilFanPower,
                          WalkIn(WalkInID).CircFanPower,
                          WalkIn(WalkInID).DesignLighting,
                          WalkIn(WalkInID).HeaterPower,
                          WalkIn(WalkInID).DefrostCapacity,
                          WalkIn(WalkInID).NumZones);
                    for (int ZoneID = 1; ZoneID <= WalkIn(WalkInID).NumZones; ++ZoneID) {
                        print(ioFiles.eio,
                              "      Walk-In Surfaces Facing Zone, {},{:.1R},{:.4R},{:.2R},{:.2R},{:.4R},{:.2R},{:.2R},{:.4R}\n",
                              WalkIn(WalkInID).ZoneName(ZoneID),
                              WalkIn(WalkInID).SurfaceArea(ZoneID),
                              WalkIn(WalkInID).UValue(ZoneID),
                              WalkIn(WalkInID).AreaStockDr(ZoneID),
                              WalkIn(WalkInID).HeightStockDr(ZoneID),
                              WalkIn(WalkInID).UValueStockDr(ZoneID),
                              WalkIn(WalkInID).AreaGlassDr(ZoneID),
                              WalkIn(WalkInID).HeightGlassDr(ZoneID),
                              WalkIn(WalkInID).UValueGlassDr(ZoneID));
                    } // Num zones for each walk in on system
                }     // NumWalkIns on system

                for (int CoilNum = 1; CoilNum <= System(SystemNum).NumCoils; ++CoilNum) {
                    int CoilID = System(SystemNum).CoilNum(CoilNum);
                    print(ioFiles.eio, "   Air Chiller Load,{},{},{}\n", WarehouseCoil(CoilID).Name, CoilID, WarehouseCoil(CoilID).ZoneName);
                } // numairchillers

                for (int CascadeLoadNum = 1; CascadeLoadNum <= System(SystemNum).NumCascadeLoads; ++CascadeLoadNum) {
                    int CascadeLoadID = System(SystemNum).CascadeLoadNum(CascadeLoadNum);
                    print(ioFiles.eio,
                          "   Cascade Load,{},{},{}\n",
                          System(Condenser(CascadeLoadID).CascadeSysID).Name,
                          CascadeLoadID,
                          Condenser(CascadeLoadID).Name);
                } // cascade load on detailed system

                for (int SecondaryNum = 1; SecondaryNum <= System(SystemNum).NumSecondarys; ++SecondaryNum) {
                    int SecondaryID = System(SystemNum).SecondaryNum(SecondaryNum);
                    print(ioFiles.eio, "   Secondary Load,{},{}\n", Secondary(SecondaryID).Name, SecondaryID);
                } // secondary load on detailed system

                for (int SubcoolerNum = 1; SubcoolerNum <= NumSimulationSubcoolers; ++SubcoolerNum) {
                    if (Subcooler(SubcoolerNum).MechSourceSysID != SystemNum) continue;
                    print(
                        ioFiles.eio, "   Mechanical Subcooler Load, {},{}\n", SubcoolerNum, Subcooler(SubcoolerNum).Name);
                } // Num sim subcoolers, looking only for NumSMech Subcoolers served by this system

                if (System(SystemNum).NumStages == 1) { // Single-stage compression system
                    for (int CompressorNum = 1; CompressorNum <= System(SystemNum).NumCompressors; ++CompressorNum) {
                        int CompID = System(SystemNum).CompressorNum(CompressorNum);
                        print(
                            ioFiles.eio, "   Refrigeration Compressor,{},{},{:.0R}\n", CompID, Compressor(CompID).Name, Compressor(CompID).NomCap);
                    }                                          // NumCompressors
                } else if (System(SystemNum).NumStages == 2) { // Two-stage compression system
                    // Low-stage compressors
                    for (int CompressorNum = 1; CompressorNum <= System(SystemNum).NumCompressors; ++CompressorNum) {
                        int CompID = System(SystemNum).CompressorNum(CompressorNum);
                        print(ioFiles.eio,
                              "   Refrigeration Low-Stage Compressor,{},{},{:.0R}\n",
                              CompID,
                              Compressor(CompID).Name,
                              Compressor(CompID).NomCap);
                    } // NumCompressors
                    // High-stage compressors
                    for (int CompressorNum = 1; CompressorNum <= System(SystemNum).NumHiStageCompressors; ++CompressorNum) {
                        int CompID = System(SystemNum).HiStageCompressorNum(CompressorNum);
                        print(ioFiles.eio,
                              "   Refrigeration High-Stage Compressor,{},{},{:.0R}\n",
                              CompID,
                              Compressor(CompID).Name,
                              Compressor(CompID).NomCap);
                    } // NumHiStageCompressors
                }     // NumStages

                int CondID = System(SystemNum).CondenserNum(1);
                {
                    auto const SELECT_CASE_var(Condenser(CondID).CondenserType);
                    if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeAir) {
                        print(ioFiles.eio,
                              "   Refrigeration Condenser:Air-Cooled,{},{},{:.1R},{:.1R},{:.1R}\n",
                              CondID,
                              Condenser(CondID).Name,
                              Condenser(CondID).RatedTCondense,
                              Condenser(CondID).RatedCapacity,
                              Condenser(CondID).RatedFanPower);
                    } else if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeEvap) {
                        print(ioFiles.eio,
                              "   Refrigeration Condenser:Evaporative-Cooled,{},{},{:.1R},{:.1R}\n",
                              CondID,
                              Condenser(CondID).Name,
                              Condenser(CondID).RatedCapacity,
                              Condenser(CondID).RatedFanPower);
                    } else if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeWater) {
                        print(ioFiles.eio,
                              "   Refrigeration Condenser:Water-Cooled,{},{},{:.1R},{:.1R},{:.1R},{:.1R}\n",
                              CondID,
                              Condenser(CondID).Name,
                              Condenser(CondID).RatedTCondense,
                              Condenser(CondID).RatedCapacity,
                              Condenser(CondID).InletTemp,
                              Condenser(CondID).DesVolFlowRate);
                    } else if (SELECT_CASE_var == DataHeatBalance::RefrigCondenserTypeCascade) {

                        {
                            auto const SELECT_CASE_var1(Condenser(CondID).CascadeTempControl);
                            if (SELECT_CASE_var1 == CascadeTempSet) {
                                ChrOut = "Fixed";
                            } else if (SELECT_CASE_var1 == CascadeTempFloat) {
                                ChrOut = "Floating";
                            }
                        } // cascade temperature control
                        print(ioFiles.eio,
                              "   Refrigeration Condenser:Cascade,{},{},{},{:.1R},{:.1R},{:.1R}\n",
                              CondID,
                              Condenser(CondID).Name,
                              ChrOut,
                              Condenser(CondID).RatedTCondense,
                              Condenser(CondID).RatedCapacity,
                              Condenser(CondID).RatedApproachT);
                    }
                } // condenser type

                for (int SubcoolerNum = 1; SubcoolerNum <= System(SystemNum).NumSubcoolers; ++SubcoolerNum) {
                    int SubcoolerID = System(SystemNum).SubcoolerNum(SubcoolerNum);
                    {
                        auto const SELECT_CASE_var(Subcooler(SubcoolerID).SubcoolerType);
                        if (SELECT_CASE_var == LiquidSuction) {
                            print(ioFiles.eio,
                                  "   Refrigeration Liquid Suction Subcooler,{},{},{:.1R},{:.1R},{:.1R}\n",
                                  SubcoolerID,
                                  Subcooler(SubcoolerID).Name,
                                  Subcooler(SubcoolerID).LiqSuctDesignDelT,
                                  Subcooler(SubcoolerID).LiqSuctDesignTliqIn,
                                  Subcooler(SubcoolerID).LiqSuctDesignTvapIn);
                        } else if (SELECT_CASE_var == Mechanical) {
                            print(ioFiles.eio,
                                  "   Refrigeration Mechanical Subcooler,{},{},{},{:.1R}\n",
                                  SubcoolerID,
                                  Subcooler(SubcoolerID).Name,
                                  Subcooler(SubcoolerID).MechSourceSys,
                                  Subcooler(SubcoolerID).MechControlTliqOut);
                        }
                    }
                } // NumSubcoolers

            } // NumRefrigSystems
        }     //(NumRefrigSystems > 0)

        if (NumTransRefrigSystems > 0) {
            print(ioFiles.eio, "#Detailed Transcritical Refrigeration Systems,{}\n", NumTransRefrigSystems);
            for (int TransSystemNum = 1; TransSystemNum <= NumTransRefrigSystems; ++TransSystemNum) {
                print(ioFiles.eio,
                      " Detailed Transcritical Refrigeration System,{},{},{},{},{},{},{},{},{:.1R}\n",
                      TransSystem(TransSystemNum).Name,
                      TransSystem(TransSystemNum).RefrigerantName,
                      TransSystem(TransSystemNum).NumCasesMT,
                      TransSystem(TransSystemNum).NumCasesLT,
                      TransSystem(TransSystemNum).NumWalkInsMT,
                      TransSystem(TransSystemNum).NumWalkInsLT,
                      TransSystem(TransSystemNum).NumCompressorsHP,
                      TransSystem(TransSystemNum).NumCompressorsLP,
                      GasCooler(TransSystem(TransSystemNum).GasCoolerNum(1)).MinCondTemp);

                for (int CaseNum = 1; CaseNum <= TransSystem(TransSystemNum).NumCasesMT; ++CaseNum) {
                    int CaseID = TransSystem(TransSystemNum).CaseNumMT(CaseNum);
                    if (RefrigCase(CaseID).ZoneNodeNum > 0) {
                        print(ioFiles.eio,
                              "   Medium Temperature Refrigeration Case,{},{},{},{},{},{:.1R},{:.2R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R}\n",
                              CaseID,
                              RefrigCase(CaseID).Name,
                              RefrigCase(CaseID).ZoneName,
                              RefrigCase(CaseID).ZoneNodeNum,
                              DataLoopNode::NodeID(RefrigCase(CaseID).ZoneNodeNum),
                              RefrigCase(CaseID).RateTotCapPerLength,
                              RefrigCase(CaseID).RatedLHR,
                              RefrigCase(CaseID).Temperature,
                              RefrigCase(CaseID).Length,
                              RefrigCase(CaseID).OperatingFanPower,
                              RefrigCase(CaseID).LightingPower,
                              RefrigCase(CaseID).AntiSweatPower,
                              RefrigCase(CaseID).DefrostPower);
                    }
                } // NumCasesMT on system
                for (int CaseNum = 1; CaseNum <= TransSystem(TransSystemNum).NumCasesLT; ++CaseNum) {
                    int CaseID = TransSystem(TransSystemNum).CaseNumLT(CaseNum);
                    if (RefrigCase(CaseID).ZoneNodeNum > 0) {
                        print(ioFiles.eio,
                              "   Low Temperature Refrigeration Case,{},{},{},{},{},{:.1R},{:.2R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R}\n",
                              CaseID,
                              RefrigCase(CaseID).Name,
                              RefrigCase(CaseID).ZoneName,
                              RefrigCase(CaseID).ZoneNodeNum,
                              DataLoopNode::NodeID(RefrigCase(CaseID).ZoneNodeNum),
                              RefrigCase(CaseID).RateTotCapPerLength,
                              RefrigCase(CaseID).RatedLHR,
                              RefrigCase(CaseID).Temperature,
                              RefrigCase(CaseID).Length,
                              RefrigCase(CaseID).OperatingFanPower,
                              RefrigCase(CaseID).LightingPower,
                              RefrigCase(CaseID).AntiSweatPower,
                              RefrigCase(CaseID).DefrostPower);
                    }
                } // NumCasesLT on system
                for (int WalkInNum = 1; WalkInNum <= TransSystem(TransSystemNum).NumWalkInsMT; ++WalkInNum) {
                    int WalkInID = TransSystem(TransSystemNum).WalkInNumMT(WalkInNum);
                    print(ioFiles.eio,
                          "   Medium Temperature Refrigeration Walk In Cooler,{},{},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{}\n",
                          WalkInID,
                          WalkIn(WalkInID).Name,
                          WalkIn(WalkInID).DesignRatedCap,
                          WalkIn(WalkInID).Temperature,
                          WalkIn(WalkInID).CoilFanPower,
                          WalkIn(WalkInID).CircFanPower,
                          WalkIn(WalkInID).DesignLighting,
                          WalkIn(WalkInID).HeaterPower,
                          WalkIn(WalkInID).DefrostCapacity,
                          WalkIn(WalkInID).NumZones);
                    for (int ZoneID = 1; ZoneID <= WalkIn(WalkInID).NumZones; ++ZoneID) {
                        print(ioFiles.eio,
                              "      Walk-In Surfaces Facing Zone,{},{:.1R},{:.4R},{:.2R},{:.2R},{:.4R},{:.2R},{:.2R},{:.4R}\n",
                              WalkIn(WalkInID).ZoneName(ZoneID),
                              WalkIn(WalkInID).SurfaceArea(ZoneID),
                              WalkIn(WalkInID).UValue(ZoneID),
                              WalkIn(WalkInID).AreaStockDr(ZoneID),
                              WalkIn(WalkInID).HeightStockDr(ZoneID),
                              WalkIn(WalkInID).UValueStockDr(ZoneID),
                              WalkIn(WalkInID).AreaGlassDr(ZoneID),
                              WalkIn(WalkInID).HeightGlassDr(ZoneID),
                              WalkIn(WalkInID).UValueGlassDr(ZoneID));
                    } // Num zones for each walk in on system
                }     // NumWalkInsMT on system
                for (int WalkInNum = 1; WalkInNum <= TransSystem(TransSystemNum).NumWalkInsLT; ++WalkInNum) {
                    int WalkInID = TransSystem(TransSystemNum).WalkInNumLT(WalkInNum);
                    print(ioFiles.eio,
                          "   Low Temperature Refrigeration Walk In Cooler,{},{},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{}\n",
                          WalkInID,
                          WalkIn(WalkInID).Name,
                          WalkIn(WalkInID).DesignRatedCap,
                          WalkIn(WalkInID).Temperature,
                          WalkIn(WalkInID).CoilFanPower,
                          WalkIn(WalkInID).CircFanPower,
                          WalkIn(WalkInID).DesignLighting,
                          WalkIn(WalkInID).HeaterPower,
                          WalkIn(WalkInID).DefrostCapacity,
                          WalkIn(WalkInID).NumZones);
                    for (int ZoneID = 1; ZoneID <= WalkIn(WalkInID).NumZones; ++ZoneID) {
                        print(ioFiles.eio,
                              "      Walk-In Surfaces Facing Zone,{},{:.1R},{:.4R},{:.2R},{:.2R},{:.4R},{:.2R},{:.2R},{:.4R}\n",
                              WalkIn(WalkInID).ZoneName(ZoneID),
                              WalkIn(WalkInID).SurfaceArea(ZoneID),
                              WalkIn(WalkInID).UValue(ZoneID),
                              WalkIn(WalkInID).AreaStockDr(ZoneID),
                              WalkIn(WalkInID).HeightStockDr(ZoneID),
                              WalkIn(WalkInID).UValueStockDr(ZoneID),
                              WalkIn(WalkInID).AreaGlassDr(ZoneID),
                              WalkIn(WalkInID).HeightGlassDr(ZoneID),
                              WalkIn(WalkInID).UValueGlassDr(ZoneID));
                    } // Num zones for each walk in on system
                }     // NumWalkInsLT on system

                for (int CompressorNum = 1; CompressorNum <= TransSystem(TransSystemNum).NumCompressorsHP; ++CompressorNum) {
                    int CompID = TransSystem(TransSystemNum).CompressorNumHP(CompressorNum);
                    print(ioFiles.eio,
                          "   High Pressure Refrigeration Compressor,{},{},{:.0R}\n",
                          CompID,
                          Compressor(CompID).Name,
                          Compressor(CompID).NomCap);
                } // NumCompressorsHP
                for (int CompressorNum = 1; CompressorNum <= TransSystem(TransSystemNum).NumCompressorsLP; ++CompressorNum) {
                    int CompID = TransSystem(TransSystemNum).CompressorNumLP(CompressorNum);
                    print(ioFiles.eio,
                          "   Low Pressure Refrigeration Compressor,{},{},{:.0R}\n",
                          CompID,
                          Compressor(CompID).Name,
                          Compressor(CompID).NomCap);
                } // NumCompressorsLP

                if (TransSystem(TransSystemNum).NumGasCoolers >= 1) {
                    int GasCoolerID = TransSystem(TransSystemNum).GasCoolerNum(1);
                    print(ioFiles.eio,
                          "   Refrigeration GasCooler:Air-Cooled,{},{},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R}\n",
                          GasCoolerID,
                          GasCooler(GasCoolerID).Name,
                          GasCooler(GasCoolerID).RatedOutletP,
                          GasCooler(GasCoolerID).RatedOutletT,
                          GasCooler(GasCoolerID).RatedApproachT,
                          GasCooler(GasCoolerID).RatedCapacity,
                          GasCooler(GasCoolerID).RatedFanPower);
                } // System(SystemNum)%NumGasCoolers >= 1

            } // NumTransRefrigSystems
        }     //(NumTransRefrigSystems > 0)

        if (NumSimulationSecondarySystems > 0) {
            print(ioFiles.eio, "#Secondary Refrigeration Systems,{}\n", NumSimulationSecondarySystems);
            for (int SecondaryID = 1; SecondaryID <= NumSimulationSecondarySystems; ++SecondaryID) {
                {
                    auto const SELECT_CASE_var(Secondary(SecondaryID).FluidType);
                    if (SELECT_CASE_var == SecFluidTypeAlwaysLiquid) {
                        print(ioFiles.eio,
                              "Secondary Refrigeration System: Fluid Always Liquid,{},{},{},{},{},{:.1R},{:.2R},{:.2R},{:.3R},{:.3R}\n",
                              SecondaryID,
                              Secondary(SecondaryID).Name,
                              Secondary(SecondaryID).NumCases,
                              Secondary(SecondaryID).NumWalkIns,
                              Secondary(SecondaryID).FluidName,
                              Secondary(SecondaryID).CoolingLoadRated,
                              Secondary(SecondaryID).TEvapDesign,
                              Secondary(SecondaryID).TApproachDifRated,
                              Secondary(SecondaryID).TRangeDifRated,
                              Secondary(SecondaryID).PumpTotRatedPower);
                    } else if (SELECT_CASE_var == SecFluidTypePhaseChange) {
                        print(ioFiles.eio,
                              "Secondary Refrigeration System: Liquid Overfeed,{},{},{},{},{},{:.1R},{:.2R},{:.2R},{:.3R},{:.3R}\n",
                              SecondaryID,
                              Secondary(SecondaryID).Name,
                              Secondary(SecondaryID).NumCases,
                              Secondary(SecondaryID).NumWalkIns,
                              Secondary(SecondaryID).FluidName,
                              Secondary(SecondaryID).CoolingLoadRated,
                              Secondary(SecondaryID).TEvapDesign,
                              Secondary(SecondaryID).TApproachDifRated,
                              Secondary(SecondaryID).CircRate,
                              Secondary(SecondaryID).PumpTotRatedPower);
                    }
                }
                for (int CaseNum = 1; CaseNum <= Secondary(SecondaryID).NumCases; ++CaseNum) {
                    int CaseID = Secondary(SecondaryID).CaseNum(CaseNum);
                    if (RefrigCase(CaseID).ZoneNodeNum > 0) {
                        print(ioFiles.eio,
                              "  Refrigeration Case,{},{},{},{},{},{:.1R},{:.2R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R}\n",
                              CaseID,
                              RefrigCase(CaseID).Name,
                              RefrigCase(CaseID).ZoneName,
                              RefrigCase(CaseID).ZoneNodeNum,
                              DataLoopNode::NodeID(RefrigCase(CaseID).ZoneNodeNum),
                              RefrigCase(CaseID).RateTotCapPerLength,
                              RefrigCase(CaseID).RatedLHR,
                              RefrigCase(CaseID).Temperature,
                              RefrigCase(CaseID).Length,
                              RefrigCase(CaseID).OperatingFanPower,
                              RefrigCase(CaseID).LightingPower,
                              RefrigCase(CaseID).AntiSweatPower,
                              RefrigCase(CaseID).DefrostPower);
                    }
                } // NumCases on secondary on secondary system

                for (int WalkInNum = 1; WalkInNum <= Secondary(SecondaryID).NumWalkIns; ++WalkInNum) {
                    int WalkInID = Secondary(SecondaryID).WalkInNum(WalkInNum);
                    print(ioFiles.eio,
                          "  Walk In,{},{},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R}\n",
                          WalkInID,
                          WalkIn(WalkInID).Name,
                          WalkIn(WalkInID).DesignRatedCap,
                          WalkIn(WalkInID).Temperature,
                          WalkIn(WalkInID).CoilFanPower,
                          WalkIn(WalkInID).CircFanPower,
                          WalkIn(WalkInID).DesignLighting,
                          WalkIn(WalkInID).HeaterPower,
                          WalkIn(WalkInID).DefrostCapacity);
                    for (int ZoneID = 1; ZoneID <= WalkIn(WalkInID).NumZones; ++ZoneID) {
                        print(ioFiles.eio,
                              "    Walk In Surfaces Facing Zone,{},{:.1R},{:.4R},{:.2R},{:.2R},{:.4R},{:.2R},{:.2R},{:.4R}\n",
                              WalkIn(WalkInID).ZoneName(ZoneID),
                              WalkIn(WalkInID).SurfaceArea(ZoneID),
                              WalkIn(WalkInID).UValue(ZoneID),
                              WalkIn(WalkInID).AreaStockDr(ZoneID),
                              WalkIn(WalkInID).HeightStockDr(ZoneID),
                              WalkIn(WalkInID).UValueStockDr(ZoneID),
                              WalkIn(WalkInID).AreaGlassDr(ZoneID),
                              WalkIn(WalkInID).HeightGlassDr(ZoneID),
                              WalkIn(WalkInID).UValueGlassDr(ZoneID));
                    } // zones for walk ins on secondary
                }     // walk ins on secondary

                for (int CoilNum = 1; CoilNum <= Secondary(SecondaryID).NumCoils; ++CoilNum) {
                    int CoilID = Secondary(SecondaryID).CoilNum(CoilNum);
                    print(ioFiles.eio, "   Air Chiller Load,{},{},{}\n", WarehouseCoil(CoilID).Name, CoilID, WarehouseCoil(CoilID).ZoneName);
                } // numairchillers
            }     // secondary
        }         // numsimulationsecondarys

        if (DataHeatBalance::NumRefrigChillerSets > 0) {
            print(ioFiles.eio, "#ZoneHVAC/Refrigeration Air Chiller Sets,{}\n", DataHeatBalance::NumRefrigChillerSets);
            for (int ChillerSetNum = 1; ChillerSetNum <= DataHeatBalance::NumRefrigChillerSets; ++ChillerSetNum) {
                print(ioFiles.eio,
                      "ZoneHVAC/Refrigeration Air Chiller Set,{},{},{},{}\n",
                      AirChillerSet(ChillerSetNum).Name,
                      ChillerSetNum,
                      AirChillerSet(ChillerSetNum).NumCoils,
                      AirChillerSet(ChillerSetNum).ZoneName);

                for (int CoilNum = 1; CoilNum <= AirChillerSet(ChillerSetNum).NumCoils; ++CoilNum) {
                    int CoilID = AirChillerSet(ChillerSetNum).CoilNum(CoilNum);
                    print(ioFiles.eio,
                          "   Refrigeration Air Chiller,{},{},{},{},{},{:.1R},{:.2R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R},{:.1R}\n",
                          CoilID,
                          WarehouseCoil(CoilID).Name,
                          WarehouseCoil(CoilID).ZoneName,
                          WarehouseCoil(CoilID).ZoneNodeNum,
                          DataLoopNode::NodeID(WarehouseCoil(CoilID).ZoneNodeNum),
                          WarehouseCoil(CoilID).UnitLoadFactorSens,
                          WarehouseCoil(CoilID).RatedSensibleCap,
                          WarehouseCoil(CoilID).TEvapDesign,
                          WarehouseCoil(CoilID).RatedTemperatureDif,
                          WarehouseCoil(CoilID).RatedFanPower,
                          WarehouseCoil(CoilID).HeaterPower,
                          WarehouseCoil(CoilID).DefrostCapacity,
                          WarehouseCoil(CoilID).RatedAirVolumeFlow);
                } // numairchillers
            }     // DataHeatBalance::NumRefrigChillerSets
        }         // DataHeatBalance::NumRefrigChillerSets
    }

    void WalkInData::CalculateWalkIn() // Absolute pointer to  Walk In
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL, May 2009
        //       DATE WRITTEN   Oct/Nov 2004
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // To model Walk In Coolers.

        // METHODOLOGY EMPLOYED:
        // Walk-in cooler performance is based on the ASHRAE load model, which includes
        // infiltration through door openings and sensible loss through walls/ceilings identified
        // by the user as sum of UA for each zone. A sub-floor heater is assumed to be sized so that
        // the temperature of the slab beneath the floor insulation is the same as the ground
        // temperature (to avoid ground freezing and heaving).
        // All equipment loads (fan, light, heaters) are modeled as well.  Sensible and latent
        // exchange with multiple adjoining zones is included. A master schedule is used for the Walk In operation and
        // additional schedules control the lights, defrost, and heater operation.

        // The fan is assumed to be off for Hot-Gas, Hot-Brine, and Electric defrost. The user can choose
        // to include the load due to bringing the coil mass up from the evaporating temperature to the melting temperature
        //  if they choose.  Otherwise this factor is set to zero.

        // Unmet loads are accumulated to be met the following time step.  This usually occurs during defrost and
        // restocking.

        // REFERENCES:
        // ASHRAE 2006 Handbook, chapters 13 and 14.
        // Gosney, W.B., Olama, G.A.-L., Heat and Enthalpy Gains through Cold Room Doorways,
        //     Proceedings of the Institute of Refrigeration, vol. 72, pp 31-41, 1975

        Real64 const DefaultWalkInDoorOpenFactor(0.05); // walk in door open factor (fraction time open)

        static std::string const RoutineName("CalculateWalkIn");
        Real64 CapApplied(0.0);          // Walk In total capacity at specific operating conditions
        Real64 DefrostSchedule(0.0);     // WalkIn defrost schedule, between 0 and 1
        Real64 DefrostEnergyNeeded(0.0); // Energy needed to melt all ice, used with temperature termination (J)
        Real64 DensityFactorFm(0.0);     // called Fm in ASHRAE 2010 eq 13 page 24.5 for door infiltration
        Real64 DensitySqRtFactor(0.0);   // from ASHRAE 2010 eq 12 page 24.4 for door infiltration

        // Current value of WalkIn operating (availability) schedule
        Real64 WalkInSchedule = ScheduleManager::GetCurrentScheduleValue(this->SchedPtr);
        if (WalkInSchedule <= 0) return;
        // GET OTHER SCHEDULES
        DefrostSchedule = ScheduleManager::GetCurrentScheduleValue(this->DefrostSchedPtr);
        Real64 DefrostDripDownSchedule = ScheduleManager::GetCurrentScheduleValue(this->DefrostDripDownSchedPtr);
        // next statement In case user doesn't understand concept of drip down schedule
        DefrostDripDownSchedule = max(DefrostDripDownSchedule, DefrostSchedule);

        // next four values optional, so set to default before checking for schedule
        Real64 StockingLoad(0.0); // Total load due to stocking WalkIn product (W)
        Real64 LightingSchedule = 1.0;
        Real64 HeaterSchedule = 1.0;
        Real64 CircFanSchedule = 1.0;
        if (this->StockingSchedPtr > 0) StockingLoad = ScheduleManager::GetCurrentScheduleValue(this->StockingSchedPtr);
        if (this->LightingSchedPtr > 0) LightingSchedule = ScheduleManager::GetCurrentScheduleValue(this->LightingSchedPtr);
        if (this->HeaterSchedPtr > 0) HeaterSchedule = ScheduleManager::GetCurrentScheduleValue(this->HeaterSchedPtr);
        if (this->CircFanSchedPtr > 0) CircFanSchedule = ScheduleManager::GetCurrentScheduleValue(this->CircFanSchedPtr);

        // Set local subroutine variables for convenience
        Real64 TWalkIn = this->Temperature; // WalkIn operating temperature (C)

        // Enthalpy of air corresponding to walk in temperature and 90% assumed RH (J/kg)
        Real64 EnthalpyAirWalkIn = Psychrometrics::PsyHFnTdbRhPb(TWalkIn, 0.9, DataEnvironment::OutBaroPress); // assume 90%RH in cooler

        // corresponds to walk in temp and 90% assumed RH(kg water/kg dry air)
        Real64 HumRatioAirWalkIn = Psychrometrics::PsyWFnTdbH(TWalkIn, EnthalpyAirWalkIn);
        Real64 DensityAirWalkIn = Psychrometrics::PsyRhoAirFnPbTdbW(DataEnvironment::OutBaroPress, TWalkIn, HumRatioAirWalkIn);
        Real64 Conv = DataEnvironment::Latitude * 2.0 * DataGlobals::Pi / 360.0; // Convert DataEnvironment::Latitude to radians
        Real64 Gravity = 9.780373 * (1.0 + 0.0052891 * pow_2(std::sin(Conv)) - 0.0000059 * pow_2(std::sin(2.0 * Conv)));

        // CALCULATE ALL LOADS INFLUENCED BY ZONE TEMPERATURE AND RH
        // set to zero before summing over zones
        Real64 SensibleLoadTotal(0.0); // Total sensible load on WalkIn over all zones (W)
        Real64 LatentLoadTotal(0.0);   // total latent load on WalkIn over all zones (W)
        Real64 ZoneLatentLoad(0.0);    // Latent WalkIn credit delivered to zone (W)

        this->SensZoneCreditRate = 0.0;
        this->SensZoneCreditCoolRate = 0.0;
        this->SensZoneCreditCool = 0.0;
        this->SensZoneCreditHeatRate = 0.0;
        this->SensZoneCreditHeat = 0.0;
        this->LatZoneCreditRate = 0.0;

        // Start zone loop:
        for (int ZoneID = 1; ZoneID <= this->NumZones; ++ZoneID) {
            int zoneNum = this->ZoneNum(ZoneID);
            int zoneNodeNum = this->ZoneNodeNum(ZoneID);
            Real64 ZoneDryBulb = DataLoopNode::Node(zoneNodeNum).Temp; // Dry Bulb Temperature of adjacent zone
            Real64 WalkInLatLoad = -ZoneLatentLoad;                    // Walk in cooler latent load facing particular zone (W)
            Real64 DelTemp = ZoneDryBulb - TWalkIn;                    // Difference between zone and walk in temperatures (C)
            Real64 StockDoorArea = this->AreaStockDr(ZoneID);
            Real64 GlassDoorArea = this->AreaGlassDr(ZoneID);                          // facing a particular zone (m2)
            Real64 UAOtherSurfaces = this->SurfaceArea(ZoneID) * this->UValue(ZoneID); // UA for non-door surfaces facing a certain zone (W/C)
            Real64 ZInfilSensLoad(0.0);                                                // Sensible load due to infiltration in one zone
            Real64 ZdoorSensLoad(0.0); // Sensible load due to UA delta T through closed door in one zone

            // Derate compared to fully developed flow through 100% open door
            Real64 DoorFlowFactor = 0.8;               // see ASHRAE Refrigeration, p13.5, 2006
            if (DelTemp <= 11.0) DoorFlowFactor = 1.1; // from ASHRAE Refrigeration Loads

            // Get infiltration loads if either type of door is present in this zone
            if (StockDoorArea > 0.0 || GlassDoorArea > 0.0) {
                // Zone relative humidity fraction (decimal)
                Real64 ZoneRHFrac = Psychrometrics::PsyRhFnTdbWPb(
                    DataLoopNode::Node(zoneNodeNum).Temp, DataLoopNode::Node(zoneNodeNum).HumRat, DataEnvironment::OutBaroPress, RoutineName);
                // Enthalpy of the air in a particular zone (J/kg)
                Real64 EnthalpyZoneAir = Psychrometrics::PsyHFnTdbRhPb(ZoneDryBulb, ZoneRHFrac, DataEnvironment::OutBaroPress, RoutineName);
                Real64 HumRatioZoneAir = Psychrometrics::PsyWFnTdbH(ZoneDryBulb, EnthalpyZoneAir, RoutineName);
                Real64 DensityZoneAir = Psychrometrics::PsyRhoAirFnPbTdbW(DataEnvironment::OutBaroPress, ZoneDryBulb, HumRatioZoneAir, RoutineName);
                if (DensityZoneAir < DensityAirWalkIn) { // usual case when walk in is colder than zone
                    DensitySqRtFactor = std::sqrt(1.0 - DensityZoneAir / DensityAirWalkIn);
                    DensityFactorFm = std::pow(2.0 / (1.0 + std::pow(DensityAirWalkIn / DensityZoneAir, 0.333)), 1.5);
                } else { // temperature inversion with zone colder and/or drier than walk-in, infiltration in reverse direction
                    // The enthalpy difference will show whether the energy transport is reversed
                    //(same air mass exchange in either direction )
                    // That is, these factors establish the magnitude of the exchange air flow, not direction
                    DensitySqRtFactor = std::sqrt(1.0 - DensityAirWalkIn / DensityZoneAir);
                    DensityFactorFm = std::pow(2.0 / (1.0 + std::pow(DensityZoneAir / DensityAirWalkIn, 0.333)), 1.5);
                } // check for density in zone and in walk-in to avoid taking sqrt of neg number

                Real64 StockDoorInfLoad = 0.0;  // infiltration through stock doors in a particular zone (W)
                Real64 StockDoorSensHeat = 0.0; // sensible heat gain through stock doors (UA*delta T) (W)
                Real64 DoorProtectEff(0.0);     // Door protection effectiveness
                Real64 DrHeight(0.0);           // Door height (m)
                Real64 DrArea(0.0);             // Door area (m2)
                Real64 FullFlowInfLoad(0.0);    // Total load (lat + sens) due to 100% open doors w/ fully developed flow (W)

                if (StockDoorArea > 0.0) {
                    {
                        auto const SELECT_CASE_var(this->StockDoorProtectType(ZoneID));
                        // Values from ASHRAE Ref p 13.6
                        if (SELECT_CASE_var == WIStockDoorNone) {
                            DoorProtectEff = 0.0;
                        } else if (SELECT_CASE_var == WIStockDoorAirCurtain) {
                            DoorProtectEff = 0.5;
                        } else if (SELECT_CASE_var == WIStockDoorStripCurtain) {
                            DoorProtectEff = 0.9;
                        }
                    }
                    DrHeight = this->HeightStockDr(ZoneID);
                    DrArea = StockDoorArea;
                    // if exists, get Stock Door Zone schedule
                    Real64 DoorOpenFactor = DefaultWalkInDoorOpenFactor;
                    if (this->StockDoorOpenSchedPtr(ZoneID) > 0)
                        DoorOpenFactor = ScheduleManager::GetCurrentScheduleValue(this->StockDoorOpenSchedPtr(ZoneID));

                    FullFlowInfLoad = 0.221 * DrArea * (EnthalpyZoneAir - EnthalpyAirWalkIn) * DensityAirWalkIn * DensitySqRtFactor *
                                      std::sqrt(Gravity * DrHeight) * DensityFactorFm;
                    StockDoorInfLoad = FullFlowInfLoad * DoorOpenFactor * DoorFlowFactor * (1.0 - DoorProtectEff);
                    StockDoorSensHeat = DrArea * this->UValueStockDr(ZoneID) * DelTemp;
                } // have stock doors

                Real64 GlassDoorSensHeat(0.0); // sensible heat gain through glass reach-in doors (UA*delta T) (W)
                Real64 GlassDoorInfLoad = 0.0; // infiltration through glass reach-in doors in a particular zone (W)

                if (GlassDoorArea > 0.0) {
                    DoorProtectEff = 0.5; // Assume glass doors have air curtain
                    DrHeight = this->HeightGlassDr(ZoneID);
                    DrArea = GlassDoorArea;
                    // get Glass Door Zone schedule
                    Real64 DoorOpenFactor = DefaultWalkInDoorOpenFactor; // default value
                    if (this->GlassDoorOpenSchedPtr(ZoneID) > 0)
                        DoorOpenFactor = ScheduleManager::GetCurrentScheduleValue(this->GlassDoorOpenSchedPtr(ZoneID));

                    FullFlowInfLoad = 0.221 * DrArea * (EnthalpyZoneAir - EnthalpyAirWalkIn) * DensityAirWalkIn * DensitySqRtFactor *
                                      std::sqrt(Gravity * DrHeight) * DensityFactorFm;
                    GlassDoorInfLoad = FullFlowInfLoad * DoorOpenFactor * DoorFlowFactor * (1.0 - DoorProtectEff);
                    GlassDoorSensHeat = DrArea * this->UValueGlassDr(ZoneID) * DelTemp;
                } // have Glass doors

                // assume mass dry air infiltrating into walk-in == mass out into zone,
                //                       that is, equal air exchange (ASHRAE 2006 Refrigeration)
                Real64 ZoneInfilLoad = -StockDoorInfLoad - GlassDoorInfLoad; // Walk in cooler infiltration load (sens + latent) in certain zone (W)
                Real64 MassDryAirRate =
                    -ZoneInfilLoad / (EnthalpyZoneAir - EnthalpyAirWalkIn); // Mass dry air infiltrating into/out-of walkin through doors (kg/s)
                Real64 WaterRemovRate =
                    MassDryAirRate * (HumRatioZoneAir - HumRatioAirWalkIn); // Walk in cooler removes water at this rate in this zone (kg/s)
                // Just as with cases,  we assume no latent credit (water removal = 0) to zone or load on cooler during dripdown
                // To be consistent with the treatment of refrigerated cases, latent load
                //  and latent credit are bothbased on reducing the infiltrating vapor to ice.  (This is
                //  slightly greater than if the latent credit were based upon condensing out the water as liquid.)
                //  then it would be: ZoneLatentLoad = -WaterRemovRate * WaterToVaporEnthalpy * (1.0d0-DefrostDripDownSchedule)
                ZoneLatentLoad = -WaterRemovRate * IcetoVaporEnthalpy * (1.0 - DefrostDripDownSchedule);
                ZInfilSensLoad = ZoneInfilLoad - (-WaterRemovRate * IcetoVaporEnthalpy); // done to avoid moving latent to sens during dripdown
                ZdoorSensLoad = -GlassDoorSensHeat - StockDoorSensHeat;
                WalkInLatLoad = -ZoneLatentLoad;
                if (this->TEvapDesign <= 0.0) { // water turned to ice on coil
                    WalkInLatLoad = WaterRemovRate * IcetoVaporEnthalpy * (1.0 - DefrostDripDownSchedule);
                    // FROST:  keep track of frost build up on evaporator coil
                    //         avoid accumulation during warm-up to avoid reverse dd test problem
                    if (!DataGlobals::WarmupFlag) {
                        Real64 FrostChangekg = (WaterRemovRate * DataGlobals::TimeStepZoneSec) * (1.0 - DefrostDripDownSchedule);
                        this->KgFrost += FrostChangekg;
                    }
                } // water to ice
            }     // No doors

            // Sensible WalkIn credit delivered to a particular zone (W)
            Real64 ZoneSensLoad = ZInfilSensLoad + ZdoorSensLoad - UAOtherSurfaces * DelTemp;
            Real64 WalkInSensLoad = -ZoneSensLoad; // Walk in cooler sensible load facing particular zone (W)

            // Update globals for use in ZoneTemperaturePredictorCorrector (Air Heat Balance) and
            //   Zone Equipment Manager. Sum walk-in credits to zone using existing 'casecredit' variable
            //   No return air fractions are applied to walk-ins, and no latent in stocking -

            DataHeatBalance::RefrigCaseCredit(zoneNum).SenCaseCreditToZone += ZoneSensLoad;
            DataHeatBalance::RefrigCaseCredit(zoneNum).LatCaseCreditToZone += ZoneLatentLoad;

            // Set up report variables for each zone for this walk-in
            // Sensible heat exchange can be positive or negative, split into separate output variables and always report positive value
            this->SensZoneCreditRate(ZoneID) = ZoneSensLoad;
            if (ZoneSensLoad <= 0.0) {
                this->SensZoneCreditCoolRate(ZoneID) = -ZoneSensLoad;
                this->SensZoneCreditCool(ZoneID) = -ZoneSensLoad * DataGlobals::TimeStepZoneSec;
                this->SensZoneCreditHeatRate(ZoneID) = 0.0;
                this->SensZoneCreditHeat(ZoneID) = 0.0;
            } else {
                this->SensZoneCreditHeatRate(ZoneID) = ZoneSensLoad;
                this->SensZoneCreditHeat(ZoneID) = ZoneSensLoad * DataGlobals::TimeStepZoneSec;
                this->SensZoneCreditCoolRate(ZoneID) = 0.0;
                this->SensZoneCreditCool(ZoneID) = 0.0;
            }
            // This rate should always be negative
            this->LatZoneCreditRate(ZoneID) = ZoneLatentLoad;
            this->LatZoneCredit(ZoneID) = ZoneLatentLoad * DataGlobals::TimeStepZoneSec;

            // Running total over all zones, use later to dispatch capacity
            SensibleLoadTotal += WalkInSensLoad;
            LatentLoadTotal += WalkInLatLoad;

        } // Do loop over zones for zone-condition-related sensible and latent loads

        // cooling coil fan power default is 375W, = 1/2 HP (Tyler showed 1/3 to 3/4 hp)

        // CALCULATE AUX LOADS DUE TO LIGHTS, FANS AND HEATERS
        Real64 LightLoad = this->DesignLighting * LightingSchedule; // Total lighting energy rate (W)
        // turn coil fan off during defrost/drip - down period

        // Total fan energy rate (W)
        Real64 FanLoad = this->CircFanPower * CircFanSchedule + this->CoilFanPower * (1.0 - DefrostDripDownSchedule);
        Real64 HeaterLoad = this->HeaterPower * HeaterSchedule; // Total heater (except defrost) energy rate (W)
        // Calculate floor load - using 'DataEnvironment::GroundTemp' assigned in weather manager (can be entered by user if desired)
        //    Default value is 18C.
        // Total floor energy rate (W)
        Real64 FloorLoad = this->FloorArea * this->FloorUValue * (DataEnvironment::GroundTemp - TWalkIn);

        Real64 DefrostLoad;

        // DEFROST CALCULATIONS
        if ((DefrostSchedule > 0.0) && (this->DefrostType != WalkInDefrostNone) && (this->DefrostType != WalkInDefrostOffCycle)) {
            DefrostLoad = this->DefrostCapacity * DefrostSchedule;             // W
            Real64 StartFrostKg = this->KgFrost;                               // frost load at start of time step (kg of ice)
            Real64 DefrostEnergy = DefrostLoad * DataGlobals::TimeStepZoneSec; // Joules
            if (this->DefrostControlType == DefrostContTempTerm) {
                //  Need to turn defrost system off early if controlled by temperature and all ice melted
                //  For temperature termination, need to recognize not all defrost heat goes to melt ice
                //  Some goes to misc losses (for fluid defrost, some coil areas bare earlier than
                //  others and xfer heat to environment)
                //  Assume full ice melting satisfies temperature control.
                //      (defaults for DefEnergyFraction are :=0.7 for elec, =0.3 for fluids)
                Real64 AvailDefrostEnergy = this->DefEnergyFraction * DefrostEnergy; // Joules avail to melt ice
                Real64 IceSensHeatNeeded = 0.0; // Energy to raise frost temperature to 0C, used w/ temp termination (J)
                if (StartFrostKg > 0.0) {
                    if (this->IceTemp < 0.0) {
                        Real64 StartIceTemp = this->IceTemp;                                       // Frost temperature at start of time step [C]
                        IceSensHeatNeeded = StartFrostKg * SpecificHeatIce * (0.0 - StartIceTemp); // Joules
                        if (AvailDefrostEnergy >= IceSensHeatNeeded) {
                            this->IceTemp = 0.0;
                            AvailDefrostEnergy -= IceSensHeatNeeded; // Joules
                        } else {                                     // DefrostEnergy < IceSensHeatNeeded
                            this->IceTemp = StartIceTemp + AvailDefrostEnergy / (SpecificHeatIce * StartFrostKg);
                            AvailDefrostEnergy = 0.0;
                        } // AvailDefrostEnergy >= IceSensHeatNeeded
                    }     // IceTemp < 0,  need to raise temperature of ice
                    // Reduce defrost heat load on walkin by amount of ice melted during time step
                    Real64 FrostChangekg = min(AvailDefrostEnergy / IceMeltEnthalpy, StartFrostKg);
                    if (FrostChangekg < StartFrostKg) {
                        DefrostLoad -= FrostChangekg * IceMeltEnthalpy / DataGlobals::TimeStepZone / DataGlobals::SecInHour;
                        if (!DataGlobals::WarmupFlag) this->KgFrost = StartFrostKg - FrostChangekg;
                        // DefrostSchedule not changed
                    } else { // all frost melted during time step, so need to terminate defrost
                        //  see Aug 8 page 3 notes
                        this->KgFrost = 0.0;
                        DefrostEnergyNeeded = (IceSensHeatNeeded + (FrostChangekg * IceMeltEnthalpy)) /
                                              this->DefEnergyFraction; // Joules - energy needed including E unavail to melt ice
                        DefrostSchedule = min(DefrostSchedule, (DefrostEnergyNeeded / (this->DefrostCapacity * DataGlobals::TimeStepZoneSec)));
                        // reduce load on walkin by energy put into ice melting
                        DefrostLoad = max(0.0,
                                          (DefrostSchedule * this->DefrostCapacity -
                                           (IceSensHeatNeeded + (FrostChangekg * IceMeltEnthalpy)) / DataGlobals::TimeStepZoneSec));
                        this->IceTemp = this->TEvapDesign;

                    }    // frost melted during time step less than amount of ice at start
                } else { // no frost present so terminate defrost and reset ice temperature for start of next defrost
                    DefrostLoad = 0.0;
                    DefrostSchedule = 0.0;
                    this->IceTemp = this->TEvapDesign;
                } // have frost present

            } else { // Not temperature control type
                Real64 FrostChangekg = min(DefrostEnergy / IceMeltEnthalpy, StartFrostKg);
                // Reduce defrost heat load on walkin by amount of ice melted during time step
                DefrostLoad -= FrostChangekg * IceMeltEnthalpy / DataGlobals::TimeStepZone / DataGlobals::SecInHour;
                if (!DataGlobals::WarmupFlag) this->KgFrost = StartFrostKg - FrostChangekg;
                // DefrostSchedule not changed
            } // Temperature termination control type

        } else { // DefrostSchedule <= 0 or have None or OffCycle
            DefrostLoad = 0.0;
        } // Defrost calculations

        if (this->DefrostType == WalkInDefrostElec) {
            this->ElecDefrostConsumption = this->DefrostCapacity * DefrostSchedule * DataGlobals::TimeStepZoneSec;
            this->ElecDefrostPower = this->DefrostCapacity * DefrostSchedule;
        } else {
            this->ElecDefrostConsumption = 0.0;
            this->ElecDefrostPower = 0.0;
        }

        // If hot brine or hot gas is used for defrost, need to reduce condenser load by heat reclaimed for defrost
        if (this->DefrostType == WalkInDefrostFluid) this->HotDefrostCondCredit = this->DefrostCapacity * DefrostSchedule;

        // loads reflects that walk ins continue to accumulate loads, even during defrost
        // but cap is used to report portion met by active system while operating

        //*** See if capacity meets load and manage accumulated stored energy ***********************************
        SensibleLoadTotal += LightLoad + HeaterLoad + FanLoad + StockingLoad + DefrostLoad + FloorLoad;
        Real64 LoadTotal = SensibleLoadTotal + LatentLoadTotal; // total load in time step (W)

        // Account for difference between load and capacity. Assume rack or system able to provide
        // rated capacity.  If it can't, that unmet energy will be stored and discharged at the system level.
        //  Here we are calculating the load the walk-in cooler places on the refrigeration compressor systems.
        //  Meet current load to the extent possible.  If extra capacity available,
        //  apply it to previously unmet/stored loads.  If capacity less than current load,
        //  (e.g. as it is during defrost cycles) save the unmet/stored load to be met in
        //  succeeding time steps. This is an artificial way of recognizing that the internal
        //  temperature will increase by a small amount during defrost and the system will have to
        //  run full out until the temperature is brought back down.

        // Rate needed to serve all stored energy during single time step (W)
        Real64 StoredEnergyRate = this->StoredEnergy / DataGlobals::TimeStepZone / DataGlobals::SecInHour;
        Real64 LoadRequested = LoadTotal + StoredEnergyRate; // Load necessary to meet current and all stored energy needs (W)

        Real64 LatentCapApplied;        // Walk In latent capacity at specific operating conditions
        Real64 SensibleCapApplied(0.0); // Walk In sensible capacity at specific operating conditions

        // prorate available cooling capacity for portion of time off due to drip down.
        Real64 MaxCap =
            this->DesignRatedCap * (1.0 - DefrostDripDownSchedule); // Design chilling capacity reduced according to drip-down schedule (W)

        if (MaxCap >= LoadRequested) {
            // Have more at least as much capacity available as needed, even counting stored energy
            CapApplied = LoadRequested;
            SensibleCapApplied = SensibleLoadTotal + StoredEnergyRate;
            LatentCapApplied = LatentLoadTotal;
            this->StoredEnergy = 0.0;
        } else {
            // Don't have as much capacity as needed (during dripdown or period following dripdown)
            CapApplied = MaxCap;
            LatentCapApplied = min(LatentLoadTotal, MaxCap); // Latent load should never be > capavail, but just in case...
            SensibleCapApplied = CapApplied - LatentCapApplied;
            if (!DataGlobals::WarmupFlag) this->StoredEnergy += (LoadTotal - MaxCap) * DataGlobals::TimeStepZoneSec;
        } // CapAvail vs Load requested

        // ReportWalkIn( WalkInID)
        this->TotalCoolingLoad = CapApplied;
        this->TotalCoolingEnergy = CapApplied * DataGlobals::TimeStepZoneSec;
        this->TotSensCoolingEnergyRate = SensibleCapApplied;
        this->TotSensCoolingEnergy = SensibleCapApplied * DataGlobals::TimeStepZoneSec;
        this->TotLatCoolingEnergyRate = LatentCapApplied;
        this->TotLatCoolingEnergy = LatentCapApplied * DataGlobals::TimeStepZoneSec;

        this->ElecFanPower = FanLoad;
        this->ElecFanConsumption = FanLoad * DataGlobals::TimeStepZoneSec;
        this->ElecHeaterPower = HeaterLoad;
        this->ElecHeaterConsumption = HeaterLoad * DataGlobals::TimeStepZoneSec;
        this->ElecLightingPower = LightLoad;
        this->ElecLightingConsumption = LightLoad * DataGlobals::TimeStepZoneSec;
        this->TotalElecPower = FanLoad + HeaterLoad + LightLoad + this->ElecDefrostPower;
        this->TotalElecConsumption = this->TotalElecPower * DataGlobals::TimeStepZoneSec;

        //**************************************************************************************************
        // Cap Energy and Kg Frost to avoid floating overflow errors
        // 1-time warning is issued. It should be rare but could happen with unrealistic inputs.
        if (this->StoredEnergy > MyLargeNumber) {
            this->StoredEnergy = MyLargeNumber;
            if (this->ShowUnmetWIEnergyWarning) {
                ShowWarningError("Refrigeration:WalkIn: " + this->Name);
                ShowContinueError(" This walk-in cooler has insufficient capacity to meet the loads");
                ShowContinueError("... Occurrence info = " + DataEnvironment::EnvironmentName + ", " + DataEnvironment::CurMnDy + ' ' +
                                  General::CreateSysTimeIntervalString());
                ShowContinueError(" Refer to documentation for further explanation of Total Cooling Capacity.");
                this->ShowUnmetWIEnergyWarning = false;
            } // ShowStoreEnergyWarning
        }     // stored energy > large number
        if (this->KgFrost > MyLargeNumber) {
            this->KgFrost = MyLargeNumber;
            if (this->ShowWIFrostWarning) {
                ShowWarningError("Refrigeration:WalkIn: " + this->Name);
                ShowContinueError(" This walkin cooler has insufficient defrost capacity to remove the excess frost accumulation.");
                ShowContinueError(" Check the defrost schedule or defrost capacity. ");
                ShowContinueError("... Occurrence info = " + DataEnvironment::EnvironmentName + ", " + DataEnvironment::CurMnDy + ' ' +
                                  General::CreateSysTimeIntervalString());
                this->ShowWIFrostWarning = false;
            }
        }
    }

    void SecondaryLoopData::CalculateSecondary(int const SecondaryNum)
    {
        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL
        //       DATE WRITTEN   Spring 2009
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Find the total cooling load, pump power, and needed primary refrigerant supply temperature
        // for a secondary system.

        // METHODOLOGY EMPLOYED:
        // Sum the loads for the cases and walk-ins supplied by a secondary loop.
        // Calculate the pumping power.
        // Assume that the fluid supply and return temperatures are fixed and the
        // fluid flow rate is varied to meed the variable load.
        // User has been told in IO and Eng ref: for secondary systems/pumps: pump energy is f(viscosity),
        //        but since specifying Tcircfluid as steady
        //        state in loop, specify power for fluid and system head/resistance at that temp
        // ashrae 2006 p4.1 supports 78% eff for pump impellers
        //  all power into heat because it would otherwise not be counted in zone
        //  if use semihermetic motor, also need to add motor ineff as heat

        // REFERENCES:
        // SCE report
        //  others

        Real64 const ErrorTol(0.001); // Iterative solution tolerance

        bool AtPartLoad;                  // Whether or not need to iterate on pump power
        bool DeRate;                      // If true, need to derate aircoils because don't carry over unmet energy
        int Iter;                         // loop counter
        Real64 CpBrine;                   // Specific heat (W/kg)
        Real64 DensityBrine;              // Density (kg/m3)
        Real64 DiffTemp;                  // (C)
        Real64 distPipeHeatGain;  // Optional (W)
        Real64 Error;                     // Used in iterative soln for pumps needed to meet load (that has to include pump energy)
        Real64 FlowVolNeeded;             // Flow rate needed to meet load (m3/s)
        Real64 PartLdFrac;                // Used to ratio pump power
        Real64 PartPumpFrac;              // Used to see if part pumps dispatched meets part pump load
        Real64 PrevTotalLoad;     // Used in pump energy convergence test
        Real64 RefrigerationLoad; // Load for cases and walk-ins served by loop, does not include pump energy (W)
        Real64 StoredEnergyRate;  // Used to meet loads unmet in previous time step (related to defrost cycles
        //     on cases/walk-ins served)(W)
        Real64 TBrineIn;                  // Brine temperature going to heat exchanger, C
        Real64 TotalHotDefrostCondCredit; // Used to credit condenser when heat reclaim used for hot gas/brine defrost (W)
        Real64 TotalPumpPower;            // Total Pumping power for loop, W
        Real64 TotalLoad;                 // Total Cooling Load on secondary loop, W
        Real64 TPipesReceiver(0.0);       // Temperature used for contents of pipes and/or receiver in calculating shell losses (C)
        Real64 VarFrac;                   // Pump power fraction for variable speed pump, dimensionless
        Real64 VolFlowRate;               // Used in dispatching pumps to meet load (m3/s)

        Real64 LocalTimeStep = DataGlobals::TimeStepZone;
        if (UseSysTimeStep) LocalTimeStep = DataHVACGlobals::TimeStepSys;

        {
            auto const SELECT_CASE_var(this->FluidType);
            if (SELECT_CASE_var == SecFluidTypeAlwaysLiquid) {
                CpBrine = this->CpBrineRated;
                DensityBrine = this->DensityBrineRated;
                TBrineIn = this->TBrineInRated;
                TPipesReceiver = this->TBrineAverage;
            } else if (SELECT_CASE_var == SecFluidTypePhaseChange) {
                TPipesReceiver = this->TCondense;
            }
        } // Fluid type

        // Initialize this secondary for this time step
        TotalPumpPower = 0.0;
        RefrigerationLoad = 0.0;
        TotalHotDefrostCondCredit = 0.0;
        FlowVolNeeded = 0.0;
        DeRate = false;

        // SCE page 28 gives a delta T for pipe heat gains
        //         (.25F each for supply and discharge) for use with mdot*cp.
        //          However, another author shows this as a major diff between dx and secondary
        //          So - allow the user to include this in his total load, even though he has to do
        //          most of the calculations before the input (to get to SumUADistPiping)).
        distPipeHeatGain = 0.0;
        if (this->SumUADistPiping > MySmallNumber) {
            int ZoneNodeNum = this->DistPipeZoneNodeNum;
            DiffTemp = DataLoopNode::Node(ZoneNodeNum).Temp - TPipesReceiver;
            distPipeHeatGain = DiffTemp * this->SumUADistPiping;
            // pipe heat load is a positive number (ie. heat absorbed by pipe, so needs to be subtracted
            //     from refrigcasecredit (- for cooling zone, + for heating zone)
            this->DistPipeZoneHeatGain = -distPipeHeatGain;
            DataHeatBalance::RefrigCaseCredit(this->DistPipeZoneNum).SenCaseCreditToZone -= distPipeHeatGain;
        } // calc distribution piping heat gains

        Real64 receiverHeatGain = 0.0;
        if (this->SumUAReceiver > MySmallNumber) {
            int ZoneNodeNum = this->ReceiverZoneNodeNum;
            DiffTemp = DataLoopNode::Node(ZoneNodeNum).Temp - TPipesReceiver;
            receiverHeatGain = DiffTemp * this->SumUAReceiver;
            // receiver heat load is a positive number (ie. heat absorbed by receiver, so needs to be subtracted
            //     from refrigcasecredit (- for cooling zone, + for heating zone)
            this->ReceiverZoneHeatGain = -receiverHeatGain;
            DataHeatBalance::RefrigCaseCredit(this->ReceiverZoneNum).SenCaseCreditToZone -= receiverHeatGain;
        } // calc receiver heat gains

        // Sum up all the case and walk-in loads served by the secondary loop
        if (this->NumCases > 0) {
            for (int caseNum = 1; caseNum <= this->NumCases; ++caseNum) {
                int CaseID = this->CaseNum(caseNum);
                RefrigCase(CaseID).CalculateCase();
                // increment TotalCoolingLoad Hot gas/brine defrost credits for each secondary loop
                RefrigerationLoad += RefrigCase(CaseID).TotalCoolingLoad;
                TotalHotDefrostCondCredit += RefrigCase(CaseID).HotDefrostCondCredit;
            } // CaseNum
        }     // NumCases > 0
        if (this->NumWalkIns > 0) {
            for (int WalkInIndex = 1; WalkInIndex <= this->NumWalkIns; ++WalkInIndex) {
                int WalkInID = this->WalkInNum(WalkInIndex);
                WalkIn(WalkInID).CalculateWalkIn();
                // increment TotalCoolingLoad for  each system
                RefrigerationLoad += WalkIn(WalkInID).TotalCoolingLoad;
                TotalHotDefrostCondCredit += WalkIn(WalkInID).HotDefrostCondCredit;
            } // NumWalkIns systems
        }     // Secondary(SecondaryNum)%NumWalkIns > 0

        if (this->NumCoils > 0) {
            for (int CoilIndex = 1; CoilIndex <= this->NumCoils; ++CoilIndex) {
                int CoilID = this->CoilNum(CoilIndex);
                // already CALL CalculateCoil(CoilID) for each coil, dispatched in coilset order for each zone
                // increment TotalCoolingLoad for each system
                //  here will find out if secondary can serve total load, if not will derate coil outout/case credits
                RefrigerationLoad += WarehouseCoil(CoilID).TotalCoolingLoad;
                TotalHotDefrostCondCredit += WarehouseCoil(CoilID).HotDefrostCondCredit;
            } // NumCoils on seocndary system
        }     // Secondary(SecondaryNum)%NumCoils > 0

        TotalLoad = RefrigerationLoad + distPipeHeatGain + receiverHeatGain;
        AtPartLoad = true;
        // Check to see if load is already >+ maxload without pump heat
        if (this->FluidType == SecFluidTypeAlwaysLiquid) { //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            FlowVolNeeded = TotalLoad / this->HeatExchangeEta / (CpBrine * DensityBrine * (TBrineIn - this->TEvapDesign));
            // For brine/glycol systems, find flow volume needed to meet load
            // Per ashrae 2006, p4.1, eval mass flow rate to pump at brine return (to chiller) temp
            //   because pumps located in return piping
            if (FlowVolNeeded >= this->MaxVolFlow) {
                // Don't need to iterate on pumps, just set to max.  Will have unmet load this time step (unless coils present)
                VolFlowRate = this->MaxVolFlow;
                TotalPumpPower = this->PumpTotRatedPower;
                TotalLoad += TotalPumpPower * this->PumpPowerToHeat;
                AtPartLoad = false;
                if (this->NumCoils > 0) DeRate = true;
            }    // flowvolneeded >= maxvolflow
        } else { // have SecFluidTypePhaseChange !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            if (TotalLoad >= this->MaxLoad) {
                TotalPumpPower = this->PumpTotRatedPower;
                TotalLoad += TotalPumpPower * this->PumpPowerToHeat;
                VolFlowRate = this->MaxVolFlow;
                AtPartLoad = false;
                if (this->NumCoils > 0) DeRate = true;
            }
        } // fluid type check for max load or max flow       >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

        // If totalLoad < maxload, then need to calculate partial pump load
        // Need an iterative soln for pump energy needed to meet total load
        //  because that total load has to include pump energy
        if (AtPartLoad) {
            for (Iter = 1; Iter <= 10; ++Iter) {
                if (TotalLoad <= 0.0) {
                    // Load on secondary loop is zero (or negative).
                    // Set volumetric flow rate and pump power to be zero.
                    VolFlowRate = 0.0;
                    TotalPumpPower = 0.0;
                    break;
                }
                PrevTotalLoad = TotalLoad;
                if (this->FluidType == SecFluidTypeAlwaysLiquid) {
                    FlowVolNeeded = TotalLoad / this->HeatExchangeEta / (CpBrine * DensityBrine * (TBrineIn - this->TEvapDesign));
                    PartLdFrac = FlowVolNeeded / this->MaxVolFlow;
                } else {
                    PartLdFrac = TotalLoad / this->MaxLoad;
                }
                if (this->PumpControlType == SecPumpControlConstant) {
                    VolFlowRate = 0.0;
                    TotalPumpPower = 0.0;
                    for (int PumpID = 1; PumpID <= this->NumPumps; ++PumpID) { // dispatch pumps to meet needed flow rate
                        if (this->FluidType == SecFluidTypeAlwaysLiquid) {     //>>>>>>>>>>>>>>>>>>>>>
                            VolFlowRate += this->PumpIncrementFlowVol;
                            TotalPumpPower += this->PumpIncrementPower;
                            if (VolFlowRate >= FlowVolNeeded) break;
                        } else { // fluid type phase change >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                            VolFlowRate += this->PumpIncrementFlowVol;
                            TotalPumpPower += this->PumpIncrementPower;
                            PartPumpFrac = TotalPumpPower / this->PumpTotRatedPower;
                            if (PartPumpFrac >= PartLdFrac) break;
                        } // fluid type              >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                    }     // Dispatching pumps until fluid flow need is met
                } else {  // pump type variable
                    VarFrac = max(0.1, CurveManager::CurveValue(this->VarSpeedCurvePtr, PartLdFrac));
                    TotalPumpPower = this->PumpTotRatedPower * VarFrac;
                    VolFlowRate = this->MaxVolFlow * PartLdFrac;
                } // pump type

                TotalLoad = RefrigerationLoad + distPipeHeatGain + receiverHeatGain + TotalPumpPower * this->PumpPowerToHeat;
                Error = std::abs((TotalLoad - PrevTotalLoad) / PrevTotalLoad);
                if (Error < ErrorTol) break;
            } // end iteration on pump energy convergence

            //   IF (Iter >=10 .AND. .NOT. DataGlobals::WarmupFlag)THEN
            //     If( .not. DataGlobals::WarmupFlag) Then
            //      Write(OutputFileDebug,707)Month, DataGlobals::CurrentTime, Iter, TotalLoad, TotalPumpPower
            //     End If
            // 707 format(' in iter loop at 707: ',1x,I2,1x,F5.2,1x,I5,7(F10.5,1x))
            //    END IF  !didn't converge
        } //(AtPartLoad)

        // If only loads are cases and walk-ins, that is, no air coils:
        //  Account for difference between load and capacity on secondary loop. Assume system able to provide
        //  rated capacity.  If it can't, that unmet energy will be stored and discharged at the system level.
        //  Meet current load to the extent possible.  If extra capacity available,
        //  apply it to previously unmet/stored loads.  If capacity less than current load,
        //  (e.g. as it may be following defrost cycles on cases or walk-ins served by secondary loop)
        //  save the unmet/stored load to be met in succeeding time steps.
        if (this->NumCoils == 0) {
            StoredEnergyRate = max(0.0, (this->UnmetEnergy / DataGlobals::TimeStepZone / DataGlobals::SecInHour));
            // Load necessary to meet current and all stored energy needs (W)
            Real64 LoadRequested = TotalLoad + StoredEnergyRate;
            if (this->MaxLoad > LoadRequested) {
                // Have at least as much capacity avail as needed, even counting stored energy
                this->TotalCoolingLoad = LoadRequested;
                RefrigerationLoad += StoredEnergyRate;
                this->UnmetEnergy = 0.0;
            } else {
                // Don't have as much capacity as needed (likely following defrost periods)
                this->TotalCoolingLoad = this->MaxLoad;
                RefrigerationLoad -= (TotalLoad - this->MaxLoad);
                if (!DataGlobals::WarmupFlag) this->UnmetEnergy += ((TotalLoad - this->MaxLoad) * DataGlobals::TimeStepZoneSec);
            } // load requested greater than MaxLoad
            if (this->UnmetEnergy > MyLargeNumber) {
                this->UnmetEnergy = MyLargeNumber;
                if (ShowUnmetSecondEnergyWarning(SecondaryNum)) {
                    ShowWarningError("Secondary Refrigeration Loop: " + this->Name);
                    ShowContinueError(" This secondary system has insufficient capacity to meet the refrigeration loads.");
                    ShowUnmetSecondEnergyWarning(SecondaryNum) = false;
                }
            } //>my large number

        } else { // air coils on secondary loop, no "unmet" energy accounting, just reduce amount of cooling provided to zone by coils
            DeRate = false;
            if (TotalLoad > this->MaxLoad) DeRate = true;
            //  TotalLoad = RefrigerationLoad + DistPipeHeatGain  + ReceiverHeatGain &
            //           + TotalPumpPower*Secondary(SecondaryNum)%PumpPowertoHeat
            FinalRateCoils(DeRate, SecondarySystem, SecondaryNum, TotalLoad, this->MaxLoad); // assign case credits for coils on this loop
            // Bug TotalCoolingLoad not set but used below
        } // no air coils on secondary loop
        this->PumpPowerTotal = TotalPumpPower;
        this->PumpElecEnergyTotal = TotalPumpPower * LocalTimeStep * DataGlobals::SecInHour;
        this->TotalRefrigLoad = RefrigerationLoad;
        this->TotalRefrigEnergy = RefrigerationLoad * LocalTimeStep * DataGlobals::SecInHour;
        this->TotalCoolingEnergy = TotalCoolingLoad * LocalTimeStep * DataGlobals::SecInHour;
        this->FlowVolActual = VolFlowRate;
        this->HotDefrostCondCredit = TotalHotDefrostCondCredit;
        this->DistPipeHeatGain = distPipeHeatGain;
        this->DistPipeHeatGainEnergy = distPipeHeatGain * LocalTimeStep * DataGlobals::SecInHour;
        this->ReceiverHeatGain = receiverHeatGain;
        this->ReceiverHeatGainEnergy = receiverHeatGain * LocalTimeStep * DataGlobals::SecInHour;
    }

    void SumZoneImpacts()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL
        //       DATE WRITTEN   Spring 2010
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Find the total impact of all refrigeration systems on each zone.

        // METHODOLOGY EMPLOYED:
        // Calculate the energy from refrigerated case credits arising from interaction between the zone and:
        //   refrigerated cases and walk-ins
        //   heat rejection from zone-located compressor-racks and zone-located air-cooled condensers
        //   heat absorbed by suction piping, secondary loop distribution piping, and
        //   secondary receiver shells

        if (UseSysTimeStep) { // air chillers
            for (int ZoneNum = 1; ZoneNum <= DataGlobals::NumOfZones; ++ZoneNum) {
                CoilSysCredit(ZoneNum).ReportH2ORemovedKgPerS_FromZoneRate = -CoilSysCredit(ZoneNum).LatKgPerS_ToZoneRate;
                CoilSysCredit(ZoneNum).ReportLatCreditToZoneRate = -CoilSysCredit(ZoneNum).LatCreditToZoneRate;
                CoilSysCredit(ZoneNum).ReportLatCreditToZoneEnergy = -CoilSysCredit(ZoneNum).LatCreditToZoneEnergy;
                // Sensible rate can be positive or negative, split into separate output variables and
                //   always report positive value
                if (CoilSysCredit(ZoneNum).SenCreditToZoneRate <= 0.0) {
                    CoilSysCredit(ZoneNum).ReportSenCoolingToZoneRate = -CoilSysCredit(ZoneNum).SenCreditToZoneRate;
                    CoilSysCredit(ZoneNum).ReportSenCoolingToZoneEnergy = -CoilSysCredit(ZoneNum).SenCreditToZoneEnergy;
                    CoilSysCredit(ZoneNum).ReportHeatingToZoneRate = 0.0;
                    CoilSysCredit(ZoneNum).ReportHeatingToZoneEnergy = 0.0;
                } else {
                    CoilSysCredit(ZoneNum).ReportSenCoolingToZoneRate = 0.0;
                    CoilSysCredit(ZoneNum).ReportSenCoolingToZoneEnergy = 0.0;
                    CoilSysCredit(ZoneNum).ReportHeatingToZoneRate = CoilSysCredit(ZoneNum).SenCreditToZoneRate;
                    CoilSysCredit(ZoneNum).ReportHeatingToZoneEnergy = -CoilSysCredit(ZoneNum).SenCreditToZoneEnergy;
                }
                CoilSysCredit(ZoneNum).ReportTotCoolingToZoneRate =
                    CoilSysCredit(ZoneNum).ReportLatCreditToZoneRate + CoilSysCredit(ZoneNum).ReportSenCoolingToZoneRate;
                CoilSysCredit(ZoneNum).ReportTotCoolingToZoneEnergy =
                    CoilSysCredit(ZoneNum).ReportLatCreditToZoneEnergy + CoilSysCredit(ZoneNum).ReportSenCoolingToZoneEnergy;
            }
        } // UseSysTimeStep signals run for air chillers

        // Can arrive here when load call to refrigeration looks for cases/walkin systems and usetimestep is .FALSE.
        if ((!UseSysTimeStep) && ((NumSimulationCases > 0) || (NumSimulationWalkIns > 0))) {
            for (int ZoneNum = 1; ZoneNum <= DataGlobals::NumOfZones; ++ZoneNum) {
                CaseWIZoneReport(ZoneNum).SenCaseCreditToZoneEnergy =
                    DataHeatBalance::RefrigCaseCredit(ZoneNum).SenCaseCreditToZone * DataGlobals::TimeStepZoneSec;
                // Latent always negative
                CaseWIZoneReport(ZoneNum).LatCoolingToZoneRate = -DataHeatBalance::RefrigCaseCredit(ZoneNum).LatCaseCreditToZone;
                CaseWIZoneReport(ZoneNum).LatCoolingToZoneEnergy = CaseWIZoneReport(ZoneNum).LatCoolingToZoneRate * DataGlobals::TimeStepZoneSec;
                // Sensible rate can be positive or negative, split into separate output variables and
                //   always report positive value
                if (DataHeatBalance::RefrigCaseCredit(ZoneNum).SenCaseCreditToZone <= 0.0) {
                    CaseWIZoneReport(ZoneNum).SenCoolingToZoneRate = -DataHeatBalance::RefrigCaseCredit(ZoneNum).SenCaseCreditToZone;
                    CaseWIZoneReport(ZoneNum).SenCoolingToZoneEnergy =
                        -DataHeatBalance::RefrigCaseCredit(ZoneNum).SenCaseCreditToZone * DataGlobals::TimeStepZoneSec;
                    CaseWIZoneReport(ZoneNum).HeatingToZoneRate = 0.0;
                    CaseWIZoneReport(ZoneNum).HeatingToZoneEnergy = 0.0;
                } else {
                    CaseWIZoneReport(ZoneNum).SenCoolingToZoneRate = 0.0;
                    CaseWIZoneReport(ZoneNum).SenCoolingToZoneEnergy = 0.0;
                    CaseWIZoneReport(ZoneNum).HeatingToZoneRate = DataHeatBalance::RefrigCaseCredit(ZoneNum).SenCaseCreditToZone;
                    CaseWIZoneReport(ZoneNum).HeatingToZoneEnergy =
                        DataHeatBalance::RefrigCaseCredit(ZoneNum).SenCaseCreditToZone * DataGlobals::TimeStepZoneSec;
                }
                CaseWIZoneReport(ZoneNum).TotCoolingToZoneRate =
                    CaseWIZoneReport(ZoneNum).SenCoolingToZoneRate + CaseWIZoneReport(ZoneNum).LatCoolingToZoneRate;
                CaseWIZoneReport(ZoneNum).TotCoolingToZoneEnergy =
                    CaseWIZoneReport(ZoneNum).SenCoolingToZoneEnergy + CaseWIZoneReport(ZoneNum).LatCoolingToZoneEnergy;
                CaseWIZoneReport(ZoneNum).TotHtXferToZoneRate =
                    DataHeatBalance::RefrigCaseCredit(ZoneNum).SenCaseCreditToZone + DataHeatBalance::RefrigCaseCredit(ZoneNum).LatCaseCreditToZone;
                CaseWIZoneReport(ZoneNum).TotHtXferToZoneEnergy = CaseWIZoneReport(ZoneNum).TotHtXferToZoneRate * DataGlobals::TimeStepZoneSec;
            } // over zones for cases and walkins
        }
    }

    void CheckRefrigerationInput(EnergyPlusData &state)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Linda Lawrie
        //       DATE WRITTEN   Sep 2010 - mining function
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Provides the structure to get Refrigeration input so that
        // it can be called from internally or outside the module.

        if (GetRefrigerationInputFlag) {

            GetRefrigerationInput(state);
            SetupReportInput();
            GetRefrigerationInputFlag = false;

            if ((!HaveCasesOrWalkins) && (!HaveChillers)) {
                ManageRefrigeration = false;
                return;
            }
            if ((!HaveDetailedRefrig) && (!HaveRefrigRacks) && (!HaveDetailedTransRefrig)) {
                ManageRefrigeration = false;
                return;
            }
        } // GetRefrigerationInputFlag
    }

    void SimAirChillerSet(EnergyPlusData &state, std::string const &AirChillerSetName,
                          int const ZoneNum,
                          bool const FirstHVACIteration,
                          Real64 &SysOutputProvided,
                          Real64 &LatOutputProvided,
                          int &AirChillerSetPtr // from ZoneEquipList(CurZoneEqNum)%EquipIndex(EquipPtr)
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL
        //       DATE WRITTEN   January 2011
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Transfers the load requested from the zone to the refrigeration module.
        // The load is met, partially met, or not met in the call to the detailed system solution
        // METHODOLOGY EMPLOYED:
        // Called from Zone Equipment Manager.

        int ChillerSetID;
        Real64 RemainingOutputToCoolingSP; // Remaining requested load in zone

        CheckRefrigerationInput(state);

        // Find the correct Chiller set
        if (AirChillerSetPtr == 0) {
            ChillerSetID = UtilityRoutines::FindItemInList(AirChillerSetName, AirChillerSet);
            if (ChillerSetID == 0) {
                ShowFatalError("SimAirChillerSet: Unit not found=" + AirChillerSetName);
            } // chillersetid ==0 because not in list
            AirChillerSetPtr = ChillerSetID;
        } else { // airchllersetpointer passed in call to subroutine not ==0
            ChillerSetID = AirChillerSetPtr;
            if (ChillerSetID > DataHeatBalance::NumRefrigChillerSets || ChillerSetID < 1) {
                ShowFatalError("SimAirChillerSet:  Invalid AirChillerSetPtr passed=" + General::TrimSigDigits(ChillerSetID) + ", Number of Units=" +
                               General::TrimSigDigits(DataHeatBalance::NumRefrigChillerSets) + ", Entered Unit name=" + AirChillerSetName);
            } // ChillerSetID makes no sense
            if (CheckChillerSetName(ChillerSetID)) {
                if (AirChillerSetName != AirChillerSet(ChillerSetID).Name) {
                    ShowFatalError("SimAirChillerSet:  Invalid AirChillerSetPtr passed=" + General::TrimSigDigits(ChillerSetID) +
                                   ", Unit name=" + AirChillerSetName + ", stored Unit Name for that index=" + AirChillerSet(ChillerSetID).Name);
                } // name not equal correct name
                CheckChillerSetName(ChillerSetID) = false;
            } // CheckChillerSetName logical test
        }     //(AirChillerSetPtr == 0 or else not == 0

        if (FirstHVACIteration) {
            for (ChillerSetID = 1; ChillerSetID <= DataHeatBalance::NumRefrigChillerSets;
                 ++ChillerSetID) { // bbb what point of do loop, only set one (airchillersetptr) to zero
                AirChillerSet(AirChillerSetPtr).QZnReqSens = 0.0;
            }
        } // FirstHVACIteration

        RemainingOutputToCoolingSP = DataZoneEnergyDemands::ZoneSysEnergyDemand(ZoneNum).RemainingOutputReqToCoolSP;
        // RemainingOutputToCoolingSP in Watts, < 0 for cooling demand

        if (RemainingOutputToCoolingSP < 0.0 && DataHeatBalFanSys::TempControlType(ZoneNum) != DataHVACGlobals::SingleHeatingSetPoint) {
            AirChillerSet(AirChillerSetPtr).QZnReqSens = RemainingOutputToCoolingSP;
        } else {
            AirChillerSet(AirChillerSetPtr).QZnReqSens = 0.0;
        }

        UseSysTimeStep = true;

        ManageRefrigeratedCaseRacks(state);

        UseSysTimeStep = false;

        // Return values to Zone Equipment Manager.
        LatOutputProvided = CoilSysCredit(ZoneNum).LatKgPerS_ToZoneRate;
        SysOutputProvided = CoilSysCredit(ZoneNum).SenCreditToZoneRate;
    }

    void AirChillerSetData::CalculateAirChillerSets()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL
        //       DATE WRITTEN   January 2011
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Transfers the load requested from the zone to the refrigeration module.
        // The load is met, partially met, or not met in the next time step when the refrigerated case
        // module is called via case credits. Therefore, by definition, the sensible and latent
        // output provided are zero.
        // METHODOLOGY EMPLOYED:
        // Called from Zone Equipment Manager.
        //       have however done the variable definitions for in and out.

        Real64 AirChillerSetSchedule(0.0); // Schedule value for air chiller SET
        Real64 QZNReqSens(0.0);            // Amount of sensible heat needed by the zone, NEGATIVE when cooling needed [W]
        Real64 RemainQZNReqSens(0.0);      // Remaining amount of sensible heat needed by the zone [W]

        // Note, all coils in a coil set are in the same zone
        // the coils may be served by different detailed systems
        // The coils are dispatched to meet the load specified in the previous time step in order listed in coilset object
        AirChillerSetSchedule = ScheduleManager::GetCurrentScheduleValue(this->SchedPtr);

        if (AirChillerSetSchedule <= 0.0) return;
        QZNReqSens = this->QZnReqSens;
        RemainQZNReqSens = QZNReqSens;

        for (int CoilIndex = 1; CoilIndex <= this->NumCoils; ++CoilIndex) {
            int CoilID = this->CoilNum(CoilIndex);

            WarehouseCoil(CoilID).CalculateCoil(RemainQZNReqSens);
            RemainQZNReqSens += WarehouseCoil(CoilID).SensCreditRate;
            // should be a negative minus a negative, so a smaller negative, that is, going toward zero, but senscoolingenergyrate expressed as
            // positive  Need to go over all the coils so that the defrosts occur on schedule, even when the chiller isn't called for at that
            // particular time step  IF(RemainQZNReqSens >=0.0d0)EXIT  !shouldn't be > 0 because limited by request in calculatecoil
            if (RemainQZNReqSens > 0.0) RemainQZNReqSens = 0.0;
        } // CoilIndex
    }

    void FinalRateCoils(bool const DeRate,              // True if compressor rack or secondary ht exchanger unable to provide capacity
                        int const SystemSourceType,     // Secondarysystem or DetailedSystem
                        int const SystemID,             // ID for Secondary loop or detailed system calling for derate
                        Real64 const InitialTotalLoad,  // Load on system or secondary loop as initially calculated [W]
                        Real64 const AvailableTotalLoad // Load that system or secondary loop is able to serve [W]
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL
        //       DATE WRITTEN   January 2011
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // When compressor system, or secondary loop capacity is insufficient to meet coil loads
        //   Come back here and derate the coil case credits to show unmet load impact
        //   Note that the coil fan, heater, and defrost would be unaffected because they
        //   would still be running at level calculated previously

        int NumCoils(0);
        Real64 DeRateFactor(0.0);        // Ratio of energy available from system or secondary loop
        Real64 InitLatCreditEnergy(0.0); // Latent credit energy before derate [W]
        Real64 FrostReduction(0.0);      // Change in frost on coils based on derated latent load [kg]

        {
            auto const SELECT_CASE_var(SystemSourceType);
            if (SELECT_CASE_var == DetailedSystem) {
                NumCoils = System(SystemID).NumCoils;
            } else if (SELECT_CASE_var == SecondarySystem) {
                NumCoils = Secondary(SystemID).NumCoils;
            }
        } // DeRateCoils

        if (DeRate) {
            ShowRecurringWarningErrorAtEnd(
                "Refrigeration:System chilling WarehouseCoils " + System(SystemID).Name +
                    " - Refrigeration system unable to meet load of warehouse coils chilled by system ... continues by derating coil load",
                System(SystemID).InsuffCapWarn);

            DeRateFactor = AvailableTotalLoad / InitialTotalLoad;
            Real64 const time_step_sec(DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour);
            for (int CoilIndex = 1; CoilIndex <= NumCoils; ++CoilIndex) {
                int CoilID = System(SystemID).CoilNum(CoilIndex);
                auto &warehouse_coil(WarehouseCoil(CoilID));

                // need to adjust ice on coil due to reduction in latent load met by coil
                InitLatCreditEnergy = warehouse_coil.LatCreditEnergy;

                warehouse_coil.TotalCoolingLoad *= DeRateFactor;
                warehouse_coil.TotalCoolingEnergy *= DeRateFactor;
                warehouse_coil.SensCoolingEnergyRate *= DeRateFactor;
                warehouse_coil.SensCoolingEnergy *= DeRateFactor;
                warehouse_coil.LatCreditRate *= DeRateFactor;
                warehouse_coil.LatCreditEnergy *= DeRateFactor;
                warehouse_coil.LatKgPerS_ToZone *= DeRateFactor;
                warehouse_coil.SensCreditRate = warehouse_coil.SensCoolingEnergyRate - warehouse_coil.ElecFanPower - warehouse_coil.ElecHeaterPower -
                                                warehouse_coil.ThermalDefrostPower;
                warehouse_coil.SensCreditEnergy = warehouse_coil.SensCreditRate * time_step_sec;

                FrostReduction = (InitLatCreditEnergy - warehouse_coil.LatCreditEnergy) / IcetoVaporEnthalpy;
                warehouse_coil.KgFrost = max(0.0, warehouse_coil.KgFrost - FrostReduction);

                if (warehouse_coil.SensCreditRate >= 0.0) {
                    warehouse_coil.ReportSensCoolCreditRate = warehouse_coil.SensCreditRate;
                    warehouse_coil.ReportHeatingCreditRate = 0.0;
                } else {
                    warehouse_coil.ReportSensCoolCreditRate = 0.0;
                    warehouse_coil.ReportHeatingCreditRate = -warehouse_coil.SensCreditRate;
                }
                warehouse_coil.ReportSensCoolCreditEnergy = warehouse_coil.ReportSensCoolCreditRate * time_step_sec;
                warehouse_coil.ReportHeatingCreditEnergy = warehouse_coil.ReportHeatingCreditRate * time_step_sec;
                warehouse_coil.ReportTotalCoolCreditRate = warehouse_coil.ReportSensCoolCreditRate + warehouse_coil.LatCreditRate;
                warehouse_coil.ReportTotalCoolCreditEnergy = warehouse_coil.ReportSensCoolCreditEnergy + warehouse_coil.LatCreditEnergy;
            }
        } // DeRate == true
    }

    void WarehouseCoilData::CalculateCoil(Real64 const QZnReq)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Therese Stovall, ORNL
        //       DATE WRITTEN   January 2011
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Simulates the refrigerated warehouse coil object.
        // Note QZnReq < 0 corresponds to cooling needed

        // METHODOLOGY EMPLOYED:
        // Called from Calculate Air Chiller Set.
        // Air chillers are used to model the type of equipment typically used in
        // refrigerated warehouses. For that reason, there is a major difference
        // between the air chiller model and those for refrigerated cases or walk-ins.
        // For cases and walk-ins, a portion of the model is directed toward
        // calculating the amount of refrigeration needed to maintain the refrigerated
        // volume at the desired temperature due to heat exchange with the surrounding
        // zone, and that zone is conditioned to a nearly constant temperature.
        // In a refrigerated warehouse, the refrigeration load is caused by heat exchange
        // with a variable external environment.  For that reason, the loads for these
        // zones are calculated by the usual EnergyPlus zone heat balance.
        // The amount of refrigeration needed to maintain the specified temperature
        // setpoints is then passed to the air chiller model, in a similar fashion
        // to the load passed to a window air conditioner model. The air chillers
        // are therefore solved using the system time step, not the zone time step
        // used for cases and walk-ins.
        // The air chiller performance is based on three types of manufacturers ratings,
        // Unit Load Factor, Total Capacity Map, or a set of European standards.
        // Correction factors for material and refrigerant are applied to all of these ratings.

        static std::string const TrackMessage("from RefrigeratedCase:CalculateCoil");

        Real64 CoilSchedule = ScheduleManager::GetCurrentScheduleValue(this->SchedPtr); // Current value of Coil operating (availability) schedule
        if (CoilSchedule <= 0.0) return;

        Real64 DefrostSchedule = ScheduleManager::GetCurrentScheduleValue(this->DefrostSchedPtr); // Coil defrost schedule, between 0 and 1
        Real64 DefrostDripDownSchedule =
            ScheduleManager::GetCurrentScheduleValue(this->DefrostDripDownSchedPtr); // Coil drip-down schedule (allows coil to drain after defrost)
        // next statement In case user doesn't understand concept of drip down schedule
        DefrostDripDownSchedule = max(DefrostDripDownSchedule, DefrostSchedule);
        // next value optional, so set to default before checking for schedule
        Real64 HeaterSchedule = 1.0; // zero to one
        if (this->HeaterSchedPtr > 0) HeaterSchedule = ScheduleManager::GetCurrentScheduleValue(this->HeaterSchedPtr);

        // Set local subroutine variables for convenience
        int FanSpeedControlType = this->FanType;
        Real64 AirVolumeFlowRated = this->RatedAirVolumeFlow;   // Coil rated air flow (m3/s)
        Real64 FanPowerRated = this->RatedFanPower;             // (W)
        Real64 HeaterLoad = this->HeaterPower * HeaterSchedule; // Total heater (except defrost) energy rate (W)
        Real64 DefrostCap = this->DefrostCapacity;              // Design defrost capacity of Coil (W)
        Real64 TEvap = this->TEvapDesign;                       // Evaporating temperature in the coil (C)

        Real64 CoilCapTotEstimate(0.0); // Part of loop to solve for total coil capacity as a function of inlet air conditions (W)
        Real64 AirVolumeFlowMax(0.0);   // Coil air flow limited by drip down schedule (m3/s)
        Real64 CoilCapTotal(0.0);       // Sensible plus latent load (W)
        Real64 CoilInletDensity(0.0);   // Coil air inlet density (kg/m3)
        Real64 CoilInletDryAirCp(0.0);  // Dry air specific heat at coil inlet temperature (J/kg-C)
        Real64 CoilInletHumRatio(0.0);  // Coil air inlet humidity ratio (kg water/kg air)
        Real64 CoilInletTemp(0.0);      // Inlet temperature of air to coil, not mixed zone temperature unless "middle" location selected (C)
        Real64 CoilInletEnthalpy(0.0);  // Coil inlet air enthalpy (J/kg)
        Real64 CoilInletRHFrac(0.0);    // Coil inlet air relative humidity expressed as a fraction (0 to 1)
        Real64 DefrostLoad(0.0);
        Real64 DryAirMassFlowMax(0.0);      // Rated volume flow rate times dry air density adjusted for schedules (kg/s)
        Real64 FanPowerActual(0.0);         // (W)
        Real64 FrostChangekg(0.0);          // Amount of frost added or melted  (kg)
        Real64 latLoadServed(0.0);          // Energy rate used to remove water from zone air (W)
        Real64 SensLoadRequestedGross(0.0); // Gross sensible load removed by coil
        Real64 SensLoadGross(0.0);          // Sensible load met by coil (W)
        Real64 SHR(0.0);                    // Sensible heat ratio, sensible load/total load
        Real64 SHRCorrection(0.0);          // Actual total/sensible load, NOT = Inverse SHR (unless coil efficiency = 1.0)
        Real64 WaterRemovRate(0.0);         // Walk in cooler removes water at this rate in this zone (kg/s)

        if (DefrostDripDownSchedule == 1.0) {
            AirVolumeFlowMax = 0.0;
            DryAirMassFlowMax = 0.0;
        } else {                            // DefrostDripDownSchedule < 1.0d0, cooling will occur at least part of the time step
            // Sensible load requested by zone balance (W)
            Real64 SensLoadRequested = -QZnReq; // here let cooling demand be positive within subroutine
            if (SensLoadRequested <= 0.0) { // No load so assume control keeps off, except that scheduled defrost still occurs
                AirVolumeFlowMax = 0.0;
                DryAirMassFlowMax = 0.0;
            } else {
                SensLoadRequestedGross = SensLoadRequested + HeaterLoad + FanPowerRated;
                Real64 ZoneMixedAirDryBulb = DataLoopNode::Node(this->ZoneNodeNum).Temp;    // (C)
                Real64 ZoneMixedAirHumRatio = DataLoopNode::Node(this->ZoneNodeNum).HumRat; // kg water/kg air in the zone mixed air
                Real64 ZoneMixedAirRHFrac = Psychrometrics::PsyRhFnTdbWPb(ZoneMixedAirDryBulb, ZoneMixedAirHumRatio, DataEnvironment::OutBaroPress, TrackMessage);
                Real64 ZoneMixedAirEnthalpy = Psychrometrics::PsyHFnTdbRhPb(ZoneMixedAirDryBulb, ZoneMixedAirRHFrac, DataEnvironment::OutBaroPress, TrackMessage);
                Real64 ZoneMixedAirDensity = Psychrometrics::PsyRhoAirFnPbTdbW(DataEnvironment::OutBaroPress, ZoneMixedAirDryBulb, ZoneMixedAirHumRatio, TrackMessage);
                Real64 ZoneDryAirDensity = Psychrometrics::PsyRhoAirFnPbTdbW(DataEnvironment::OutBaroPress, ZoneMixedAirDryBulb, 0.0, TrackMessage);
                Real64 DryAirMassFlowRated = AirVolumeFlowRated * ZoneDryAirDensity;
                // calc t inlet to coil assuming at middle/mixed point in room  bbb -
                //    later need to do for hottest/coolest in room where Tin /= Tzonemixed
                // calc RH inlet to coil assuming at middle/mixed point in room
                // calc coilcap, sens and latent, available as f(inlet T,RH)
                switch (this->VerticalLocation) {
                case Floor:
                    // purposely fall through
                case Ceiling:
                    // purposely fall through
                case Middle:
                    CoilInletTemp = ZoneMixedAirDryBulb;
                    CoilInletEnthalpy = ZoneMixedAirEnthalpy;
                    CoilInletRHFrac = ZoneMixedAirRHFrac;
                    CoilInletDensity = ZoneMixedAirDensity;
                    CoilInletHumRatio = ZoneMixedAirHumRatio;
                    CoilInletDryAirCp = Psychrometrics::PsyCpAirFnW(0.0);
                    break;
                }
                AirVolumeFlowMax = AirVolumeFlowRated * (1.0 - DefrostDripDownSchedule) * CoilSchedule;
                DryAirMassFlowMax = DryAirMassFlowRated * (1.0 - DefrostDripDownSchedule) * CoilSchedule;

            } // Sens load requested is non-zero
        }     // DefrostDripDownSchedule == 1.0d0

        if (AirVolumeFlowMax > 0.0) {

            Real64 TemperatureDif =
                min(this->MaxTemperatureDif, (CoilInletTemp - TEvap)); // difference between inlet air and evaporating temperature (deltaC)

            if (this->RatingType == RatedCapacityTotal) {
                // RatingType = CapacityTotalSpecificConditions, will be doing a table lookup
                //    based upon RHInlet, DT1, CoilInletTemperature - see excel files from B. Nelson, CoilCom
                //    In the table, X1== inlet air dry bulb temperature
                //                  X2== Difference between inlet T and evap T
                //                  X3== RH expressed as decimal
                CoilCapTotEstimate = CurveManager::CurveValue(this->SHRCorrectionCurvePtr, CoilInletTemp, TemperatureDif, CoilInletRHFrac) *
                                     this->RatedCapTotal * (1.0 - DefrostDripDownSchedule) * CoilSchedule;

            } else { // work with unit load factor (sensible only), function of DT1 (Tair in drybulb-Tevap)
                Real64 SensibleCapacityMax = this->UnitLoadFactorSens * TemperatureDif * (1.0 - DefrostDripDownSchedule) *
                                             CoilSchedule; // Sensible capacity adjusted for any time in dripdown state (W)

                if (SensibleCapacityMax > 0.0) {
                    Real64 ExitTemperatureEstimate =
                        CoilInletTemp -
                        (SensibleCapacityMax / (DryAirMassFlowMax * CoilInletDryAirCp)); // Estimated Air temperature leaving the coil (C)
                    if (ExitTemperatureEstimate <= TEvap) {
                        ShowWarningError(TrackMessage + "Refrigeration:AirCoil: " + this->Name);
                        ShowContinueError(" The estimated air outlet temperature is less than the evaporating temperature.");
                    }
                    Real64 ExitEnthalpyEstimate = Psychrometrics::PsyHFnTdbRhPb(
                        ExitTemperatureEstimate, 1.0, DataEnvironment::OutBaroPress, TrackMessage); // Estimated Air enthalpy leaving the coil (J/kg)
                    if (ExitEnthalpyEstimate <= CoilInletEnthalpy) {
                        CoilCapTotEstimate = (CoilInletEnthalpy - ExitEnthalpyEstimate) * AirVolumeFlowMax * CoilInletDensity;
                    } else {
                        // Assume no water is extracted from flow
                        ExitEnthalpyEstimate = Psychrometrics::PsyHFnTdbW(ExitTemperatureEstimate, CoilInletHumRatio);
                        CoilCapTotEstimate = (CoilInletEnthalpy - ExitEnthalpyEstimate) * AirVolumeFlowMax * CoilInletDensity;
                    }
                    if (SensibleCapacityMax > CoilCapTotEstimate) SensibleCapacityMax = CoilCapTotEstimate;
                    if (std::abs(CoilCapTotEstimate) > 0.0) {
                        SHR = SensibleCapacityMax / (CoilCapTotEstimate);
                    } else {
                        // will occur whenever defrost or dripdown
                        SHR = 0.0;
                    }

                    {
                        auto const SELECT_CASE_var(this->SHRCorrectionType);
                        if (SELECT_CASE_var == SHR60) {
                            // line from y = SHRCorrection60 value to 1. as x(SHR) goes from .6 to 1, from B. Nelson, ASHRAE August 2010
                            Real64 Slope = (this->SHRCorrection60 - 1.0) / (0.6 - 1.0); // Part of linear SHR60 correction factor, dimensionless
                            Real64 Yint = this->SHRCorrection60 - (Slope * 0.6);        // Part of linear SHR60 correction factor, dimensionless
                            SHRCorrection = Slope * SHR + Yint;
                        } else if (SELECT_CASE_var == QuadraticSHR) {
                            SHRCorrection = CurveManager::CurveValue(this->SHRCorrectionCurvePtr, SHR);
                        } else if (SELECT_CASE_var == European) {
                            // With European ratings, either start with rated total sensible capacity or rated total capacity
                            //    If rated total capacity is used, 'get input'
                            //    translated it to rated total sensible capacity using
                            //    PARAMETER ::EuropeanWetCoilFactor = (/1.35D0, 1.15D0,  1.05D0,  1.01D0,   1.0D0/)
                            //    That sensible capacity rating was then turned to a rated UnitLoadFactor using
                            //    the rated temperature difference. That sensible rating was also corrected
                            //    for refrigerant and fin material in 'get input' and is given as UnitLoadFactor
                            //  The total (sens + latent) capacity is equal to that * DT1 * WetCoilFactor(TcoilIn)
                            //    Sensible capacity max already has DT1, just need WetCoilFactor(TcoilIn)
                            // PARAMETER ::EuropeanWetCoilFactor = (/1.35D0, 1.15D0,  1.05D0,  1.01D0,   1.0D0/)
                            // PARAMETER ::EuropeanAirInletTemp  = (/10.0D0,  0.0D0, -18.0D0, -25.0D0, -34.0D0/)
                            // PARAMETER ::EuropeanEvapTemp      = (/ 0.0D0, -8.0D0, -25.0D0, -31.0D0, -40.0D0/)
                            // PARAMETER ::EuropeanDT1           = (/10.0D0,  8.0D0,   7.0D0,   7.0D0,   6.0D0/)
                            if (CoilInletTemp <= -25.0) {
                                SHRCorrection = 1.0;
                            } else if (CoilInletTemp > -25.0 && CoilInletTemp <= 0.0) {
                                SHRCorrection = (EuropeanWetCoilFactor(2) - EuropeanWetCoilFactor(4)) /
                                                    (EuropeanAirInletTemp(2) - EuropeanAirInletTemp(4)) * (EuropeanAirInletTemp(2) - CoilInletTemp) +
                                                EuropeanWetCoilFactor(4);
                            } else if (CoilInletTemp > 0.0 && CoilInletTemp <= 5.0) {
                                SHRCorrection = (EuropeanWetCoilFactor(1) - EuropeanWetCoilFactor(2)) /
                                                    (EuropeanAirInletTemp(1) - EuropeanAirInletTemp(2)) * (EuropeanAirInletTemp(1) - CoilInletTemp) +
                                                EuropeanWetCoilFactor(2);
                            } else if (CoilInletTemp > 5.0) {
                                SHRCorrection = EuropeanWetCoilFactor(1);
                            } // calc correction as a function of coil inlet temperature
                        }
                    }
                    CoilCapTotEstimate = SHRCorrection * SensibleCapacityMax;
                } else { // NOT (SensibleCapacityMax > 0.0d0)
                    CoilCapTotEstimate = 0.0;
                } //  (SensibleCapacityMax > 0.0d0)
            }     // Rating type : CapacityTotalSpecificConditions or Sensible Unit Load Factor

            if (CoilCapTotEstimate > 0.0) {
                Real64 ExitEnthalpy =
                    CoilInletEnthalpy - (CoilCapTotEstimate / (AirVolumeFlowMax * CoilInletDensity)); // Air enthalpy leaving the coil (J/kg)
                Real64 ExitTemperature = Psychrometrics::PsyTsatFnHPb(
                    ExitEnthalpy, DataEnvironment::OutBaroPress, TrackMessage); // RH =1.0 at Tsat // Air temperature leaving the coil (C)
                Real64 ExitHumRatio = Psychrometrics::PsyWFnTdbH(ExitTemperature, ExitEnthalpy, TrackMessage); // kg water/kg air
                if (ExitHumRatio > CoilInletHumRatio) ExitHumRatio = CoilInletHumRatio;
                WaterRemovRate = DryAirMassFlowMax * (CoilInletHumRatio - ExitHumRatio);
                latLoadServed = WaterRemovRate * IcetoVaporEnthalpy;
                SensLoadGross = CoilCapTotEstimate - latLoadServed;
                FanPowerActual = FanPowerRated;
                if (SensLoadGross < 0.0) {
                    // Could rarely happen during initial cooldown of a warm environment
                    SensLoadGross = 0.0;
                    latLoadServed = CoilCapTotEstimate;
                    WaterRemovRate = latLoadServed / IcetoVaporEnthalpy;
                }    // SensLoadGross < 0
            } else { // NOT (SensibleCapacityMax > 0.0d0)
                WaterRemovRate = 0.0;
                latLoadServed = 0.0;
                SensLoadGross = 0.0;
                FanPowerActual = 0.0;
            } //(CoilCapTotEstimate > 0.0d0)

            Real64 FanPowerMax = FanPowerRated * (1.0 - DefrostDripDownSchedule); // Total fan energy rate, limited by dripdown period (W)
            if (SensLoadGross > SensLoadRequestedGross) { // part load operation
                // don't need full chiller power, reduce fan speed to reduce air flow
                // move fan to part power if need to
                Real64 CapFac = SensLoadRequestedGross / SensLoadGross; // used to reduce fan power when don't need full coil capacity
                Real64 AirVolRatio = max(this->FanMinAirFlowRatio, std::pow(CapFac, EvaporatorAirVolExponent)); // used when operating at part load
                // Fans limited by minimum air flow ratio

                {
                    auto const SELECT_CASE_var(FanSpeedControlType);
                    if (SELECT_CASE_var == FanVariableSpeed) { // fan power law, adjusted for reality, applies
                        Real64 FanPowerRatio = std::pow(AirVolRatio, 2.5); // Used for variable speed fans, dimensionless
                        FanPowerActual = FanPowerRatio * FanPowerMax;
                    } else if (SELECT_CASE_var == FanConstantSpeed) {
                        FanPowerActual = AirVolRatio * std::exp(1.0 - AirVolRatio) * FanPowerMax;
                    } else if (SELECT_CASE_var == FanConstantSpeedLinear) { // e.g., on-off control
                        FanPowerActual = AirVolRatio * FanPowerMax;
                    } else if (SELECT_CASE_var == FanTwoSpeed) {
                        // low speed setting of 1/2 fan speed can give up to 60% of capacity.
                        // 1/2 speed corresonds to ~1/8 power consumption (FanHalfSpeedRatio = 1/(2**2.5) = 0.1768)
                        // dampers are used to control flow within those two ranges as in FanConstantSpeed
                        if (CapFac < CapFac60Percent) {
                            FanPowerActual = ((AirVolRatio + 0.4) * (FanHalfSpeedRatio)) * std::exp(1.0 - AirVolRatio) * FanPowerMax;
                        } else {
                            FanPowerActual = AirVolRatio * std::exp(1.0 - AirVolRatio) * FanPowerMax;
                        } // capfac60percent
                    }
                } // fan speed control type

                // reduce latent capacity according to value called for for sensible  - recalc latent.
                //   recalc coilcaptotal
                WaterRemovRate *= AirVolRatio;
                latLoadServed = WaterRemovRate * IcetoVaporEnthalpy;
                SensLoadGross = SensLoadRequestedGross;
            } else { // at full load
                FanPowerActual = FanPowerMax;
            } // part load and sensload served > 0.

            CoilCapTotal = SensLoadGross + latLoadServed;
            if (CoilCapTotal > 0.0) {
                SHR = SensLoadGross / CoilCapTotal;
            } else {
                SHR = 0.0;
            } //(CoilCapTotal > 0.0d0)

            // now handle ice on coil and defrost because defrost energy not into melting ice goes into sensible load
            // FROST:  keep track of frost build up on evaporator coil
            //         avoid accumulation during warm-up to avoid reverse dd test problem
            if (!DataGlobals::WarmupFlag) {
                FrostChangekg = (WaterRemovRate * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour);
                this->KgFrost += FrostChangekg;
            }

        } else { // NOT (AirVolumeFlowMax > 0.0d0)
            WaterRemovRate = 0.0;
            latLoadServed = 0.0;
            SensLoadGross = 0.0;
            FanPowerActual = 0.0;
        } //(AirVolumeFlowMax > 0.0d0)

        // DEFROST CALCULATIONS   ***** need to reduce sensible heat to zone from
        //                     defrost by amount used to melt ice. Last two elements
        //                     in starting IF are there to mimic temperature override
        //                     on the coils that stops defrost if the coils get above
        //                     a certain temperature (such as when there's no load and no ice)
        if ((DefrostSchedule > 0.0) && (this->DefrostType != DefrostNone) && (this->DefrostType != DefrostOffCycle)) {
            DefrostLoad = DefrostCap * DefrostSchedule; // Part of the defrost that is a heat load on the zone (W)
            Real64 DefrostEnergy = DefrostLoad * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour; // Joules
            Real64 StartFrostKg = this->KgFrost; // frost load at start of time step (kg of ice)

            if (this->DefrostControlType == DefrostContTempTerm) {
                //  Need to turn defrost system off early if controlled by temperature and all ice melted
                //  For temperature termination, need to recognize not all defrost heat goes to melt ice
                //  Some goes to misc losses (for fluid defrost, some coil areas bare earlier than
                //  others and xfer heat to environment)
                //  Assume full ice melting satisfies temperature control.
                //      (defaults for DefEnergyFraction are :=0.7 for elec, =0.3 for fluids)
                Real64 AvailDefrostEnergy = this->DefEnergyFraction * DefrostEnergy; // available to melt ice with temp term control (J)
                Real64 IceSensHeatNeeded = 0.0; // Energy to raise frost temperature to 0C, used w/ temp termination (J)
                if (StartFrostKg > 0.0) {
                    if (this->IceTemp < 0.0) {
                        Real64 StartIceTemp = this->IceTemp;                                       // Frost temperature at start of time step [C]
                        IceSensHeatNeeded = StartFrostKg * SpecificHeatIce * (0.0 - StartIceTemp); // Joules
                        if (AvailDefrostEnergy >= IceSensHeatNeeded) {
                            this->IceTemp = 0.0;
                            AvailDefrostEnergy -= IceSensHeatNeeded; // Joules
                        } else {                                     // DefrostEnergy < IceSensHeatNeeded
                            this->IceTemp = StartIceTemp + AvailDefrostEnergy / (SpecificHeatIce * StartFrostKg);
                            AvailDefrostEnergy = 0.0;
                        } // AvailDefrostEnergy >= IceSensHeatNeeded
                    }     // IceTemp < 0,  need to raise temperature of ice
                    // Reduce defrost heat load on walkin by amount of ice melted during time step
                    FrostChangekg = min(AvailDefrostEnergy / IceMeltEnthalpy, StartFrostKg);
                    if (FrostChangekg < StartFrostKg) {
                        DefrostLoad -= FrostChangekg * IceMeltEnthalpy / DataHVACGlobals::TimeStepSys / DataGlobals::SecInHour;
                        if (!DataGlobals::WarmupFlag) this->KgFrost = StartFrostKg - FrostChangekg;
                        // DefrostSchedule not changed because ice not all melted, temp term not triggered
                    } else { // all frost melted during time step, so need to terminate defrost
                        //  see Aug 8 2010 page 3 notes
                        this->KgFrost = 0.0;
                        Real64 DefrostEnergyNeeded = (IceSensHeatNeeded + (FrostChangekg * IceMeltEnthalpy)) /
                                                     this->DefEnergyFraction; // Joules - energy needed including E unavail to melt ice
                        DefrostSchedule =
                            min(DefrostSchedule, (DefrostEnergyNeeded / (DefrostCap * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour)));
                        // reduce heat load on warehouse by energy put into ice melting
                        // Defrost load that actually goes to melting ice (W)
                        Real64 DefrostRateNeeded =
                            (IceSensHeatNeeded + (FrostChangekg * IceMeltEnthalpy)) / (DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour);
                        DefrostLoad = max(0.0, (DefrostSchedule * DefrostCap - DefrostRateNeeded));
                        this->IceTemp = this->TEvapDesign;
                    } // frost melted during time step less than amount of ice at start
                } else {
                    // no frost present so terminate defrost and reset ice temperature for start of next defrost
                    // However, dripdown schedule still prevents/limits cooling capacity during time step
                    DefrostLoad = 0.0;
                    DefrostSchedule = 0.0;
                    this->IceTemp = this->TEvapDesign;
                } // have frost present

            } else {
                // Not temperature control type, controlled only by schedule
                // Reduce defrost heat load on the zone by amount of ice melted during time step
                // But DefrostSchedule not changed
                FrostChangekg = max(0.0, min((DefrostEnergy / IceMeltEnthalpy), StartFrostKg));
                DefrostLoad -= FrostChangekg * IceMeltEnthalpy / DataHVACGlobals::TimeStepSys / DataGlobals::SecInHour;
                if (!DataGlobals::WarmupFlag) this->KgFrost = StartFrostKg - FrostChangekg;
            } // Temperature termination vs. time-clock control type

        } else { // DefrostSchedule <= 0 or have None or OffCycle
            DefrostLoad = 0.0;
        } // Defrost calculations

        Real64 SensLoadFromZone = SensLoadGross - HeaterLoad - DefrostLoad -
                                  FanPowerActual; // Net sensible load removed from zone after accounting for heaters, fans, defrost [W]

        // ReportWarehouseCoil(CoilID)
        this->ThermalDefrostPower = DefrostLoad;
        if (this->DefrostType == DefrostElec) {
            this->ElecDefrostConsumption = DefrostCap * DefrostSchedule * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour;
            this->ElecDefrostPower = DefrostCap * DefrostSchedule;
        } else {
            this->ElecDefrostConsumption = 0.0;
            this->ElecDefrostPower = 0.0;
        }

        // If hot brine or hot gas is used for defrost, need to reduce condenser load by heat reclaimed for defrost
        if (this->DefrostType == DefrostFluid) this->HotDefrostCondCredit = DefrostCap * DefrostSchedule;
        // LatentLoadServed is positive for latent heat removed from zone
        // SensLoadFromZone positive for heat REMOVED from zone, switch when do credit to zone
        this->SensCreditRate = SensLoadFromZone;
        this->SensCreditEnergy = SensLoadFromZone * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour;
        this->LatCreditRate = latLoadServed;
        this->LatCreditEnergy = latLoadServed * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour;
        this->LatKgPerS_ToZone = WaterRemovRate;
        this->TotalCoolingLoad = CoilCapTotal;
        this->TotalCoolingEnergy = CoilCapTotal * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour;
        this->SensCoolingEnergyRate = SensLoadGross;
        this->SensCoolingEnergy = SensLoadGross * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour;
        this->SensHeatRatio = SHR;
        this->ElecFanPower = FanPowerActual;
        this->ElecFanConsumption = FanPowerActual * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour;
        this->ElecHeaterPower = HeaterLoad;
        this->ElecHeaterConsumption = HeaterLoad * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour;

        this->TotalElecPower = FanPowerActual + HeaterLoad + this->ElecDefrostPower;
        this->TotalElecConsumption = this->TotalElecPower * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour;

        if (this->SensCreditRate >= 0.0) {
            this->ReportSensCoolCreditRate = this->SensCreditRate;
            this->ReportHeatingCreditRate = 0.0;
        } else {
            this->ReportSensCoolCreditRate = 0.0;
            this->ReportHeatingCreditRate = -this->SensCreditRate;
        }
        this->ReportSensCoolCreditEnergy = this->ReportSensCoolCreditRate * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour;
        this->ReportHeatingCreditEnergy = this->ReportHeatingCreditRate * DataHVACGlobals::TimeStepSys * DataGlobals::SecInHour;
        this->ReportTotalCoolCreditRate = this->ReportSensCoolCreditRate + this->LatCreditRate;
        this->ReportTotalCoolCreditEnergy = this->ReportSensCoolCreditEnergy + this->LatCreditEnergy;

        //**************************************************************************************************
        // Cap Kg Frost to avoid floating overflow errors
        // 1-time warning is issued. It should be rare but could happen with unrealistic inputs.

        if (this->KgFrost > MyLargeNumber) {
            this->KgFrost = MyLargeNumber;
            if (this->ShowCoilFrostWarning) {
                ShowWarningError("Refrigeration:AirCoil: " + this->Name);
                ShowContinueError(" This refrigerated air coil has insufficient defrost capacity to remove the excess frost accumulation.");
                ShowContinueError(" Check the defrost schedule or defrost capacity. ");
                ShowContinueErrorTimeStamp("... Occurrence info");
                this->ShowCoilFrostWarning = false;
            }
        }
    }

    void FigureRefrigerationZoneGains(EnergyPlusData &state)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         B. Griffith
        //       DATE WRITTEN   Dec 2011
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // initialize zone gain terms at begin environment

        CheckRefrigerationInput(state);

        if (DataGlobals::BeginEnvrnFlag && FigureRefrigerationZoneGainsMyEnvrnFlag) {

            if (DataHeatBalance::NumRefrigSystems > 0) {
                for (auto &e : System) {
                    e.PipeHeatLoad = 0.0;
                    e.NetHeatRejectLoad = 0.0;
                }
            }

            if (NumTransRefrigSystems > 0) {
                for (auto &e : TransSystem) {
                    e.PipeHeatLoadMT = 0.0;
                    e.PipeHeatLoadLT = 0.0;
                    e.NetHeatRejectLoad = 0.0;
                }
            }

            if (DataHeatBalance::NumRefrigeratedRacks > 0) {
                for (auto &e : RefrigRack) {
                    e.SensZoneCreditHeatRate = 0.0;
                    e.SensHVACCreditHeatRate = 0.0;
                }
            }

            if (NumSimulationSecondarySystems > 0) {
                for (auto &e : Secondary) {
                    e.DistPipeZoneHeatGain = 0.0;
                    e.ReceiverZoneHeatGain = 0.0;
                }
            }

            if (NumSimulationWalkIns > 0) {
                for (int loop = 1; loop <= NumSimulationWalkIns; ++loop) {
                    WalkIn(loop).SensZoneCreditRate = 0.0;
                    WalkIn(loop).LatZoneCreditRate = 0.0;
                }
            }
            if (NumSimulationCases > 0) {
                for (auto &e : RefrigCase) {
                    e.SensZoneCreditRate = 0.0;
                    e.SensHVACCreditRate = 0.0;
                    e.LatZoneCreditRate = 0.0;
                    e.LatHVACCreditRate = 0.0;
                }
            }
            FigureRefrigerationZoneGainsMyEnvrnFlag = false;
        }
        if (!DataGlobals::BeginEnvrnFlag) FigureRefrigerationZoneGainsMyEnvrnFlag = true;
    }

    void ZeroHVACValues()
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         T. Stovall
        //       DATE WRITTEN   Aug 2012
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // Reset all values that communicate outside module for HVAC steps
        // to zero when called on zone timestep. Otherwise, values may be held over when
        // no HVAC load calls module during that zone time step.

        int DemandARRID(0); // Index to water tank Demand used for evap condenser

        if (HaveRefrigRacks) {
            // HaveRefrigRacks is TRUE when NumRefrigeratedRAcks > 0
            // RefrigRack ALLOCATED to NumRefrigeratedRacks
            for (int RackNum = 1; RackNum <= DataHeatBalance::NumRefrigeratedRacks; ++RackNum) {
                if (RefrigRack(RackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeWater) {
                    Real64 MassFlowRate = 0.0;
                    PlantUtilities::SetComponentFlowRate(MassFlowRate,
                                                         RefrigRack(RackNum).InletNode,
                                                         RefrigRack(RackNum).OutletNode,
                                                         RefrigRack(RackNum).PlantLoopNum,
                                                         RefrigRack(RackNum).PlantLoopSideNum,
                                                         RefrigRack(RackNum).PlantBranchNum,
                                                         RefrigRack(RackNum).PlantCompNum);
                }
                if (RefrigRack(RackNum).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) {
                    if (RefrigRack(RackNum).EvapWaterSupplyMode == WaterSupplyFromTank) {
                        DemandARRID = RefrigRack(RackNum).EvapWaterTankDemandARRID;
                        int TankID = RefrigRack(RackNum).EvapWaterSupTankID;
                        DataWater::WaterStorage(TankID).VdotRequestDemand(DemandARRID) = 0.0;
                    }
                }
            } // RackNum
        }     // HaveRefrigRacks

        if (DataHeatBalance::NumRefrigCondensers > 0) {
            // Condenser ALLOCATED to DataHeatBalance::NumRefrigCondensers
            for (int CondID = 1; CondID <= DataHeatBalance::NumRefrigCondensers; ++CondID) {
                if (Condenser(CondID).CondenserType == DataHeatBalance::RefrigCondenserTypeWater) {
                    Real64 MassFlowRate = 0.0;
                    PlantUtilities::SetComponentFlowRate(MassFlowRate,
                                                         Condenser(CondID).InletNode,
                                                         Condenser(CondID).OutletNode,
                                                         Condenser(CondID).PlantLoopNum,
                                                         Condenser(CondID).PlantLoopSideNum,
                                                         Condenser(CondID).PlantBranchNum,
                                                         Condenser(CondID).PlantCompNum);
                }
                if (Condenser(CondID).CondenserType == DataHeatBalance::RefrigCondenserTypeEvap) {
                    if (Condenser(CondID).EvapWaterSupplyMode == WaterSupplyFromTank) {
                        DemandARRID = Condenser(CondID).EvapWaterTankDemandARRID;
                        int TankID = Condenser(CondID).EvapWaterSupTankID;
                        DataWater::WaterStorage(TankID).VdotRequestDemand(DemandARRID) = 0.0;
                    }
                }
            } // ICond
        }     // DataHeatBalance::NumRefrigCondensers>0
    }

} // namespace RefrigeratedCase

} // namespace EnergyPlus
