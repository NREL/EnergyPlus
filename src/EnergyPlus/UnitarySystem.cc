// EnergyPlus, Copyright (c) 1996-2021, The Board of Trustees of the University of Illinois,
// The Regents of the University of California, through Lawrence Berkeley National Laboratory
// (subject to receipt of any required approvals from the U.S. Dept. of Energy), Oak Ridge
// National Laboratory, managed by UT-Battelle, Alliance for Sustainable Energy, LLC, and other
// contributors. All rights reserved.
//
// NOTICE: This Software was developed under funding from the U.S. Department of Energy and the
// U.S. Government consequently retains certain rights. As such, the U.S. Government has been
// granted for itself and others acting on its behalf a paid-up, nonexclusive, irrevocable,
// worldwide license in the Software to reproduce, distribute copies to the public, prepare
// derivative works, and perform publicly and display publicly, and to permit others to do so.
//
// Redistribution and use in source and binary forms, with or without modification, are permitted
// provided that the following conditions are met:
//
// (1) Redistributions of source code must retain the above copyright notice, this list of
//     conditions and the following disclaimer.
//
// (2) Redistributions in binary form must reproduce the above copyright notice, this list of
//     conditions and the following disclaimer in the documentation and/or other materials
//     provided with the distribution.
//
// (3) Neither the name of the University of California, Lawrence Berkeley National Laboratory,
//     the University of Illinois, U.S. Dept. of Energy nor the names of its contributors may be
//     used to endorse or promote products derived from this software without specific prior
//     written permission.
//
// (4) Use of EnergyPlus(TM) Name. If Licensee (i) distributes the software in stand-alone form
//     without changes from the version obtained under this License, or (ii) Licensee makes a
//     reference solely to the software portion of its product, Licensee must refer to the
//     software as "EnergyPlus version X" software, where "X" is the version number Licensee
//     obtained under this License and may not use a different name for the software. Except as
//     specifically required in this Section (4), Licensee shall not use in a company name, a
//     product name, in advertising, publicity, or other promotional activities any name, trade
//     name, trademark, logo, or other designation of "EnergyPlus", "E+", "e+" or confusingly
//     similar designation, without the U.S. Department of Energy's prior written consent.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// C++ headers
#include <string>

// EnergyPlus headers
#include <EnergyPlus/AirflowNetwork/include/AirflowNetwork/Elements.hpp>
#include <EnergyPlus/Autosizing/All_Simple_Sizing.hh>
#include <EnergyPlus/Autosizing/CoolingAirFlowSizing.hh>
#include <EnergyPlus/Autosizing/CoolingCapacitySizing.hh>
#include <EnergyPlus/Autosizing/HeatingAirFlowSizing.hh>
#include <EnergyPlus/Autosizing/HeatingCapacitySizing.hh>
#include <EnergyPlus/Autosizing/SystemAirFlowSizing.hh>
#include <EnergyPlus/BranchInputManager.hh>
#include <EnergyPlus/BranchNodeConnections.hh>
#include <EnergyPlus/Coils/CoilCoolingDX.hh>
#include <EnergyPlus/DXCoils.hh>
#include <EnergyPlus/Data/EnergyPlusData.hh>
#include <EnergyPlus/DataHVACControllers.hh>
#include <EnergyPlus/DataHVACSystems.hh>
#include <EnergyPlus/DataHeatBalFanSys.hh>
#include <EnergyPlus/DataHeatBalance.hh>
#include <EnergyPlus/DataSizing.hh>
#include <EnergyPlus/DataZoneControls.hh>
#include <EnergyPlus/DataZoneEnergyDemands.hh>
#include <EnergyPlus/DataZoneEquipment.hh>
#include <EnergyPlus/EMSManager.hh>
#include <EnergyPlus/Fans.hh>
#include <EnergyPlus/FaultsManager.hh>
#include <EnergyPlus/FluidProperties.hh>
#include <EnergyPlus/General.hh>
#include <EnergyPlus/GeneralRoutines.hh>
#include <EnergyPlus/HVACFan.hh>
#include <EnergyPlus/HVACHXAssistedCoolingCoil.hh>
#include <EnergyPlus/HeatingCoils.hh>
#include <EnergyPlus/InputProcessing/InputProcessor.hh>
#include <EnergyPlus/NodeInputManager.hh>
#include <EnergyPlus/PackagedThermalStorageCoil.hh>
#include <EnergyPlus/Plant/DataPlant.hh>
#include <EnergyPlus/PlantUtilities.hh>
#include <EnergyPlus/Psychrometrics.hh>
#include <EnergyPlus/ReportCoilSelection.hh>
#include <EnergyPlus/SZVAVModel.hh>
#include <EnergyPlus/ScheduleManager.hh>
#include <EnergyPlus/SetPointManager.hh>
#include <EnergyPlus/SimAirServingZones.hh>
#include <EnergyPlus/SingleDuct.hh>
#include <EnergyPlus/SteamCoils.hh>
#include <EnergyPlus/UnitarySystem.hh>
#include <EnergyPlus/UserDefinedComponents.hh>
#include <EnergyPlus/UtilityRoutines.hh>
#include <EnergyPlus/VariableSpeedCoils.hh>
#include <EnergyPlus/WaterCoils.hh>
#include <EnergyPlus/WaterToAirHeatPump.hh>
#include <EnergyPlus/WaterToAirHeatPumpSimple.hh>
#include <EnergyPlus/ZonePlenum.hh>

namespace EnergyPlus {
namespace UnitarySystems {

    static constexpr std::string_view fluidNameSteam("STEAM");
    static constexpr std::string_view blankString("");

    UnitarySysInputSpec::UnitarySysInputSpec()
        : dx_heating_coil_sizing_ratio(1.0), minimum_supply_air_temperature(2.0), cooling_supply_air_flow_rate(-999.0),
          cooling_supply_air_flow_rate_per_floor_area(-999.0), cooling_fraction_of_autosized_cooling_supply_air_flow_rate(-999.0),
          cooling_supply_air_flow_rate_per_unit_of_capacity(-999.0), heating_supply_air_flow_rate(-999.0),
          heating_supply_air_flow_rate_per_floor_area(-999.0), heating_fraction_of_autosized_heating_supply_air_flow_rate(-999.0),
          heating_supply_air_flow_rate_per_unit_of_capacity(-999.0), no_load_supply_air_flow_rate(-999.0),
          no_load_supply_air_flow_rate_per_floor_area(-999.0), no_load_fraction_of_autosized_cooling_supply_air_flow_rate(-999.0),
          no_load_fraction_of_autosized_heating_supply_air_flow_rate(-999.0),
          no_load_supply_air_flow_rate_per_unit_of_capacity_during_cooling_operation(-999.0),
          no_load_supply_air_flow_rate_per_unit_of_capacity_during_heating_operation(-999.0), maximum_supply_air_temperature(80.0),
          maximum_outdoor_dry_bulb_temperature_for_supplemental_heater_operation(21.0), maximum_cycling_rate(2.5), heat_pump_time_constant(60.0),
          fraction_of_on_cycle_power_use(0.01), heat_pump_fan_delay_time(60.0), ancillary_on_cycle_electric_power(0.0),
          ancillary_off_cycle_electric_power(0.0), design_heat_recovery_water_flow_rate(0.0), maximum_temperature_for_heat_recovery(80.0)
    {
    }

    DesignSpecMSHP::DesignSpecMSHP()
        : numOfSpeedHeating(0), numOfSpeedCooling(0), noLoadAirFlowRateRatio(1.0), m_DesignSpecMSHPType_Num(0), m_SingleModeFlag(false)
    {
    }

    UnitarySys::UnitarySys() // constructor
        : m_UnitarySysNum(-1), m_sysType(SysType::Unassigned), m_ThisSysInputShouldBeGotten(true), m_SysAvailSchedPtr(0),
          m_ControlType(ControlType::None), m_DehumidControlType_Num(DehumCtrlType::None), m_Humidistat(false), m_ValidASHRAECoolCoil(false),
          m_ValidASHRAEHeatCoil(false), m_SimASHRAEModel(false), m_setFaultModelInput(true), m_FanIndex(0), m_FanPlace(FanPlace::NotYetSet),
          m_FanOpModeSchedPtr(0), m_FanExists(false), m_FanType_Num(0), m_RequestAutoSize(false), m_ActualFanVolFlowRate(0.0),
          m_DesignFanVolFlowRate(0.0), m_DesignMassFlowRate(0.0), m_FanAvailSchedPtr(0), m_FanOpMode(0), m_ATMixerIndex(0), m_ATMixerPriNode(0),
          m_ATMixerSecNode(0), m_AirLoopEquipment(true), m_ZoneInletNode(0), m_ZoneSequenceCoolingNum(0), m_ZoneSequenceHeatingNum(0),
          m_HeatCoilExists(false), m_HeatingSizingRatio(1.0), m_HeatingCoilType_Num(0), m_DXHeatingCoil(false), m_HeatingCoilIndex(0),
          m_HeatingCoilAvailSchPtr(0), m_DesignHeatingCapacity(0.0), m_MaxHeatAirVolFlow(0.0), m_NumOfSpeedHeating(0), m_MultiSpeedHeatingCoil(false),

          m_VarSpeedHeatingCoil(false), m_SystemHeatControlNodeNum(0), m_CoolCoilExists(false), m_CoolingCoilType_Num(0), m_NumOfSpeedCooling(0),
          m_CoolingCoilAvailSchPtr(0), m_DesignCoolingCapacity(0.0), m_MaxCoolAirVolFlow(0.0), m_CondenserNodeNum(0),
          m_CondenserType(DataHeatBalance::RefrigCondenserType::Unassigned), m_CoolingCoilIndex(0), m_HeatPump(false),
          m_ActualDXCoilIndexForHXAssisted(0), m_DiscreteSpeedCoolingCoil(false), m_ContSpeedCoolingCoil(false), m_SystemCoolControlNodeNum(0),
          m_WaterCyclingMode(0), m_ISHundredPercentDOASDXCoil(false), m_RunOnSensibleLoad(false), m_RunOnLatentLoad(false),
          m_RunOnLatentOnlyWithSensible(false), m_DehumidificationMode(0), m_SuppHeatCoilType_Num(0), m_SuppCoilExists(false),
          m_DesignSuppHeatingCapacity(0.0), m_SuppCoilAirInletNode(0), m_SuppCoilAirOutletNode(0),

          m_SuppCoilFluidInletNode(0), m_MaxSuppCoilFluidFlow(0.0), m_SuppHeatCoilIndex(0), m_SuppHeatControlNodeNum(0), m_SupHeaterLoad(0.0),
          m_CoolingSAFMethod(0), m_HeatingSAFMethod(0), m_NoCoolHeatSAFMethod(0), m_MaxNoCoolHeatAirVolFlow(0.0),
          m_AirFlowControl(UseCompFlow::FlowNotYetSet), m_CoolingCoilUpstream(true), m_MaxOATSuppHeat(0.0), m_MinOATCompressorCooling(0.0),
          m_MinOATCompressorHeating(0.0), m_MaxONOFFCyclesperHour(0.0), m_HPTimeConstant(0.0), m_OnCyclePowerFraction(0.0), m_FanDelayTime(0.0),
          m_AncillaryOnPower(0.0), m_AncillaryOffPower(0.0), m_DesignHRWaterVolumeFlow(0.0), m_MaxHROutletWaterTemp(0.0), m_HeatRecActive(false),
          m_HeatRecoveryInletNodeNum(0), m_HeatRecoveryOutletNodeNum(0), m_DesignSpecMSHPIndex(-1), m_NoLoadAirFlowRateRatio(1.0), m_SingleMode(0),
          m_MultiOrVarSpeedHeatCoil(false), m_MultiOrVarSpeedCoolCoil(false), m_PartLoadFrac(0.0), m_CoolingPartLoadFrac(0.0),
          m_HeatingPartLoadFrac(0.0), m_SuppHeatPartLoadFrac(0.0), m_HeatCompPartLoadRatio(0.0), m_CoolCompPartLoadRatio(0.0), m_SpeedRatio(0.0),
          m_CycRatio(0.0), m_MyEnvrnFlag(true), m_MyEnvrnFlag2(true), m_MyPlantScanFlag(true), m_MySuppCoilPlantScanFlag(true),
          m_MySetPointCheckFlag(true), m_MySizingCheckFlag(true), m_InitHeatPump(false), m_HRLoopNum(0), m_HRLoopSideNum(0), m_HRBranchNum(0),
          m_HRCompNum(0), m_SuppCoilLoopNum(0), m_SuppCoilLoopSide(0), m_SuppCoilBranchNum(0), m_SuppCoilCompNum(0), m_SuppCoilFluidOutletNodeNum(0),
          m_WSHPRuntimeFrac(0.0), m_CompPartLoadRatio(0.0), m_CoolingCoilSensDemand(0.0), m_CoolingCoilLatentDemand(0.0),
          m_HeatingCoilSensDemand(0.0), m_SenLoadLoss(0.0), m_LatLoadLoss(0.0), m_DesignHeatRecMassFlowRate(0.0), m_HeatRecoveryMassFlowRate(0.0),
          m_HeatRecoveryRate(0.0), m_HeatRecoveryEnergy(0.0), m_HeatRecoveryInletTemp(0.0), m_HeatRecoveryOutletTemp(0.0), m_IterationCounter(0),
          m_DesiredOutletTemp(0.0), m_DesiredOutletHumRat(0.0), m_FrostControlStatus(0), m_CoolingCycRatio(0.0), m_CoolingSpeedRatio(0.0),
          m_CoolingSpeedNum(0), m_HeatingCycRatio(0.0), m_HeatingSpeedRatio(0.0), m_HeatingSpeedNum(0), m_SpeedNum(0),
          m_EMSOverrideCoilSpeedNumOn(false), m_EMSOverrideCoilSpeedNumValue(0.0), m_CoilSpeedErrIdx(0), m_DehumidInducedHeatingDemandRate(0.0),
          m_TotalAuxElecPower(0.0), m_HeatingAuxElecConsumption(0.0), m_CoolingAuxElecConsumption(0.0), m_ElecPower(0.0), m_ElecPowerConsumption(0.0),
          m_LastMode(0), m_FirstPass(true), m_TotCoolEnergyRate(0.0), m_SensCoolEnergyRate(0.0), m_LatCoolEnergyRate(0.0), m_TotHeatEnergyRate(0.0),
          m_SensHeatEnergyRate(0.0), m_LatHeatEnergyRate(0.0), m_DesignFanVolFlowRateEMSOverrideOn(false), m_MaxHeatAirVolFlowEMSOverrideOn(false),
          m_MaxCoolAirVolFlowEMSOverrideOn(false), m_MaxNoCoolHeatAirVolFlowEMSOverrideOn(false), m_DesignFanVolFlowRateEMSOverrideValue(0.0),
          m_MaxHeatAirVolFlowEMSOverrideValue(0.0), m_MaxCoolAirVolFlowEMSOverrideValue(0.0), m_MaxNoCoolHeatAirVolFlowEMSOverrideValue(0.0),
          m_EMSOverrideSensZoneLoadRequest(false), m_EMSOverrideMoistZoneLoadRequest(false), m_EMSSensibleZoneLoadValue(0.0),
          m_EMSMoistureZoneLoadValue(0.0), m_StageNum(0), m_Staged(false), m_HeatingFanSpeedRatio(0.0), m_CoolingFanSpeedRatio(0.0),
          m_NoHeatCoolSpeedRatio(0.0), m_MyFanFlag(true), m_MyCheckFlag(true), m_SensibleLoadMet(0.0), m_LatentLoadMet(0.0), m_MyStagedFlag(false),
          m_SensibleLoadPredicted(0.0), m_MoistureLoadPredicted(0.0), m_FaultyCoilSATFlag(false), m_FaultyCoilSATIndex(0), m_FaultyCoilSATOffset(0.0),
          m_TESOpMode(0), m_initLoadBasedControlAirLoopPass(false), m_airLoopPassCounter(0), m_airLoopReturnCounter(0), m_FanCompNotSetYet(true),
          m_CoolCompNotSetYet(true), m_HeatCompNotSetYet(true), m_SuppCompNotSetYet(true), m_OKToPrintSizing(false), m_IsDXCoil(true),
          m_SmallLoadTolerance(5.0), m_TemperatureOffsetControlActive(false), m_minAirToWaterTempOffset(0.0), m_HRcoolCoilFluidInletNode(0),
          m_HRcoolCoilAirInNode(0), m_minWaterLoopTempForHR(0.0), m_waterSideEconomizerFlag(false), m_WaterHRPlantLoopModel(false),
          UnitarySystemType_Num(0), MaxIterIndex(0), RegulaFalsiFailedIndex(0), NodeNumOfControlledZone(0), FanPartLoadRatio(0.0),
          CoolCoilWaterFlowRatio(0.0), HeatCoilWaterFlowRatio(0.0), ControlZoneNum(0), AirInNode(0), AirOutNode(0), MaxCoolAirMassFlow(0.0),
          MaxHeatAirMassFlow(0.0), MaxNoCoolHeatAirMassFlow(0.0), DesignMinOutletTemp(0.0), DesignMaxOutletTemp(0.0), LowSpeedCoolFanRatio(0.0),
          LowSpeedHeatFanRatio(0.0), MaxCoolCoilFluidFlow(0.0), MaxHeatCoilFluidFlow(0.0), CoolCoilInletNodeNum(0), CoolCoilOutletNodeNum(0),
          CoolCoilFluidOutletNodeNum(0), CoolCoilLoopNum(0), CoolCoilLoopSide(0), CoolCoilBranchNum(0), CoolCoilCompNum(0), CoolCoilFluidInletNode(0),
          HeatCoilLoopNum(0), HeatCoilLoopSide(0), HeatCoilBranchNum(0), HeatCoilCompNum(0), HeatCoilFluidInletNode(0), HeatCoilFluidOutletNodeNum(0),
          HeatCoilInletNodeNum(0), HeatCoilOutletNodeNum(0), ATMixerExists(false), ATMixerType(0), ATMixerOutNode(0), ControlZoneMassFlowFrac(0.0),
          m_CompPointerMSHP(nullptr), LoadSHR(0.0), CoilSHR(0.0), temperatureOffsetControlStatus(0)
    {
    }

    void UnitarySys::simulate(EnergyPlusData &state,
                              std::string_view Name,
                              bool const FirstHVACIteration,
                              int const &AirLoopNum,
                              int &CompIndex,
                              bool &HeatActive,
                              bool &CoolActive,
                              int const ZoneOAUnitNum,
                              Real64 const OAUCoilOutTemp,
                              bool const ZoneEquipment,
                              Real64 &sysOutputProvided,
                              Real64 &latOutputProvided)
    {
        simulateSys(state,
                    Name,
                    FirstHVACIteration,
                    AirLoopNum,
                    CompIndex,
                    HeatActive,
                    CoolActive,
                    ZoneOAUnitNum,
                    OAUCoilOutTemp,
                    ZoneEquipment,
                    sysOutputProvided,
                    latOutputProvided);
    }

    void UnitarySys::simulateSys(EnergyPlusData &state,
                                 std::string_view Name,
                                 bool const FirstHVACIteration,
                                 int const &AirLoopNum,
                                 int &CompIndex,
                                 bool &HeatActive,
                                 bool &CoolActive,
                                 int const ZoneOAUnitNum,
                                 Real64 const OAUCoilOutTemp,
                                 bool const ZoneEquipment,
                                 Real64 &sysOutputProvided,
                                 Real64 &latOutputProvided)
    {
        int CompOn = 0;

        // Obtains and Allocates unitary system related parameters from input file
        if (this->m_ThisSysInputShouldBeGotten) {
            // Get the unitary system input
            getUnitarySystemInput(state, Name, ZoneEquipment, ZoneOAUnitNum);
        }
        CompIndex = this->m_UnitarySysNum;

        state.dataUnitarySystems->FanSpeedRatio = 1.0;
        if (ZoneEquipment) {
            this->initUnitarySystems(state, 0, FirstHVACIteration, ZoneOAUnitNum, OAUCoilOutTemp);
        } else {
            this->initUnitarySystems(state, AirLoopNum, FirstHVACIteration, ZoneOAUnitNum, OAUCoilOutTemp);
        }

        // MassFlowRateMaxAvail issues are impeding non-VAV air loop equipment by limiting air flow
        // temporarily open up flow limits while simulating, and then set this same value at the INLET after this parent has simulated
        Real64 tempMassFlowRateMaxAvail = state.dataLoopNodes->Node(this->AirInNode).MassFlowRateMaxAvail;
        // this is not working for CoilSystem simulated with UnitarySystem. Try to protect when this happens.
        if (AirLoopNum > 0 && this->m_ControlType != ControlType::Setpoint) {
            state.dataLoopNodes->Node(this->AirInNode).MassFlowRateMaxAvail = this->m_DesignMassFlowRate;
        }

        if (this->m_OKToPrintSizing) {
            bool HXUnitOn = false;
            {
                auto const SELECT_CASE_var(this->m_ControlType);
                if (SELECT_CASE_var == ControlType::Setpoint) {
                    if (ZoneEquipment) {
                        this->controlUnitarySystemtoSP(
                            state, 0, FirstHVACIteration, CompOn, OAUCoilOutTemp, HXUnitOn, sysOutputProvided, latOutputProvided);
                    } else {
                        this->controlUnitarySystemtoSP(
                            state, AirLoopNum, FirstHVACIteration, CompOn, OAUCoilOutTemp, HXUnitOn, sysOutputProvided, latOutputProvided);
                    }
                } else if (SELECT_CASE_var == ControlType::Load || SELECT_CASE_var == ControlType::CCMASHRAE) {
                    if (ZoneEquipment) {
                        this->controlUnitarySystemtoLoad(
                            state, 0, FirstHVACIteration, CompOn, OAUCoilOutTemp, HXUnitOn, sysOutputProvided, latOutputProvided);
                    } else {
                        this->controlUnitarySystemtoLoad(
                            state, AirLoopNum, FirstHVACIteration, CompOn, OAUCoilOutTemp, HXUnitOn, sysOutputProvided, latOutputProvided);
                    }
                }
            }
        }

        // Report the current output
        if (ZoneEquipment) {
            this->reportUnitarySystem(state, 0);
        } else {
            this->reportUnitarySystem(state, AirLoopNum);
        }

        // CoolActive = false; // set in call from ZoneEquipmentManager
        if (this->m_CoolingPartLoadFrac * double(CompOn) > 0.0) CoolActive = true;
        // HeatActive = false; // set in call from ZoneEquipmentManager
        if (this->m_HeatingPartLoadFrac * double(CompOn) > 0.0 || this->m_SuppHeatPartLoadFrac * double(CompOn) > 0.0) HeatActive = true;

        // set econo lockout flag
        // If the sysem is not an equipment of Outdoor air unit
        //  IF (AirLoopNum /=-1 .AND. ALLOCATED(AirLoopControlInfo) .AND. UnitarySystem(UnitarySysNum)%AirLoopEquipment) THEN
        if (AirLoopNum > 0 && allocated(state.dataAirLoop->AirLoopControlInfo) && this->m_AirLoopEquipment) {

            if ((this->m_HeatCompPartLoadRatio > 0.0 || this->m_SpeedRatio > 0.0 || this->m_CycRatio > 0.0) &&
                state.dataAirLoop->AirLoopControlInfo(AirLoopNum).CanLockoutEconoWithCompressor) {
                state.dataAirLoop->AirLoopControlInfo(AirLoopNum).ReqstEconoLockoutWithCompressor = true;
            } else {
                state.dataAirLoop->AirLoopControlInfo(AirLoopNum).ReqstEconoLockoutWithCompressor = false;
            }

            if ((HeatActive) && (state.dataAirLoop->AirLoopControlInfo(AirLoopNum).CanLockoutEconoWithCompressor ||
                                 state.dataAirLoop->AirLoopControlInfo(AirLoopNum).CanLockoutEconoWithHeating)) {
                state.dataAirLoop->AirLoopControlInfo(AirLoopNum).ReqstEconoLockoutWithHeating = true;
            } else {
                state.dataAirLoop->AirLoopControlInfo(AirLoopNum).ReqstEconoLockoutWithHeating = false;
            }
        }

        // Calculate heat recovery
        if (this->m_HeatRecActive) {
            this->unitarySystemHeatRecovery(state);
        }

        // Coils should have been sized by now. Set this flag to false in case other equipment is downstream of Unitary System.
        // No, can't do this since there are other checks that need this flag (e.g., HVACManager, SetHeatToReturnAirFlag())
        //  AirLoopControlInfo(AirLoopNum)%UnitarySys = .FALSE.

        if (AirLoopNum > 0 && this->m_ControlType != ControlType::Setpoint) {
            state.dataLoopNodes->Node(this->AirInNode).MassFlowRateMaxAvail = tempMassFlowRateMaxAvail;
        }
    }

    DesignSpecMSHP *DesignSpecMSHP::factory(EnergyPlusData &state, int object_type_of_num, std::string const objectName)
    {

        if (state.dataUnitarySystems->getMSHPInputOnceFlag) {
            DesignSpecMSHP::getDesignSpecMSHP(state);
            state.dataUnitarySystems->getMSHPInputOnceFlag = false;
        }
        for (auto &dSpec : state.dataUnitarySystems->designSpecMSHP) {
            if (UtilityRoutines::SameString(dSpec.name, objectName) && dSpec.m_DesignSpecMSHPType_Num == object_type_of_num) {
                return &dSpec;
            }
        }
        ShowSevereError(state, "Design Specification MultiSpeed Heat Pump factory: Error getting inputs for system named: " + objectName);
        return nullptr;
    }

    void DesignSpecMSHP::getDesignSpecMSHP(EnergyPlusData &state)
    {
        bool errorsFound(false);

        DesignSpecMSHP::getDesignSpecMSHPdata(state, errorsFound);

        if (errorsFound) {
            ShowFatalError(state, "Design Specification MultiSpeed Heat Pump: Previous errors cause termination.");
        }
    }

    void DesignSpecMSHP::getDesignSpecMSHPdata(EnergyPlusData &state, bool errorsFound)
    {
        std::string cCurrentModuleObject = "UnitarySystemPerformance:Multispeed";

        auto const instances = state.dataInputProcessing->inputProcessor->epJSON.find(cCurrentModuleObject);
        if (instances == state.dataInputProcessing->inputProcessor->epJSON.end()) {
            errorsFound = true;
        } else {
            int designSpecNum = 0;
            auto &instancesValue = instances.value();
            for (auto instance = instancesValue.begin(); instance != instancesValue.end(); ++instance) {

                // *************** used only to eliminate unused object warning when using only Json type getInput **********
                int TotalArgs = 0;
                int NumAlphas = 0;
                int NumNumbers = 0;
                state.dataInputProcessing->inputProcessor->getObjectDefMaxArgs(state, cCurrentModuleObject, TotalArgs, NumAlphas, NumNumbers);
                int IOStatus = 0;
                Array1D_string Alphas(NumAlphas);
                Array1D<Real64> Numbers(NumNumbers, 0.0);
                Array1D_bool lNumericBlanks(NumNumbers, true);
                Array1D_bool lAlphaBlanks(NumAlphas, true);
                Array1D_string cAlphaFields(NumAlphas);
                Array1D_string cNumericFields(NumNumbers);
                state.dataInputProcessing->inputProcessor->getObjectItem(state,
                                                                         cCurrentModuleObject,
                                                                         ++designSpecNum,
                                                                         Alphas,
                                                                         NumAlphas,
                                                                         Numbers,
                                                                         NumNumbers,
                                                                         IOStatus,
                                                                         lNumericBlanks,
                                                                         lAlphaBlanks,
                                                                         cAlphaFields,
                                                                         cNumericFields);
                // **********************************************************************************************************

                auto const &fields = instance.value();
                auto const &thisObjectName = instance.key();
                DesignSpecMSHP thisDesignSpec;

                thisDesignSpec.name = UtilityRoutines::MakeUPPERCase(thisObjectName);
                thisDesignSpec.numOfSpeedHeating = fields.at("number_of_speeds_for_heating").get<int>(); // required field
                thisDesignSpec.numOfSpeedCooling = fields.at("number_of_speeds_for_cooling").get<int>(); // required field
                int maxSpeeds = max(thisDesignSpec.numOfSpeedHeating, thisDesignSpec.numOfSpeedCooling);
                thisDesignSpec.m_DesignSpecMSHPType_Num = 1; // add global int value for factory

                std::string loc_m_SingleModeOp("No");
                if (fields.find("single_mode_operation") != fields.end()) { // not required field
                    loc_m_SingleModeOp = UtilityRoutines::MakeUPPERCase(fields.at("single_mode_operation").get<std::string>());
                }
                // set single mode flag
                if (UtilityRoutines::SameString(loc_m_SingleModeOp, "Yes")) {
                    thisDesignSpec.m_SingleModeFlag = true;
                } else if (UtilityRoutines::SameString(loc_m_SingleModeOp, "No")) {
                    thisDesignSpec.m_SingleModeFlag = false;
                } else {
                }

                Real64 loc_m_NoLoadAirFlowRateRatio(1.0);
                if (fields.find("no_load_supply_air_flow_rate_ratio") != fields.end()) { // not required field
                    loc_m_NoLoadAirFlowRateRatio = fields.at("no_load_supply_air_flow_rate_ratio").get<Real64>();
                }
                thisDesignSpec.noLoadAirFlowRateRatio = loc_m_NoLoadAirFlowRateRatio;

                thisDesignSpec.heatingVolFlowRatio.resize(maxSpeeds + 1);
                thisDesignSpec.coolingVolFlowRatio.resize(maxSpeeds + 1);

                auto speedFlowRatios = fields.find("flow_ratios");
                if (speedFlowRatios != fields.end()) {
                    auto flowRatioArray = speedFlowRatios.value();
                    int numSpeedInputs = flowRatioArray.size();
                    if (numSpeedInputs >= maxSpeeds) {
                        int speedNum = -1;
                        for (auto flowRatio : flowRatioArray) {
                            speedNum += 1;
                            auto m_CoolingSpeedRatioObject = flowRatio.at("cooling_speed_supply_air_flow_ratio");
                            if (m_CoolingSpeedRatioObject == "Autosize") {
                                if (speedNum < (maxSpeeds + 1)) thisDesignSpec.coolingVolFlowRatio[speedNum] = -99999;
                            } else {
                                if (speedNum < (maxSpeeds + 1))
                                    thisDesignSpec.coolingVolFlowRatio[speedNum] = m_CoolingSpeedRatioObject.get<Real64>();
                            }
                            auto m_HeatingSpeedRatioObject = flowRatio.at("heating_speed_supply_air_flow_ratio");
                            if (m_HeatingSpeedRatioObject == "Autosize") {
                                if (speedNum < (maxSpeeds + 1)) thisDesignSpec.heatingVolFlowRatio[speedNum] = -99999;
                            } else {
                                if (speedNum < (maxSpeeds + 1))
                                    thisDesignSpec.heatingVolFlowRatio[speedNum] = m_HeatingSpeedRatioObject.get<Real64>();
                            }
                        }
                    } else if (numSpeedInputs < maxSpeeds) {
                        ShowSevereError(state, cCurrentModuleObject + ": Error getting inputs for system named: " + thisObjectName);
                        ShowContinueError(state,
                                          format("Number of speed inputs ({:.0T} is less than number of speeds ({:.0T}).",
                                                 Real64(numSpeedInputs),
                                                 Real64(maxSpeeds)));
                        errorsFound = true;
                    }
                }
                state.dataUnitarySystems->designSpecMSHP.push_back(thisDesignSpec);
            }
        }
    } // namespace UnitarySystems

    HVACSystemData *UnitarySys::factory(
        EnergyPlusData &state, int const object_type_of_num, std::string const objectName, bool const ZoneEquipment, int const ZoneOAUnitNum)
    {
        if (state.dataUnitarySystems->getInputOnceFlag) {
            UnitarySys::getUnitarySystemInput(state, objectName, ZoneEquipment, ZoneOAUnitNum);
            state.dataUnitarySystems->getInputOnceFlag = false;
        }
        int sysNum = -1;
        for (auto &sys : state.dataUnitarySystems->unitarySys) {
            ++sysNum;
            if (UtilityRoutines::SameString(sys.Name, objectName) && object_type_of_num == DataHVACGlobals::UnitarySys_AnyCoilType) {
                state.dataUnitarySystems->unitarySys[sysNum].m_UnitarySysNum = sysNum;
                return &sys;
            }
        }
        ShowFatalError(state, "UnitarySystem factory: Error getting inputs for system named: " + objectName);
        return nullptr;
    }

    int getDesignSpecMSHPIndex(
        EnergyPlusData &state,      // lookup vector index for design spec object name in object array EnergyPlus::UnitarySystems::designSpecMSHP
        std::string_view objectName // IDF name in input
    )
    {
        int index = -1;
        for (std::size_t loop = 0; loop < state.dataUnitarySystems->designSpecMSHP.size(); ++loop) {
            DesignSpecMSHP *thisDesignSpecMSHPObjec = &state.dataUnitarySystems->designSpecMSHP[loop];
            if (UtilityRoutines::SameString(objectName, thisDesignSpecMSHPObjec->name)) {
                index = loop;
                return index;
            }
        }
        ShowSevereError(
            state, "getDesignSpecMSHPIndex: did not find UnitarySystemPerformance:Multispeed name =" + std::string{objectName} + ". Check inputs");
        return index;
    }

    int getUnitarySystemIndex(
        EnergyPlusData &state,      // lookup vector index for UnitarySystem object name in object array EnergyPlus::UnitarySystems::unitarySys
        std::string_view objectName // IDF name in input
    )
    {
        int index = -1;
        bool found = false;
        for (std::size_t loop = 0; loop < state.dataUnitarySystems->unitarySys.size(); ++loop) {
            UnitarySys *thisUnitarySysObjec = &state.dataUnitarySystems->unitarySys[loop];
            if (UtilityRoutines::SameString(objectName, thisUnitarySysObjec->Name)) {
                index = loop;
                found = true;
                break;
            }
        }
        return index;
    }

    void UnitarySys::initUnitarySystems(
        EnergyPlusData &state, int const &AirLoopNum, bool const &FirstHVACIteration, int const ZoneOAUnitNum, Real64 const OAUCoilOutTemp)
    {
        static constexpr std::string_view routineName("InitUnitarySystems");
        bool errorsFound = false; // error flag for mining functions

        if (state.dataUnitarySystems->myOneTimeFlag) {
            // initialize or allocate something once
            state.dataUnitarySystems->myOneTimeFlag = false;
        }

        if (!state.dataGlobal->SysSizingCalc && this->m_MySizingCheckFlag && !this->m_ThisSysInputShouldBeGotten) {
            if (AirLoopNum > 0) {
                if (this->m_FanExists && (this->m_CoolCoilExists && (this->m_HeatCoilExists || this->m_SuppCoilExists)))
                    state.dataAirLoop->AirLoopControlInfo(AirLoopNum).UnitarySys = true;
                state.dataAirLoop->AirLoopControlInfo(AirLoopNum).UnitarySysSimulating = true;
                if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {
                    DXCoils::SetCoilSystemCoolingData(state, this->m_CoolingCoilName, this->Name);
                }
                // open this up to include UnitarySystem on a future commit
                if (!this->m_FanExists && this->m_sysType == SysType::CoilCoolingDX) {
                    if (this->m_CoolCoilExists) { // copy this block for heating coil also on future commit
                        bool coilDataSet = false;
                        bool errorsFound = false;
                        std::string coilName;
                        std::string coilType;
                        if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {
                            VariableSpeedCoils::getCoilTypeAndName(state, this->m_CoolingCoilIndex, coilType, coilName, errorsFound);
                            if (!errorsFound) coilDataSet = true;
                        } else if (this->m_CoolingCoilIndex == DataHVACGlobals::CoilDX_CoolingSingleSpeed) {
                            // need to check for all other coil types
                        }
                        if (coilDataSet) {
                            switch (state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).supFanModelTypeEnum) {
                            case DataAirSystems::structArrayLegacyFanModels: {
                                int SupFanNum = state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).SupFanNum;
                                if (SupFanNum > 0) {
                                    state.dataRptCoilSelection->coilSelectionReportObj->setCoilSupplyFanInfo(
                                        state,
                                        coilName,
                                        coilType,
                                        state.dataFans->Fan(state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).SupFanNum).FanName,
                                        DataAirSystems::structArrayLegacyFanModels,
                                        state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).SupFanNum);
                                }

                                break;
                            }
                            case DataAirSystems::objectVectorOOFanSystemModel: {
                                if (state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).supFanVecIndex >= 0) {
                                    state.dataRptCoilSelection->coilSelectionReportObj->setCoilSupplyFanInfo(
                                        state,
                                        coilName,
                                        coilType,
                                        state.dataHVACFan->fanObjs[state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).supFanVecIndex]->name,
                                        DataAirSystems::objectVectorOOFanSystemModel,
                                        state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).supFanVecIndex);
                                }
                                break;
                            }
                            case DataAirSystems::fanModelTypeNotYetSet: {
                                // do nothing
                                break;
                            }
                            }
                        }
                    }
                }
            }
            this->sizeSystem(state, FirstHVACIteration, AirLoopNum);
            this->m_MySizingCheckFlag = false;
            if (AirLoopNum > 0) {
                state.dataAirLoop->AirLoopControlInfo(AirLoopNum).FanOpMode = this->m_FanOpMode;
                state.dataAirLoop->AirLoopControlInfo(AirLoopNum).CycFanSchedPtr = this->m_FanOpModeSchedPtr;
            } else if (AirLoopNum < 0) {
                if (this->m_ControlType == ControlType::CCMASHRAE) {
                    ShowSevereError(state, this->UnitType + ": " + this->Name);
                    ShowContinueError(state, "  Invalid application of Control Type = SingleZoneVAV in outdoor air system.");
                    ShowFatalError(state, "InitUnitarySystems: Program terminated for previous conditions.");
                }
            }
        }

        if (this->m_MyFanFlag) {
            std::string FanType = ""; // used in warning messages
            std::string FanName = ""; // used in warning messages
            if (this->m_ActualFanVolFlowRate != DataSizing::AutoSize) {
                if (this->m_ActualFanVolFlowRate > 0.0) {
                    this->m_HeatingFanSpeedRatio = this->m_MaxHeatAirVolFlow / this->m_ActualFanVolFlowRate;
                    this->m_CoolingFanSpeedRatio = this->m_MaxCoolAirVolFlow / this->m_ActualFanVolFlowRate;
                    this->m_NoHeatCoolSpeedRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_ActualFanVolFlowRate;
                    if (this->m_FanExists && !this->m_MultiOrVarSpeedHeatCoil && !this->m_MultiOrVarSpeedCoolCoil) {
                        bool fanHasPowerSpeedRatioCurve = false;
                        if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                            if (state.dataHVACFan->fanObjs[this->m_FanIndex]->powerModFuncFlowFractionCurveIndex > 0)
                                fanHasPowerSpeedRatioCurve = true;
                            FanType = "Fan:SystemModel";
                            FanName = this->m_FanName;
                        } else {
                            if (Fans::GetFanSpeedRatioCurveIndex(state, FanType, FanName, this->m_FanIndex) > 0) fanHasPowerSpeedRatioCurve = true;
                        }
                        if (fanHasPowerSpeedRatioCurve) {

                            if (this->m_ActualFanVolFlowRate == this->m_MaxHeatAirVolFlow &&
                                this->m_ActualFanVolFlowRate == this->m_MaxCoolAirVolFlow &&
                                this->m_ActualFanVolFlowRate == this->m_MaxNoCoolHeatAirVolFlow) {
                                ShowWarningError(state, this->UnitType + " \"" + this->Name + "\"");
                                ShowContinueError(state, "...For fan type and name = " + FanType + " \"" + FanName + "\"");
                                ShowContinueError(state,
                                                  "...Fan power ratio function of speed ratio curve has no impact if fan volumetric flow rate is the "
                                                  "same as the unitary system volumetric flow rate.");
                                ShowContinueError(state,
                                                  format("...Fan volumetric flow rate            = {:.5R} m3/s.", this->m_ActualFanVolFlowRate));
                                ShowContinueError(state, format("...Unitary system volumetric flow rate = {:.5R} m3/s.", this->m_MaxHeatAirVolFlow));
                            }
                        }
                    }
                    if (this->m_MultiOrVarSpeedHeatCoil || this->m_MultiOrVarSpeedCoolCoil) {
                        if (this->m_MultiOrVarSpeedCoolCoil) {
                            int NumSpeeds = this->m_NumOfSpeedCooling;
                            if (this->m_MSCoolingSpeedRatio.empty()) this->m_MSCoolingSpeedRatio.resize(NumSpeeds);
                            for (int Iter = 1; Iter <= NumSpeeds; ++Iter) {
                                this->m_MSCoolingSpeedRatio[Iter] = this->m_CoolVolumeFlowRate[Iter] / this->m_ActualFanVolFlowRate;
                            }
                        }
                        if (this->m_MultiOrVarSpeedHeatCoil) {
                            int NumSpeeds = this->m_NumOfSpeedHeating;
                            if (this->m_MSHeatingSpeedRatio.empty()) this->m_MSHeatingSpeedRatio.resize(NumSpeeds);
                            for (int Iter = 1; Iter <= NumSpeeds; ++Iter) {
                                this->m_MSHeatingSpeedRatio[Iter] = this->m_HeatVolumeFlowRate[Iter] / this->m_ActualFanVolFlowRate;
                            }
                        }
                        this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_ActualFanVolFlowRate;
                    }
                }
                this->m_MyFanFlag = false;
            } else {
                if (this->m_FanExists) {
                    if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                        this->m_ActualFanVolFlowRate = state.dataHVACFan->fanObjs[this->m_FanIndex]->designAirVolFlowRate;
                    } else {
                        this->m_ActualFanVolFlowRate =
                            Fans::GetFanDesignVolumeFlowRate(state, blankString, blankString, errorsFound, this->m_FanIndex);
                    }
                }
            }
        }

        // why is this here, it doesn't do anything
        int OutdoorAirUnitNum = 0;
        int OAUCoilOutletTemp = 0.0;
        if (AirLoopNum == -1) { // This DX system is component of ZoneHVAC:OutdoorAirUnit
            OutdoorAirUnitNum = ZoneOAUnitNum;
            OAUCoilOutletTemp = OAUCoilOutTemp;
        }

        // Scan hot water and steam heating coil plant components for one time initializations
        if (this->m_MyPlantScanFlag && allocated(state.dataPlnt->PlantLoop)) {
            if (this->m_HeatRecActive) {
                state.dataUnitarySystems->initUnitarySystemsErrFlag = false;
                PlantUtilities::ScanPlantLoopsForObject(state,
                                                        this->Name,
                                                        DataPlant::TypeOf_UnitarySysRecovery,
                                                        this->m_HRLoopNum,
                                                        this->m_HRLoopSideNum,
                                                        this->m_HRBranchNum,
                                                        this->m_HRCompNum,
                                                        state.dataUnitarySystems->initUnitarySystemsErrFlag,
                                                        _,
                                                        _,
                                                        _,
                                                        _,
                                                        _);
                if (state.dataUnitarySystems->initUnitarySystemsErrFlag) {
                    ShowFatalError(state, "InitUnitarySystems: Program terminated for previous conditions.");
                }
            }
            int TypeOfCoilWaterCooling = 0;
            std::string CoolingCoilType = "";
            std::string CoolingCoilName = "";
            if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
                this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed ||
                this->m_CoolingCoilType_Num == DataHVACGlobals::CoilWater_CoolingHXAssisted) {
                if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater) {
                    TypeOfCoilWaterCooling = DataPlant::TypeOf_CoilWaterCooling;
                    CoolingCoilType = "Coil:Cooling:Water";
                    CoolingCoilName = this->m_CoolingCoilName;
                } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) {
                    TypeOfCoilWaterCooling = DataPlant::TypeOf_CoilWaterDetailedFlatCooling;
                    CoolingCoilType = "Coil:Cooling:Water:DetailedGeometry";
                    CoolingCoilName = this->m_CoolingCoilName;
                } else {
                    TypeOfCoilWaterCooling =
                        HVACHXAssistedCoolingCoil::GetCoilObjectTypeNum(state,
                                                                        DataHVACGlobals::cAllCoilTypes(this->m_CoolingCoilType_Num),
                                                                        this->m_CoolingCoilName,
                                                                        state.dataUnitarySystems->initUnitarySystemsErrFlag,
                                                                        true);
                    if (TypeOfCoilWaterCooling == DataHVACGlobals::Coil_CoolingWater) {
                        TypeOfCoilWaterCooling = DataPlant::TypeOf_CoilWaterCooling;
                        CoolingCoilType = "Coil:Cooling:Water";
                    } else if (TypeOfCoilWaterCooling == DataHVACGlobals::Coil_CoolingWaterDetailed) {
                        TypeOfCoilWaterCooling = DataPlant::TypeOf_CoilWaterDetailedFlatCooling;
                        CoolingCoilType = "Coil:Cooling:Water:DetailedGeometry";
                    }
                    CoolingCoilName = HVACHXAssistedCoolingCoil::GetHXDXCoilName(state,
                                                                                 DataHVACGlobals::cAllCoilTypes(this->m_CoolingCoilType_Num),
                                                                                 this->m_CoolingCoilName,
                                                                                 state.dataUnitarySystems->initUnitarySystemsErrFlag);
                }
                state.dataUnitarySystems->initUnitarySystemsErrFlag = false;
                PlantUtilities::ScanPlantLoopsForObject(state,
                                                        CoolingCoilName,
                                                        TypeOfCoilWaterCooling,
                                                        this->CoolCoilLoopNum,
                                                        this->CoolCoilLoopSide,
                                                        this->CoolCoilBranchNum,
                                                        this->CoolCoilCompNum,
                                                        state.dataUnitarySystems->initUnitarySystemsErrFlag,
                                                        _,
                                                        _,
                                                        _,
                                                        _,
                                                        _);
                if (state.dataUnitarySystems->initUnitarySystemsErrFlag) {
                    ShowFatalError(state, "InitUnitarySystem: Program terminated for previous conditions.");
                }
                this->MaxCoolCoilFluidFlow = WaterCoils::GetCoilMaxWaterFlowRate(
                    state, CoolingCoilType, CoolingCoilName, state.dataUnitarySystems->initUnitarySystemsErrorsFound);

                if (this->MaxCoolCoilFluidFlow > 0.0) {
                    Real64 rho = FluidProperties::GetDensityGlycol(state,
                                                                   state.dataPlnt->PlantLoop(this->CoolCoilLoopNum).FluidName,
                                                                   DataGlobalConstants::CWInitConvTemp,
                                                                   state.dataPlnt->PlantLoop(this->CoolCoilLoopNum).FluidIndex,
                                                                   routineName);
                    this->MaxCoolCoilFluidFlow *= rho;
                }
                // fill outlet node for coil
                this->CoolCoilFluidOutletNodeNum = state.dataPlnt->PlantLoop(this->CoolCoilLoopNum)
                                                       .LoopSide(this->CoolCoilLoopSide)
                                                       .Branch(this->CoolCoilBranchNum)
                                                       .Comp(this->CoolCoilCompNum)
                                                       .NodeNumOut;
            }
            int TypeOfCoilWaterHeating = 0;
            std::string HeatingCoilType = "";
            if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater ||
                this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {
                if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
                    TypeOfCoilWaterHeating = DataPlant::TypeOf_CoilWaterSimpleHeating;
                    HeatingCoilType = "Coil:Heating:Water";
                    WaterCoils::SetCoilDesFlow(state,
                                               DataHVACGlobals::cAllCoilTypes(this->m_HeatingCoilType_Num),
                                               this->m_HeatingCoilName,
                                               this->m_MaxHeatAirVolFlow,
                                               state.dataUnitarySystems->initUnitarySystemsErrorsFound);
                } else {
                    TypeOfCoilWaterHeating = DataPlant::TypeOf_CoilSteamAirHeating;
                    HeatingCoilType = "Coil:Heating:Steam";
                }
                state.dataUnitarySystems->initUnitarySystemsErrFlag = false;
                PlantUtilities::ScanPlantLoopsForObject(state,
                                                        this->m_HeatingCoilName,
                                                        TypeOfCoilWaterHeating,
                                                        this->HeatCoilLoopNum,
                                                        this->HeatCoilLoopSide,
                                                        this->HeatCoilBranchNum,
                                                        this->HeatCoilCompNum,
                                                        state.dataUnitarySystems->initUnitarySystemsErrFlag,
                                                        _,
                                                        _,
                                                        _,
                                                        _,
                                                        _);
                if (state.dataUnitarySystems->initUnitarySystemsErrFlag) {
                    ShowFatalError(state, "InitUnitarySystem: Program terminated for previous conditions.");
                }
                if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
                    this->MaxHeatCoilFluidFlow = WaterCoils::GetCoilMaxWaterFlowRate(
                        state, HeatingCoilType, this->m_HeatingCoilName, state.dataUnitarySystems->initUnitarySystemsErrorsFound);

                    if (this->MaxHeatCoilFluidFlow > 0.0) {
                        Real64 rho = FluidProperties::GetDensityGlycol(state,
                                                                       state.dataPlnt->PlantLoop(this->HeatCoilLoopNum).FluidName,
                                                                       DataGlobalConstants::HWInitConvTemp,
                                                                       state.dataPlnt->PlantLoop(this->HeatCoilLoopNum).FluidIndex,
                                                                       routineName);
                        this->MaxHeatCoilFluidFlow =
                            WaterCoils::GetCoilMaxWaterFlowRate(
                                state, HeatingCoilType, this->m_HeatingCoilName, state.dataUnitarySystems->initUnitarySystemsErrorsFound) *
                            rho;
                    }
                } else {
                    this->MaxHeatCoilFluidFlow =
                        SteamCoils::GetCoilMaxSteamFlowRate(state, this->m_HeatingCoilIndex, state.dataUnitarySystems->initUnitarySystemsErrorsFound);
                    if (this->MaxHeatCoilFluidFlow > 0.0) {
                        int SteamIndex = 0; // Function GetSatDensityRefrig will look up steam index if 0 is passed
                        Real64 TempSteamIn = 100.0;
                        Real64 SteamDensity = FluidProperties::GetSatDensityRefrig(state, fluidNameSteam, TempSteamIn, 1.0, SteamIndex, routineName);
                        this->MaxHeatCoilFluidFlow *= SteamDensity;
                    }
                }
                // fill outlet node for coil
                this->HeatCoilFluidOutletNodeNum = state.dataPlnt->PlantLoop(this->HeatCoilLoopNum)
                                                       .LoopSide(this->HeatCoilLoopSide)
                                                       .Branch(this->HeatCoilBranchNum)
                                                       .Comp(this->HeatCoilCompNum)
                                                       .NodeNumOut;
            }

            this->m_MyPlantScanFlag = false;

        } else if (this->m_MyPlantScanFlag && !state.dataGlobal->AnyPlantInModel) {
            this->m_MyPlantScanFlag = false;
        }

        // Scan Supplemental hot water and steam heating coil plant components for one time initializations
        if (this->m_MySuppCoilPlantScanFlag && allocated(state.dataPlnt->PlantLoop)) {
            if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
                state.dataUnitarySystems->initUnitarySystemsErrFlag = false;
                PlantUtilities::ScanPlantLoopsForObject(state,
                                                        this->m_SuppHeatCoilName,
                                                        DataPlant::TypeOf_CoilWaterSimpleHeating,
                                                        this->m_SuppCoilLoopNum,
                                                        this->m_SuppCoilLoopSide,
                                                        this->m_SuppCoilBranchNum,
                                                        this->m_SuppCoilCompNum,
                                                        state.dataUnitarySystems->initUnitarySystemsErrFlag,
                                                        _,
                                                        _,
                                                        _,
                                                        _,
                                                        _);
                WaterCoils::SetCoilDesFlow(state,
                                           DataHVACGlobals::cAllCoilTypes(this->m_SuppHeatCoilType_Num),
                                           this->m_SuppHeatCoilName,
                                           this->m_MaxHeatAirVolFlow,
                                           state.dataUnitarySystems->initUnitarySystemsErrorsFound);

                if (state.dataUnitarySystems->initUnitarySystemsErrFlag) {
                    ShowFatalError(state, "InitUnitarySystems: Program terminated for previous conditions.");
                }
                this->m_MaxSuppCoilFluidFlow = WaterCoils::GetCoilMaxWaterFlowRate(
                    state, "Coil:Heating:Water", this->m_SuppHeatCoilName, state.dataUnitarySystems->initUnitarySystemsErrorsFound);

                if (this->m_MaxSuppCoilFluidFlow > 0.0) {
                    Real64 rho = FluidProperties::GetDensityGlycol(state,
                                                                   state.dataPlnt->PlantLoop(this->m_SuppCoilLoopNum).FluidName,
                                                                   DataGlobalConstants::CWInitConvTemp,
                                                                   state.dataPlnt->PlantLoop(this->m_SuppCoilLoopNum).FluidIndex,
                                                                   routineName);
                    this->m_MaxSuppCoilFluidFlow =
                        WaterCoils::GetCoilMaxWaterFlowRate(
                            state, "Coil:Heating:Water", this->m_SuppHeatCoilName, state.dataUnitarySystems->initUnitarySystemsErrorsFound) *
                        rho;
                }
                // fill outlet node for coil
                this->m_SuppCoilFluidOutletNodeNum = state.dataPlnt->PlantLoop(this->m_SuppCoilLoopNum)
                                                         .LoopSide(this->m_SuppCoilLoopSide)
                                                         .Branch(this->m_SuppCoilBranchNum)
                                                         .Comp(this->m_SuppCoilCompNum)
                                                         .NodeNumOut;

            } else if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {
                state.dataUnitarySystems->initUnitarySystemsErrFlag = false;
                PlantUtilities::ScanPlantLoopsForObject(state,
                                                        this->m_SuppHeatCoilName,
                                                        DataPlant::TypeOf_CoilSteamAirHeating,
                                                        this->m_SuppCoilLoopNum,
                                                        this->m_SuppCoilLoopSide,
                                                        this->m_SuppCoilBranchNum,
                                                        this->m_SuppCoilCompNum,
                                                        state.dataUnitarySystems->initUnitarySystemsErrFlag,
                                                        _,
                                                        _,
                                                        _,
                                                        _,
                                                        _);
                if (state.dataUnitarySystems->initUnitarySystemsErrFlag) {
                    ShowFatalError(state, "InitUnitarySystems: Program terminated for previous conditions.");
                }
                this->m_MaxSuppCoilFluidFlow =
                    SteamCoils::GetCoilMaxSteamFlowRate(state, this->m_SuppHeatCoilIndex, state.dataUnitarySystems->initUnitarySystemsErrorsFound);
                if (this->m_MaxSuppCoilFluidFlow > 0.0) {
                    int SteamIndex = 0; // Function GetSatDensityRefrig will look up steam index if 0 is passed
                    Real64 TempSteamIn = 100.0;
                    Real64 SteamDensity = FluidProperties::GetSatDensityRefrig(state, fluidNameSteam, TempSteamIn, 1.0, SteamIndex, routineName);
                    this->m_MaxSuppCoilFluidFlow *= SteamDensity;
                }

                // fill outlet node for coil
                this->m_SuppCoilFluidOutletNodeNum = state.dataPlnt->PlantLoop(this->m_SuppCoilLoopNum)
                                                         .LoopSide(this->m_SuppCoilLoopSide)
                                                         .Branch(this->m_SuppCoilBranchNum)
                                                         .Comp(this->m_SuppCoilCompNum)
                                                         .NodeNumOut;
            }

            this->m_MySuppCoilPlantScanFlag = false;

        } else if (this->m_MySuppCoilPlantScanFlag && !state.dataGlobal->AnyPlantInModel) {
            this->m_MySuppCoilPlantScanFlag = false;
        }

        // do the Begin Environment initializations
        if (state.dataGlobal->BeginEnvrnFlag && this->m_MyEnvrnFlag) {
            this->m_DesignMassFlowRate = this->m_DesignFanVolFlowRate * state.dataEnvrn->StdRhoAir;
            this->MaxCoolAirMassFlow = this->m_MaxCoolAirVolFlow * state.dataEnvrn->StdRhoAir;
            this->MaxHeatAirMassFlow = this->m_MaxHeatAirVolFlow * state.dataEnvrn->StdRhoAir;
            this->MaxNoCoolHeatAirMassFlow = this->m_MaxNoCoolHeatAirVolFlow * state.dataEnvrn->StdRhoAir;
            this->m_WSHPRuntimeFrac = 0.0;
            this->m_CompPartLoadRatio = 0.0;
            this->m_CoolingCoilSensDemand = 0.0;
            this->m_CoolingCoilLatentDemand = 0.0;
            this->m_HeatingCoilSensDemand = 0.0;
            this->m_SenLoadLoss = 0.0;
            if (this->m_Humidistat) {
                this->m_LatLoadLoss = 0.0;
            }

            if ((this->m_HeatRecActive) && (!this->m_MyPlantScanFlag)) {

                Real64 rho = FluidProperties::GetDensityGlycol(state,
                                                               state.dataPlnt->PlantLoop(this->m_HRLoopNum).FluidName,
                                                               DataGlobalConstants::HWInitConvTemp,
                                                               state.dataPlnt->PlantLoop(this->m_HRLoopNum).FluidIndex,
                                                               routineName);

                this->m_DesignHeatRecMassFlowRate = this->m_DesignHRWaterVolumeFlow * rho;

                PlantUtilities::InitComponentNodes(state,
                                                   0.0,
                                                   this->m_DesignHeatRecMassFlowRate,
                                                   this->m_HeatRecoveryInletNodeNum,
                                                   this->m_HeatRecoveryOutletNodeNum,
                                                   this->m_HRLoopNum,
                                                   this->m_HRLoopSideNum,
                                                   this->m_HRBranchNum,
                                                   this->m_HRCompNum);
            }
            //   set fluid-side hardware limits
            if (this->CoolCoilFluidInletNode > 0) {

                if (this->MaxCoolCoilFluidFlow == DataSizing::AutoSize) {
                    // If water coil max water flow rate is DataSizing::AutoSized, simulate once in order to mine max flow rate
                    std::string CoolingCoilType = "";
                    if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater) {
                        CoolingCoilType = "Coil:Cooling:Water";
                    } else {
                        CoolingCoilType = "Coil:Cooling:Water:DetailedGeometry";
                    }
                    WaterCoils::SimulateWaterCoilComponents(state, this->m_CoolingCoilName, FirstHVACIteration, this->m_CoolingCoilIndex);
                    Real64 CoilMaxVolFlowRate = WaterCoils::GetCoilMaxWaterFlowRate(
                        state, CoolingCoilType, this->m_CoolingCoilName, state.dataUnitarySystems->initUnitarySystemsErrorsFound);
                    if (CoilMaxVolFlowRate != DataSizing::AutoSize) {
                        Real64 rho = FluidProperties::GetDensityGlycol(state,
                                                                       state.dataPlnt->PlantLoop(this->CoolCoilLoopNum).FluidName,
                                                                       DataGlobalConstants::CWInitConvTemp,
                                                                       state.dataPlnt->PlantLoop(this->CoolCoilLoopNum).FluidIndex,
                                                                       routineName);
                        this->MaxCoolCoilFluidFlow = CoilMaxVolFlowRate * rho;
                    }
                }

                PlantUtilities::InitComponentNodes(state,
                                                   0.0,
                                                   this->MaxCoolCoilFluidFlow,
                                                   this->CoolCoilFluidInletNode,
                                                   this->CoolCoilFluidOutletNodeNum,
                                                   this->CoolCoilLoopNum,
                                                   this->CoolCoilLoopSide,
                                                   this->CoolCoilBranchNum,
                                                   this->CoolCoilCompNum);
            }
            if (this->HeatCoilFluidInletNode > 0) {

                if (this->MaxHeatCoilFluidFlow == DataSizing::AutoSize) {
                    // IF water coil max water flow rate is DataSizing::AutoSized, simulate once in order to mine max flow rate
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
                        WaterCoils::SimulateWaterCoilComponents(state, this->m_HeatingCoilName, FirstHVACIteration, this->m_HeatingCoilIndex);
                        Real64 CoilMaxVolFlowRate = WaterCoils::GetCoilMaxWaterFlowRate(
                            state, "Coil:Heating:Water", this->m_HeatingCoilName, state.dataUnitarySystems->initUnitarySystemsErrorsFound);
                        if (CoilMaxVolFlowRate != DataSizing::AutoSize) {
                            Real64 rho = FluidProperties::GetDensityGlycol(state,
                                                                           state.dataPlnt->PlantLoop(this->HeatCoilLoopNum).FluidName,
                                                                           DataGlobalConstants::CWInitConvTemp,
                                                                           state.dataPlnt->PlantLoop(this->HeatCoilLoopNum).FluidIndex,
                                                                           routineName);
                            this->MaxHeatCoilFluidFlow = CoilMaxVolFlowRate * rho;
                        }
                    }
                    // If steam coil max steam flow rate is DataSizing::AutoSized, simulate once in order to mine max flow rate
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {
                        SteamCoils::SimulateSteamCoilComponents(
                            state,
                            this->m_HeatingCoilName,
                            FirstHVACIteration,
                            this->m_HeatingCoilIndex,
                            1.0,
                            state.dataUnitarySystems->initUnitarySystemsQActual); // QCoilReq, simulate any load > 0 to get max capacity
                        Real64 CoilMaxVolFlowRate = SteamCoils::GetCoilMaxSteamFlowRate(
                            state, this->m_HeatingCoilIndex, state.dataUnitarySystems->initUnitarySystemsErrorsFound);
                        if (CoilMaxVolFlowRate != DataSizing::AutoSize) {
                            int SteamIndex = 0; // Function GetSatDensityRefrig will look up steam index if 0 is passed
                            Real64 TempSteamIn = 100.0;
                            Real64 SteamDensity =
                                FluidProperties::GetSatDensityRefrig(state, fluidNameSteam, TempSteamIn, 1.0, SteamIndex, routineName);
                            this->MaxHeatCoilFluidFlow = CoilMaxVolFlowRate * SteamDensity;
                        }
                    }
                }

                PlantUtilities::InitComponentNodes(state,
                                                   0.0,
                                                   this->MaxHeatCoilFluidFlow,
                                                   this->HeatCoilFluidInletNode,
                                                   this->HeatCoilFluidOutletNodeNum,
                                                   this->HeatCoilLoopNum,
                                                   this->HeatCoilLoopSide,
                                                   this->HeatCoilBranchNum,
                                                   this->HeatCoilCompNum);
            }
            if (this->m_SuppCoilFluidInletNode > 0) {
                if (this->m_MaxSuppCoilFluidFlow == DataSizing::AutoSize) {
                    if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
                        // If water coil max water flow rate is DataSizing::AutoSized, simulate once in order to mine max flow rate
                        WaterCoils::SimulateWaterCoilComponents(state, this->m_SuppHeatCoilName, FirstHVACIteration, this->m_SuppHeatCoilIndex);
                        Real64 CoilMaxVolFlowRate = WaterCoils::GetCoilMaxWaterFlowRate(
                            state, "Coil:Heating:Water", this->m_SuppHeatCoilName, state.dataUnitarySystems->initUnitarySystemsErrorsFound);
                        if (CoilMaxVolFlowRate != DataSizing::AutoSize) {
                            Real64 rho = FluidProperties::GetDensityGlycol(state,
                                                                           state.dataPlnt->PlantLoop(this->m_SuppCoilLoopNum).FluidName,
                                                                           DataGlobalConstants::CWInitConvTemp,
                                                                           state.dataPlnt->PlantLoop(this->m_SuppCoilLoopNum).FluidIndex,
                                                                           routineName);
                            this->m_MaxSuppCoilFluidFlow = CoilMaxVolFlowRate * rho;
                        }
                    }
                    if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {
                        SteamCoils::SimulateSteamCoilComponents(
                            state,
                            this->m_SuppHeatCoilName,
                            FirstHVACIteration,
                            this->m_SuppHeatCoilIndex,
                            1.0,
                            state.dataUnitarySystems->initUnitarySystemsQActual); // QCoilReq, simulate any load > 0 to get max capacity
                        Real64 CoilMaxVolFlowRate = SteamCoils::GetCoilMaxSteamFlowRate(
                            state, this->m_SuppHeatCoilIndex, state.dataUnitarySystems->initUnitarySystemsErrorsFound);
                        if (CoilMaxVolFlowRate != DataSizing::AutoSize) {
                            int SteamIndex = 0; // Function GetSatDensityRefrig will look up steam index if 0 is passed
                            Real64 TempSteamIn = 100.0;
                            Real64 SteamDensity =
                                FluidProperties::GetSatDensityRefrig(state, fluidNameSteam, TempSteamIn, 1.0, SteamIndex, routineName);
                            this->m_MaxSuppCoilFluidFlow = CoilMaxVolFlowRate * SteamDensity;
                        }
                    }
                    PlantUtilities::InitComponentNodes(state,
                                                       0.0,
                                                       this->m_MaxSuppCoilFluidFlow,
                                                       this->m_SuppCoilFluidInletNode,
                                                       this->m_SuppCoilFluidOutletNodeNum,
                                                       this->m_SuppCoilLoopNum,
                                                       this->m_SuppCoilLoopSide,
                                                       this->m_SuppCoilBranchNum,
                                                       this->m_SuppCoilCompNum);
                }
            }
            this->m_MyEnvrnFlag = false;
        }

        if (!state.dataGlobal->BeginEnvrnFlag) {
            this->m_MyEnvrnFlag = true;
        }

        // Init maximum available Heat Recovery flow rate
        if ((this->m_HeatRecActive) && (!this->m_MyPlantScanFlag)) {
            Real64 mdotHR = 0.0;
            if (ScheduleManager::GetCurrentScheduleValue(state, this->m_SysAvailSchedPtr) > 0.0) {
                if (FirstHVACIteration) {
                    mdotHR = this->m_DesignHeatRecMassFlowRate;
                } else {
                    if (this->m_HeatRecoveryMassFlowRate > 0.0) {
                        mdotHR = this->m_HeatRecoveryMassFlowRate;
                    } else {
                        mdotHR = this->m_DesignHeatRecMassFlowRate;
                    }
                }
            } else {
                mdotHR = 0.0;
            }

            mdotHR = min(state.dataLoopNodes->Node(this->m_HeatRecoveryOutletNodeNum).MassFlowRateMaxAvail, mdotHR);
            state.dataLoopNodes->Node(this->m_HeatRecoveryInletNodeNum).MassFlowRate = mdotHR;
        }

        // get operating capacity of water and steam coil
        if (FirstHVACIteration || this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat) {
            if (FirstHVACIteration) {
                this->m_IterationCounter = 0;
                for (auto &val : this->m_IterationMode) {
                    val = 0;
                }

                // for DX systems, just read the inlet node flow rate and let air loop decide flow
                if (this->m_ControlType == ControlType::Setpoint && this->m_sysType == SysType::Unitary) {
                    if (ScheduleManager::GetCurrentScheduleValue(state, this->m_SysAvailSchedPtr) > 0.0) {
                        if (this->m_LastMode == state.dataUnitarySystems->CoolingMode) {
                            if (this->m_MultiOrVarSpeedCoolCoil) {
                                state.dataLoopNodes->Node(this->AirInNode).MassFlowRate = this->m_CoolMassFlowRate[this->m_NumOfSpeedCooling];
                            } else {
                                state.dataLoopNodes->Node(this->AirInNode).MassFlowRate = this->MaxCoolAirMassFlow;
                            }
                        } else if (this->m_LastMode == state.dataUnitarySystems->HeatingMode) {
                            if (this->m_MultiOrVarSpeedHeatCoil) {
                                state.dataLoopNodes->Node(this->AirInNode).MassFlowRate = this->m_HeatMassFlowRate[this->m_NumOfSpeedHeating];
                            } else {
                                state.dataLoopNodes->Node(this->AirInNode).MassFlowRate = this->MaxHeatAirMassFlow;
                            }
                        } else {
                            if (this->m_MultiOrVarSpeedCoolCoil) {
                                state.dataLoopNodes->Node(this->AirInNode).MassFlowRate = this->MaxNoCoolHeatAirMassFlow;
                            } else {
                                state.dataLoopNodes->Node(this->AirInNode).MassFlowRate = this->MaxNoCoolHeatAirMassFlow;
                            }
                        }
                    } else {
                        state.dataLoopNodes->Node(this->AirInNode).MassFlowRate = 0.0;
                    }
                }
                if (this->m_WaterHRPlantLoopModel) {
                    // initialize loop water temp on FirstHVACIteration
                    Real64 airInTemp = state.dataLoopNodes->Node(this->CoolCoilInletNodeNum).Temp;
                    Real64 companionAirInTemp = state.dataLoopNodes->Node(this->m_HRcoolCoilAirInNode).Temp;
                    Real64 oneHalfAirDeltaT = (companionAirInTemp - airInTemp) / 2.0;
                    Real64 initialLoopTemp = airInTemp + oneHalfAirDeltaT;
                    if (initialLoopTemp > this->m_minWaterLoopTempForHR && std::abs(oneHalfAirDeltaT) > this->m_minAirToWaterTempOffset) {
                        state.dataLoopNodes->Node(this->CoolCoilFluidInletNode).Temp = initialLoopTemp;
                        this->temperatureOffsetControlStatus = 1;
                    } else {
                        this->temperatureOffsetControlStatus = 0;
                    }
                }
            }
            if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
                this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) {

                //     set water-side mass flow rates
                Real64 mdot = this->MaxCoolCoilFluidFlow;
                PlantUtilities::SetComponentFlowRate(state,
                                                     mdot,
                                                     this->CoolCoilFluidInletNode,
                                                     this->CoolCoilFluidOutletNodeNum,
                                                     this->CoolCoilLoopNum,
                                                     this->CoolCoilLoopSide,
                                                     this->CoolCoilBranchNum,
                                                     this->CoolCoilCompNum);
                //     simulate water coil to find operating capacity
                WaterCoils::SimulateWaterCoilComponents(state,
                                                        this->m_CoolingCoilName,
                                                        FirstHVACIteration,
                                                        this->m_CoolingCoilIndex,
                                                        state.dataUnitarySystems->initUnitarySystemsQActual);
                this->m_DesignCoolingCapacity = state.dataUnitarySystems->initUnitarySystemsQActual;

            } // from IF(UnitarySystem(UnitarySysNum)%CoolingCoilType_Num == Coil_CoolingWater .OR. Coil_CoolingWaterDetailed
            if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {

                //     set water-side mass flow rates
                Real64 mdot = this->MaxHeatCoilFluidFlow;
                PlantUtilities::SetComponentFlowRate(state,
                                                     mdot,
                                                     this->HeatCoilFluidInletNode,
                                                     this->HeatCoilFluidOutletNodeNum,
                                                     this->HeatCoilLoopNum,
                                                     this->HeatCoilLoopSide,
                                                     this->HeatCoilBranchNum,
                                                     this->HeatCoilCompNum);
                //     simulate water coil to find operating capacity
                WaterCoils::SimulateWaterCoilComponents(state,
                                                        this->m_HeatingCoilName,
                                                        FirstHVACIteration,
                                                        this->m_HeatingCoilIndex,
                                                        state.dataUnitarySystems->initUnitarySystemsQActual);
                this->m_DesignHeatingCapacity = state.dataUnitarySystems->initUnitarySystemsQActual;

            } // from IF(UnitarySystem(UnitarySysNum)%HeatingCoilType_Num == Coil_HeatingWater) THEN

            if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {

                //     set water-side mass flow rates
                Real64 mdot = this->MaxHeatCoilFluidFlow;
                PlantUtilities::SetComponentFlowRate(state,
                                                     mdot,
                                                     this->HeatCoilFluidInletNode,
                                                     this->HeatCoilFluidOutletNodeNum,
                                                     this->HeatCoilLoopNum,
                                                     this->HeatCoilLoopSide,
                                                     this->HeatCoilBranchNum,
                                                     this->HeatCoilCompNum);
                //     simulate steam coil to find operating capacity
                SteamCoils::SimulateSteamCoilComponents(
                    state,
                    this->m_HeatingCoilName,
                    FirstHVACIteration,
                    this->m_HeatingCoilIndex,
                    1.0,
                    state.dataUnitarySystems->initUnitarySystemsQActual); // QCoilReq, simulate any load > 0 to get max capacity of steam coil
                this->m_DesignHeatingCapacity = SteamCoils::GetCoilCapacity(state,
                                                                            DataHVACGlobals::cAllCoilTypes(this->m_HeatingCoilType_Num),
                                                                            this->m_HeatingCoilName,
                                                                            state.dataUnitarySystems->initUnitarySystemsErrorsFound);

            } // from IF(UnitarySystem(UnitarySysNum)%HeatingCoilType_Num == Coil_HeatingSteam) THEN
            if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {

                //     set steam-side mass flow rates
                Real64 mdot = this->m_MaxSuppCoilFluidFlow;
                PlantUtilities::SetComponentFlowRate(state,
                                                     mdot,
                                                     this->m_SuppCoilFluidInletNode,
                                                     this->m_SuppCoilFluidOutletNodeNum,
                                                     this->m_SuppCoilLoopNum,
                                                     this->m_SuppCoilLoopSide,
                                                     this->m_SuppCoilBranchNum,
                                                     this->m_SuppCoilCompNum);
                //     simulate water coil to find operating capacity
                if (mdot > 0.0) { // not sure why this is here and not used for other coil types, wouldn't capacity be 0 if water flow = 0? Maybe a
                                  // speed issue where coil doesn't need to be simulation if mdot=0.
                    WaterCoils::SimulateWaterCoilComponents(state,
                                                            this->m_SuppHeatCoilName,
                                                            FirstHVACIteration,
                                                            this->m_SuppHeatCoilIndex,
                                                            state.dataUnitarySystems->initUnitarySystemsQActual);
                    this->m_DesignSuppHeatingCapacity = state.dataUnitarySystems->initUnitarySystemsQActual;
                } else {
                    this->m_DesignSuppHeatingCapacity = 0.0;
                }

            } // from IF(UnitarySystem(UnitarySysNum)%SuppHeatCoilType_Num == Coil_HeatingWater) THEN

            if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {

                //     set air-side and steam-side mass flow rates
                Real64 mdot = this->m_MaxSuppCoilFluidFlow;
                PlantUtilities::SetComponentFlowRate(state,
                                                     mdot,
                                                     this->m_SuppCoilFluidInletNode,
                                                     this->m_SuppCoilFluidOutletNodeNum,
                                                     this->m_SuppCoilLoopNum,
                                                     this->m_SuppCoilLoopSide,
                                                     this->m_SuppCoilBranchNum,
                                                     this->m_SuppCoilCompNum);
                //     simulate steam coil to find operating capacity
                SteamCoils::SimulateSteamCoilComponents(
                    state,
                    this->m_SuppHeatCoilName,
                    FirstHVACIteration,
                    this->m_SuppHeatCoilIndex,
                    1.0,
                    state.dataUnitarySystems->initUnitarySystemsQActual); // QCoilReq, simulate any load > 0 to get max capacity of steam coil
                this->m_DesignSuppHeatingCapacity = SteamCoils::GetCoilCapacity(
                    state, "Coil:Heating:Steam", this->m_SuppHeatCoilName, state.dataUnitarySystems->initUnitarySystemsErrorsFound);

            } // from IF(UnitarySystem(UnitarySysNum)%SuppHeatCoilType_Num == Coil_HeatingSteam) THEN
        }     // from IF( FirstHVACIteration ) THEN

        this->m_IterationCounter += 1;

        if (this->m_MySetPointCheckFlag) {
            if (!state.dataGlobal->SysSizingCalc && state.dataHVACGlobal->DoSetPointTest) {

                if (this->m_CoolCoilExists) {
                    int ControlNode = this->m_SystemCoolControlNodeNum;
                    if (ControlNode > 0) {
                        this->checkNodeSetPoint(state, AirLoopNum, ControlNode, state.dataUnitarySystems->CoolingCoil, OAUCoilOutTemp);
                    }
                }

                if (this->m_HeatCoilExists) {
                    int ControlNode = this->m_SystemHeatControlNodeNum;
                    if (ControlNode > 0) {
                        this->checkNodeSetPoint(state, AirLoopNum, ControlNode, state.dataUnitarySystems->HeatingCoil, OAUCoilOutTemp);
                    }
                }

                if (this->m_SuppCoilExists) {
                    int ControlNode = this->m_SuppHeatControlNodeNum;
                    if (ControlNode > 0) {
                        this->checkNodeSetPoint(state, AirLoopNum, ControlNode, state.dataUnitarySystems->SuppHeatCoil, OAUCoilOutTemp);
                    }
                }

                this->m_MySetPointCheckFlag = false;
            }
        }

        if (m_setFaultModelInput) {
            if ((!state.dataGlobal->WarmupFlag) && (!state.dataGlobal->DoingSizing) && (!state.dataGlobal->KickOffSimulation)) {

                // check FaultsManager if connection exists
                FaultsManager::SetFaultyCoilSATSensor(state, this->UnitType, this->Name, this->m_FaultyCoilSATFlag, this->m_FaultyCoilSATIndex);
                if (this->m_FaultyCoilSATFlag) {
                    if (this->m_ControlType != ControlType::Setpoint) {
                        ShowWarningError(state,
                                         state.dataFaultsMgr->FaultsCoilSATSensor(this->m_FaultyCoilSATIndex).FaultType + ": " +
                                             state.dataFaultsMgr->FaultsCoilSATSensor(this->m_FaultyCoilSATIndex).Name);
                        ShowContinueError(state, "For : " + this->UnitType + ": " + this->Name);
                        ShowContinueError(state,
                                          "The specified unitary system is not controlled on leaving air temperature. The coil SAT sensor "
                                          "fault model will not be applied.");
                        this->m_FaultyCoilSATFlag = false;
                    }
                }
                m_setFaultModelInput = false;
            }
        }

        // re-set water-side economizer flags each time step
        if (this->m_TemperatureOffsetControlActive && !this->m_WaterHRPlantLoopModel) {
            if (state.dataLoopNodes->Node(this->CoolCoilFluidInletNode).Temp >
                (state.dataLoopNodes->Node(this->AirInNode).Temp - this->m_minAirToWaterTempOffset)) {
                // disable coilsystem if entering fluid temp is > entering air temp minus user specified temp offset
                this->temperatureOffsetControlStatus = 0;
            } else {
                // enable coilsystem waterside economizer mode
                this->temperatureOffsetControlStatus = 1;
            }
        }
        if (AirLoopNum > 0) {
            if (this->m_sysType == SysType::CoilCoolingWater) {
                if (this->m_waterSideEconomizerFlag) { // CoilSystem:Cooling:Water has an input for economizer lockout
                    state.dataUnitarySystems->economizerFlag = state.dataAirLoop->AirLoopControlInfo(AirLoopNum).EconoActive;
                    if (state.dataUnitarySystems->economizerFlag) {
                        // user input economizer lockout will disable heat recovery loop AND water economizer
                        this->temperatureOffsetControlStatus = 0;
                    }
                } else {
                    state.dataUnitarySystems->economizerFlag = false;
                }
            } else {
                state.dataUnitarySystems->economizerFlag = state.dataAirLoop->AirLoopControlInfo(AirLoopNum).EconoActive;
            }
        }

        this->m_CoolingPartLoadFrac = 0.0;
        this->m_HeatingPartLoadFrac = 0.0;
        this->m_SuppHeatPartLoadFrac = 0.0;
        this->m_CoolingCycRatio = 0.0;
        this->m_CoolingSpeedRatio = 0.0;
        this->m_CoolingSpeedNum = 0;
        this->m_HeatingCycRatio = 0.0;
        this->m_HeatingSpeedRatio = 0.0;
        this->m_HeatingSpeedNum = 0;
        this->m_HeatingCoilSensDemand = 0.0;
        this->m_CoolingCoilSensDemand = 0.0;
        this->m_CoolingCoilLatentDemand = 0.0;
        this->m_DehumidInducedHeatingDemandRate = 0.0;
        this->CoolCoilWaterFlowRatio = 0.0;
        this->HeatCoilWaterFlowRatio = 0.0;

        // water/steam coil initialization
        if (this->CoolCoilFluidInletNode > 0) {
            Real64 mdot = 0.0;
            PlantUtilities::SetComponentFlowRate(state,
                                                 mdot,
                                                 this->CoolCoilFluidInletNode,
                                                 this->CoolCoilFluidOutletNodeNum,
                                                 this->CoolCoilLoopNum,
                                                 this->CoolCoilLoopSide,
                                                 this->CoolCoilBranchNum,
                                                 this->CoolCoilCompNum);
        }
        if (this->HeatCoilFluidInletNode > 0) {
            Real64 mdot = 0.0;
            PlantUtilities::SetComponentFlowRate(state,
                                                 mdot,
                                                 this->HeatCoilFluidInletNode,
                                                 this->HeatCoilFluidOutletNodeNum,
                                                 this->HeatCoilLoopNum,
                                                 this->HeatCoilLoopSide,
                                                 this->HeatCoilBranchNum,
                                                 this->HeatCoilCompNum);
        }
        if (this->m_SuppCoilFluidInletNode > 0) {
            Real64 mdot = 0.0;
            PlantUtilities::SetComponentFlowRate(state,
                                                 mdot,
                                                 this->m_SuppCoilFluidInletNode,
                                                 this->m_SuppCoilFluidOutletNodeNum,
                                                 this->m_SuppCoilLoopNum,
                                                 this->m_SuppCoilLoopSide,
                                                 this->m_SuppCoilBranchNum,
                                                 this->m_SuppCoilCompNum);
        }

        this->m_InitHeatPump = true;
        state.dataUnitarySystems->m_massFlow1 = 0.0;
        state.dataUnitarySystems->m_massFlow2 = 0.0;
        state.dataUnitarySystems->m_runTimeFraction1 = 0.0;
        state.dataUnitarySystems->m_runTimeFraction2 = 0.0;
    }

    void UnitarySys::checkNodeSetPoint(EnergyPlusData &state,
                                       int const AirLoopNum,       // number of the current air loop being simulated
                                       int const ControlNode,      // Node to test for set point
                                       int const CoilType,         // True if cooling coil, then test for HumRatMax set point
                                       Real64 const OAUCoilOutTemp // the coil inlet temperature of OutdoorAirUnit
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad
        //       DATE WRITTEN   March 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine checks for proper set point at control node.

        // METHODOLOGY EMPLOYED:
        // Uses the control node to test for set point.

        if (AirLoopNum == -1) {                                                   // Outdoor Air Unit
            state.dataLoopNodes->Node(ControlNode).TempSetPoint = OAUCoilOutTemp; // Set the coil outlet temperature
            if (this->m_ISHundredPercentDOASDXCoil) {
                this->frostControlSetPointLimit(state,
                                                this->m_DesiredOutletTemp,
                                                state.dataLoopNodes->Node(ControlNode).HumRatMax,
                                                state.dataEnvrn->OutBaroPress,
                                                this->DesignMinOutletTemp,
                                                1);
            }
        } else if (AirLoopNum != -1) { // Not an Outdoor air unit

            bool SetPointErrorFlag = false;
            if (state.dataLoopNodes->Node(ControlNode).TempSetPoint == DataLoopNode::SensedNodeFlagValue &&
                this->m_ControlType == ControlType::Setpoint) {
                if (!state.dataGlobal->AnyEnergyManagementSystemInModel) {
                    ShowSevereError(state, this->UnitType + ": Missing temperature setpoint for unitary system = " + this->Name);
                    ShowContinueError(state, "  use a Setpoint Manager to establish a setpoint at the coil control node.");
                    SetPointErrorFlag = true;
                } else {
                    EMSManager::CheckIfNodeSetPointManagedByEMS(
                        state, ControlNode, EMSManager::SPControlType::iTemperatureSetPoint, SetPointErrorFlag);
                    if (SetPointErrorFlag) {
                        ShowSevereError(state, this->UnitType + ": Missing temperature setpoint for unitary system = " + this->Name);
                        ShowContinueError(state, "  use a Setpoint Manager to establish a setpoint at the coil control node.");
                        ShowContinueError(state, "  or use an EMS actuator to establish a temperature setpoint at the coil control node.");
                    }
                }
            }
            if ((this->m_DehumidControlType_Num != DehumCtrlType::None) &&
                (state.dataLoopNodes->Node(ControlNode).HumRatMax == DataLoopNode::SensedNodeFlagValue) &&
                this->m_ControlType == ControlType::Setpoint && CoilType == state.dataUnitarySystems->CoolingCoil) {
                if (!state.dataGlobal->AnyEnergyManagementSystemInModel &&
                    state.dataLoopNodes->Node(this->CoolCoilOutletNodeNum).HumRatMax == DataLoopNode::SensedNodeFlagValue) {
                    ShowSevereError(state, this->UnitType + ": Missing humidity ratio setpoint (HUMRATMAX) for unitary system = " + this->Name);
                    ShowContinueError(state, "  use a Setpoint Manager to establish a setpoint at the coil control node.");
                    SetPointErrorFlag = true;
                } else if (state.dataGlobal->AnyEnergyManagementSystemInModel) {
                    EMSManager::CheckIfNodeSetPointManagedByEMS(
                        state, ControlNode, EMSManager::SPControlType::iHumidityRatioMaxSetPoint, SetPointErrorFlag);
                    if (SetPointErrorFlag) {
                        ShowSevereError(state,
                                        this->UnitType + ": Missing maximum humidity ratio setpoint (HUMRATMAX) for unitary system = " + this->Name);
                        ShowContinueError(state, "  use a Setpoint Manager to establish a setpoint at the coil control node.");
                        ShowContinueError(state, "  or use an EMS actuator to establish a maximum humidity ratio setpoint.");
                    }
                }
            }
        }
    }

    void UnitarySys::frostControlSetPointLimit(EnergyPlusData &state,
                                               Real64 &TempSetPoint,       // temperature setpoint of the sensor node
                                               Real64 &HumRatSetPoint,     // humidity ratio setpoint of the sensor node
                                               Real64 const BaroPress,     // baromtric pressure, Pa [N/m^2]
                                               Real64 const TfrostControl, // minimum temperature limit for forst control
                                               int const ControlMode       // temperature or humidity control mode
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Bereket Nigusse, FSEC
        //       DATE WRITTEN   January 2013

        // PURPOSE OF THIS SUBROUTINE:
        // Controls the forst formation condition based on user specified minimum DX coil outlet
        // air temperature. Resets the cooling setpoint based on the user specified limiting
        // temperature for frost control.
        // METHODOLOGY EMPLOYED:
        // Based on FrostControlSetPointLimit by Bereket Nigusse

        // Locals
        // SUBROUTINE PARAMETER DEFINITIONS:
        int const RunOnSensible(1); // identifier for temperature (sensible load) control
        int const RunOnLatent(2);   // identifier for humidity (latent load) control
        static constexpr std::string_view routineName("FrostControlSetPointLimit");

        Real64 AirMassFlow = state.dataLoopNodes->Node(this->CoolCoilInletNodeNum).MassFlowRate;
        if (ControlMode == RunOnSensible && AirMassFlow > DataHVACGlobals::SmallAirVolFlow &&
            TempSetPoint < state.dataLoopNodes->Node(this->CoolCoilInletNodeNum).Temp) {
            if (TempSetPoint < TfrostControl) {
                TempSetPoint = TfrostControl;
                this->m_FrostControlStatus = 1;
            }
        } else if (ControlMode == RunOnLatent && AirMassFlow > DataHVACGlobals::SmallAirVolFlow &&
                   HumRatSetPoint < state.dataLoopNodes->Node(this->CoolCoilInletNodeNum).HumRat) {
            Real64 HumRatioSat = Psychrometrics::PsyWFnTdpPb(state, TfrostControl, BaroPress, routineName);
            if (HumRatioSat > HumRatSetPoint) {
                HumRatSetPoint = HumRatioSat;
                this->m_FrostControlStatus = 2;
            }
        } else {
            this->m_FrostControlStatus = 0;
        }
    }

    void UnitarySys::getUnitarySystemInput(EnergyPlusData &state, std::string_view objectName, bool const ZoneEquipment, int const ZoneOAUnitNum)
    {

        bool errorsFound(false);
        UnitarySys::allocateUnitarySys(state);

        UnitarySys::getDXCoilSystemData(state, objectName, ZoneEquipment, ZoneOAUnitNum, errorsFound);
        UnitarySys::getCoilWaterSystemInputData(state, objectName, ZoneEquipment, ZoneOAUnitNum, errorsFound);
        UnitarySys::getUnitarySystemInputData(state, objectName, ZoneEquipment, ZoneOAUnitNum, errorsFound);

        // all systems should have been processed at this point? I think so, so don't need to if test this call?
        if (int(state.dataUnitarySystems->unitarySys.size()) == state.dataUnitarySystems->numUnitarySystems &&
            state.dataZoneEquip->ZoneEquipInputsFilled)
            setupAllOutputVars(state, state.dataUnitarySystems->numUnitarySystems);

        if (errorsFound) {
            ShowFatalError(state, "getUnitarySystemInputData: previous errors cause termination. Check inputs");
        }
    }

    void UnitarySys::sizeSystem(EnergyPlusData &state, bool const FirstHVACIteration, int const AirLoopNum)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine is for sizing unitary system components for which nominal cpacities
        // and flow rates have not been specified in the input. Coil sizing is preformed in the coil module.
        // Future modifications will size coils here and "push" this info to the specific coil.

        // METHODOLOGY EMPLOYED:
        // Obtains heating capacities and flow rates from the zone or system sizing arrays.
        // NOTE: In UNITARYSYSTEM:HEATPUMP:AIRTOAIR we are sizing the heating capacity to be
        // equal to the cooling capacity.  Thus the cooling and
        // and heating capacities of a DX heat pump system will be identical. In real life the ARI
        // heating and cooling capacities are close but not identical.

        // SUBROUTINE PARAMETER DEFINITIONS:
        static constexpr std::string_view RoutineName("SizeUnitarySystem");

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        int Iter;                  // iteration count
        int MSHPIndex;             // Index to design Specification object
        int BranchNum;             // Index to branch on air loop
        Real64 SystemFlow;         // AirloopHVAC flow rate [m3/s]
        Real64 BranchFanFlow;      // branch fan flow rate [m3/s]
        bool ErrFound;             // logical error flag
        std::string FanType;       // fan type
        std::string m_FanName;     // fan name
        std::string SystemType;    // type of air loop equipment
        std::string HXCoilName;    // cooling coil name in HXAssisted parent
        int ActualCoolCoilType;    // cooling coil type in HXAssisted parent
        int SaveCurDuctType;       // used during sizing to save the current duct type
        Real64 QActual;            // water coil output [W]
        Real64 capacityMultiplier; // used for ASHRAE model sizing

        Real64 TempSize;  // DataSizing::AutoSized value of input field
        int FieldNum = 2; // IDD numeric field number where input field description is found
        int SizingMethod; // Integer representation of sizing method (e.g., DataHVACGlobals::CoolingAirflowSizing, DataSizing::HeatingCapacitySizing,
                          // etc.)
        bool PrintFlag;   // TRUE when sizing information is reported in the eio file
        bool SizingDesRunThisSys;         // checks if sizing was performed
        int NumAirLoopZones(0);           // number of zone inlet nodes in an air loop
        int ZoneInSysIndex(0);            // number of zone inlet nodes counter in an airloop
        Real64 SumOfMassFlowRateMax(0.0); // the sum of zone inlet mass flow rates
        int ZoneInletNodeNum(0);          // zone inlet nodes node number
        Real64 minNoLoadFlow;             // used for sizing MaxNoCoolHeatVolFlow for SingleZoneVAV method
        //////////// hoisted into namespace ////////////////////////////////////////////////
        // static int NumUnitarySystemsSized( 0 ); // counter used to delete UnitarySystemNumericFields array after last system is sized
        ////////////////////////////////////////////////////////////////////////////////////
        // References
        DataSizing::ZoneEqSizingData *select_EqSizing(nullptr);

        auto &OASysEqSizing(state.dataSize->OASysEqSizing);

        // sweep specific data into one pointer to avoid if statements throughout this subroutine
        if (state.dataSize->CurOASysNum > 0) {
            select_EqSizing = &OASysEqSizing(state.dataSize->CurOASysNum);
        } else if (state.dataSize->CurSysNum > 0) {
            select_EqSizing = &state.dataSize->UnitarySysEqSizing(state.dataSize->CurSysNum);
            // this was reseting data set by OutdoorAirUnit when UnitarySystem is child
            // question is then who resets these (#8751 temporary fix)?
            // move here for now and only reset UnitarySystem flags, then find better way to do this
            select_EqSizing->AirFlow = false;
            select_EqSizing->CoolingAirFlow = false;
            select_EqSizing->HeatingAirFlow = false;
            select_EqSizing->AirVolFlow = 0.0;
            select_EqSizing->CoolingAirVolFlow = 0.0;
            select_EqSizing->HeatingAirVolFlow = 0.0;
            select_EqSizing->Capacity = false;
            select_EqSizing->CoolingCapacity = false;
            select_EqSizing->HeatingCapacity = false;
            select_EqSizing->DesCoolingLoad = 0.0;
            select_EqSizing->DesHeatingLoad = 0.0;
            select_EqSizing->OAVolFlow = 0.0; // UnitarySys doesn't have OA
        } else if (state.dataSize->CurZoneEqNum > 0) {
            select_EqSizing = &state.dataSize->ZoneEqSizing(state.dataSize->CurZoneEqNum);
            state.dataSize->ZoneEqUnitarySys = true;
        } else {
            assert(false);
        }
        // Object Data, points to specific array
        DataSizing::ZoneEqSizingData &EqSizing(*select_EqSizing);

        // coil sizing requires this information to check proper flow/capacity limits (#8761)
        if (this->m_ISHundredPercentDOASDXCoil) {
            state.dataHVACGlobal->DXCT = 2; // uses 100% DX coil flow limits
        } else {
            state.dataHVACGlobal->DXCT = 1; // uses normal DX coil flow limits
        }

        bool anyEMSRan;
        EMSManager::ManageEMS(state, EMSManager::EMSCallFrom::UnitarySystemSizing, anyEMSRan, ObjexxFCL::Optional_int_const()); // calling point
        bool HardSizeNoDesRun; // Indicator to a hard-sized field with no design sizing data

        // Initiate all reporting variables
        if (((state.dataSize->CurOASysNum > 0 || state.dataSize->CurSysNum > 0) && state.dataSize->SysSizingRunDone) ||
            (state.dataSize->CurZoneEqNum > 0 && state.dataSize->ZoneSizingRunDone)) {
            HardSizeNoDesRun = false;
        } else {
            HardSizeNoDesRun = true;
        }
        std::string SizingString;
        std::string CompName = this->Name;
        std::string CompType = this->UnitType;
        int CoolingSAFlowMethod = this->m_CoolingSAFMethod;
        int HeatingSAFlowMethod = this->m_HeatingSAFMethod;
        // can't reset this to 0 for systems where DX heating coil is in downstream unit and DX cooling coil is in upstream unit
        //        DXCoolCap = 0.0;
        state.dataSize->UnitaryHeatCap = 0.0;
        state.dataSize->SuppHeatCap = 0.0;
        bool TempCoolingLoad = state.dataUnitarySystems->CoolingLoad;
        bool TempHeatingLoad = state.dataUnitarySystems->HeatingLoad;
        state.dataUnitarySystems->CoolingLoad = true;
        state.dataUnitarySystems->HeatingLoad = false;
        state.dataSize->ZoneCoolingOnlyFan = false;
        state.dataSize->ZoneHeatingOnlyFan = false;
        bool IsAutoSize = false;
        Real64 SysCoolingFlow = 0.0;
        Real64 SysHeatingFlow = 0.0;
        Real64 CoolCapAtPeak = 0.0;
        Real64 HeatCapAtPeak = 0.0;

        if (state.dataSize->CurSysNum > 0 && state.dataSize->CurOASysNum == 0 && this->m_FanExists) {
            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                state.dataAirSystemsData->PrimaryAirSystems(state.dataSize->CurSysNum).supFanVecIndex = this->m_FanIndex;
                state.dataAirSystemsData->PrimaryAirSystems(state.dataSize->CurSysNum).supFanModelTypeEnum =
                    DataAirSystems::objectVectorOOFanSystemModel;
                state.dataSize->DataFanEnumType = DataAirSystems::objectVectorOOFanSystemModel;
                state.dataSize->DataFanIndex = this->m_FanIndex;
            } else {
                state.dataAirSystemsData->PrimaryAirSystems(state.dataSize->CurSysNum).SupFanNum = this->m_FanIndex;
                state.dataAirSystemsData->PrimaryAirSystems(state.dataSize->CurSysNum).supFanModelTypeEnum =
                    DataAirSystems::structArrayLegacyFanModels;
                state.dataSize->DataFanEnumType = DataAirSystems::structArrayLegacyFanModels;
                state.dataSize->DataFanIndex = this->m_FanIndex;
            }
            if (this->m_FanPlace == FanPlace::BlowThru) {
                state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).supFanLocation = DataAirSystems::fanPlacement::BlowThru;
            } else if (this->m_FanPlace == FanPlace::DrawThru) {
                state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).supFanLocation = DataAirSystems::fanPlacement::DrawThru;
            }
        } else if (state.dataSize->CurZoneEqNum > 0 && this->m_FanExists) {
            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                state.dataSize->DataFanEnumType = DataAirSystems::objectVectorOOFanSystemModel;
            } else {
                state.dataSize->DataFanEnumType = DataAirSystems::structArrayLegacyFanModels;
            }
            state.dataSize->DataFanIndex = this->m_FanIndex;
            if (this->m_FanPlace == FanPlace::BlowThru) {
                state.dataSize->DataFanPlacement = DataSizing::zoneFanPlacement::zoneBlowThru;
            } else if (this->m_FanPlace == FanPlace::DrawThru) {
                state.dataSize->DataFanPlacement = DataSizing::zoneFanPlacement::zoneDrawThru;
            }
        }

        if (this->ATMixerExists && state.dataSize->CurZoneEqNum > 0) { // set up ATMixer conditions for scalable capacity sizing
            SingleDuct::setATMixerSizingProperties(state, this->m_ATMixerIndex, this->ControlZoneNum, state.dataSize->CurZoneEqNum);
        }

        PrintFlag = false;
        // STEP 1: find the DataSizing::AutoSized cooling air flow rate and capacity
        if (this->m_CoolCoilExists) {
            if (!this->m_HeatCoilExists) state.dataSize->ZoneCoolingOnlyFan = true;
            TempSize = this->m_MaxCoolAirVolFlow;
            SaveCurDuctType = state.dataSize->CurDuctType;
            // might want to rethink this method. Tries to find the larger of cooling or heating capcity
            // however, if there is no heating coil the cooling air flow rate is used, not the main flow rate
            // this is fine if there are no other systems on the branch. CoilSystem does not do this (#8761).
            if (this->UnitType == "AirLoopHVAC:UnitarySystem") state.dataSize->CurDuctType = DataHVACGlobals::Cooling;
            bool errorsFound = false;
            if ((CoolingSAFlowMethod == state.dataUnitarySystems->SupplyAirFlowRate) || (CoolingSAFlowMethod == state.dataUnitarySystems->None)) {
                CoolingAirFlowSizer sizingCoolingAirFlow;
                // sizingCoolingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                sizingCoolingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                SysCoolingFlow = sizingCoolingAirFlow.size(state, TempSize, errorsFound);
            } else if (CoolingSAFlowMethod == state.dataUnitarySystems->FlowPerFloorArea) {
                CoolingAirFlowSizer sizingCoolingAirFlow;
                // sizingCoolingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                sizingCoolingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                SysCoolingFlow = sizingCoolingAirFlow.size(state, TempSize, errorsFound);
                this->m_MaxCoolAirVolFlow = DataSizing::AutoSize;
            } else if (CoolingSAFlowMethod == state.dataUnitarySystems->FractionOfAutoSizedCoolingValue) {
                TempSize = DataSizing::AutoSize;
                CoolingAirFlowSizer sizingCoolingAirFlow;
                // sizingCoolingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                sizingCoolingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                SysCoolingFlow = sizingCoolingAirFlow.size(state, TempSize, errorsFound);
                SysCoolingFlow *= this->m_MaxCoolAirVolFlow;
                this->m_MaxCoolAirVolFlow = DataSizing::AutoSize;
            } else if (CoolingSAFlowMethod == state.dataUnitarySystems->FlowPerCoolingCapacity) {
                if (this->m_DesignCoolingCapacity == DataSizing::AutoSize) {
                    TempSize = DataSizing::AutoSize;
                    CoolingAirFlowSizer sizingCoolingAirFlow;
                    // sizingCoolingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                    sizingCoolingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                    state.dataSize->DataFlowUsedForSizing = sizingCoolingAirFlow.size(state, TempSize, errorsFound);
                    SizingMethod = DataHVACGlobals::CoolingCapacitySizing;
                    TempSize = DataSizing::AutoSize;
                    if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling) {
                        state.dataSize->DataTotCapCurveIndex =
                            state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].getOpModeCapFTIndex(false);
                        state.dataSize->DataIsDXCoil = true;
                    } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed ||
                               this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling ||
                               this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed ||
                               this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) {
                        state.dataSize->DataTotCapCurveIndex = DXCoils::GetDXCoilCapFTCurveIndex(state, this->m_CoolingCoilIndex, ErrFound);
                        state.dataSize->DataIsDXCoil = true;
                    }
                    CoolingCapacitySizer sizerCoolingCapacity;
                    sizerCoolingCapacity.overrideSizingString(SizingString);
                    sizerCoolingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                    CoolCapAtPeak = sizerCoolingCapacity.size(state, TempSize, errorsFound);
                    SysCoolingFlow = CoolCapAtPeak * this->m_MaxCoolAirVolFlow;
                    state.dataSize->DataTotCapCurveIndex = 0;
                    EqSizing.CoolingCapacity = true;
                    EqSizing.DesCoolingLoad = CoolCapAtPeak;
                } else {
                    SysCoolingFlow = this->m_DesignCoolingCapacity * this->m_MaxCoolAirVolFlow;
                    CoolCapAtPeak = this->m_DesignCoolingCapacity;
                    state.dataSize->DXCoolCap = CoolCapAtPeak;
                }
                this->m_MaxCoolAirVolFlow = DataSizing::AutoSize;
            } else {
                // should never happen
                ShowSevereError(state, std::string{RoutineName} + ": " + CompType + " = " + std::string{CompName});
                ShowContinueError(state, "Illegal entry for Cooling Supply Air Flow Rate Method.");
            }

            state.dataSize->CurDuctType = SaveCurDuctType;
            EqSizing.CoolingAirFlow = true;
            EqSizing.CoolingAirVolFlow = SysCoolingFlow;

            // Cooling airflow should be known at this point. Now find DataSizing::AutoSized design cooling capacity.
            if (CoolingSAFlowMethod != state.dataUnitarySystems->FlowPerCoolingCapacity && this->m_DesignCoolingCapacity < 0.0) {
                SizingMethod = DataHVACGlobals::CoolingCapacitySizing;
                state.dataSize->DataFlowUsedForSizing = EqSizing.CoolingAirVolFlow;
                TempSize = DataSizing::AutoSize;
                if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling) {
                    state.dataSize->DataTotCapCurveIndex =
                        state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].getOpModeCapFTIndex(false);
                    state.dataSize->DataIsDXCoil = true;
                } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed ||
                           this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling ||
                           this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed ||
                           this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) {
                    state.dataSize->DataTotCapCurveIndex = DXCoils::GetDXCoilCapFTCurveIndex(state, this->m_CoolingCoilIndex, ErrFound);
                    state.dataSize->DataIsDXCoil = true;
                }
                if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {
                    state.dataSize->DataTotCapCurveIndex = VariableSpeedCoils::GetVSCoilCapFTCurveIndex(state, this->m_CoolingCoilIndex, ErrFound);
                    state.dataSize->DataIsDXCoil = true;
                }
                CoolingCapacitySizer sizerCoolingCapacity;
                sizerCoolingCapacity.overrideSizingString(SizingString);
                sizerCoolingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                CoolCapAtPeak = sizerCoolingCapacity.size(state, TempSize, errorsFound);
                state.dataSize->DXCoolCap = CoolCapAtPeak;
                // CoilSystem does not size the cooling coil (#8761)
                if (this->UnitType == "AirLoopHVAC:UnitarySystem") {
                    EqSizing.CoolingCapacity = true;
                    EqSizing.DesCoolingLoad = CoolCapAtPeak;
                }
            } else {
                if (!HardSizeNoDesRun &&
                    (CoolingSAFlowMethod != state.dataUnitarySystems->FlowPerCoolingCapacity && this->m_DesignCoolingCapacity > 0.0)) {
                    // corrected code for #8756
                    if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed ||
                        this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling ||
                        this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed ||
                        this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) {
                        state.dataSize->DataTotCapCurveIndex = DXCoils::GetDXCoilCapFTCurveIndex(state, this->m_CoolingCoilIndex, ErrFound);
                        state.dataSize->DataIsDXCoil = true;
                    }
                    if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {
                        state.dataSize->DataTotCapCurveIndex =
                            VariableSpeedCoils::GetVSCoilCapFTCurveIndex(state, this->m_CoolingCoilIndex, ErrFound);
                        state.dataSize->DataIsDXCoil = true;
                    }
                    SizingMethod = DataHVACGlobals::CoolingCapacitySizing;
                    state.dataSize->DataFlowUsedForSizing = EqSizing.CoolingAirVolFlow;
                    TempSize = DataSizing::AutoSize;
                    CoolingCapacitySizer sizerCoolingCapacity;
                    sizerCoolingCapacity.overrideSizingString(SizingString);
                    sizerCoolingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                    CoolCapAtPeak = sizerCoolingCapacity.size(state, TempSize, errorsFound);
                    state.dataSize->DXCoolCap = CoolCapAtPeak;
                    EqSizing.CoolingCapacity = true;
                    EqSizing.DesCoolingLoad = CoolCapAtPeak;
                } else {
                    CoolCapAtPeak = this->m_DesignCoolingCapacity;
                }
            }
            state.dataSize->DataIsDXCoil = false;
            state.dataSize->DataTotCapCurveIndex = 0;
            state.dataSize->DataFlowUsedForSizing = 0.0;
        }

        // STEP 2: find the DataSizing::AutoSized heating air flow rate and capacity
        if (this->m_HeatCoilExists) {
            if (!this->m_CoolCoilExists) state.dataSize->ZoneHeatingOnlyFan = true;
            FieldNum = 7; // N7 , \field Heating Supply Air Flow Rate
            SizingMethod = DataHVACGlobals::HeatingAirflowSizing;
            // SizingString = UnitarySystemNumericFields(UnitarySysNum).FieldNames(FieldNum) + " [m3/s]";
            TempSize = this->m_MaxHeatAirVolFlow;
            SaveCurDuctType = state.dataSize->CurDuctType;
            state.dataSize->CurDuctType = DataHVACGlobals::Heating;
            if ((HeatingSAFlowMethod == state.dataUnitarySystems->SupplyAirFlowRate) || (HeatingSAFlowMethod == state.dataUnitarySystems->None)) {
                bool errorsFound = false;
                HeatingAirFlowSizer sizingHeatingAirFlow;
                sizingHeatingAirFlow.overrideSizingString(SizingString);
                // sizingHeatingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                sizingHeatingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                SysHeatingFlow = sizingHeatingAirFlow.size(state, TempSize, errorsFound);
            } else if (HeatingSAFlowMethod == state.dataUnitarySystems->FlowPerFloorArea) {
                bool errorsFound = false;
                HeatingAirFlowSizer sizingHeatingAirFlow;
                sizingHeatingAirFlow.overrideSizingString(SizingString);
                // sizingHeatingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                sizingHeatingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                SysHeatingFlow = sizingHeatingAirFlow.size(state, TempSize, errorsFound);
                this->m_MaxHeatAirVolFlow = DataSizing::AutoSize;
            } else if (HeatingSAFlowMethod == state.dataUnitarySystems->FractionOfAutoSizedHeatingValue) {
                TempSize = DataSizing::AutoSize;
                bool errorsFound = false;
                HeatingAirFlowSizer sizingHeatingAirFlow;
                sizingHeatingAirFlow.overrideSizingString(SizingString);
                // sizingHeatingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                sizingHeatingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                SysHeatingFlow = sizingHeatingAirFlow.size(state, TempSize, errorsFound);
                SysHeatingFlow *= this->m_MaxHeatAirVolFlow;
                this->m_MaxHeatAirVolFlow = DataSizing::AutoSize;
            } else if (HeatingSAFlowMethod == state.dataUnitarySystems->FlowPerHeatingCapacity) {
                TempSize = DataSizing::AutoSize;
                bool errorsFound = false;
                HeatingAirFlowSizer sizingHeatingAirFlow;
                sizingHeatingAirFlow.overrideSizingString(SizingString);
                // sizingHeatingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
                sizingHeatingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                state.dataSize->DataFlowUsedForSizing = sizingHeatingAirFlow.size(state, TempSize, errorsFound);
                SizingMethod = DataHVACGlobals::HeatingCapacitySizing;
                TempSize = DataSizing::AutoSize;
                state.dataSize->DataFracOfAutosizedCoolingCapacity = 1.0;
                state.dataSize->DataHeatSizeRatio = this->m_HeatingSizingRatio;
                if (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                    this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {
                    state.dataSize->DataTotCapCurveIndex = DXCoils::GetDXCoilCapFTCurveIndex(state, this->m_HeatingCoilIndex, ErrFound);
                    state.dataSize->DataIsDXCoil = true;
                }
                if (state.dataSize->CurSysNum > 0)
                    state.dataAirLoop->AirLoopControlInfo(AirLoopNum).UnitarySysSimulating =
                        false; // set to false to allow calculation of actual heating capacity
                HeatingCapacitySizer sizerHeatingCapacity;
                sizerHeatingCapacity.overrideSizingString(SizingString);
                sizerHeatingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                HeatCapAtPeak = sizerHeatingCapacity.size(state, TempSize, errorsFound);
                if (state.dataSize->CurSysNum > 0) state.dataAirLoop->AirLoopControlInfo(AirLoopNum).UnitarySysSimulating = true;
                SysHeatingFlow = HeatCapAtPeak * this->m_MaxHeatAirVolFlow;
                this->m_MaxHeatAirVolFlow = DataSizing::AutoSize;
                EqSizing.HeatingCapacity = true;
                EqSizing.DesHeatingLoad = HeatCapAtPeak;
            } else {
                // should never happen
                ShowSevereError(state, std::string{RoutineName} + ": " + CompType + " = " + std::string{CompName});
                ShowContinueError(state, "Illegal entry for Heating Supply Air Flow Rate Method.");
            }

            state.dataSize->CurDuctType = SaveCurDuctType;
            EqSizing.HeatingAirFlow = true;
            EqSizing.HeatingAirVolFlow = SysHeatingFlow;

            // Heating airflow should be known at this point. Now find DataSizing::AutoSized design heating capacity.
            if (HeatingSAFlowMethod != state.dataUnitarySystems->FlowPerHeatingCapacity && this->m_DesignHeatingCapacity == DataSizing::AutoSize) {
                SizingMethod = DataHVACGlobals::HeatingCapacitySizing;
                state.dataSize->DataFlowUsedForSizing = EqSizing.HeatingAirVolFlow;
                TempSize = DataSizing::AutoSize;
                state.dataSize->DataHeatSizeRatio = this->m_HeatingSizingRatio;
                if (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical ||
                    this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating) {
                    state.dataSize->DataTotCapCurveIndex = DXCoils::GetDXCoilCapFTCurveIndex(state, this->m_HeatingCoilIndex, ErrFound);
                    state.dataSize->DataIsDXCoil = true;
                }
                if (state.dataSize->CurSysNum > 0)
                    state.dataAirLoop->AirLoopControlInfo(AirLoopNum).UnitarySysSimulating =
                        false; // set to false to allow calculation of actual heating capacity
                bool errorsFound = false;
                HeatingCapacitySizer sizerHeatingCapacity;
                sizerHeatingCapacity.overrideSizingString(SizingString);
                sizerHeatingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                HeatCapAtPeak = sizerHeatingCapacity.size(state, TempSize, errorsFound);
                if (state.dataSize->CurSysNum > 0) state.dataAirLoop->AirLoopControlInfo(AirLoopNum).UnitarySysSimulating = true;
                EqSizing.HeatingCapacity = true;
                EqSizing.DesHeatingLoad = HeatCapAtPeak;
            } else {
                if (!HardSizeNoDesRun && (HeatingSAFlowMethod != state.dataUnitarySystems->FlowPerHeatingCapacity &&
                                          this->m_DesignHeatingCapacity != DataSizing::AutoSize)) {
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating) {
                        SizingMethod = DataHVACGlobals::HeatingCapacitySizing;
                        state.dataSize->DataFlowUsedForSizing = EqSizing.HeatingAirVolFlow;
                        TempSize = DataSizing::AutoSize;
                        state.dataSize->DataHeatSizeRatio = this->m_HeatingSizingRatio;
                        state.dataSize->DataTotCapCurveIndex = DXCoils::GetDXCoilCapFTCurveIndex(state, this->m_HeatingCoilIndex, ErrFound);
                        state.dataSize->DataIsDXCoil = true;
                        if (state.dataSize->CurSysNum > 0)
                            state.dataAirLoop->AirLoopControlInfo(AirLoopNum).UnitarySysSimulating =
                                false; // set to false to allow calculation of actual heating capacity
                        bool errorsFound = false;
                        HeatingCapacitySizer sizerHeatingCapacity;
                        sizerHeatingCapacity.overrideSizingString(SizingString);
                        sizerHeatingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                        HeatCapAtPeak = sizerHeatingCapacity.size(state, TempSize, errorsFound);
                        if (state.dataSize->CurSysNum > 0) state.dataAirLoop->AirLoopControlInfo(AirLoopNum).UnitarySysSimulating = true;
                        EqSizing.HeatingCapacity = true;
                        EqSizing.DesHeatingLoad = HeatCapAtPeak;
                    }
                } else {
                    HeatCapAtPeak = this->m_DesignHeatingCapacity;
                }
            }
            //            if ( ! UnitarySystem( UnitarySysNum ).CoolCoilExists )DXCoolCap = HeatCapAtPeak;
            state.dataSize->DataIsDXCoil = false;
            state.dataSize->DataTotCapCurveIndex = 0;
            state.dataSize->DataFlowUsedForSizing = 0.0;
        }

        // STEP 3: use the greater of cooling and heating air flow rates for system flow
        // previous version of E+ used maximum flow rate for unitary systems. Keep this methodology for now.
        // Delete next 2 lines and uncomment 2 lines inside next if (HeatPump) statement to allow non-heat pump systems to operate at different flow
        // rates (might require additional change to if block logic).
        EqSizing.CoolingAirVolFlow = max(EqSizing.CoolingAirVolFlow, EqSizing.HeatingAirVolFlow);
        EqSizing.HeatingAirVolFlow = EqSizing.CoolingAirVolFlow;

        // STEP 4: set heat pump coil capacities equal to greater of cooling or heating capacity
        if (this->m_HeatPump) { // if a heat pump, use maximum values and set main air flow and capacity variables
            EqSizing.AirFlow = true;
            EqSizing.AirVolFlow = max(EqSizing.CoolingAirVolFlow, EqSizing.HeatingAirVolFlow);
            //            EqSizing.CoolingAirVolFlow = EqSizing.AirVolFlow;
            //            EqSizing.HeatingAirVolFlow = EqSizing.AirVolFlow;
            EqSizing.Capacity = true;
            EqSizing.DesCoolingLoad = max(EqSizing.DesCoolingLoad, EqSizing.DesHeatingLoad);
            EqSizing.DesHeatingLoad = EqSizing.DesCoolingLoad;
            state.dataSize->DXCoolCap = EqSizing.DesCoolingLoad;
        } else if (!this->m_CoolCoilExists && state.dataSize->CurZoneEqNum > 0) {
            state.dataSize->DXCoolCap = EqSizing.DesHeatingLoad;
        }

        // TODO: decide which parent objects will report
        if (this->m_OKToPrintSizing && this->m_sysType == SysType::Unitary) PrintFlag = true;
        // STEP 5: report system parameters (e.g., air flow rates, capacities, etc.)
        if (this->m_FanExists) {

            EqSizing.SystemAirFlow = true;
            EqSizing.AirVolFlow = max(EqSizing.CoolingAirVolFlow, EqSizing.HeatingAirVolFlow);
            if (this->m_DesignFanVolFlowRate <= 0.0) { // attempt to catch any missed logic in GetUnitarySystem
                this->m_DesignFanVolFlowRate = DataSizing::AutoSize;
            }
            state.dataSize->DataEMSOverrideON = this->m_DesignFanVolFlowRateEMSOverrideOn;
            state.dataSize->DataEMSOverride = this->m_DesignFanVolFlowRateEMSOverrideValue;

            bool errorsFound = false;
            SystemAirFlowSizer sizerSystemAirFlow;
            std::string sizingString = "Supply Air Flow Rate [m3/s]";
            sizerSystemAirFlow.overrideSizingString(sizingString);
            sizerSystemAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
            this->m_DesignFanVolFlowRate = sizerSystemAirFlow.size(state, this->m_DesignFanVolFlowRate, errorsFound);

            state.dataSize->DataEMSOverrideON = false;
            EqSizing.SystemAirFlow = false;
        }

        // not sure what to do if UnitarySystem has only 1 coil type and flow needs to occur when present coil is off
        // how does constant fan operating mode pertain here?
        if (this->m_HeatCoilExists && !this->m_CoolCoilExists) {
            if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize) this->m_MaxCoolAirVolFlow = EqSizing.HeatingAirVolFlow;
        } else if (this->m_CoolCoilExists && !this->m_HeatCoilExists) {
            if (this->m_MaxHeatAirVolFlow == DataSizing::AutoSize) this->m_MaxHeatAirVolFlow = EqSizing.CoolingAirVolFlow;
        }

        if (this->m_HeatCoilExists) {

            SizingMethod = DataHVACGlobals::HeatingAirflowSizing;
            if (this->m_MaxHeatAirVolFlow <= 0.0) { // attempt to catch any missed logic in GetUnitarySystem
                this->m_MaxHeatAirVolFlow = DataSizing::AutoSize;
            }
            FieldNum = 7; // N7 , \field Heating Supply Air Flow Rate
            state.dataSize->DataEMSOverrideON = this->m_MaxHeatAirVolFlowEMSOverrideOn;
            state.dataSize->DataEMSOverride = this->m_MaxHeatAirVolFlowEMSOverrideValue;
            TempSize = this->m_MaxHeatAirVolFlow;
            // SizingString = UnitarySystemNumericFields(UnitarySysNum).FieldNames(FieldNum) + " [m3/s]";
            SizingString = "Heating Supply Air Flow Rate [m3/s]";
            bool errorsFound = false;
            HeatingAirFlowSizer sizingHeatingAirFlow;
            sizingHeatingAirFlow.overrideSizingString(SizingString);
            // sizingHeatingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
            sizingHeatingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
            this->m_MaxHeatAirVolFlow = sizingHeatingAirFlow.size(state, TempSize, errorsFound);
            state.dataSize->DataEMSOverrideON = false;
            state.dataSize->DataConstantUsedForSizing = 0.0;
        }

        if (this->m_CoolCoilExists) {

            if (this->m_MaxCoolAirVolFlow <= 0.0) { // attempt to catch any missed logic in GetUnitarySystem
                this->m_MaxCoolAirVolFlow = DataSizing::AutoSize;
            }
            state.dataSize->DataEMSOverrideON = this->m_MaxCoolAirVolFlowEMSOverrideOn;
            state.dataSize->DataEMSOverride = this->m_MaxCoolAirVolFlowEMSOverrideValue;
            TempSize = this->m_MaxCoolAirVolFlow;
            bool errorsFound = false;
            CoolingAirFlowSizer sizingCoolingAirFlow;
            std::string stringOverride = "Cooling Supply Air Flow Rate [m3/s]";
            if (state.dataGlobal->isEpJSON) stringOverride = "cooling_supply_air_flow_rate [m3/s]";
            sizingCoolingAirFlow.overrideSizingString(stringOverride);
            // sizingCoolingAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
            sizingCoolingAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
            this->m_MaxCoolAirVolFlow = sizingCoolingAirFlow.size(state, TempSize, errorsFound);
            state.dataSize->DataEMSOverrideON = false;
            state.dataSize->DataConstantUsedForSizing = 0.0;
        }

        // If not set, set DesignFanVolFlowRate as greater of cooling and heating to make sure this value > 0.
        // If fan is hard-sized, use that value, otherwise the fan will size to DesignFanVolFlowRate
        if (this->m_DesignFanVolFlowRate <= 0.0) {
            this->m_DesignFanVolFlowRate = max(this->m_MaxCoolAirVolFlow, this->m_MaxHeatAirVolFlow);
            if (this->m_ActualFanVolFlowRate > 0.0) this->m_DesignFanVolFlowRate = this->m_ActualFanVolFlowRate;
            if (this->m_DesignFanVolFlowRate <= 0.0) {
                ShowWarningError(state, std::string{RoutineName} + ": " + CompType + " = " + std::string{CompName});
                ShowFatalError(state, "Unable to determine fan air flow rate.");
            }
        }
        if (!this->m_FanExists) this->m_ActualFanVolFlowRate = this->m_DesignFanVolFlowRate;

        if (this->m_CoolCoilExists || this->m_HeatCoilExists || this->m_SuppCoilExists) {

            MSHPIndex = this->m_DesignSpecMSHPIndex;
            // set no load air flow ratio local var
            Real64 NoLoadCoolingAirFlowRateRatio = 1.0;
            Real64 NoLoadHeatingAirFlowRateRatio = 1.0;
            if (MSHPIndex > -1) {
                if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[0] == DataSizing::AutoSize) {
                    NoLoadCoolingAirFlowRateRatio =
                        min(this->m_NoLoadAirFlowRateRatio, 1.0 / double(state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling));
                } else {
                    NoLoadCoolingAirFlowRateRatio =
                        min(this->m_NoLoadAirFlowRateRatio, state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[0]);
                }
                if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[0] == DataSizing::AutoSize) {
                    NoLoadHeatingAirFlowRateRatio =
                        min(this->m_NoLoadAirFlowRateRatio, 1.0 / double(state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedHeating));
                } else {
                    NoLoadHeatingAirFlowRateRatio =
                        min(this->m_NoLoadAirFlowRateRatio, state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[0]);
                }
                this->m_NoLoadAirFlowRateRatio = min(NoLoadCoolingAirFlowRateRatio, NoLoadHeatingAirFlowRateRatio);
            } else {
                if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed ||
                    this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) {
                    if (this->m_CoolCoilExists && this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {
                        Real64 MaxSpeedFlowRate =
                            state.dataVariableSpeedCoils->VarSpeedCoil(this->m_CoolingCoilIndex)
                                .MSRatedAirVolFlowRate(state.dataVariableSpeedCoils->VarSpeedCoil(this->m_CoolingCoilIndex).NumOfSpeeds);
                        if (MaxSpeedFlowRate > 0.0) {
                            NoLoadCoolingAirFlowRateRatio =
                                state.dataVariableSpeedCoils->VarSpeedCoil(this->m_CoolingCoilIndex).MSRatedAirVolFlowRate(1) / MaxSpeedFlowRate;
                        }
                    }
                    if (this->m_HeatCoilExists && this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) {
                        Real64 MaxSpeedFlowRate =
                            state.dataVariableSpeedCoils->VarSpeedCoil(this->m_HeatingCoilIndex)
                                .MSRatedAirVolFlowRate(state.dataVariableSpeedCoils->VarSpeedCoil(this->m_HeatingCoilIndex).NumOfSpeeds);
                        if (MaxSpeedFlowRate > 0.0) {
                            NoLoadHeatingAirFlowRateRatio =
                                state.dataVariableSpeedCoils->VarSpeedCoil(this->m_HeatingCoilIndex).MSRatedAirVolFlowRate(1) / MaxSpeedFlowRate;
                        }
                    }
                    this->m_NoLoadAirFlowRateRatio = min(NoLoadCoolingAirFlowRateRatio, NoLoadHeatingAirFlowRateRatio);
                }
            }
            if (this->m_NoCoolHeatSAFMethod <= state.dataUnitarySystems->SupplyAirFlowRate && this->m_ControlType == ControlType::CCMASHRAE) {
                if (this->m_MaxNoCoolHeatAirVolFlow == DataSizing::AutoSize) {
                    state.dataSize->DataConstantUsedForSizing = max(this->m_MaxCoolAirVolFlow, this->m_MaxHeatAirVolFlow);
                    if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {
                        minNoLoadFlow = 0.6667; // TODO: Should this have a Coil:Cooling:DX block?
                    } else {
                        if (this->m_NoLoadAirFlowRateRatio < 1.0) {
                            minNoLoadFlow = this->m_NoLoadAirFlowRateRatio;
                        } else {
                            minNoLoadFlow = 0.5;
                        }
                    }
                    if (this->m_MaxCoolAirVolFlow >= this->m_MaxHeatAirVolFlow) {
                        state.dataSize->DataFractionUsedForSizing =
                            min(minNoLoadFlow, (this->m_MaxHeatAirVolFlow / this->m_MaxCoolAirVolFlow) - 0.01);
                    } else {
                        state.dataSize->DataFractionUsedForSizing =
                            min(minNoLoadFlow, (this->m_MaxCoolAirVolFlow / this->m_MaxHeatAirVolFlow) - 0.01);
                    }
                } else {
                    state.dataSize->DataConstantUsedForSizing = this->m_MaxNoCoolHeatAirVolFlow;
                    state.dataSize->DataFractionUsedForSizing = 1.0;
                }
            } else if (this->m_NoCoolHeatSAFMethod == state.dataUnitarySystems->FractionOfAutoSizedCoolingValue) {
                this->m_MaxNoCoolHeatAirVolFlow *= EqSizing.CoolingAirVolFlow;
                state.dataSize->DataConstantUsedForSizing = this->m_MaxNoCoolHeatAirVolFlow;
                state.dataSize->DataFractionUsedForSizing = 1.0;
                this->m_MaxNoCoolHeatAirVolFlow = DataSizing::AutoSize;
            } else if (this->m_NoCoolHeatSAFMethod == state.dataUnitarySystems->FractionOfAutoSizedHeatingValue) {
                this->m_MaxNoCoolHeatAirVolFlow *= EqSizing.HeatingAirVolFlow;
                state.dataSize->DataConstantUsedForSizing = this->m_MaxNoCoolHeatAirVolFlow;
                state.dataSize->DataFractionUsedForSizing = 1.0;
                this->m_MaxNoCoolHeatAirVolFlow = DataSizing::AutoSize;
            } else if (this->m_NoCoolHeatSAFMethod == state.dataUnitarySystems->FlowPerCoolingCapacity) {
                if (EqSizing.DesCoolingLoad <= 0.0) {
                    // water coils not sizing yet
                    if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
                        this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) {
                        WaterCoils::SimulateWaterCoilComponents(
                            state, this->m_CoolingCoilName, FirstHVACIteration, this->m_CoolingCoilIndex, QActual, this->m_FanOpMode, 1.0);
                        EqSizing.DesCoolingLoad = WaterCoils::GetWaterCoilCapacity(
                            state,
                            UtilityRoutines::MakeUPPERCase(DataHVACGlobals::cAllCoilTypes(this->m_CoolingCoilType_Num)),
                            this->m_CoolingCoilName,
                            ErrFound);
                    }
                }
                this->m_MaxNoCoolHeatAirVolFlow *= EqSizing.DesCoolingLoad;
                state.dataSize->DataConstantUsedForSizing = this->m_MaxNoCoolHeatAirVolFlow;
                state.dataSize->DataFractionUsedForSizing = 1.0;
                this->m_MaxNoCoolHeatAirVolFlow = DataSizing::AutoSize;
            } else if (this->m_NoCoolHeatSAFMethod == state.dataUnitarySystems->FlowPerHeatingCapacity) {
                if (EqSizing.DesHeatingLoad <= 0.0) {
                    // water coil not sizing yet
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
                        WaterCoils::SimulateWaterCoilComponents(
                            state, this->m_HeatingCoilName, FirstHVACIteration, this->m_HeatingCoilIndex, QActual, this->m_FanOpMode, 1.0);
                        EqSizing.DesHeatingLoad = WaterCoils::GetWaterCoilCapacity(
                            state,
                            UtilityRoutines::MakeUPPERCase(DataHVACGlobals::cAllCoilTypes(this->m_HeatingCoilType_Num)),
                            this->m_HeatingCoilName,
                            ErrFound);
                    }
                }
                this->m_MaxNoCoolHeatAirVolFlow *= EqSizing.DesHeatingLoad;
                state.dataSize->DataConstantUsedForSizing = this->m_MaxNoCoolHeatAirVolFlow;
                state.dataSize->DataFractionUsedForSizing = 1.0;
                this->m_MaxNoCoolHeatAirVolFlow = DataSizing::AutoSize;
            } else {
                state.dataSize->DataFractionUsedForSizing = this->m_NoLoadAirFlowRateRatio;
            }

            FieldNum = 11; // N11 , \field No Load Supply Air Flow Rate
            state.dataSize->DataEMSOverrideON = this->m_MaxNoCoolHeatAirVolFlowEMSOverrideOn;
            state.dataSize->DataEMSOverride = this->m_MaxNoCoolHeatAirVolFlowEMSOverrideValue;
            TempSize = this->m_MaxNoCoolHeatAirVolFlow;
            // SizingString = UnitarySystemNumericFields(UnitarySysNum).FieldNames(FieldNum) + " [m3/s]";
            SizingString = "No Load Supply Air Flow Rate [m3/s]";
            bool errorsFound = false;
            SystemAirFlowSizer sizerSystemAirFlow;
            sizerSystemAirFlow.overrideSizingString(SizingString);
            // sizerSystemAirFlow.setHVACSizingIndexData(FanCoil(FanCoilNum).HVACSizingIndex);
            sizerSystemAirFlow.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
            this->m_MaxNoCoolHeatAirVolFlow = sizerSystemAirFlow.size(state, TempSize, errorsFound);
            state.dataSize->DataEMSOverrideON = false;
            state.dataSize->DataConstantUsedForSizing = 0.0;
            state.dataSize->DataFractionUsedForSizing = 0.0;
        }

        if (this->m_MaxCoolAirVolFlow > 0.0) {
            this->LowSpeedCoolFanRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_MaxCoolAirVolFlow;
        }
        if (this->m_MaxHeatAirVolFlow > 0.0) {
            this->LowSpeedHeatFanRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_MaxHeatAirVolFlow;
        }

        if (this->ATMixerExists && state.dataSize->CurZoneEqNum > 0) { // set up ATMixer conditions for use in component sizing
            SingleDuct::setATMixerSizingProperties(state, this->m_ATMixerIndex, this->ControlZoneNum, state.dataSize->CurZoneEqNum);
        }

        // Change the Volume Flow Rates to Mass Flow Rates
        this->m_DesignMassFlowRate = this->m_DesignFanVolFlowRate * state.dataEnvrn->StdRhoAir;
        this->MaxCoolAirMassFlow = this->m_MaxCoolAirVolFlow * state.dataEnvrn->StdRhoAir;
        this->MaxHeatAirMassFlow = this->m_MaxHeatAirVolFlow * state.dataEnvrn->StdRhoAir;
        this->MaxNoCoolHeatAirMassFlow = this->m_MaxNoCoolHeatAirVolFlow * state.dataEnvrn->StdRhoAir;

        // initialize multi-speed coils
        if ((this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit) ||
            (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed)) {

            if (this->m_NumOfSpeedCooling > 0) {
                if (this->m_CoolVolumeFlowRate.empty()) this->m_CoolVolumeFlowRate.resize(this->m_NumOfSpeedCooling + 1);
                if (this->m_CoolMassFlowRate.empty()) this->m_CoolMassFlowRate.resize(this->m_NumOfSpeedCooling + 1);
                if (this->m_MSCoolingSpeedRatio.empty()) this->m_MSCoolingSpeedRatio.resize(this->m_NumOfSpeedCooling + 1);
            }

            MSHPIndex = this->m_DesignSpecMSHPIndex;
            if (MSHPIndex > -1) {
                for (Iter = state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling; Iter >= 1; --Iter) {
                    if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1] == DataSizing::AutoSize) {
                        state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1] =
                            double(Iter) / double(state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling);
                    }
                }
            }

            VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                      blankString,
                                                      this->m_CoolingCoilIndex,
                                                      0,
                                                      this->m_MaxONOFFCyclesperHour,
                                                      this->m_HPTimeConstant,
                                                      this->m_FanDelayTime,
                                                      0,
                                                      0.0,
                                                      1,
                                                      0.0,
                                                      0.0,
                                                      0.0,
                                                      0.0); // conduct the sizing operation in the VS WSHP
            if (this->m_NumOfSpeedCooling != state.dataVariableSpeedCoils->VarSpeedCoil(this->m_CoolingCoilIndex).NumOfSpeeds) {
                ShowWarningError(state, std::string{RoutineName} + ": " + CompType + " = " + std::string{CompName});
                ShowContinueError(state, "Number of cooling speeds does not match coil object.");
                ShowFatalError(state,
                               "Cooling coil = " + state.dataVariableSpeedCoils->VarSpeedCoil(this->m_CoolingCoilIndex).VarSpeedCoilType + ": " +
                                   state.dataVariableSpeedCoils->VarSpeedCoil(this->m_CoolingCoilIndex).Name);
            }
            state.dataSize->DXCoolCap = VariableSpeedCoils::GetCoilCapacityVariableSpeed(
                state, DataHVACGlobals::cAllCoilTypes(this->m_CoolingCoilType_Num), this->m_CoolingCoilName, ErrFound);
            EqSizing.DesCoolingLoad = state.dataSize->DXCoolCap;
            EqSizing.DesHeatingLoad = state.dataSize->DXCoolCap;

            for (Iter = 1; Iter <= this->m_NumOfSpeedCooling; ++Iter) {
                this->m_CoolVolumeFlowRate[Iter] = state.dataVariableSpeedCoils->VarSpeedCoil(this->m_CoolingCoilIndex).MSRatedAirVolFlowRate(Iter);
                this->m_CoolMassFlowRate[Iter] = this->m_CoolVolumeFlowRate[Iter] * state.dataEnvrn->StdRhoAir;
                this->m_MSCoolingSpeedRatio[Iter] = this->m_CoolVolumeFlowRate[Iter] / this->m_DesignFanVolFlowRate;
            }

            if (MSHPIndex > -1) {
                this->m_MaxNoCoolHeatAirVolFlow =
                    this->m_MaxCoolAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                this->MaxNoCoolHeatAirMassFlow = this->m_MaxNoCoolHeatAirVolFlow * state.dataEnvrn->StdRhoAir;
                this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
            } else if (this->m_CoolVolumeFlowRate.empty()) {
                this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
            }

        } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling) {

            if (this->m_NumOfSpeedCooling > 0) {
                if (this->m_CoolVolumeFlowRate.empty()) this->m_CoolVolumeFlowRate.resize(this->m_NumOfSpeedCooling + 1);
                if (this->m_CoolMassFlowRate.empty()) this->m_CoolMassFlowRate.resize(this->m_NumOfSpeedCooling + 1);
                if (this->m_MSCoolingSpeedRatio.empty()) this->m_MSCoolingSpeedRatio.resize(this->m_NumOfSpeedCooling + 1);
            }

            // it feels like we are jamming the rectangular DXCoil into an oval box here
            MSHPIndex = this->m_DesignSpecMSHPIndex;
            if (MSHPIndex > -1) {
                for (Iter = state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling; Iter >= 1;
                     --Iter) { // use reverse order since we divide by HeatVolumeFlowRate(max)
                    if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1] == DataSizing::AutoSize) {
                        state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1] =
                            double(Iter) / double(state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling);
                    }
                }
            }

            // mine capacity from Coil:Cooling:DX object
            auto &newCoil = state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex];
            // TODO: Determine operating mode based on dehumdification stuff, using normalMode for now
            if (this->m_NumOfSpeedCooling != (int)newCoil.performance.normalMode.speeds.size()) {
                ShowWarningError(state, std::string{RoutineName} + ": " + CompType + " = " + std::string{CompName});
                ShowContinueError(state, "Number of cooling speeds does not match coil object.");
                ShowFatalError(state, "Cooling coil = Coil:Cooling:DX: " + newCoil.name);
            }

            // Use discrete/continuous control algorithm regardless of number of speeds
            if (newCoil.performance.capControlMethod == CoilCoolingDXCurveFitPerformance::CapControlMethod::DISCRETE) {
                this->m_DiscreteSpeedCoolingCoil = true;
            } else if (newCoil.performance.capControlMethod == CoilCoolingDXCurveFitPerformance::CapControlMethod::CONTINUOUS) {
                this->m_ContSpeedCoolingCoil = true;
            }

            newCoil.size(state);
            if (MSHPIndex == -1) {
                for (Iter = 1; Iter <= this->m_NumOfSpeedCooling; ++Iter) {
                    this->m_CoolVolumeFlowRate[Iter] = newCoil.performance.normalMode.speeds[Iter - 1].evap_air_flow_rate;
                    this->m_CoolMassFlowRate[Iter] = this->m_CoolVolumeFlowRate[Iter] * state.dataEnvrn->StdRhoAir;
                    // it seems the ratio should reference the actual flow rates, not the fan flow ???
                    if (this->m_DesignFanVolFlowRate > 0.0 && this->m_FanExists) {
                        this->m_MSCoolingSpeedRatio[Iter] = this->m_CoolVolumeFlowRate[Iter] / this->m_DesignFanVolFlowRate;
                    } else {
                        this->m_MSCoolingSpeedRatio[Iter] = this->m_CoolVolumeFlowRate[Iter] / this->m_CoolVolumeFlowRate[this->m_NumOfSpeedCooling];
                    }
                }
            }

            state.dataSize->DXCoolCap = newCoil.performance.normalMode.ratedGrossTotalCap;
            EqSizing.DesCoolingLoad = state.dataSize->DXCoolCap;
            if (this->m_HeatPump) EqSizing.DesHeatingLoad = state.dataSize->DXCoolCap;

            if (MSHPIndex > -1) {
                for (Iter = state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling; Iter > 0; --Iter) {
                    if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1] == DataSizing::AutoSize)
                        state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1] =
                            double(Iter) / double(state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling);
                    this->m_CoolVolumeFlowRate[Iter] =
                        this->m_MaxCoolAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1];
                    this->m_CoolMassFlowRate[Iter] = this->m_CoolVolumeFlowRate[Iter] * state.dataEnvrn->StdRhoAir;
                    this->m_MSCoolingSpeedRatio[Iter] = this->m_CoolVolumeFlowRate[Iter] / this->m_DesignFanVolFlowRate;
                }
                this->m_MaxNoCoolHeatAirVolFlow =
                    this->m_MaxCoolAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                this->MaxNoCoolHeatAirMassFlow = this->m_MaxNoCoolHeatAirVolFlow * state.dataEnvrn->StdRhoAir;
                this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
            } else if (this->m_CoolVolumeFlowRate.empty()) {
                this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
            }

        } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling ||
                   this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {

            if (this->m_NumOfSpeedCooling > 0) {
                if (this->m_CoolVolumeFlowRate.empty()) this->m_CoolVolumeFlowRate.resize(this->m_NumOfSpeedCooling + 1);
                if (this->m_CoolMassFlowRate.empty()) this->m_CoolMassFlowRate.resize(this->m_NumOfSpeedCooling + 1);
                if (this->m_MSCoolingSpeedRatio.empty()) this->m_MSCoolingSpeedRatio.resize(this->m_NumOfSpeedCooling + 1);
            }

            // set the multi-speed high flow rate variable in case a non-zero air flow rate resides on the coil inlet during sizing (e.g., upstream
            // system ran prior to this one)
            state.dataHVACGlobal->MSHPMassFlowRateHigh =
                EqSizing.CoolingAirVolFlow *
                state.dataEnvrn->StdRhoAir; // doesn't matter what this value is since only coil size is needed and CompOn = 0 here
            DXCoils::SimDXCoilMultiSpeed(state, blankString, 1.0, 1.0, this->m_CoolingCoilIndex, 0, 0, 0);
            if (!HardSizeNoDesRun && EqSizing.Capacity) {
                // do nothing, the vars EqSizing.DesCoolingLoad and DataSizing::DXCoolCap are already set earlier and the values could be max of the
                // cooling and heating autosized values. Thus reseting them here to user specified value may not be the design size used else where
            } else {
                state.dataSize->DXCoolCap =
                    DXCoils::GetCoilCapacityByIndexType(state, this->m_CoolingCoilIndex, this->m_CoolingCoilType_Num, ErrFound);
                EqSizing.DesCoolingLoad = state.dataSize->DXCoolCap;
            }
            MSHPIndex = this->m_DesignSpecMSHPIndex;

            if (MSHPIndex > -1) {
                // use reverse order since we divide by CoolVolumeFlowRate(max)
                for (Iter = state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling; Iter > 0; --Iter) {
                    if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1] == DataSizing::AutoSize)
                        state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1] =
                            double(Iter) / double(state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling);
                    this->m_CoolVolumeFlowRate[Iter] =
                        this->m_MaxCoolAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1];
                    this->m_CoolMassFlowRate[Iter] = this->m_CoolVolumeFlowRate[Iter] * state.dataEnvrn->StdRhoAir;
                    this->m_MSCoolingSpeedRatio[Iter] = this->m_CoolVolumeFlowRate[Iter] / this->m_DesignFanVolFlowRate;
                }
                this->m_MaxNoCoolHeatAirVolFlow =
                    this->m_MaxCoolAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                this->MaxNoCoolHeatAirMassFlow = this->m_MaxNoCoolHeatAirVolFlow * state.dataEnvrn->StdRhoAir;
                this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
            } else if (this->m_CoolVolumeFlowRate.empty()) {
                this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
            } else {
                for (Iter = this->m_NumOfSpeedCooling; Iter > 0; --Iter) {
                    this->m_CoolVolumeFlowRate[Iter] = this->m_MaxCoolAirVolFlow * Iter / this->m_NumOfSpeedCooling;
                    this->m_CoolMassFlowRate[Iter] = this->m_CoolVolumeFlowRate[Iter] * state.dataEnvrn->StdRhoAir;
                    this->m_MSCoolingSpeedRatio[Iter] = this->m_CoolVolumeFlowRate[Iter] / this->m_DesignFanVolFlowRate;
                }
                this->MaxNoCoolHeatAirMassFlow = this->m_MaxNoCoolHeatAirVolFlow * state.dataEnvrn->StdRhoAir;
                this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
            }
        } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
                   this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) {

            if (this->m_NumOfSpeedCooling > 0) {
                if (this->m_CoolVolumeFlowRate.empty()) this->m_CoolVolumeFlowRate.resize(this->m_NumOfSpeedCooling + 1);
                if (this->m_CoolMassFlowRate.empty()) this->m_CoolMassFlowRate.resize(this->m_NumOfSpeedCooling + 1);
                if (this->m_MSCoolingSpeedRatio.empty()) this->m_MSCoolingSpeedRatio.resize(this->m_NumOfSpeedCooling + 1);
            }
            MSHPIndex = this->m_DesignSpecMSHPIndex;

            if (MSHPIndex > -1) {
                for (Iter = state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling; Iter > 0; --Iter) {
                    if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1] == DataSizing::AutoSize)
                        state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1] =
                            double(Iter) / double(state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedCooling);
                    this->m_CoolVolumeFlowRate[Iter] =
                        this->m_MaxCoolAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].coolingVolFlowRatio[Iter - 1];
                    this->m_CoolMassFlowRate[Iter] = this->m_CoolVolumeFlowRate[Iter] * state.dataEnvrn->StdRhoAir;
                    this->m_MSCoolingSpeedRatio[Iter] = this->m_CoolVolumeFlowRate[Iter] / this->m_DesignFanVolFlowRate;
                }
                this->m_MaxNoCoolHeatAirVolFlow =
                    this->m_MaxCoolAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                this->MaxNoCoolHeatAirMassFlow = this->m_MaxNoCoolHeatAirVolFlow * state.dataEnvrn->StdRhoAir;
                this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
            } else if (this->m_CoolVolumeFlowRate.empty()) {
                this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
            }
        }

        if (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingElectric_MultiStage ||
            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingGas_MultiStage) {

            if (this->m_NumOfSpeedHeating > 0) {
                if (this->m_HeatVolumeFlowRate.empty()) this->m_HeatVolumeFlowRate.resize(this->m_NumOfSpeedHeating + 1);
                if (this->m_HeatMassFlowRate.empty()) this->m_HeatMassFlowRate.resize(this->m_NumOfSpeedHeating + 1);
                if (this->m_MSHeatingSpeedRatio.empty()) this->m_MSHeatingSpeedRatio.resize(this->m_NumOfSpeedHeating + 1);
            }

            MSHPIndex = this->m_DesignSpecMSHPIndex;

            if (MSHPIndex > -1) {
                // use reverse order since we divide by HeatVolumeFlowRate(max)
                for (Iter = state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedHeating; Iter > 0; --Iter) {
                    if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1] == DataSizing::AutoSize) {
                        if (this->m_ControlType == ControlType::Setpoint &&
                            (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingElectric_MultiStage ||
                             this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingGas_MultiStage)) {
                            state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1] = 1.0;
                        } else {
                            state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1] =
                                double(Iter) / double(state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedHeating);
                        }
                    } else {
                        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingElectric_MultiStage ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingGas_MultiStage) {
                            if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1] < 1.0 &&
                                this->m_ControlType == ControlType::Setpoint) {
                                ShowWarningError(state, std::string{RoutineName} + ": " + CompType + " = " + std::string{CompName});
                                ShowContinueError(state, "Design specification object = " + state.dataUnitarySystems->designSpecMSHP[MSHPIndex].name);
                                ShowContinueError(state,
                                                  "When control type = SetPointBased the outlet air temperature must change with coil capacity, if "
                                                  "air flow also changes outlet air temperature will be relatively constant.");
                                ShowContinueError(
                                    state,
                                    format("Speed {} Supply Air Flow Ratio During Heating Operation will be set = 1.0 and the simulation continues",
                                           Iter));
                                state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1] = 1.0;
                            }
                        }
                    }
                    this->m_HeatVolumeFlowRate[Iter] =
                        this->m_MaxHeatAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1];
                    this->m_HeatMassFlowRate[Iter] = this->m_HeatVolumeFlowRate[Iter] * state.dataEnvrn->StdRhoAir;
                    this->m_MSHeatingSpeedRatio[Iter] = this->m_HeatVolumeFlowRate[Iter] / this->m_DesignFanVolFlowRate;
                }
                if (this->m_CoolCoilExists) {
                    if (this->m_CoolVolumeFlowRate.size() > 0 && MSHPIndex > -1) {
                        this->m_MaxNoCoolHeatAirVolFlow =
                            min(this->m_MaxNoCoolHeatAirVolFlow,
                                this->m_MaxHeatAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio);
                        this->MaxNoCoolHeatAirMassFlow =
                            min(this->MaxNoCoolHeatAirMassFlow,
                                this->MaxHeatAirMassFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio);
                        this->m_NoLoadAirFlowRateRatio =
                            min(this->m_NoLoadAirFlowRateRatio, this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate);
                    } else {
                        this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
                    }
                } else if (MSHPIndex > -1) {
                    this->m_MaxNoCoolHeatAirVolFlow =
                        this->m_MaxHeatAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                    this->MaxNoCoolHeatAirMassFlow = this->m_MaxNoCoolHeatAirVolFlow * state.dataEnvrn->StdRhoAir;
                    this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
                } else {
                    this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
                }
            }
        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit ||
                   this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) {

            MSHPIndex = this->m_DesignSpecMSHPIndex;
            if (MSHPIndex > -1) {
                for (Iter = state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedHeating; Iter > 0; --Iter) {
                    if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1] == DataSizing::AutoSize) {
                        state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1] =
                            double(Iter) / double(state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedHeating);
                    }
                }
            }

            VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                      blankString,
                                                      this->m_HeatingCoilIndex,
                                                      0,
                                                      this->m_MaxONOFFCyclesperHour,
                                                      this->m_HPTimeConstant,
                                                      this->m_FanDelayTime,
                                                      0,
                                                      0.0,
                                                      1,
                                                      0.0,
                                                      0.0,
                                                      0.0,
                                                      0.0); // conduct the sizing operation in the VS WSHP

            if (this->m_NumOfSpeedHeating != state.dataVariableSpeedCoils->VarSpeedCoil(this->m_HeatingCoilIndex).NumOfSpeeds) {
                ShowWarningError(state, std::string{RoutineName} + ": " + CompType + " = " + std::string{CompName});
                ShowContinueError(state, "Number of heating speeds does not match coil object.");
                ShowFatalError(state,
                               "Heating coil = " + state.dataVariableSpeedCoils->VarSpeedCoil(this->m_HeatingCoilIndex).VarSpeedCoilType + ": " +
                                   state.dataVariableSpeedCoils->VarSpeedCoil(this->m_HeatingCoilIndex).Name);
            }

            if (this->m_NumOfSpeedHeating > 0) {
                if (this->m_HeatVolumeFlowRate.empty()) this->m_HeatVolumeFlowRate.resize(this->m_NumOfSpeedHeating + 1);
                if (this->m_HeatMassFlowRate.empty()) this->m_HeatMassFlowRate.resize(this->m_NumOfSpeedHeating + 1);
                if (this->m_MSHeatingSpeedRatio.empty()) this->m_MSHeatingSpeedRatio.resize(this->m_NumOfSpeedHeating + 1);
            }

            for (Iter = 1; Iter <= this->m_NumOfSpeedHeating; ++Iter) {
                this->m_HeatVolumeFlowRate[Iter] = state.dataVariableSpeedCoils->VarSpeedCoil(this->m_HeatingCoilIndex).MSRatedAirVolFlowRate(Iter);
                this->m_HeatMassFlowRate[Iter] = this->m_HeatVolumeFlowRate[Iter] * state.dataEnvrn->StdRhoAir;
                if (this->m_DesignFanVolFlowRate > 0.0 && this->m_FanExists) {
                    this->m_MSHeatingSpeedRatio[Iter] = this->m_HeatVolumeFlowRate[Iter] / this->m_DesignFanVolFlowRate;
                } else {
                    this->m_MSHeatingSpeedRatio[Iter] = this->m_HeatVolumeFlowRate[Iter] / this->m_HeatVolumeFlowRate[this->m_NumOfSpeedHeating];
                }
            }

            if (this->m_CoolCoilExists && this->m_NumOfSpeedHeating > 0) {
                if (this->m_CoolVolumeFlowRate.size() > 0 && MSHPIndex > -1) {
                    this->m_MaxNoCoolHeatAirVolFlow =
                        min(this->m_MaxNoCoolHeatAirVolFlow,
                            this->m_MaxHeatAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio);
                    this->MaxNoCoolHeatAirMassFlow =
                        min(this->MaxNoCoolHeatAirMassFlow,
                            this->MaxHeatAirMassFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio);
                    this->m_NoLoadAirFlowRateRatio =
                        min(this->m_NoLoadAirFlowRateRatio, this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate);
                } else if (this->m_CoolVolumeFlowRate.empty() && MSHPIndex > -1) {
                    this->m_MaxNoCoolHeatAirVolFlow =
                        this->m_MaxHeatAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                    this->MaxNoCoolHeatAirMassFlow =
                        this->MaxHeatAirMassFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                    this->m_NoLoadAirFlowRateRatio = this->m_MSHeatingSpeedRatio[this->m_NumOfSpeedHeating] *
                                                     state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                } else if (this->m_CoolVolumeFlowRate.size() > 0) {
                    this->m_MaxNoCoolHeatAirVolFlow = min(this->m_MaxNoCoolHeatAirVolFlow, this->m_MaxNoCoolHeatAirVolFlow);
                    this->MaxNoCoolHeatAirMassFlow = min(this->MaxNoCoolHeatAirMassFlow, this->MaxNoCoolHeatAirMassFlow);
                    this->m_NoLoadAirFlowRateRatio =
                        min(this->m_NoLoadAirFlowRateRatio, this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate);
                } else {
                    this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
                }
            } else if (MSHPIndex > -1) {
                this->m_MaxNoCoolHeatAirVolFlow =
                    this->m_MaxHeatAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                this->MaxNoCoolHeatAirMassFlow = this->m_MaxNoCoolHeatAirVolFlow * state.dataEnvrn->StdRhoAir;
                this->m_NoLoadAirFlowRateRatio = this->m_MSHeatingSpeedRatio[this->m_NumOfSpeedHeating] *
                                                 state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
            } else {
                this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
            }
        }
        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {

            if (this->m_NumOfSpeedHeating > 0) {
                if (this->m_HeatVolumeFlowRate.empty()) this->m_HeatVolumeFlowRate.resize(this->m_NumOfSpeedHeating + 1);
                if (this->m_HeatMassFlowRate.empty()) this->m_HeatMassFlowRate.resize(this->m_NumOfSpeedHeating + 1);
                if (this->m_MSHeatingSpeedRatio.empty()) this->m_MSHeatingSpeedRatio.resize(this->m_NumOfSpeedHeating + 1);
            }

            MSHPIndex = this->m_DesignSpecMSHPIndex;
            if (MSHPIndex > -1) {
                for (Iter = state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedHeating; Iter > 0; --Iter) {
                    if (state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1] == DataSizing::AutoSize) {
                        state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1] =
                            double(Iter) / double(state.dataUnitarySystems->designSpecMSHP[MSHPIndex].numOfSpeedHeating);
                    }
                    this->m_HeatVolumeFlowRate[Iter] =
                        this->m_MaxHeatAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].heatingVolFlowRatio[Iter - 1];
                    this->m_HeatMassFlowRate[Iter] = this->m_HeatVolumeFlowRate[Iter] * state.dataEnvrn->StdRhoAir;
                    this->m_MSHeatingSpeedRatio[Iter] = this->m_HeatVolumeFlowRate[Iter] / this->m_DesignFanVolFlowRate;
                }
                if (this->m_CoolCoilExists) {
                    if (this->m_CoolVolumeFlowRate.size() > 0 && MSHPIndex > 0) {
                        this->m_MaxNoCoolHeatAirVolFlow =
                            min(this->m_MaxNoCoolHeatAirVolFlow,
                                this->m_MaxHeatAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio);
                        this->MaxNoCoolHeatAirMassFlow =
                            min(this->MaxNoCoolHeatAirMassFlow,
                                this->MaxHeatAirMassFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio);
                        this->m_NoLoadAirFlowRateRatio =
                            min(this->m_NoLoadAirFlowRateRatio, this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate);
                    } else {
                        this->m_MaxNoCoolHeatAirVolFlow = min(this->m_MaxNoCoolHeatAirVolFlow, this->m_MaxNoCoolHeatAirVolFlow);
                        this->MaxNoCoolHeatAirMassFlow = min(this->MaxNoCoolHeatAirMassFlow, this->MaxNoCoolHeatAirMassFlow);
                        this->m_NoLoadAirFlowRateRatio =
                            min(this->m_NoLoadAirFlowRateRatio, (this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate));
                    }
                } else if (MSHPIndex > -1) {
                    this->m_MaxNoCoolHeatAirVolFlow =
                        this->m_MaxHeatAirVolFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                    this->MaxNoCoolHeatAirMassFlow =
                        this->MaxHeatAirMassFlow * state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                    this->m_NoLoadAirFlowRateRatio = this->m_MSHeatingSpeedRatio[this->m_NumOfSpeedHeating] *
                                                     state.dataUnitarySystems->designSpecMSHP[MSHPIndex].noLoadAirFlowRateRatio;
                } else {
                    this->m_NoLoadAirFlowRateRatio = this->m_MaxNoCoolHeatAirVolFlow / this->m_DesignFanVolFlowRate;
                }
            }
        }

        // Not sure if this may be needed for special cases
        if (this->m_CoolCoilExists && this->m_MaxCoolAirVolFlow < 0.0) {
            if (!state.dataSize->SysSizingRunDone) {
                BranchNum = BranchInputManager::GetAirBranchIndex(state, "AirloopHVAC:UnitarySystem", this->Name);
                FanType = "";
                m_FanName = "";
                BranchFanFlow = 0.0;
                if (BranchNum > 0.0) BranchInputManager::GetBranchFanTypeName(state, BranchNum, FanType, m_FanName, ErrFound);
                if (!ErrFound && BranchNum > 0) {
                    if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                        BranchFanFlow = state.dataHVACFan->fanObjs[this->m_FanIndex]->designAirVolFlowRate;
                    } else {
                        BranchFanFlow = Fans::GetFanDesignVolumeFlowRate(state, FanType, m_FanName, ErrFound);
                    }
                }
                if (BranchFanFlow > 0.0) {
                    this->m_MaxCoolAirVolFlow = BranchFanFlow;
                } else {
                    SystemFlow = 0.0;
                    if (AirLoopNum > 0.0) SystemFlow = state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).DesignVolFlowRate;
                    if (SystemFlow > 0.0) {
                        this->m_MaxCoolAirVolFlow = SystemFlow;
                    } else {
                        // what do I do?
                    }
                }
            }
        }

        // why is this here?
        this->m_SenLoadLoss = 0.0;
        if (this->m_Humidistat) {
            this->m_LatLoadLoss = 0.0;
        }

        if (this->m_CoolCoilExists) {

            SizingMethod = DataHVACGlobals::CoolingCapacitySizing;
            // water coils must report their size to parent objects (or split out sizing routines for water coils so they can be call from here)
            if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
                this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) {
                WaterCoils::SimulateWaterCoilComponents(
                    state, this->m_CoolingCoilName, FirstHVACIteration, this->m_CoolingCoilIndex, QActual, this->m_FanOpMode, 1.0);
                state.dataSize->DataConstantUsedForSizing =
                    WaterCoils::GetWaterCoilCapacity(state,
                                                     UtilityRoutines::MakeUPPERCase(DataHVACGlobals::cAllCoilTypes(this->m_CoolingCoilType_Num)),
                                                     this->m_CoolingCoilName,
                                                     ErrFound);
                EqSizing.DesCoolingLoad = state.dataSize->DataConstantUsedForSizing;
                state.dataSize->DataFractionUsedForSizing = 1.0;
                SizingMethod = DataHVACGlobals::AutoCalculateSizing;
                this->m_DesignCoolingCapacity = DataSizing::AutoSize;
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilWater_CoolingHXAssisted) {
                HXCoilName = HVACHXAssistedCoolingCoil::GetHXDXCoilName(
                    state, DataHVACGlobals::cAllCoilTypes(this->m_CoolingCoilType_Num), this->m_CoolingCoilName, ErrFound);
                ActualCoolCoilType = HVACHXAssistedCoolingCoil::GetCoilObjectTypeNum(
                    state, DataHVACGlobals::cAllCoilTypes(this->m_CoolingCoilType_Num), this->m_CoolingCoilName, ErrFound, true);
                HVACHXAssistedCoolingCoil::SimHXAssistedCoolingCoil(
                    state, blankString, true, state.dataUnitarySystems->On, 1.0, this->m_CoolingCoilIndex, 1, false, 1.0, false);
                state.dataSize->DataConstantUsedForSizing = WaterCoils::GetWaterCoilCapacity(
                    state, UtilityRoutines::MakeUPPERCase(DataHVACGlobals::cAllCoilTypes(ActualCoolCoilType)), HXCoilName, ErrFound);
                EqSizing.DesCoolingLoad = state.dataSize->DataConstantUsedForSizing;
                state.dataSize->DataFractionUsedForSizing = 1.0;
                SizingMethod = DataHVACGlobals::AutoCalculateSizing;
                this->m_DesignCoolingCapacity = DataSizing::AutoSize;
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) {
                WaterToAirHeatPumpSimple::SimWatertoAirHPSimple(state,
                                                                blankString,
                                                                this->m_CoolingCoilIndex,
                                                                this->m_CoolingCoilSensDemand,
                                                                this->m_CoolingCoilLatentDemand,
                                                                0,
                                                                0.0,
                                                                this->m_MaxONOFFCyclesperHour,
                                                                this->m_HPTimeConstant,
                                                                this->m_FanDelayTime,
                                                                0,
                                                                0.0,
                                                                FirstHVACIteration);
                state.dataSize->DataConstantUsedForSizing = WaterToAirHeatPumpSimple::GetCoilCapacity(
                    state, DataHVACGlobals::cAllCoilTypes(this->m_CoolingCoilType_Num), this->m_CoolingCoilName, ErrFound);
                EqSizing.DesCoolingLoad = state.dataSize->DataConstantUsedForSizing;
                state.dataSize->DataFractionUsedForSizing = 1.0;
                SizingMethod = DataHVACGlobals::AutoCalculateSizing;
                this->m_DesignCoolingCapacity = DataSizing::AutoSize;
                if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple ||
                    this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP)
                    EqSizing.DesHeatingLoad = state.dataSize->DataConstantUsedForSizing;
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHP) {
                WaterToAirHeatPump::SimWatertoAirHP(state,
                                                    blankString,
                                                    this->m_CoolingCoilIndex,
                                                    this->MaxCoolAirMassFlow,
                                                    this->m_FanOpMode,
                                                    FirstHVACIteration,
                                                    0.0,
                                                    this->m_MaxONOFFCyclesperHour,
                                                    this->m_HPTimeConstant,
                                                    this->m_FanDelayTime,
                                                    this->m_InitHeatPump,
                                                    0.0,
                                                    0.0,
                                                    0,
                                                    0.0);
                state.dataSize->DataConstantUsedForSizing = WaterToAirHeatPump::GetCoilCapacity(
                    state, DataHVACGlobals::cAllCoilTypes(this->m_CoolingCoilType_Num), this->m_CoolingCoilName, ErrFound);
                EqSizing.DesCoolingLoad = state.dataSize->DataConstantUsedForSizing;
                state.dataSize->DataFractionUsedForSizing = 1.0;
                SizingMethod = DataHVACGlobals::AutoCalculateSizing;
                if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP ||
                    this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple)
                    EqSizing.DesHeatingLoad = state.dataSize->DataConstantUsedForSizing;
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling) {
                PackagedThermalStorageCoil::SimTESCoil(
                    state, this->m_CoolingCoilName, this->m_CoolingCoilIndex, this->m_FanOpMode, this->m_TESOpMode, 0.0);
                PackagedThermalStorageCoil::GetTESCoilCoolingCapacity(
                    state, this->m_CoolingCoilName, state.dataSize->DataConstantUsedForSizing, ErrFound, CompType);
                EqSizing.DesCoolingLoad = state.dataSize->DataConstantUsedForSizing;
                state.dataSize->DataFractionUsedForSizing = 1.0;
                SizingMethod = DataHVACGlobals::AutoCalculateSizing;
            }

            TempSize = this->m_DesignCoolingCapacity;
            state.dataSize->DataFlowUsedForSizing = this->m_MaxCoolAirVolFlow;
            SizingString = "Nominal Cooling Capacity [W]";
            bool errorsFound = false;
            CoolingCapacitySizer sizerCoolingCapacity;
            sizerCoolingCapacity.overrideSizingString(SizingString);
            sizerCoolingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
            this->m_DesignCoolingCapacity = sizerCoolingCapacity.size(state, TempSize, errorsFound);
            state.dataSize->DataConstantUsedForSizing = 0.0;
            state.dataSize->DataFractionUsedForSizing = 0.0;
            state.dataSize->DataFlowUsedForSizing = 0.0;
        }

        if (this->m_HeatCoilExists) {

            SizingMethod = DataHVACGlobals::HeatingCapacitySizing;

            // water coils must report their size to parent objects (or split out sizing routines for water coils so they can be call from here)
            if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
                WaterCoils::SimulateWaterCoilComponents(
                    state, this->m_HeatingCoilName, FirstHVACIteration, this->m_HeatingCoilIndex, QActual, this->m_FanOpMode, 1.0);
                state.dataSize->DataConstantUsedForSizing =
                    WaterCoils::GetWaterCoilCapacity(state,
                                                     UtilityRoutines::MakeUPPERCase(DataHVACGlobals::cAllCoilTypes(this->m_HeatingCoilType_Num)),
                                                     this->m_HeatingCoilName,
                                                     ErrFound);
                EqSizing.DesHeatingLoad = state.dataSize->DataConstantUsedForSizing;
                state.dataSize->DataFractionUsedForSizing = 1.0;
                SizingMethod = DataHVACGlobals::AutoCalculateSizing;
                this->m_DesignHeatingCapacity = DataSizing::AutoSize;
            }

            TempSize = this->m_DesignHeatingCapacity;
            SizingString = "Nominal Heating Capacity [W]";
            if (state.dataSize->CurSysNum > 0)
                state.dataAirLoop->AirLoopControlInfo(AirLoopNum).UnitarySysSimulating =
                    false; // set to false to allow calculation of parent object heating capacity
            bool errorsFound = false;
            HeatingCapacitySizer sizerHeatingCapacity;
            sizerHeatingCapacity.overrideSizingString(SizingString);
            sizerHeatingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
            TempSize = sizerHeatingCapacity.size(state, TempSize, errorsFound);
            if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) state.dataSize->DXCoolCap = TempSize;
            if (state.dataSize->CurSysNum > 0) state.dataAirLoop->AirLoopControlInfo(AirLoopNum).UnitarySysSimulating = true;
            this->m_DesignHeatingCapacity = TempSize;
            state.dataSize->DataConstantUsedForSizing = 0.0;
            state.dataSize->DataFractionUsedForSizing = 0.0;
            state.dataSize->DataHeatSizeRatio = 1.0;
        }

        if (!HardSizeNoDesRun && (EqSizing.Capacity && EqSizing.DesHeatingLoad > 0.0)) {
            // vars EqSizing.DesHeatingLoad is already set earlier and supplemental heating coil should
            // be sized to design value instead of user specified value if HardSizeNoDesRun is false
            state.dataSize->UnitaryHeatCap = EqSizing.DesHeatingLoad;

        } else {
            state.dataSize->UnitaryHeatCap = this->m_DesignHeatingCapacity;
        }

        if ((this->m_HeatCoilExists || this->m_SuppCoilExists) && this->m_ControlType != ControlType::CCMASHRAE) {

            TempSize = this->DesignMaxOutletTemp;
            MaxHeaterOutletTempSizer sizerMaxHeaterOutTemp;
            sizerMaxHeaterOutTemp.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
            this->DesignMaxOutletTemp = sizerMaxHeaterOutTemp.size(state, TempSize, ErrFound);
        }

        if (this->m_SuppCoilExists) {

            SizingMethod = DataHVACGlobals::HeatingCapacitySizing;

            PrintFlag = false;
            TempSize = this->m_DesignSuppHeatingCapacity;
            SizingString = "Supplemental Heating Coil Nominal Capacity [W]";
            if (TempSize == DataSizing::AutoSize) {
                IsAutoSize = true;
                bool errorsFound = false;
                HeatingCapacitySizer sizerHeatingCapacity;
                sizerHeatingCapacity.overrideSizingString(SizingString);
                sizerHeatingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
                this->m_DesignSuppHeatingCapacity = sizerHeatingCapacity.size(state, TempSize, errorsFound);
            }
            // logic here isn't accurate. Replicating temporarily to minimize diffs in AutoSizingLibrary refactor
            TempSize = this->m_DesignSuppHeatingCapacity;

            if (this->m_Humidistat && this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat && IsAutoSize) {
                state.dataSize->DataConstantUsedForSizing = max(this->m_DesignSuppHeatingCapacity, this->m_DesignCoolingCapacity);
                state.dataSize->DataFractionUsedForSizing = 1.0;
                SizingMethod = DataHVACGlobals::AutoCalculateSizing;
                TempSize = DataSizing::AutoSize;
            }

            if (this->m_OKToPrintSizing) PrintFlag = true;
            bool errorsFound = false;
            HeatingCapacitySizer sizerHeatingCapacity;
            sizerHeatingCapacity.overrideSizingString(SizingString);
            sizerHeatingCapacity.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
            this->m_DesignSuppHeatingCapacity = sizerHeatingCapacity.size(state, TempSize, errorsFound);
            IsAutoSize = false;
            state.dataSize->DataConstantUsedForSizing = 0.0;
            state.dataSize->DataFractionUsedForSizing = 0.0;

            state.dataSize->SuppHeatCap = this->m_DesignSuppHeatingCapacity;
        }

        // register plant flow rate. Not sure this has ever been tested.
        if (this->m_HeatRecActive) {
            PlantUtilities::RegisterPlantCompDesignFlow(state, this->m_HeatRecoveryInletNodeNum, this->m_DesignHRWaterVolumeFlow);
        }

        // Set flow rate for unitary system with no fan
        if (state.dataSize->CurOASysNum == 0 && state.dataSize->CurZoneEqNum == 0 && this->m_DesignFanVolFlowRate <= 0.0) {
            SystemFlow = 0;
            if (AirLoopNum > 0) SystemFlow = state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).DesignVolFlowRate;
            if (SystemFlow > 0.0) {
                this->m_DesignFanVolFlowRate = SystemFlow;
            } else {
                this->m_DesignFanVolFlowRate = max(this->m_MaxCoolAirVolFlow, this->m_MaxHeatAirVolFlow);
            }
            this->m_DesignMassFlowRate = this->m_DesignFanVolFlowRate * state.dataEnvrn->StdRhoAir;
        }

        // Moved from InitLoadBasedControl
        // Find the number of zones (zone Inlet Nodes) attached to an air loop from the air loop number
        if (this->m_AirLoopEquipment && this->m_ControlType != ControlType::Setpoint) {
            if (allocated(state.dataAirLoop->AirToZoneNodeInfo))
                NumAirLoopZones =
                    state.dataAirLoop->AirToZoneNodeInfo(AirLoopNum).NumZonesCooled + state.dataAirLoop->AirToZoneNodeInfo(AirLoopNum).NumZonesHeated;
            if (allocated(state.dataAirLoop->AirToZoneNodeInfo)) {
                state.dataUnitarySystems->initLoadBasedControlFlowFracFlagReady = true;
                for (ZoneInSysIndex = 1; ZoneInSysIndex <= NumAirLoopZones; ++ZoneInSysIndex) {
                    // zone inlet nodes for cooling
                    if (state.dataAirLoop->AirToZoneNodeInfo(AirLoopNum).NumZonesCooled > 0) {
                        if (state.dataAirLoop->AirToZoneNodeInfo(AirLoopNum).TermUnitCoolInletNodes(ZoneInSysIndex) == -999) {
                            // the data structure for the zones inlet nodes has not been filled
                            state.dataUnitarySystems->initLoadBasedControlFlowFracFlagReady = false;
                        }
                    }
                    // zone inlet nodes for heating
                    if (state.dataAirLoop->AirToZoneNodeInfo(AirLoopNum).NumZonesHeated > 0) {
                        if (state.dataAirLoop->AirToZoneNodeInfo(AirLoopNum).TermUnitHeatInletNodes(ZoneInSysIndex) == -999) {
                            // the data structure for the zones inlet nodes has not been filled
                            state.dataUnitarySystems->initLoadBasedControlFlowFracFlagReady = false;
                        }
                    }
                }
            }
            if (allocated(state.dataAirLoop->AirToZoneNodeInfo) && state.dataUnitarySystems->initLoadBasedControlFlowFracFlagReady) {
                SumOfMassFlowRateMax = 0.0; // initialize the sum of the maximum flows
                for (ZoneInSysIndex = 1; ZoneInSysIndex <= NumAirLoopZones; ++ZoneInSysIndex) {
                    ZoneInletNodeNum = state.dataAirLoop->AirToZoneNodeInfo(AirLoopNum).TermUnitCoolInletNodes(ZoneInSysIndex);
                    SumOfMassFlowRateMax += state.dataLoopNodes->Node(ZoneInletNodeNum).MassFlowRateMax;
                    if (state.dataAirLoop->AirToZoneNodeInfo(AirLoopNum).CoolCtrlZoneNums(ZoneInSysIndex) == this->ControlZoneNum) {
                        state.dataUnitarySystems->initLoadBasedControlCntrlZoneTerminalUnitMassFlowRateMax =
                            state.dataLoopNodes->Node(ZoneInletNodeNum).MassFlowRateMax;
                    }
                }
                if (SumOfMassFlowRateMax != 0.0) {
                    if (state.dataUnitarySystems->initLoadBasedControlCntrlZoneTerminalUnitMassFlowRateMax >= DataHVACGlobals::SmallAirVolFlow) {
                        this->ControlZoneMassFlowFrac =
                            state.dataUnitarySystems->initLoadBasedControlCntrlZoneTerminalUnitMassFlowRateMax / SumOfMassFlowRateMax;
                    } else {
                        ShowSevereError(state, this->UnitType + " = " + this->Name);
                        ShowContinueError(state, " The Fraction of Supply Air Flow That Goes Through the Controlling Zone is set to 1.");
                        this->ControlZoneMassFlowFrac = 1.0;
                    }
                    this->m_SmallLoadTolerance = 5.0 / this->ControlZoneMassFlowFrac; // adjust 5W load tolerance by control zone fraction
                    BaseSizer::reportSizerOutput(state,
                                                 this->UnitType,
                                                 this->Name,
                                                 "Fraction of Supply Air Flow That Goes Through the Controlling Zone",
                                                 this->ControlZoneMassFlowFrac);
                }
            }
        } else {
            this->ControlZoneMassFlowFrac = 1.0;
        }

        if (this->m_ControlType == ControlType::CCMASHRAE) {

            SizingDesRunThisSys = false;
            state.dataSize->DataZoneUsedForSizing = this->ControlZoneNum;
            CheckThisZoneForSizing(state, state.dataSize->DataZoneUsedForSizing, SizingDesRunThisSys);

            capacityMultiplier = 0.5; // one-half of design zone load
            if (SizingDesRunThisSys) {
                state.dataSize->DataCapacityUsedForSizing = state.dataSize->FinalZoneSizing(this->ControlZoneNum).DesCoolLoad * capacityMultiplier;
            } else {
                state.dataSize->DataCapacityUsedForSizing = this->m_DesignCoolingCapacity * capacityMultiplier;
            }
            state.dataSize->DataCapacityUsedForSizing /= this->ControlZoneMassFlowFrac;
            state.dataSize->DataFlowUsedForSizing = this->m_MaxNoCoolHeatAirVolFlow;
            ASHRAEMinSATCoolingSizer sizerASHRAEMinSATCooling;
            std::string stringOverride = "Minimum Supply Air Temperature [C]";
            if (state.dataGlobal->isEpJSON) stringOverride = "minimum_supply_air_temperature [C]";
            sizerASHRAEMinSATCooling.overrideSizingString(stringOverride);
            sizerASHRAEMinSATCooling.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
            this->DesignMinOutletTemp = sizerASHRAEMinSATCooling.size(state, this->DesignMinOutletTemp, ErrFound);

            if (SizingDesRunThisSys) {
                state.dataSize->DataCapacityUsedForSizing = state.dataSize->FinalZoneSizing(this->ControlZoneNum).DesHeatLoad * capacityMultiplier;
            } else {
                state.dataSize->DataCapacityUsedForSizing = this->m_DesignHeatingCapacity * capacityMultiplier;
            }
            state.dataSize->DataCapacityUsedForSizing /= this->ControlZoneMassFlowFrac;
            state.dataSize->DataFlowUsedForSizing = this->m_MaxNoCoolHeatAirVolFlow;
            ASHRAEMaxSATHeatingSizer sizerASHRAEMaxSATHeating;
            stringOverride = "Maximum Supply Air Temperature [C]";
            if (state.dataGlobal->isEpJSON) stringOverride = "maximum_supply_air_temperature [C]";
            sizerASHRAEMaxSATHeating.overrideSizingString(stringOverride);
            sizerASHRAEMaxSATHeating.initializeWithinEP(state, CompType, CompName, PrintFlag, RoutineName);
            this->DesignMaxOutletTemp = sizerASHRAEMaxSATHeating.size(state, this->DesignMaxOutletTemp, ErrFound);

            state.dataSize->DataCapacityUsedForSizing = 0.0; // reset so other routines don't use this inadvertently
            state.dataSize->DataFlowUsedForSizing = 0.0;
            state.dataSize->DataZoneUsedForSizing = 0;

            // check that MaxNoCoolHeatAirVolFlow is less than both MaxCoolAirVolFlow and MaxHeatAirVolFlow
            if (this->m_MaxNoCoolHeatAirVolFlow >= this->m_MaxCoolAirVolFlow || this->m_MaxNoCoolHeatAirVolFlow >= this->m_MaxHeatAirVolFlow) {
                ShowSevereError(state, this->UnitType + " = " + this->Name);
                ShowContinueError(state,
                                  " For SingleZoneVAV control the No Load Supply Air Flow Rate must be less than both the cooling and heating supply "
                                  "air flow rates.");
                this->m_MaxNoCoolHeatAirVolFlow = min(this->m_MaxCoolAirVolFlow, this->m_MaxHeatAirVolFlow) - 0.01;
                ShowContinueError(state,
                                  format(" The SingleZoneVAV control No Load Supply Air Flow Rate is reset to {:.5T} and the simulation continues.",
                                         this->m_MaxNoCoolHeatAirVolFlow));
            }
        }

        state.dataUnitarySystems->CoolingLoad = TempCoolingLoad;
        state.dataUnitarySystems->HeatingLoad = TempHeatingLoad;
        // if (++NumUnitarySystemsSized == NumUnitarySystem)
        //    UnitarySystemNumericFields.deallocate(); // remove temporary array for field names at end of sizing
    }

    void UnitarySys::processInputSpec(EnergyPlusData &state,
                                      const UnitarySysInputSpec &input_data,
                                      int sysNum,
                                      bool &errorsFound,
                                      bool const ZoneEquipment,
                                      int const ZoneOAUnitNum)
    {

        static constexpr std::string_view unitarySysHeatPumpPerformanceObjectType("UnitarySystemPerformance:Multispeed");

        std::string cCurrentModuleObject = input_data.system_type;
        std::string thisObjectName = input_data.name;
        this->Name = UtilityRoutines::MakeUPPERCase(thisObjectName);
        sysNum = getUnitarySystemIndex(state, thisObjectName);
        this->m_UnitarySysNum = sysNum;

        std::string loc_AirInNodeName = input_data.air_inlet_node_name;
        if (state.dataUnitarySystems->getInputOnceFlag) {
            this->AirInNode = NodeInputManager::GetOnlySingleNode(state,
                                                                  loc_AirInNodeName,
                                                                  errorsFound,
                                                                  cCurrentModuleObject,
                                                                  thisObjectName,
                                                                  DataLoopNode::NodeFluidType::Air,
                                                                  DataLoopNode::NodeConnectionType::Inlet,
                                                                  NodeInputManager::compFluidStream::Primary,
                                                                  DataLoopNode::ObjectIsParent);
        } else {
            this->AirInNode = UtilityRoutines::FindItemInList(loc_AirInNodeName, state.dataLoopNodes->NodeID);
        }

        std::string loc_AirOutNodeName = input_data.air_outlet_node_name;
        if (state.dataUnitarySystems->getInputOnceFlag) {
            this->AirOutNode = NodeInputManager::GetOnlySingleNode(state,
                                                                   loc_AirOutNodeName,
                                                                   errorsFound,
                                                                   cCurrentModuleObject,
                                                                   thisObjectName,
                                                                   DataLoopNode::NodeFluidType::Air,
                                                                   DataLoopNode::NodeConnectionType::Outlet,
                                                                   NodeInputManager::compFluidStream::Primary,
                                                                   DataLoopNode::ObjectIsParent);
        } else {
            this->AirOutNode = UtilityRoutines::FindItemInList(loc_AirOutNodeName, state.dataLoopNodes->NodeID);
        }

        // need to read in all information needed to SetupOutputVariable in setupAllOutputVars
        // as soon as all systems are read in, regardless if all information is available, reports will be set up.
        // make sure we have all the information needed to process reports (see IF blocks in setupAllOutputVars).
        // all coil types, which comps exist, control type, heat recovery active, cooling coil index.
        bool errFlag = false;
        bool PrintMessage = false;

        std::string loc_m_DesignSpecMultispeedHPType = input_data.design_specification_multispeed_object_type;
        std::string loc_m_DesignSpecMultispeedHPName = input_data.design_specification_multispeed_object_name;
        if (loc_m_DesignSpecMultispeedHPType != "" && loc_m_DesignSpecMultispeedHPName != "") {
            this->m_DesignSpecMultispeedHPType = loc_m_DesignSpecMultispeedHPType;
            this->m_DesignSpecMultispeedHPName = loc_m_DesignSpecMultispeedHPName;
            int designSpecType_Num = 1;

            DesignSpecMSHP thisDesignSpec;
            this->m_CompPointerMSHP = thisDesignSpec.factory(state, designSpecType_Num, loc_m_DesignSpecMultispeedHPName);
            this->m_DesignSpecMSHPIndex = getDesignSpecMSHPIndex(state, this->m_DesignSpecMultispeedHPName);
        }

        // these are needed for call from GetOASysNumHeat(Cool)ingCoils
        std::string loc_heatingCoilType = input_data.heating_coil_object_type;
        if (loc_heatingCoilType.size() > 0) {
            this->m_HeatCoilExists = true;
        }
        std::string loc_m_HeatingCoilName = input_data.heating_coil_name;
        if (this->m_HeatCoilExists && this->m_HeatingCoilType_Num == 0) {
            if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:DX:VariableSpeed")) {
                this->m_HeatingCoilType_Num = DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed;
            } else if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:DX:MultiSpeed")) {
                this->m_HeatingCoilType_Num = DataHVACGlobals::CoilDX_MultiSpeedHeating;
            } else if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:Water")) {
                this->m_HeatingCoilType_Num = DataHVACGlobals::Coil_HeatingWater;
                if (this->m_DesignSpecMSHPIndex > -1) {
                    this->m_NumOfSpeedHeating = this->m_CompPointerMSHP->numOfSpeedHeating;
                    if (this->m_NumOfSpeedHeating > 1) {
                        this->m_MultiSpeedHeatingCoil = true;
                        this->m_MultiOrVarSpeedHeatCoil = true;
                    }
                }
            } else if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:Steam")) {
                this->m_HeatingCoilType_Num = DataHVACGlobals::Coil_HeatingSteam;
            } else if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:WaterToAirHeatPump:EquationFit")) {
                this->m_HeatingCoilType_Num = DataHVACGlobals::Coil_HeatingWaterToAirHPSimple;
            } else if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:WaterToAirHeatPump:ParameterEstimation")) {
                this->m_HeatingCoilType_Num = DataHVACGlobals::Coil_HeatingWaterToAirHP;
            } else if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:WaterToAirHeatPump:VariableSpeedEquationFit")) {
                this->m_HeatingCoilType_Num = DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit;
            } else if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:Electric:MultiStage")) {
                this->m_HeatingCoilType_Num = DataHVACGlobals::Coil_HeatingElectric_MultiStage;
            } else if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:Gas:MultiStage")) {
                this->m_HeatingCoilType_Num = DataHVACGlobals::Coil_HeatingGas_MultiStage;
            } else if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:Fuel") ||
                       UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:Electric") ||
                       UtilityRoutines::SameString(loc_heatingCoilType, "Coil:Heating:Desuperheater")) {
                this->m_HeatingCoilType_Num = HeatingCoils::GetHeatingCoilTypeNum(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
            } else if (UtilityRoutines::SameString(loc_heatingCoilType, "Coil:UserDefined")) {
                this->m_HeatingCoilType_Num = DataHVACGlobals::Coil_UserDefined;
            } else if (this->m_HeatCoilExists) {
                this->m_HeatingCoilType_Num = DXCoils::GetCoilTypeNum(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag, PrintMessage);
            }

            if (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingElectric_MultiStage ||
                this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingGas_MultiStage) {
                this->m_MultiSpeedHeatingCoil = true;
            } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit ||
                       this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) {
                this->m_VarSpeedHeatingCoil = true;
            }
        }

        std::string loc_coolingCoilType = input_data.cooling_coil_object_type;
        if (loc_coolingCoilType.size() > 0) { // not required field
            this->m_CoolCoilExists = true;
        }
        std::string loc_m_CoolingCoilName = input_data.cooling_coil_name;
        // Find the type of coil. do not print message since this may not be the correct coil type.
        errFlag = false;
        if (this->m_CoolCoilExists && this->m_CoolingCoilType_Num == 0) {
            if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:DX:VariableSpeed")) {
                this->m_CoolingCoilType_Num = DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed;
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:DX:MultiSpeed")) {
                this->m_CoolingCoilType_Num = DataHVACGlobals::CoilDX_MultiSpeedCooling;
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:Water")) {
                this->m_IsDXCoil = false;
                this->m_CoolingCoilType_Num = DataHVACGlobals::Coil_CoolingWater;
                if (this->m_DesignSpecMSHPIndex > -1) {
                    this->m_NumOfSpeedCooling = this->m_CompPointerMSHP->numOfSpeedCooling;
                    if (this->m_NumOfSpeedCooling > 1) {
                        this->m_DiscreteSpeedCoolingCoil = true;
                        this->m_MultiOrVarSpeedCoolCoil = true;
                    }
                }
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:Water:DetailedGeometry")) {
                this->m_IsDXCoil = false;
                this->m_CoolingCoilType_Num = DataHVACGlobals::Coil_CoolingWaterDetailed;
                if (this->m_DesignSpecMSHPIndex > -1) {
                    this->m_NumOfSpeedCooling = this->m_CompPointerMSHP->numOfSpeedCooling;
                    if (this->m_NumOfSpeedCooling > 1) {
                        this->m_DiscreteSpeedCoolingCoil = true;
                        this->m_MultiOrVarSpeedCoolCoil = true;
                    }
                }
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:DX:TwoStageWithHumidityControlMode")) {
                this->m_CoolingCoilType_Num = DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl;
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "CoilSystem:Cooling:DX:HeatExchangerAssisted")) {
                this->m_CoolingCoilType_Num =
                    HVACHXAssistedCoolingCoil::GetCoilGroupTypeNum(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag, PrintMessage);
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "CoilSystem:Cooling:Water:HeatExchangerAssisted")) {
                this->m_IsDXCoil = false;
                this->m_CoolingCoilType_Num =
                    HVACHXAssistedCoolingCoil::GetCoilGroupTypeNum(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag, PrintMessage);
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:WaterToAirHeatPump:EquationFit")) {
                this->m_CoolingCoilType_Num = DataHVACGlobals::Coil_CoolingWaterToAirHPSimple;
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:WaterToAirHeatPump:ParameterEstimation")) {
                this->m_CoolingCoilType_Num = DataHVACGlobals::Coil_CoolingWaterToAirHP;
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:WaterToAirHeatPump:VariableSpeedEquationFit")) {
                this->m_CoolingCoilType_Num = DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit;
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:DX:SingleSpeed")) {
                this->m_CoolingCoilType_Num = DataHVACGlobals::CoilDX_CoolingSingleSpeed;
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:DX:TwoSpeed")) {
                this->m_CoolingCoilType_Num = DataHVACGlobals::CoilDX_CoolingTwoSpeed;
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:UserDefined")) {
                this->m_IsDXCoil = false;
                this->m_CoolingCoilType_Num = DataHVACGlobals::Coil_UserDefined;
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:DX:SingleSpeed:ThermalStorage")) {
                this->m_CoolingCoilType_Num = DataHVACGlobals::CoilDX_PackagedThermalStorageCooling;
            } else if (UtilityRoutines::SameString(loc_coolingCoilType, "Coil:Cooling:DX")) { // CoilCoolingDX
                this->m_CoolingCoilType_Num = DataHVACGlobals::CoilDX_Cooling;
                this->m_CoolingCoilIndex = CoilCoolingDX::factory(state, loc_m_CoolingCoilName);
                if (this->m_CoolingCoilIndex == -1) {
                    ShowFatalError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                } else {
                    // set variable speed coil flag as necessary
                    auto &newCoil = state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex];
                    this->m_NumOfSpeedCooling = (int)newCoil.performance.normalMode.speeds.size();
                    if (this->m_NumOfSpeedCooling > 1) {
                        if (newCoil.performance.capControlMethod == CoilCoolingDXCurveFitPerformance::CapControlMethod::DISCRETE) {
                            this->m_DiscreteSpeedCoolingCoil = true;
                        } else if (newCoil.performance.capControlMethod == CoilCoolingDXCurveFitPerformance::CapControlMethod::CONTINUOUS) {
                            this->m_ContSpeedCoolingCoil = true;
                        }
                        this->m_MultiOrVarSpeedCoolCoil = true;
                    }
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Illegal Cooling Coil Object Type = " + loc_coolingCoilType);
            }

            if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling) {
                this->m_DiscreteSpeedCoolingCoil = true;
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit ||
                       this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {
                this->m_ContSpeedCoolingCoil = true;
            }
        }

        std::string loc_suppHeatCoilType = input_data.supplemental_heating_coil_object_type;
        if (input_data.supplemental_heating_coil_object_type.size() > 0) {
            this->m_SuppCoilExists = true;
        }

        if (input_data.supply_fan_object_type.size() > 0 && input_data.supply_fan_name.size() > 0) {
            this->m_FanExists = true;
        }

        std::string loc_m_ControlType = input_data.control_type;

        if (UtilityRoutines::SameString(loc_m_ControlType, "Load")) {
            this->m_ControlType = ControlType::Load;
        } else if (UtilityRoutines::SameString(loc_m_ControlType, "SetPoint")) {
            this->m_ControlType = ControlType::Setpoint;
        } else if (UtilityRoutines::SameString(loc_m_ControlType, "SingleZoneVAV")) {
            this->m_ControlType = ControlType::CCMASHRAE;
            this->m_ValidASHRAECoolCoil = true;
            this->m_ValidASHRAEHeatCoil = true;
        } else {
            ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
            ShowContinueError(state, "Invalid Control Type = " + loc_m_ControlType);
            errorsFound = true;
        }

        Real64 loc_m_DesignHRWaterVolumeFlow = input_data.design_heat_recovery_water_flow_rate;
        this->m_DesignHRWaterVolumeFlow = loc_m_DesignHRWaterVolumeFlow;
        if (this->m_DesignHRWaterVolumeFlow > 0.0) {
            this->m_HeatRecActive = true;
        }

        // Early calls to ATMixer don't have enough info to pass GetInput. Need to get the data next time through.
        if (sysNum == -1 || !state.dataZoneEquip->ZoneEquipInputsFilled) {
            return;
        }

        if (ZoneEquipment) {
            this->UnitarySystemType_Num = DataZoneEquipment::ZoneUnitarySys_Num;
            this->m_OKToPrintSizing = true;
        } else {
            this->UnitarySystemType_Num = static_cast<int>(SimAirServingZones::CompType::UnitarySystemModel);
        }

        this->m_IterationMode.resize(3);

        Real64 loc_m_HeatingSizingRatio = input_data.dx_heating_coil_sizing_ratio;
        std::string loc_m_ISHundredPercentDOASDXCoil = input_data.use_doas_dx_cooling_coil;
        Real64 loc_DesignMinOutletTemp = input_data.minimum_supply_air_temperature;
        std::string loc_latentControlFlag = input_data.latent_load_control;
        std::string loc_m_SuppHeatCoilName = input_data.supplemental_heating_coil_name;
        std::string loc_m_CoolingSAFMethod = input_data.cooling_supply_air_flow_rate_method;
        Real64 loc_m_CoolingSAFMethod_SAFlow = input_data.cooling_supply_air_flow_rate;
        Real64 loc_m_CoolingSAFMethod_SAFlowPerFloorArea = input_data.cooling_supply_air_flow_rate_per_floor_area;
        Real64 loc_m_CoolingSAFMethod_FracOfAutosizedCoolingSAFlow = input_data.cooling_fraction_of_autosized_cooling_supply_air_flow_rate;
        Real64 loc_m_CoolingSAFMethod_FlowPerCoolingCapacity = input_data.cooling_supply_air_flow_rate_per_unit_of_capacity;
        std::string loc_m_HeatingSAFMethod = input_data.heating_supply_air_flow_rate_method;
        Real64 loc_m_HeatingSAFMethod_SAFlow = input_data.heating_supply_air_flow_rate;
        Real64 loc_m_HeatingSAFMethod_SAFlowPerFloorArea = input_data.heating_supply_air_flow_rate_per_floor_area;
        Real64 loc_m_HeatingSAFMethod_FracOfAutosizedHeatingSAFlow = input_data.heating_fraction_of_autosized_heating_supply_air_flow_rate;
        Real64 loc_m_HeatingSAFMethod_FlowPerHeatingCapacity = input_data.heating_supply_air_flow_rate_per_unit_of_capacity;
        std::string loc_m_NoCoolHeatSAFMethod = input_data.no_load_supply_air_flow_rate_method;
        Real64 loc_m_NoCoolHeatSAFMethod_SAFlow = input_data.no_load_supply_air_flow_rate;
        Real64 loc_m_NoCoolHeatSAFMethod_SAFlowPerFloorArea = input_data.no_load_supply_air_flow_rate_per_floor_area;
        Real64 loc_m_NoCoolHeatSAFMethod_FracOfAutosizedCoolingSAFlow = input_data.no_load_fraction_of_autosized_cooling_supply_air_flow_rate;
        Real64 loc_m_NoCoolHeatSAFMethod_FracOfAutosizedHeatingSAFlow = input_data.no_load_fraction_of_autosized_heating_supply_air_flow_rate;
        Real64 loc_m_NoCoolHeatSAFMethod_FlowPerCoolingCapacity =
            input_data.no_load_supply_air_flow_rate_per_unit_of_capacity_during_cooling_operation;
        Real64 loc_m_NoCoolHeatSAFMethod_FlowPerHeatingCapacity =
            input_data.no_load_supply_air_flow_rate_per_unit_of_capacity_during_heating_operation;
        Real64 loc_DesignMaxOutletTemp = input_data.maximum_supply_air_temperature;
        Real64 loc_m_MaxOATSuppHeat = input_data.maximum_outdoor_dry_bulb_temperature_for_supplemental_heater_operation;
        std::string loc_condenserInletNodeName = input_data.outdoor_dry_bulb_temperature_sensor_node_name;
        Real64 loc_m_MaxONOFFCyclesperHour = input_data.maximum_cycling_rate;
        Real64 loc_m_HPTimeConstant = input_data.heat_pump_time_constant;
        Real64 loc_m_OnCyclePowerFraction = input_data.fraction_of_on_cycle_power_use;
        Real64 loc_m_FanDelayTime = input_data.heat_pump_fan_delay_time;
        Real64 loc_m_AncillaryOnPower = input_data.ancillary_on_cycle_electric_power;
        Real64 loc_m_AncillaryOffPower = input_data.ancillary_off_cycle_electric_power;
        Real64 loc_m_MaxHROutletWaterTemp = input_data.maximum_temperature_for_heat_recovery;
        std::string loc_heatRecoveryInletNodeName = input_data.heat_recovery_water_inlet_node_name;
        std::string loc_heatRecoveryOutletNodeName = input_data.heat_recovery_water_outlet_node_name;

        std::string loc_m_SystemCoolControlNodeName = input_data.dx_cooling_coil_system_sensor_node_name;

        int FanInletNode = 0;
        int FanOutletNode = 0;
        Real64 FanVolFlowRate = 0.0;
        int CoolingCoilInletNode = 0;
        int CoolingCoilOutletNode = 0;
        int HeatingCoilInletNode = 0;
        int HeatingCoilOutletNode = 0;
        int SupHeatCoilInletNode = 0;
        int SupHeatCoilOutletNode = 0;

        bool isNotOK = false;

        std::string loc_sysAvailSched = input_data.availability_schedule_name;
        if (loc_sysAvailSched.size() > 0) {
            this->m_SysAvailSchedPtr = ScheduleManager::GetScheduleIndex(state, loc_sysAvailSched);
            if (this->m_SysAvailSchedPtr == 0) {
                ShowWarningError(state,
                                 "getUnitarySystemInputData" + cCurrentModuleObject + "=\"" + this->Name + "\", invalid Availability Schedule Name" +
                                     " = " + loc_sysAvailSched);
                ShowContinueError(state, "Set the default as Always On. Simulation continues.");
                this->m_SysAvailSchedPtr = DataGlobalConstants::ScheduleAlwaysOn;
            }
        } else {
            this->m_SysAvailSchedPtr = DataGlobalConstants::ScheduleAlwaysOn;
        }

        std::string loc_controlZoneName = input_data.controlling_zone_or_thermostat_location;
        if (loc_controlZoneName.size() > 0) { // not required field
            this->ControlZoneNum = UtilityRoutines::FindItemInList(loc_controlZoneName, state.dataHeatBal->Zone);
        } else if (this->m_ControlType == ControlType::Load || this->m_ControlType == ControlType::CCMASHRAE) {
            ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
            ShowContinueError(state, "Controlling Zone or Thermostat Location cannot be blank when Control Type = Load or SingleZoneVAV");
            errorsFound = true;
        }

        // check that control zone name is valid for load based control
        if (this->m_ControlType == ControlType::Load || this->m_ControlType == ControlType::CCMASHRAE) {
            if (this->ControlZoneNum == 0) {
                ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
                ShowContinueError(state, "When Control Type = Load or SingleZoneVAV");
                ShowContinueError(state, " Controlling Zone or Thermostat Location must be a valid zone name, zone name = " + loc_controlZoneName);
                errorsFound = true;
            }
        }

        std::string loc_dehumm_ControlType = input_data.dehumidification_control_type;
        if (UtilityRoutines::SameString(loc_dehumm_ControlType, "None")) {
            this->m_DehumidControlType_Num = DehumCtrlType::None;
            this->m_Humidistat = false;
        } else if (UtilityRoutines::SameString(loc_dehumm_ControlType, "CoolReheat")) {
            this->m_DehumidControlType_Num = DehumCtrlType::CoolReheat;
            this->m_Humidistat = true;
        } else if (UtilityRoutines::SameString(loc_dehumm_ControlType, "Multimode")) {
            this->m_DehumidControlType_Num = DehumCtrlType::Multimode;
            this->m_Humidistat = true;
        } else {
            ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
            ShowContinueError(state, "Illegal dehumidification control type = " + loc_dehumm_ControlType);
            this->m_Humidistat = false;
            errorsFound = true;
        }
        if (this->m_Humidistat && this->m_ControlType == ControlType::Load) {
            bool AirNodeFound = false;
            for (int HStatZoneNum = 1; HStatZoneNum <= state.dataZoneCtrls->NumHumidityControlZones; ++HStatZoneNum) {
                if (state.dataZoneCtrls->HumidityControlZone(HStatZoneNum).ActualZoneNum != this->ControlZoneNum) continue;
                AirNodeFound = true;
            }
            if (!AirNodeFound && this->ControlZoneNum > 0) {
                ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
                ShowContinueError(state, "Did not find Air Node (Zone with Humidistat).");
                ShowContinueError(state, "specified Controlling Zone or Thermostat Location name = " + loc_controlZoneName);
                errorsFound = true;
            }
        }

        Real64 TotalFloorAreaOnAirLoop = 0.0;
        int AirLoopNumber = 0;
        bool AirNodeFound = false;
        bool AirLoopFound = false;
        bool OASysFound = false;
        bool ZoneEquipmentFound = false;
        bool ZoneInletNodeFound = false;
        bool ZoneExhaustNodeFound = false;
        bool InducedNodeFound = false;

        // Get AirTerminal mixer data
        SingleDuct::GetATMixer(state,
                               thisObjectName,
                               this->m_ATMixerName,
                               this->m_ATMixerIndex,
                               this->ATMixerType,
                               this->m_ATMixerPriNode,
                               this->m_ATMixerSecNode,
                               this->ATMixerOutNode,
                               this->AirOutNode);
        if (this->ATMixerType == DataHVACGlobals::ATMixer_InletSide || this->ATMixerType == DataHVACGlobals::ATMixer_SupplySide) {
            this->ATMixerExists = true;
        }

        // if part of ZoneHVAC:OutdoorAirUnit bypass most checks for connection to air loop or OASystem
        if (ZoneOAUnitNum > 0) OASysFound = true;

        if (!AirLoopFound && !OASysFound) {
            int ControlledZoneNum = 0;
            int ZoneExhNum = 0;

            if (!this->ATMixerExists) {
                ZoneExhaustNodeFound = searchExhaustNodes(state, this->AirInNode, ControlledZoneNum, ZoneExhNum);
                if (ZoneExhaustNodeFound) {
                    ZoneEquipmentFound = true;
                    // The Node was found among the exhaust nodes, now check that a matching inlet node exists
                    this->m_ZoneInletNode = state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).ExhaustNode(ZoneExhNum);
                    this->ControlZoneNum = ControlledZoneNum;
                    this->setSystemParams(state, TotalFloorAreaOnAirLoop, thisObjectName);
                    ZoneInletNodeFound = searchZoneInletNodesByEquipmentIndex(state, this->AirOutNode, this->ControlZoneNum);
                } else { // find if the inlet node is an induced node from zone plenum
                    int ZoneInletNum = 0;
                    ZoneInletNodeFound = searchZoneInletNodes(state, this->AirOutNode, this->ControlZoneNum, ZoneInletNum);
                    if (ZoneInletNodeFound) {
                        InducedNodeFound = ZonePlenum::ValidateInducedNode(state,
                                                                           this->AirInNode,
                                                                           state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).NumReturnNodes,
                                                                           state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).ReturnNode);
                        if (InducedNodeFound) {
                            this->m_ZoneInletNode = this->AirOutNode;
                            ZoneEquipmentFound = true;
                            this->setSystemParams(state, TotalFloorAreaOnAirLoop, thisObjectName);
                        }
                    }
                }
            } else if (this->ATMixerType == DataHVACGlobals::ATMixer_InletSide) {
                ZoneExhaustNodeFound = searchExhaustNodes(state, this->m_ATMixerSecNode, ControlledZoneNum, ZoneExhNum);
                if (ZoneExhaustNodeFound) {
                    ZoneEquipmentFound = true;
                    this->m_ZoneInletNode = this->AirOutNode;
                    this->ControlZoneNum = ControlledZoneNum;
                    this->setSystemParams(state, TotalFloorAreaOnAirLoop, thisObjectName);
                    // The Node was found among the exhaust nodes, now check that a matching inlet node exists
                    ZoneInletNodeFound = searchZoneInletNodesByEquipmentIndex(state, this->AirOutNode, this->ControlZoneNum);
                } else {
                    int ZoneInletNum = 0;
                    ZoneInletNodeFound = searchZoneInletNodes(state, this->AirOutNode, this->ControlZoneNum, ZoneInletNum);
                    if (ZoneInletNodeFound) {
                        InducedNodeFound = ZonePlenum::ValidateInducedNode(state,
                                                                           this->m_ATMixerSecNode,
                                                                           state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).NumReturnNodes,
                                                                           state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).ReturnNode);
                        if (InducedNodeFound) {
                            this->m_ZoneInletNode = this->AirOutNode;
                            ZoneEquipmentFound = true;
                            this->setSystemParams(state, TotalFloorAreaOnAirLoop, thisObjectName);
                        }
                    }
                }
            } else if (this->ATMixerType == DataHVACGlobals::ATMixer_SupplySide) {
                ZoneExhaustNodeFound = searchExhaustNodes(state, this->AirInNode, ControlledZoneNum, ZoneExhNum);
                if (ZoneExhaustNodeFound) {
                    ZoneEquipmentFound = true;
                    this->m_ZoneInletNode = this->ATMixerOutNode;
                    this->ControlZoneNum = ControlledZoneNum;
                    this->setSystemParams(state, TotalFloorAreaOnAirLoop, thisObjectName);
                    // The Node was found among the exhaust nodes, now check that a matching inlet node exists
                    ZoneInletNodeFound = searchZoneInletNodesByEquipmentIndex(state, this->ATMixerOutNode, this->ControlZoneNum);
                } else {
                    int ZoneInletNum = 0;
                    ZoneInletNodeFound = searchZoneInletNodes(state, this->ATMixerOutNode, this->ControlZoneNum, ZoneInletNum);
                    if (ZoneInletNodeFound) {
                        InducedNodeFound = ZonePlenum::ValidateInducedNode(state,
                                                                           this->AirInNode,
                                                                           state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).NumReturnNodes,
                                                                           state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).ReturnNode);
                        if (InducedNodeFound) {
                            this->m_ZoneInletNode = this->ATMixerOutNode;
                            ZoneEquipmentFound = true;
                            this->setSystemParams(state, TotalFloorAreaOnAirLoop, thisObjectName);
                        }
                    }
                }
            }
        }

        if (!ZoneEquipmentFound) {
            // check if the UnitarySystem is connected to an air loop

            int compIndex;
            int branchIndex;
            AirLoopFound = searchTotalComponents(state, thisObjectName, compIndex, branchIndex, AirLoopNumber);
            if (AirLoopFound) {
                for (int ControlledZoneNum = 1; ControlledZoneNum <= state.dataGlobal->NumOfZones; ++ControlledZoneNum) {
                    if (state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).ActualZoneNum != this->ControlZoneNum) continue;
                    //             Find the controlled zone number for the specified thermostat location
                    this->NodeNumOfControlledZone = state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).ZoneNode;

                    //             Determine if system is on air loop served by the thermostat location specified
                    ZoneInletNodeFound = false;
                    int ZoneInletNum = 0;
                    ZoneInletNodeFound = searchZoneInletNodeAirLoopNum(state, AirLoopNumber, ControlledZoneNum, ZoneInletNum);
                    if (ZoneInletNodeFound) {
                        this->m_ZoneInletNode = state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).InletNode(ZoneInletNum);
                        TotalFloorAreaOnAirLoop +=
                            state.dataHeatBal->Zone(state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).ActualZoneNum).FloorArea;
                    }

                    // if (this->m_ZoneInletNode == 0) AirLoopFound = false;
                    for (int TstatZoneNum = 1; TstatZoneNum <= state.dataZoneCtrls->NumTempControlledZones; ++TstatZoneNum) {
                        if (state.dataZoneCtrls->TempControlledZone(TstatZoneNum).ActualZoneNum != this->ControlZoneNum) continue;
                        AirNodeFound = true;
                    }
                    for (int TstatZoneNum = 1; TstatZoneNum <= state.dataZoneCtrls->NumComfortControlledZones; ++TstatZoneNum) {
                        if (state.dataZoneCtrls->ComfortControlledZone(TstatZoneNum).ActualZoneNum != this->ControlZoneNum) continue;
                        AirNodeFound = true;
                    }
                    if (!AirNodeFound && this->ControlZoneNum > 0) {
                        ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
                        ShowContinueError(state, "Did not find Air Node (Zone with Thermostat or Thermal Comfort Thermostat).");
                        ShowContinueError(state, "specified Controlling Zone or Thermostat Location name = " + loc_controlZoneName);
                        errorsFound = true;
                    }
                }
            }

            for (int AirLoopNum = 1; AirLoopNum <= state.dataHVACGlobal->NumPrimaryAirSys; ++AirLoopNum) {
                for (int BranchNum = 1; BranchNum <= state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).NumBranches; ++BranchNum) {
                    for (int CompNum = 1; CompNum <= state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).Branch(BranchNum).TotalComponents;
                         ++CompNum) {
                        if (UtilityRoutines::SameString(state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).Branch(BranchNum).Comp(CompNum).Name,
                                                        thisObjectName) &&
                            UtilityRoutines::SameString(
                                state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).Branch(BranchNum).Comp(CompNum).TypeOf,
                                cCurrentModuleObject)) {
                            AirLoopNumber = AirLoopNum;
                            AirLoopFound = true;
                            for (int ControlledZoneNum = 1; ControlledZoneNum <= state.dataGlobal->NumOfZones; ++ControlledZoneNum) {
                                if (state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).ActualZoneNum != this->ControlZoneNum) continue;
                                //             Find the controlled zone number for the specified thermostat location
                                this->NodeNumOfControlledZone = state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).ZoneNode;

                                //             Determine if system is on air loop served by the thermostat location specified
                                ZoneInletNodeFound = false;
                                int ZoneInletNum = 0;
                                ZoneInletNodeFound = searchZoneInletNodeAirLoopNum(state, AirLoopNumber, ControlledZoneNum, ZoneInletNum);
                                if (ZoneInletNodeFound) {
                                    this->m_ZoneInletNode = state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).InletNode(ZoneInletNum);
                                    TotalFloorAreaOnAirLoop +=
                                        state.dataHeatBal->Zone(state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).ActualZoneNum).FloorArea;
                                }

                                // if (this->m_ZoneInletNode == 0) AirLoopFound = false;
                                for (int TstatZoneNum = 1; TstatZoneNum <= state.dataZoneCtrls->NumTempControlledZones; ++TstatZoneNum) {
                                    if (state.dataZoneCtrls->TempControlledZone(TstatZoneNum).ActualZoneNum != this->ControlZoneNum) continue;
                                    AirNodeFound = true;
                                }
                                for (int TstatZoneNum = 1; TstatZoneNum <= state.dataZoneCtrls->NumComfortControlledZones; ++TstatZoneNum) {
                                    if (state.dataZoneCtrls->ComfortControlledZone(TstatZoneNum).ActualZoneNum != this->ControlZoneNum) continue;
                                    AirNodeFound = true;
                                }
                                if (!AirNodeFound && this->ControlZoneNum > 0) {
                                    ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
                                    ShowContinueError(state, "Did not find Air Node (Zone with Thermostat or Thermal Comfort Thermostat).");
                                    ShowContinueError(state, "specified Controlling Zone or Thermostat Location name = " + loc_controlZoneName);
                                    errorsFound = true;
                                }
                                break;
                            }
                        }
                    }
                }
            }

            if (ZoneEquipmentFound && !ZoneExhaustNodeFound && !InducedNodeFound) {
                // Exhaust Node was not found
                ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
                ShowContinueError(state,
                                  "Incorrect or misspelled Air Inlet Node Name or Exhaust Node Name or Induced Node Name. = " + loc_AirInNodeName);
                ShowContinueError(state,
                                  "Air Inlet Node " + loc_AirInNodeName +
                                      " name does not match any controlled zone exhaust node name. Check ZoneHVAC:EquipmentConnections "
                                      "object inputs.");
                ShowContinueError(state, "or Induced Air Outlet Node Name specified in AirLoopHVAC:ReturnPlenum object.");
                errorsFound = true;
            } else if (ZoneEquipmentFound && !ZoneInletNodeFound) {
                bool ZoneInletNodeExists = false;
                int InletControlledZoneNum = 0;
                int ZoneInletNum = 0;
                ZoneInletNodeExists = searchZoneInletNodes(state, this->AirOutNode, InletControlledZoneNum, ZoneInletNum);
                if (!ZoneInletNodeExists) {
                    ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
                    ShowContinueError(state, "Incorrect or misspelled Air Outlet Node Name = " + loc_AirOutNodeName);
                    ShowContinueError(state,
                                      "Node name does not match any controlled zone inlet node name. Check ZoneHVAC:EquipmentConnections "
                                      "object inputs.");
                    errorsFound = true;
                }
            }

            // check if the UnitarySystem is connected to an outside air system
            if (!AirLoopFound && state.dataAirLoop->NumOASystems > 0) {
                for (int OASysNum = 1; OASysNum <= state.dataAirLoop->NumOASystems; ++OASysNum) {
                    for (int OACompNum = 1; OACompNum <= state.dataAirLoop->OutsideAirSys(OASysNum).NumComponents; ++OACompNum) {
                        if (!UtilityRoutines::SameString(state.dataAirLoop->OutsideAirSys(OASysNum).ComponentName(OACompNum), thisObjectName) ||
                            !UtilityRoutines::SameString(state.dataAirLoop->OutsideAirSys(OASysNum).ComponentType(OACompNum), cCurrentModuleObject))
                            continue;
                        AirLoopNumber = OASysNum;
                        OASysFound = true;
                        break;
                    }
                }
            }
        }

        if (!AirLoopFound && !ZoneEquipmentFound && !OASysFound) {
            // Unsucessful attempt to get all input data.
            return;
        } else {
            if (AirLoopFound && (this->m_ZoneInletNode > 0 || this->m_ControlType == ControlType::Setpoint)) {
                this->m_OKToPrintSizing = true;
                this->m_ThisSysInputShouldBeGotten = false;
            } else if (ZoneEquipmentFound) {
                this->m_OKToPrintSizing = true;
                this->m_ThisSysInputShouldBeGotten = false;
            } else if (OASysFound) {
                this->m_OKToPrintSizing = true;
                this->m_ThisSysInputShouldBeGotten = false;
            }
        }

        if (AirLoopNumber == 0 && !ZoneEquipmentFound &&
            (this->m_ControlType == ControlType::Load || this->m_ControlType == ControlType::CCMASHRAE)) {
            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, "Did not find proper connection for AirLoopHVAC or ZoneHVAC system.");
            ShowContinueError(state, "specified Controlling Zone or Thermostat Location name = " + loc_controlZoneName);
            if (!AirNodeFound && !ZoneEquipmentFound) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Did not find air node (zone with thermostat).");
                // ShowContinueError(state, "specified " + cAlphaFields(iControlZoneAlphaNum) + " = " + Alphas(iControlZoneAlphaNum));
                ShowContinueError(state,
                                  "Both a ZoneHVAC:EquipmentConnections object and a ZoneControl:Thermostat object must be specified for this zone.");
            }
            errorsFound = true;
        }

        if (!ZoneEquipmentFound)
            BranchNodeConnections::TestCompSet(
                state, cCurrentModuleObject, UtilityRoutines::MakeUPPERCase(thisObjectName), loc_AirInNodeName, loc_AirOutNodeName, "Air Nodes");

        std::string loc_fanType = input_data.supply_fan_object_type;
        std::string loc_m_FanName = input_data.supply_fan_name;

        if (loc_m_FanName != "" && loc_fanType != "") {
            if (UtilityRoutines::SameString(loc_fanType, "Fan:SystemModel")) {
                if (!HVACFan::checkIfFanNameIsAFanSystem(state, loc_m_FanName)) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else {
                    this->m_FanType_Num = DataHVACGlobals::FanType_SystemModelObject;
                    isNotOK = false;
                    ValidateComponent(state, loc_fanType, loc_m_FanName, isNotOK, cCurrentModuleObject);
                    if (isNotOK) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    } else { // mine data from fan object
                        if (HVACFan::getFanObjectVectorIndex(state, loc_m_FanName, false) < 0) {
                            state.dataHVACFan->fanObjs.emplace_back(new HVACFan::FanSystem(state, loc_m_FanName)); // call constructor
                        }
                        this->m_FanIndex = HVACFan::getFanObjectVectorIndex(state, loc_m_FanName);
                        if (this->m_FanIndex > -1) {
                            FanInletNode = state.dataHVACFan->fanObjs[this->m_FanIndex]->inletNodeNum;
                            FanOutletNode = state.dataHVACFan->fanObjs[this->m_FanIndex]->outletNodeNum;
                            this->m_FanAvailSchedPtr = state.dataHVACFan->fanObjs[this->m_FanIndex]->availSchedIndex;
                            FanVolFlowRate = state.dataHVACFan->fanObjs[this->m_FanIndex]->designAirVolFlowRate;
                        } else {
                            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                            ShowContinueError(state, "Unable to access fan data.");
                            ShowContinueError(state, "Fan Type = " + loc_fanType + ", Fan name = " + loc_m_FanName);
                            errorsFound = true;
                        }
                        if (FanVolFlowRate == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                        this->m_ActualFanVolFlowRate = FanVolFlowRate;
                        this->m_DesignFanVolFlowRate = FanVolFlowRate;
                    }
                }
            } else {
                Fans::GetFanType(state, loc_m_FanName, this->m_FanType_Num, isNotOK, cCurrentModuleObject, loc_m_FanName);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else {
                    isNotOK = false;
                    ValidateComponent(state, loc_fanType, loc_m_FanName, isNotOK, cCurrentModuleObject);
                    if (isNotOK) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    } else { // mine data from fan object
                        // Get the fan index
                        Fans::GetFanIndex(state, loc_m_FanName, this->m_FanIndex, errFlag, ObjexxFCL::Optional_string_const());
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                        // Get the Design Fan Volume Flow Rate
                        errFlag = false;
                        FanVolFlowRate = Fans::GetFanDesignVolumeFlowRate(state, loc_fanType, loc_m_FanName, errFlag);
                        if (FanVolFlowRate == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                        this->m_ActualFanVolFlowRate = FanVolFlowRate;
                        this->m_DesignFanVolFlowRate = FanVolFlowRate;
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                        // Get the Fan Inlet Node
                        errFlag = false;
                        FanInletNode = Fans::GetFanInletNode(state, loc_fanType, loc_m_FanName, errFlag);
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                        // Get the Fan Outlet Node
                        errFlag = false;
                        FanOutletNode = Fans::GetFanOutletNode(state, loc_fanType, loc_m_FanName, errFlag);
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                        // Get the fan's availability schedule
                        errFlag = false;
                        this->m_FanAvailSchedPtr = Fans::GetFanAvailSchPtr(state, loc_fanType, loc_m_FanName, errFlag);
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                    } // IF (IsNotOK) THEN
                }
            }
            this->m_FanExists = true;
            this->m_FanName = loc_m_FanName;
        } else {
            if ((loc_m_FanName == "" && loc_fanType != "") || (loc_m_FanName != "" && loc_fanType == "")) {
                ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
                ShowContinueError(state, "Invalid Fan Type or Name: Fan Name = " + loc_m_FanName + ", Fan Type = " + loc_fanType);
                errorsFound = true;
            }
        }

        // Add fan to component sets array
        if (this->m_FanExists && this->m_FanCompNotSetYet) {
            BranchNodeConnections::SetUpCompSets(state,
                                                 cCurrentModuleObject,
                                                 thisObjectName,
                                                 loc_fanType,
                                                 loc_m_FanName,
                                                 state.dataLoopNodes->NodeID(FanInletNode),
                                                 state.dataLoopNodes->NodeID(FanOutletNode));
            this->m_FanCompNotSetYet = false;
        }

        std::string loc_supFanPlace = input_data.fan_placement;
        if (UtilityRoutines::SameString(loc_supFanPlace, "BlowThrough")) this->m_FanPlace = FanPlace::BlowThru;
        if (UtilityRoutines::SameString(loc_supFanPlace, "DrawThrough")) this->m_FanPlace = FanPlace::DrawThru;
        if (this->m_FanPlace == FanPlace::NotYetSet && this->m_FanExists) {
            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, "Illegal Fan Placement = " + loc_supFanPlace);
            errorsFound = true;
        }

        std::string loc_supFanOpMode = input_data.supply_air_fan_operating_mode_schedule_name;

        this->m_FanOpModeSchedPtr = ScheduleManager::GetScheduleIndex(state, loc_supFanOpMode);
        if (loc_supFanOpMode != "" && this->m_FanOpModeSchedPtr == 0) {
            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, "Illegal Fan Operating Mode Schedule Name = " + loc_supFanOpMode);
            // ShowContinueError(state, "Illegal " + cAlphaFields(iFanSchedAlphaNum) + " = " + Alphas(iFanSchedAlphaNum));
            errorsFound = true;
        } else if (this->m_FanOpModeSchedPtr == 0) {
            if (this->m_ControlType == ControlType::Setpoint) {
                // Fan operating mode must be constant fan so that the coil outlet temp is proportional to PLR
                // Cycling fan always outputs the full load outlet air temp so should not be used with set point based control
                this->m_FanOpMode = DataHVACGlobals::ContFanCycCoil;
            } else {
                this->m_FanOpMode = DataHVACGlobals::CycFanCycCoil;
                if (this->m_FanType_Num != DataHVACGlobals::FanType_SimpleOnOff &&
                    this->m_FanType_Num != DataHVACGlobals::FanType_SystemModelObject && this->m_FanExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    // ShowContinueError(state, cAlphaFields(iFanTypeAlphaNum) + " = " + Alphas(iFanTypeAlphaNum));
                    // ShowContinueError(state, "Fan type must be Fan:OnOff of Fan:SystemModel when " + cAlphaFields(iFanSchedAlphaNum) + " =
                    // Blank.");
                    ShowContinueError(state,
                                      "Fan type must be Fan:OnOff or Fan:SystemModel when Supply Air Fan Operating Mode Schedule Name is blank.");
                    errorsFound = true;
                }
            }
        } else if (this->m_FanOpModeSchedPtr > 0 && this->m_ControlType == ControlType::Setpoint) {
            if (!ScheduleManager::CheckScheduleValueMinMax(state, this->m_FanOpModeSchedPtr, ">", 0.0, "<=", 1.0)) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "For " + loc_fanType + " = " + loc_m_FanName);
                ShowContinueError(state, "Fan operating mode must be continuous (fan operating mode schedule values > 0).");
                ShowContinueError(state, "Error found in Supply Air Fan Operating Mode Schedule Name " + loc_supFanOpMode);
                ShowContinueError(state, "...schedule values must be (>0., <=1.)");
                errorsFound = true;
            }
        }

        // Check fan's schedule for cycling fan operation IF constant volume fan is used
        if (this->m_FanOpModeSchedPtr > 0 && this->m_FanType_Num == DataHVACGlobals::FanType_SimpleConstVolume) {
            if (!ScheduleManager::CheckScheduleValueMinMax(state, this->m_FanOpModeSchedPtr, ">", 0.0, "<=", 1.0)) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Fan operating mode must be continuous (fan operating mode schedule values > 0).");
                ShowContinueError(state, "Error found in Supply Air Fan Operating Mode Schedule Name " + loc_supFanOpMode);
                ShowContinueError(state, "...schedule values must be (>0., <=1.)");
                errorsFound = true;
            }
        }

        PrintMessage = true;
        // Get coil data
        this->m_HeatingSizingRatio = loc_m_HeatingSizingRatio;
        int HeatingCoilPLFCurveIndex = 0;
        this->m_HeatingCoilName = loc_m_HeatingCoilName;
        this->m_HeatingCoilTypeName = loc_heatingCoilType; //  for coil selection report
        if (loc_heatingCoilType != "") {
            PrintMessage = false;
        } else {
            this->m_ValidASHRAEHeatCoil = false;
        }

        if (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {

            this->m_DXHeatingCoil = true;
            errFlag = false;

            ValidateComponent(state, loc_heatingCoilType, loc_m_HeatingCoilName, isNotOK, cCurrentModuleObject);
            if (isNotOK) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;

            } else { // mine data from DX heating coil

                // Get DX heating coil index
                DXCoils::GetDXCoilIndex(state,
                                        loc_m_HeatingCoilName,
                                        this->m_HeatingCoilIndex,
                                        errFlag,
                                        ObjexxFCL::Optional_string_const(),
                                        ObjexxFCL::Optional_bool_const());
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                this->m_HeatingCoilAvailSchPtr = DXCoils::GetDXCoilAvailSchPtr(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get DX heating coil capacity
                this->m_DesignHeatingCapacity = DXCoils::GetCoilCapacity(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (this->m_DesignHeatingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get DX coil air flow rate.
                this->m_MaxHeatAirVolFlow = DXCoils::GetDXCoilAirFlow(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (this->m_MaxHeatAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil Nodes
                HeatingCoilInletNode = DXCoils::GetCoilInletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                HeatingCoilOutletNode = DXCoils::GetCoilOutletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                DXCoils::SetDXCoolingCoilData(
                    state, this->m_HeatingCoilIndex, errorsFound, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, loc_m_HeatingSizingRatio);
            }

        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed ||
                   this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit) {

            this->m_DXHeatingCoil = true;
            errFlag = false;

            ValidateComponent(state, loc_heatingCoilType, loc_m_HeatingCoilName, isNotOK, cCurrentModuleObject);
            if (isNotOK) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
            } else {

                this->m_HeatingCoilIndex = VariableSpeedCoils::GetCoilIndexVariableSpeed(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                this->m_NumOfSpeedHeating = VariableSpeedCoils::GetVSCoilNumOfSpeeds(state, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                this->m_HeatingCoilAvailSchPtr = DataGlobalConstants::ScheduleAlwaysOn;

                this->m_MaxHeatAirVolFlow =
                    VariableSpeedCoils::GetCoilAirFlowRateVariableSpeed(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (this->m_MaxHeatAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                HeatingCoilInletNode = VariableSpeedCoils::GetCoilInletNodeVariableSpeed(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                HeatingCoilOutletNode =
                    VariableSpeedCoils::GetCoilOutletNodeVariableSpeed(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }
                // Get DX heating coil capacity
                this->m_DesignHeatingCapacity =
                    VariableSpeedCoils::GetCoilCapacityVariableSpeed(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (this->m_DesignHeatingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }
            }
        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating) {
            this->m_DXHeatingCoil = true;
            errFlag = false;
            DXCoils::GetDXCoilIndex(
                state, loc_m_HeatingCoilName, this->m_HeatingCoilIndex, errFlag, loc_heatingCoilType, ObjexxFCL::Optional_bool_const());
            if (errFlag) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
                errFlag = false;
            }

            this->m_HeatingCoilAvailSchPtr = DXCoils::GetDXCoilAvailSchPtr(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);

            // Get DX coil air flow rate.
            this->m_MaxHeatAirVolFlow = DXCoils::GetDXCoilAirFlow(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
            if (this->m_MaxHeatAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
            if (errFlag) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
                errFlag = false;
            }

            HeatingCoilInletNode = DXCoils::GetCoilInletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
            if (errFlag) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
                errFlag = false;
            }
            HeatingCoilOutletNode = DXCoils::GetCoilOutletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
            if (errFlag) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
                errFlag = false;
            }

            this->m_DesignHeatingCapacity = DXCoils::GetCoilCapacity(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);

        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingElectric_MultiStage ||
                   this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingGas_MultiStage) {

            errFlag = false;
            HeatingCoils::GetCoilIndex(state, loc_m_HeatingCoilName, this->m_HeatingCoilIndex, errFlag);
            if (errFlag) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
                errFlag = false;
            }
            HeatingCoilInletNode = HeatingCoils::GetCoilInletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
            if (errFlag) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
                errFlag = false;
            }
            HeatingCoilOutletNode = HeatingCoils::GetCoilOutletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
            if (errFlag) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
                errFlag = false;
            }

            this->m_HeatingCoilAvailSchPtr = HeatingCoils::GetCoilAvailScheduleIndex(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);

            this->m_DesignHeatingCapacity = HeatingCoils::GetCoilCapacity(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);

            if (this->m_DesignHeatingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;

        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingGasOrOtherFuel ||
                   this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingElectric ||
                   this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingDesuperheater) {
            errFlag = false;
            if (errFlag) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
                errFlag = false;
            } else {

                ValidateComponent(state, loc_heatingCoilType, loc_m_HeatingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;

                } else { // mine data from heating coil

                    // Get heating coil index
                    errFlag = false;
                    HeatingCoils::GetCoilIndex(state, loc_m_HeatingCoilName, this->m_HeatingCoilIndex, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the design heating capacity
                    this->m_DesignHeatingCapacity = HeatingCoils::GetCoilCapacity(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                    if (this->m_DesignHeatingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    this->m_HeatingCoilAvailSchPtr =
                        HeatingCoils::GetCoilAvailScheduleIndex(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);

                    // Get the Heating Coil Inlet Node
                    HeatingCoilInletNode = HeatingCoils::GetCoilInletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the Heating Coil Outlet Node
                    HeatingCoilOutletNode = HeatingCoils::GetCoilOutletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the Heating Coil PLF Curve Index
                    HeatingCoilPLFCurveIndex = HeatingCoils::GetHeatingCoilPLFCurveIndex(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }
                    // These heating coil types do not have an air flow input field
                    if (this->m_RequestAutoSize) {
                        this->m_MaxHeatAirVolFlow = DataSizing::AutoSize;
                    }
                } // IF (IsNotOK) THEN
            }

        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
            ValidateComponent(state, loc_heatingCoilType, loc_m_HeatingCoilName, isNotOK, cCurrentModuleObject);
            if (isNotOK) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
            } else { // mine data from heating coil object

                errFlag = false;
                this->m_HeatingCoilAvailSchPtr =
                    WaterCoils::GetWaterCoilAvailScheduleIndex(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                this->m_HeatingCoilIndex = WaterCoils::GetWaterCoilIndex(state, "COIL:HEATING:WATER", loc_m_HeatingCoilName, errFlag);
                if (this->m_HeatingCoilIndex == 0) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    // ShowContinueError(state, "Illegal " + cAlphaFields(iHeatingCoilNameAlphaNum) + " = " + HeatingCoilName);
                    errorsFound = true;
                    errFlag = false;
                }

                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil water Inlet or control Node number
                this->HeatCoilFluidInletNode = WaterCoils::GetCoilWaterInletNode(state, "Coil:Heating:Water", loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil hot water max volume flow rate
                this->MaxHeatCoilFluidFlow = WaterCoils::GetCoilMaxWaterFlowRate(state, "Coil:Heating:Water", loc_m_HeatingCoilName, errFlag);
                if (this->MaxHeatCoilFluidFlow == DataSizing::AutoSize) {
                    this->m_RequestAutoSize = true;
                    this->m_DesignHeatingCapacity = DataSizing::AutoSize;
                }

                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil Inlet Node
                HeatingCoilInletNode = WaterCoils::GetCoilInletNode(state, "Coil:Heating:Water", loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil Outlet Node
                HeatingCoilOutletNode = WaterCoils::GetCoilOutletNode(state, "Coil:Heating:Water", loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }
            }

        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {
            ValidateComponent(state, loc_heatingCoilType, loc_m_HeatingCoilName, isNotOK, cCurrentModuleObject);
            if (isNotOK) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
            } else { // mine data from heating coil object

                errFlag = false;
                this->m_HeatingCoilAvailSchPtr =
                    SteamCoils::GetSteamCoilAvailScheduleIndex(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                this->m_HeatingCoilIndex = SteamCoils::GetSteamCoilIndex(state, "COIL:HEATING:STEAM", loc_m_HeatingCoilName, errFlag);
                if (this->m_HeatingCoilIndex == 0) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Illegal Heating Coil Name = " + loc_m_HeatingCoilName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil steam inlet node number
                errFlag = false;
                this->HeatCoilFluidInletNode = SteamCoils::GetCoilSteamInletNode(state, "Coil:Heating:Steam", loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil steam max volume flow rate
                this->MaxHeatCoilFluidFlow = SteamCoils::GetCoilMaxSteamFlowRate(state, this->m_HeatingCoilIndex, errFlag);
                if (this->MaxHeatCoilFluidFlow == DataSizing::AutoSize) {
                    this->m_RequestAutoSize = true;
                    this->m_DesignHeatingCapacity = DataSizing::AutoSize;
                }

                if (this->MaxHeatCoilFluidFlow > 0.0) {
                    int SteamIndex = 0; // Function GetSatDensityRefrig will look up steam index if 0 is passed
                    Real64 TempSteamIn = 100.0;
                    Real64 SteamDensity =
                        FluidProperties::GetSatDensityRefrig(state, fluidNameSteam, TempSteamIn, 1.0, SteamIndex, "getUnitarySystemInputData");
                    this->MaxHeatCoilFluidFlow *= SteamDensity;
                    errFlag = false;
                }

                // Get the Heating Coil Inlet Node
                errFlag = false;
                HeatingCoilInletNode = SteamCoils::GetCoilAirInletNode(state, this->m_HeatingCoilIndex, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil Outlet Node
                HeatingCoilOutletNode = SteamCoils::GetCoilAirOutletNode(state, this->m_HeatingCoilIndex, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                if (this->m_RequestAutoSize) {
                    this->m_MaxHeatAirVolFlow = DataSizing::AutoSize;
                }
            }

        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple) {
            this->m_DXHeatingCoil = true;
            ValidateComponent(state, loc_heatingCoilType, loc_m_HeatingCoilName, isNotOK, cCurrentModuleObject);
            if (isNotOK) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
            } else { // mine data from heating coil object

                errFlag = false;
                this->m_HeatingCoilAvailSchPtr = DataGlobalConstants::ScheduleAlwaysOn;
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                this->m_HeatingCoilIndex = WaterToAirHeatPumpSimple::GetCoilIndex(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (this->m_HeatingCoilIndex == 0) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Illegal Heating Coil Name = " + loc_m_HeatingCoilName);
                    errorsFound = true;
                    errFlag = false;
                }

                this->m_DesignHeatingCapacity = WaterToAirHeatPumpSimple::GetCoilCapacity(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get DX coil air flow rate. Later fields will overwrite this IF input field is present
                errFlag = false;
                this->m_MaxHeatAirVolFlow = WaterToAirHeatPumpSimple::GetCoilAirFlowRate(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (this->m_MaxHeatAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                }

                // Get the Heating Coil Inlet Node
                errFlag = false;
                HeatingCoilInletNode = WaterToAirHeatPumpSimple::GetCoilInletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil Outlet Node
                HeatingCoilOutletNode = WaterToAirHeatPumpSimple::GetCoilOutletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }
            }

        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP) {
            this->m_DXHeatingCoil = true;
            ValidateComponent(state, loc_heatingCoilType, loc_m_HeatingCoilName, isNotOK, cCurrentModuleObject);
            if (isNotOK) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
            } else { // mine data from heating coil object

                errFlag = false;
                this->m_HeatingCoilAvailSchPtr = DataGlobalConstants::ScheduleAlwaysOn;
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                this->m_HeatingCoilIndex = WaterToAirHeatPump::GetCoilIndex(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (this->m_HeatingCoilIndex == 0) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Illegal Heating Coil Name = " + loc_m_HeatingCoilName);
                    errorsFound = true;
                    errFlag = false;
                }

                this->m_DesignHeatingCapacity = WaterToAirHeatPump::GetCoilCapacity(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil Inlet Node
                errFlag = false;
                HeatingCoilInletNode = WaterToAirHeatPump::GetCoilInletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Heating Coil Outlet Node
                HeatingCoilOutletNode = WaterToAirHeatPump::GetCoilOutletNode(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }
            }

        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_UserDefined) {
            ValidateComponent(state, loc_heatingCoilType, loc_m_HeatingCoilName, isNotOK, cCurrentModuleObject);
            if (isNotOK) {
                ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                errorsFound = true;
            } else { // mine data from Heating coil object

                errFlag = false;
                this->m_HeatingCoilAvailSchPtr = DataGlobalConstants::ScheduleAlwaysOn;
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                UserDefinedComponents::GetUserDefinedCoilIndex(state, loc_m_HeatingCoilName, this->m_HeatingCoilIndex, errFlag, cCurrentModuleObject);
                if (this->m_HeatingCoilIndex == 0) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Illegal Heating Coil Name = " + loc_m_HeatingCoilName);
                    errorsFound = true;
                    errFlag = false;
                }

                // **** How to get this info ****
                // UnitarySystem( UnitarySysNum ).DesignHeatingCapacity =
                //     GetWtoAHPCoilCapacity(CoolingCoilType,  loc_m_CoolingCoilName,  errFlag );
                // if ( errFlag ) {
                //    ShowContinueError(state,  "Occurs in " + CurrentModuleObject + " = " +
                //         UnitarySystem(UnitarySysNum.Name);
                //    ErrorsFound = true;
                //    errFlag = false;
                //  }

                // Get the Cooling Coil Inlet Node
                errFlag = false;
                UserDefinedComponents::GetUserDefinedCoilAirInletNode(
                    state, loc_m_HeatingCoilName, HeatingCoilInletNode, errFlag, cCurrentModuleObject);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                // Get the Cooling Coil Outlet Node
                UserDefinedComponents::GetUserDefinedCoilAirOutletNode(
                    state, loc_m_HeatingCoilName, HeatingCoilOutletNode, errFlag, cCurrentModuleObject);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }
            }

        } else if (this->m_HeatCoilExists) {
            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, "Illegal Heating Coil Object Type = " + loc_heatingCoilType);
            errorsFound = true;
        } // IF (this->m_HeatingCoilType_Num == Coil_HeatingGasOrOtherFuel .OR. &, etc.

        // coil outlet node set point has priority, IF not exist, then use system outlet node
        if (SetPointManager::NodeHasSPMCtrlVarType(state, this->AirOutNode, SetPointManager::iCtrlVarType::Temp))
            this->m_SystemHeatControlNodeNum = this->AirOutNode;
        if (SetPointManager::NodeHasSPMCtrlVarType(state, HeatingCoilOutletNode, SetPointManager::iCtrlVarType::Temp))
            this->m_SystemHeatControlNodeNum = HeatingCoilOutletNode;

        this->HeatCoilInletNodeNum = HeatingCoilInletNode;
        this->HeatCoilOutletNodeNum = HeatingCoilOutletNode;
        this->m_HeatingCoilName = loc_m_HeatingCoilName;

        // Add heating coil to component sets array
        if (this->m_HeatCoilExists && this->m_HeatCompNotSetYet) {
            if (this->m_HeatingCoilType_Num != DataHVACGlobals::CoilDX_MultiSpeedHeating) {
                BranchNodeConnections::SetUpCompSets(state,
                                                     cCurrentModuleObject,
                                                     thisObjectName,
                                                     loc_heatingCoilType,
                                                     loc_m_HeatingCoilName,
                                                     state.dataLoopNodes->NodeID(HeatingCoilInletNode),
                                                     state.dataLoopNodes->NodeID(HeatingCoilOutletNode));
            } else {
                BranchNodeConnections::SetUpCompSets(
                    state, cCurrentModuleObject, thisObjectName, loc_heatingCoilType, loc_m_HeatingCoilName, "UNDEFINED", "UNDEFINED");
            }
            this->m_HeatCompNotSetYet = false;
        }

        // Get Cooling Coil Information IF available
        if (loc_coolingCoilType != "" && loc_m_CoolingCoilName != "") {

            if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed ||
                this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {
                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;

                } else { // mine data from DX cooling coil

                    if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {
                        this->m_NumOfSpeedCooling = 2;
                        this->m_MultiOrVarSpeedCoolCoil = true;
                    } else {
                        this->m_NumOfSpeedCooling = 1;
                        this->m_MultiOrVarSpeedCoolCoil = false;
                    }

                    // Get DX cooling coil index
                    DXCoils::GetDXCoilIndex(state,
                                            loc_m_CoolingCoilName,
                                            this->m_CoolingCoilIndex,
                                            isNotOK,
                                            ObjexxFCL::Optional_string_const(),
                                            ObjexxFCL::Optional_bool_const());
                    if (isNotOK) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }
                    if (state.dataGlobal->DoCoilDirectSolutions && this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed) {
                        DXCoils::DisableLatentDegradation(state, this->m_CoolingCoilIndex);
                    }

                    this->m_CoolingCoilAvailSchPtr = DXCoils::GetDXCoilAvailSchPtr(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);

                    // Get DX cooling coil capacity
                    errFlag = false;
                    this->m_DesignCoolingCapacity = DXCoils::GetCoilCapacity(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_DesignCoolingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get DX coil air flow rate. Latter fields will overwrite this IF input field is present
                    errFlag = false;
                    this->m_MaxCoolAirVolFlow = DXCoils::GetDXCoilAirFlow(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get the Cooling Coil Nodes
                    errFlag = false;
                    CoolingCoilInletNode = DXCoils::GetCoilInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    CoolingCoilOutletNode = DXCoils::GetCoilOutletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get Outdoor condenser node from DX coil object
                    errFlag = false;
                    this->m_CondenserNodeNum = DXCoils::GetCoilCondenserInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    if (this->m_FanExists) {
                        errFlag = false;
                        DXCoils::SetDXCoolingCoilData(
                            state, this->m_CoolingCoilIndex, errFlag, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, loc_m_FanName);
                        DXCoils::SetDXCoolingCoilData(
                            state, this->m_CoolingCoilIndex, errFlag, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, this->m_FanIndex);
                        DXCoils::SetDXCoolingCoilData(state,
                                                      this->m_CoolingCoilIndex,
                                                      errFlag,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      _,
                                                      this->m_FanType_Num);
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }
                    }
                    if (this->m_HeatCoilExists) {
                        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {
                            this->m_HeatPump = true;
                        }

                        // set fan info for heating coils
                        if (this->m_FanExists) {
                            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                                state.dataRptCoilSelection->coilSelectionReportObj->setCoilSupplyFanInfo(state,
                                                                                                         this->m_HeatingCoilName,
                                                                                                         this->m_HeatingCoilTypeName,
                                                                                                         this->m_FanName,
                                                                                                         DataAirSystems::objectVectorOOFanSystemModel,
                                                                                                         this->m_FanIndex);
                            } else {
                                state.dataRptCoilSelection->coilSelectionReportObj->setCoilSupplyFanInfo(state,
                                                                                                         this->m_HeatingCoilName,
                                                                                                         this->m_HeatingCoilTypeName,
                                                                                                         this->m_FanName,
                                                                                                         DataAirSystems::structArrayLegacyFanModels,
                                                                                                         this->m_FanIndex);
                            }
                        }
                    }

                } // IF (IsNotOK) THEN

                // Push heating coil PLF curve index to DX coil
                if (HeatingCoilPLFCurveIndex > 0) {
                    DXCoils::SetDXCoolingCoilData(state, this->m_CoolingCoilIndex, errorsFound, HeatingCoilPLFCurveIndex);
                }

            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling) {
                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;

                } else {
                    //                    // call CoilCoolingDX constructor
                    this->m_CoolingCoilIndex = CoilCoolingDX::factory(state, loc_m_CoolingCoilName);
                    if (this->m_CoolingCoilIndex == -1) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    } else {

                        // mine data from coil object
                        // TODO: Need to check for autosize on these I guess
                        auto &newCoil = state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex];
                        this->m_DesignCoolingCapacity = newCoil.performance.normalMode.ratedGrossTotalCap;
                        this->m_MaxCoolAirVolFlow = newCoil.performance.normalMode.ratedEvapAirFlowRate;
                        if (this->m_DesignCoolingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                        if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                        this->m_CoolingCoilAvailSchPtr = newCoil.availScheduleIndex;
                        CoolingCoilInletNode = newCoil.evapInletNodeIndex;
                        CoolingCoilOutletNode = newCoil.evapOutletNodeIndex;
                        this->m_CondenserNodeNum = newCoil.condInletNodeIndex;
                        this->m_NumOfSpeedCooling = (int)newCoil.performance.normalMode.speeds.size();
                        this->m_MinOATCompressorCooling = newCoil.performance.minOutdoorDrybulb;
                        newCoil.supplyFanName = this->m_FanName;
                        newCoil.supplyFanIndex = this->m_FanIndex;
                        newCoil.supplyFanType = this->m_FanType_Num;
                        if (newCoil.SubcoolReheatFlag) {
                            this->m_Humidistat = true;
                            if (this->m_NumOfSpeedCooling > 1) {
                                this->FullOutput.resize(this->m_NumOfSpeedCooling + 1);
                                this->FullLatOutput.resize(this->m_NumOfSpeedCooling + 1);
                                this->SpeedSHR.resize(this->m_NumOfSpeedCooling + 1);
                            }
                            if (this->m_ControlType == ControlType::Setpoint) {
                                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                                ShowContinueError(state,
                                                  "Setpoint control is not available for SubcoolReheat cooling coil. Load control is forced. "
                                                  "Simulation continues.");
                                this->m_ControlType = ControlType::Load;
                            }
                        }
                        newCoil.setData(this->m_FanIndex, this->m_FanType_Num, this->m_FanName, this->m_SuppCoilLoopNum);

                        // Push heating coil PLF curve index to DX coil
                        //                    if ( HeatingCoilPLFCurveIndex > 0 ) {
                        //                        SetDXCoolingCoilData( UnitarySystem( UnitarySysNum ).CoolingCoilIndex, ErrorsFound,
                        //                        HeatingCoilPLFCurveIndex );
                        //                    }
                    }

                    if (state.dataGlobal->DoCoilDirectSolutions && this->m_NumOfSpeedCooling > 1) {
                        this->FullOutput.resize(this->m_NumOfSpeedCooling + 1);
                    }

                    if (this->m_HeatCoilExists) {
                        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {
                            this->m_HeatPump = true;
                        }

                        // set fan info for heating coils
                        if (this->m_FanExists) {
                            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                                state.dataRptCoilSelection->coilSelectionReportObj->setCoilSupplyFanInfo(state,
                                                                                                         this->m_HeatingCoilName,
                                                                                                         this->m_HeatingCoilTypeName,
                                                                                                         this->m_FanName,
                                                                                                         DataAirSystems::objectVectorOOFanSystemModel,
                                                                                                         this->m_FanIndex);

                            } else {
                                state.dataRptCoilSelection->coilSelectionReportObj->setCoilSupplyFanInfo(state,
                                                                                                         this->m_HeatingCoilName,
                                                                                                         this->m_HeatingCoilTypeName,
                                                                                                         this->m_FanName,
                                                                                                         DataAirSystems::structArrayLegacyFanModels,
                                                                                                         this->m_FanIndex);
                            }
                        }
                    }
                }

            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) {
                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;

                } else { // mine data from DX cooling coil

                    // Get DX cooling coil index
                    DXCoils::GetDXCoilIndex(state,
                                            loc_m_CoolingCoilName,
                                            this->m_CoolingCoilIndex,
                                            isNotOK,
                                            ObjexxFCL::Optional_string_const(),
                                            ObjexxFCL::Optional_bool_const());
                    if (isNotOK) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    this->m_CoolingCoilAvailSchPtr = DXCoils::GetDXCoilAvailSchPtr(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);

                    // Get DX cooling coil capacity
                    errFlag = false;
                    this->m_DesignCoolingCapacity = DXCoils::GetCoilCapacity(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_DesignCoolingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get DX coil air flow rate. Later fields will overwrite this IF input field is present
                    errFlag = false;
                    this->m_MaxCoolAirVolFlow = DXCoils::GetDXCoilAirFlow(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get the Cooling Coil Nodes
                    errFlag = false;
                    CoolingCoilInletNode = DXCoils::GetCoilInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    CoolingCoilOutletNode = DXCoils::GetCoilOutletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get Outdoor condenser node from DX coil object
                    errFlag = false;
                    this->m_CondenserNodeNum = DXCoils::GetCoilCondenserInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                } // IF (IsNotOK) THEN

                // Push heating coil PLF curve index to DX coil
                if (HeatingCoilPLFCurveIndex > 0) {
                    DXCoils::SetDXCoolingCoilData(state, this->m_CoolingCoilIndex, errorsFound, HeatingCoilPLFCurveIndex);
                }

                if (this->m_HeatCoilExists) {
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {
                        this->m_HeatPump = true;
                    }
                }

            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted) {
                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;

                } else { // mine data from heat exchanger assisted cooling coil

                    // Get DX heat exchanger assisted cooling coil index
                    errFlag = false;
                    HVACHXAssistedCoolingCoil::GetHXDXCoilIndex(state, loc_m_CoolingCoilName, this->m_CoolingCoilIndex, isNotOK);
                    if (isNotOK) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    errFlag = false;
                    std::string ChildCoolingCoilName =
                        HVACHXAssistedCoolingCoil::GetHXDXCoilName(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK);
                    std::string ChildCoolingCoilType =
                        HVACHXAssistedCoolingCoil::GetHXDXCoilType(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK);
                    if (isNotOK) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    if (UtilityRoutines::SameString(ChildCoolingCoilType, "COIL:COOLING:DX:SINGLESPEED")) {

                        errFlag = false;
                        this->m_CoolingCoilAvailSchPtr = DXCoils::GetDXCoilAvailSchPtr(state, ChildCoolingCoilType, ChildCoolingCoilName, errFlag);
                        if (isNotOK) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                        // Get DX coil air flow rate. Later fields will overwrite this IF input field is present
                        errFlag = false;
                        this->m_MaxCoolAirVolFlow = DXCoils::GetDXCoilAirFlow(state, ChildCoolingCoilType, ChildCoolingCoilName, errFlag);
                        if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                        // Get Outdoor condenser node from heat exchanger assisted DX coil object
                        errFlag = false;
                        this->m_CondenserNodeNum = DXCoils::GetCoilCondenserInletNode(
                            state,
                            "COIL:COOLING:DX:SINGLESPEED",
                            HVACHXAssistedCoolingCoil::GetHXDXCoilName(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag),
                            errFlag);

                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                    } else if (UtilityRoutines::SameString(ChildCoolingCoilType, "COIL:COOLING:DX:VARIABLESPEED")) {
                        this->m_CoolingCoilAvailSchPtr = DataGlobalConstants::ScheduleAlwaysOn;
                        errFlag = false;
                        this->m_MaxCoolAirVolFlow =
                            VariableSpeedCoils::GetCoilAirFlowRateVariableSpeed(state, ChildCoolingCoilType, ChildCoolingCoilName, errFlag);
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }
                        this->m_CondenserNodeNum = VariableSpeedCoils::GetVSCoilCondenserInletNode(state, ChildCoolingCoilName, errFlag);
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }
                    }

                    // Get DX cooling coil capacity
                    errFlag = false;
                    this->m_DesignCoolingCapacity =
                        HVACHXAssistedCoolingCoil::GetCoilCapacity(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_DesignCoolingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get the Cooling Coil Nodes
                    errFlag = false;
                    CoolingCoilInletNode = HVACHXAssistedCoolingCoil::GetCoilInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    CoolingCoilOutletNode = HVACHXAssistedCoolingCoil::GetCoilOutletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Push heating coil PLF curve index to DX coil
                    if (HeatingCoilPLFCurveIndex > 0) {
                        // get the actual index to the DX cooling coil object
                        int DXCoilIndex =
                            HVACHXAssistedCoolingCoil::GetActualDXCoilIndex(state, loc_coolingCoilType, loc_m_CoolingCoilName, errorsFound);
                        this->m_ActualDXCoilIndexForHXAssisted = DXCoilIndex;
                        int ActualCoolCoilType =
                            HVACHXAssistedCoolingCoil::GetCoilObjectTypeNum(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag, true);
                        if (ActualCoolCoilType == DataHVACGlobals::CoilDX_CoolingSingleSpeed) {
                            DXCoils::SetDXCoolingCoilData(state, DXCoilIndex, errorsFound, HeatingCoilPLFCurveIndex);
                        }
                        // what could we do for VS coil here? odd thing here
                    }

                    if (this->m_HeatCoilExists) {
                        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                            this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {
                            this->m_HeatPump = true;
                        }
                    }

                } // IF (IsNotOK) THEN
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilWater_CoolingHXAssisted) {
                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;

                } else { // mine data from heat exchanger assisted cooling coil

                    errFlag = false;
                    int ActualCoolCoilType =
                        HVACHXAssistedCoolingCoil::GetCoilObjectTypeNum(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag, true);
                    std::string HXCoilName = HVACHXAssistedCoolingCoil::GetHXDXCoilName(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);

                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get DX heat exchanger assisted cooling coil index
                    errFlag = false;
                    HVACHXAssistedCoolingCoil::GetHXDXCoilIndex(state, loc_m_CoolingCoilName, this->m_CoolingCoilIndex, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    errFlag = false;
                    this->m_CoolingCoilAvailSchPtr =
                        WaterCoils::GetWaterCoilAvailScheduleIndex(state, DataHVACGlobals::cAllCoilTypes(ActualCoolCoilType), HXCoilName, errFlag);
                    this->MaxCoolCoilFluidFlow =
                        WaterCoils::GetCoilMaxWaterFlowRate(state, DataHVACGlobals::cAllCoilTypes(ActualCoolCoilType), HXCoilName, errFlag);
                    // Get the Cooling Coil water Inlet Node number
                    this->CoolCoilFluidInletNode =
                        WaterCoils::GetCoilWaterInletNode(state, DataHVACGlobals::cAllCoilTypes(ActualCoolCoilType), HXCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get the Cooling Coil Nodes
                    errFlag = false;
                    CoolingCoilInletNode = HVACHXAssistedCoolingCoil::GetCoilInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    CoolingCoilOutletNode = HVACHXAssistedCoolingCoil::GetCoilOutletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    errFlag = false;
                    this->m_MaxCoolAirVolFlow =
                        HVACHXAssistedCoolingCoil::GetHXCoilAirFlowRate(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize) {
                        this->m_RequestAutoSize = true;
                        this->m_DesignCoolingCapacity = DataSizing::AutoSize;
                    }
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    this->m_CondenserNodeNum = 0;

                    // Push heating coil PLF curve index to DX coil
                    if (HeatingCoilPLFCurveIndex > 0) {
                        // get the actual index to the DX cooling coil object
                        int DXCoilIndex =
                            HVACHXAssistedCoolingCoil::GetActualDXCoilIndex(state, loc_coolingCoilType, loc_m_CoolingCoilName, errorsFound);
                        this->m_ActualDXCoilIndexForHXAssisted = DXCoilIndex;
                        int ActualCoolCoilType =
                            HVACHXAssistedCoolingCoil::GetCoilObjectTypeNum(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag, true);
                        if (ActualCoolCoilType == DataHVACGlobals::CoilDX_CoolingSingleSpeed) {
                            DXCoils::SetDXCoolingCoilData(state, DXCoilIndex, errorsFound, HeatingCoilPLFCurveIndex);
                        }
                        // VS coil issue here
                    }

                } // IF (IsNotOK) THEN
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed ||
                       this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit) {
                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else {
                    errFlag = false;
                    this->m_CoolingCoilIndex =
                        VariableSpeedCoils::GetCoilIndexVariableSpeed(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    CoolingCoilInletNode =
                        VariableSpeedCoils::GetCoilInletNodeVariableSpeed(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    CoolingCoilOutletNode =
                        VariableSpeedCoils::GetCoilOutletNodeVariableSpeed(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    this->m_CondenserNodeNum = VariableSpeedCoils::GetVSCoilCondenserInletNode(state, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    this->m_CoolingCoilAvailSchPtr = DataGlobalConstants::ScheduleAlwaysOn;

                    this->m_NumOfSpeedCooling = VariableSpeedCoils::GetVSCoilNumOfSpeeds(state, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    errFlag = false;
                    this->m_DesignCoolingCapacity =
                        VariableSpeedCoils::GetCoilCapacityVariableSpeed(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_DesignCoolingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    errFlag = false;
                    this->m_MaxCoolAirVolFlow =
                        VariableSpeedCoils::GetCoilAirFlowRateVariableSpeed(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Set fan info
                    if (this->m_FanExists) {
                        VariableSpeedCoils::setVarSpeedFanInfo(state, this->m_CoolingCoilIndex, loc_m_FanName, this->m_FanIndex, this->m_FanType_Num);
                    }
                }

                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                }

                if (this->m_HeatCoilExists) {
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {
                        this->m_HeatPump = true;
                    }
                }

            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling) {
                errFlag = false;
                DXCoils::GetDXCoilIndex(
                    state, loc_m_CoolingCoilName, this->m_CoolingCoilIndex, errFlag, loc_coolingCoilType, ObjexxFCL::Optional_bool_const());
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                this->m_CoolingCoilAvailSchPtr = DXCoils::GetDXCoilAvailSchPtr(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);

                errFlag = false;
                CoolingCoilInletNode = DXCoils::GetCoilInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                errFlag = false;
                CoolingCoilOutletNode = DXCoils::GetCoilOutletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                    errFlag = false;
                }

                errFlag = false;
                this->m_DesignCoolingCapacity = DXCoils::GetCoilCapacity(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                if (this->m_DesignCoolingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                }

                // Get DX coil air flow rate. Later fields will overwrite this IF input field is present
                errFlag = false;
                this->m_MaxCoolAirVolFlow = DXCoils::GetDXCoilAirFlow(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                }

                if (this->m_HeatCoilExists) {
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {
                        this->m_HeatPump = true;
                    }
                }

            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
                       this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) {

                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else { // mine data from Cooling coil object

                    errFlag = false;
                    this->m_CoolingCoilAvailSchPtr =
                        WaterCoils::GetWaterCoilAvailScheduleIndex(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    this->m_CoolingCoilIndex = WaterCoils::GetWaterCoilIndex(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_CoolingCoilIndex == 0) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Illegal Cooling Coil Name = " + loc_m_CoolingCoilName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // call for air flow rate not valid for other water coil types
                    if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater) {
                        this->m_MaxCoolAirVolFlow = WaterCoils::GetWaterCoilDesAirFlow(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                            errFlag = false;
                        }
                    }

                    // Get the Cooling Coil water Inlet Node number
                    this->CoolCoilFluidInletNode = WaterCoils::GetCoilWaterInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    bool InletNodeNotControlled = true;
                    //  CALL CheckCoilWaterInletNode(this->CoolCoilFluidInletNode,InletNodeNotControlled)
                    if (!InletNodeNotControlled) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state,
                                          state.dataHVACCtrl->ControllerTypes(DataHVACControllers::ControllerSimple_Type) + " found for " +
                                              loc_coolingCoilType + " = \"" + loc_m_CoolingCoilName + ".\"");
                        ShowContinueError(state, "...water coil controllers are not used with " + this->UnitType);
                        errorsFound = true;
                    }

                    // Get the Cooling Coil chilled water max volume flow rate
                    errFlag = false;
                    this->MaxCoolCoilFluidFlow = WaterCoils::GetCoilMaxWaterFlowRate(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->MaxCoolCoilFluidFlow == DataSizing::AutoSize) {
                        this->m_RequestAutoSize = true;
                        this->m_DesignCoolingCapacity = DataSizing::AutoSize; // water coils don't have a capacity field, need other logic?
                    }
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the Cooling Coil Inlet Node
                    CoolingCoilInletNode = WaterCoils::GetCoilInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the Cooling Coil Outlet Node
                    CoolingCoilOutletNode = WaterCoils::GetCoilOutletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }
                }
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) {
                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else { // mine data from Cooling coil object

                    errFlag = false;
                    this->m_CoolingCoilAvailSchPtr = DataGlobalConstants::ScheduleAlwaysOn;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    this->m_CoolingCoilIndex = WaterToAirHeatPumpSimple::GetCoilIndex(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_CoolingCoilIndex == 0) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Illegal Cooling Coil Name = " + loc_m_CoolingCoilName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    this->m_DesignCoolingCapacity =
                        WaterToAirHeatPumpSimple::GetCoilCapacity(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get DX coil air flow rate. Later fields will overwrite this IF input field is present
                    errFlag = false;
                    this->m_MaxCoolAirVolFlow =
                        WaterToAirHeatPumpSimple::GetCoilAirFlowRate(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize) this->m_RequestAutoSize = true;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get the Cooling Coil Inlet Node
                    errFlag = false;
                    CoolingCoilInletNode = WaterToAirHeatPumpSimple::GetCoilInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the Cooling Coil Outlet Node
                    CoolingCoilOutletNode = WaterToAirHeatPumpSimple::GetCoilOutletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }
                }

                if (this->m_HeatCoilExists) {
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {
                        this->m_HeatPump = true;
                    }
                }

            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHP) {
                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else { // mine data from Cooling coil object

                    errFlag = false;
                    this->m_CoolingCoilAvailSchPtr = DataGlobalConstants::ScheduleAlwaysOn;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    this->m_CoolingCoilIndex = WaterToAirHeatPump::GetCoilIndex(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (this->m_CoolingCoilIndex == 0) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Illegal Cooling Coil Name = " + loc_m_CoolingCoilName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    this->m_DesignCoolingCapacity = WaterToAirHeatPump::GetCoilCapacity(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the Cooling Coil Inlet Node
                    errFlag = false;
                    CoolingCoilInletNode = WaterToAirHeatPump::GetCoilInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the Cooling Coil Outlet Node
                    CoolingCoilOutletNode = WaterToAirHeatPump::GetCoilOutletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }
                }

                if (this->m_HeatCoilExists) {
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical) {
                        this->m_HeatPump = true;
                    }
                }

            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_UserDefined) {
                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else { // mine data from Cooling coil object

                    errFlag = false;
                    this->m_CoolingCoilAvailSchPtr = DataGlobalConstants::ScheduleAlwaysOn;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    UserDefinedComponents::GetUserDefinedCoilIndex(
                        state, loc_m_CoolingCoilName, this->m_CoolingCoilIndex, errFlag, cCurrentModuleObject);
                    if (this->m_CoolingCoilIndex == 0) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Illegal Cooling Coil Name = " + loc_m_CoolingCoilName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // **** How to get this info ****
                    //                        UnitarySystem( UnitarySysNum ).DesignCoolingCapacity =
                    // GetWtoAHPCoilCapacity(
                    // CoolingCoilType, loc_m_CoolingCoilName, errFlag );                         if ( errFlag ) {
                    //                            ShowContinueError(state,  "Occurs in " + CurrentModuleObject + " = "
                    //+
                    // UnitarySystem( UnitarySysNum ).Name );                             ErrorsFound = true;
                    //                            errFlag = false;
                    //                        }

                    // Get the Cooling Coil Inlet Node
                    errFlag = false;
                    UserDefinedComponents::GetUserDefinedCoilAirInletNode(
                        state, loc_m_CoolingCoilName, CoolingCoilInletNode, errFlag, cCurrentModuleObject);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the Cooling Coil Outlet Node
                    UserDefinedComponents::GetUserDefinedCoilAirOutletNode(
                        state, loc_m_CoolingCoilName, CoolingCoilOutletNode, errFlag, cCurrentModuleObject);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }
                }

            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling) {
                ValidateComponent(state, loc_coolingCoilType, loc_m_CoolingCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else { // mine data from Cooling coil object

                    errFlag = false;
                    this->m_CoolingCoilAvailSchPtr = DataGlobalConstants::ScheduleAlwaysOn;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    PackagedThermalStorageCoil::GetTESCoilIndex(
                        state, loc_m_CoolingCoilName, this->m_CoolingCoilIndex, errFlag, cCurrentModuleObject);
                    if (this->m_CoolingCoilIndex == 0) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Illegal Cooling Coil Name = " + loc_m_CoolingCoilName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    PackagedThermalStorageCoil::GetTESCoilCoolingAirFlowRate(
                        state, loc_m_CoolingCoilName, this->m_MaxCoolAirVolFlow, errFlag, cCurrentModuleObject);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    PackagedThermalStorageCoil::GetTESCoilCoolingCapacity(
                        state, loc_m_CoolingCoilName, this->m_DesignCoolingCapacity, errFlag, cCurrentModuleObject);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the Cooling Coil Inlet Node
                    errFlag = false;
                    PackagedThermalStorageCoil::GetTESCoilAirInletNode(
                        state, loc_m_CoolingCoilName, CoolingCoilInletNode, errFlag, cCurrentModuleObject);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the Cooling Coil Outlet Node
                    PackagedThermalStorageCoil::GetTESCoilAirOutletNode(
                        state, loc_m_CoolingCoilName, CoolingCoilOutletNode, errFlag, cCurrentModuleObject);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }
                }

            } else { // IF(.NOT. lAlphaBlanks(16))THEN
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                // ShowContinueError(state, "Illegal " + cAlphaFields(iCoolingCoilTypeAlphaNum) + " = " + Alphas(iCoolingCoilTypeAlphaNum));
                errorsFound = true;
            }

            if (loc_m_SystemCoolControlNodeName.size() > 0) { // used by CoilSystem:Cooling:DX
                this->m_SystemCoolControlNodeNum = NodeInputManager::GetOnlySingleNode(state,
                                                                                       loc_m_SystemCoolControlNodeName,
                                                                                       errFlag,
                                                                                       cCurrentModuleObject,
                                                                                       thisObjectName,
                                                                                       DataLoopNode::NodeFluidType::Air,
                                                                                       DataLoopNode::NodeConnectionType::Sensor,
                                                                                       NodeInputManager::compFluidStream::Primary,
                                                                                       DataLoopNode::ObjectIsParent);
            } else {
                if (SetPointManager::NodeHasSPMCtrlVarType(state, this->AirOutNode, SetPointManager::iCtrlVarType::Temp))
                    this->m_SystemCoolControlNodeNum = this->AirOutNode;
                if (SetPointManager::NodeHasSPMCtrlVarType(state, CoolingCoilOutletNode, SetPointManager::iCtrlVarType::Temp))
                    this->m_SystemCoolControlNodeNum = CoolingCoilOutletNode;
            }

            this->CoolCoilInletNodeNum = CoolingCoilInletNode;
            this->CoolCoilOutletNodeNum = CoolingCoilOutletNode;
            this->m_CoolingCoilName = loc_m_CoolingCoilName;

        } else {
            this->m_ValidASHRAECoolCoil = false;
        }

        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple &&
            this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) {
            this->m_WaterCyclingMode = DataHVACGlobals::WaterCycling;
            WaterToAirHeatPumpSimple::SetSimpleWSHPData(
                state, this->m_CoolingCoilIndex, errorsFound, this->m_WaterCyclingMode, _, this->m_HeatingCoilIndex);
        }

        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit &&
            this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit) {
            VariableSpeedCoils::SetVarSpeedCoilData(state, this->m_CoolingCoilIndex, errorsFound, _, this->m_HeatingCoilIndex);
        }

        // Add cooling coil to component sets array
        if (this->m_CoolCoilExists && this->m_CoolCompNotSetYet) {
            if (this->m_CoolingCoilType_Num != DataHVACGlobals::CoilDX_MultiSpeedCooling) {
                BranchNodeConnections::SetUpCompSets(state,
                                                     cCurrentModuleObject,
                                                     thisObjectName,
                                                     loc_coolingCoilType,
                                                     loc_m_CoolingCoilName,
                                                     state.dataLoopNodes->NodeID(CoolingCoilInletNode),
                                                     state.dataLoopNodes->NodeID(CoolingCoilOutletNode));
            } else {
                BranchNodeConnections::SetUpCompSets(
                    state, cCurrentModuleObject, thisObjectName, loc_coolingCoilType, loc_m_CoolingCoilName, "UNDEFINED", "UNDEFINED");
            }
            this->m_CoolCompNotSetYet = false;
        }
        // Run as 100% DOAS DX coil
        if (!UtilityRoutines::SameString(loc_m_ISHundredPercentDOASDXCoil, "Yes")) {
            this->m_ISHundredPercentDOASDXCoil = false;
        } else {
            if (UtilityRoutines::SameString(loc_m_ISHundredPercentDOASDXCoil, "Yes")) {
                this->m_ISHundredPercentDOASDXCoil = true;
                if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {
                    ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
                    // ShowContinueError(state, "Invalid entry for " + cAlphaFields(iDOASDXCoilAlphaNum) + " :" +
                    // Alphas(iDOASDXCoilAlphaNum));
                    ShowContinueError(state, "Variable DX Cooling Coil is not supported as 100% DOAS DX coil.");
                    ShowContinueError(state, "Variable DX Cooling Coil resets Use DOAS DX Cooling Coil = No and the simulation continues.");
                    this->m_ISHundredPercentDOASDXCoil = false;
                }
            } else if (UtilityRoutines::SameString(loc_m_ISHundredPercentDOASDXCoil, "")) {
                this->m_ISHundredPercentDOASDXCoil = false;
            } else if (UtilityRoutines::SameString(loc_m_ISHundredPercentDOASDXCoil, "No")) {
                this->m_ISHundredPercentDOASDXCoil = false;
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Invalid entry for Use DOAS DX Cooling Coil = " + loc_m_ISHundredPercentDOASDXCoil);
                ShowContinueError(state, "Must be Yes or No.");
                errorsFound = true;
            }
        }

        // considered as as 100% DOAS DX cooling coil
        if (this->m_ISHundredPercentDOASDXCoil) {
            // set the system DX Coil application type to the child DX coil
            if (!(this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed ||
                  this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {
                DXCoils::SetDXCoilTypeData(state, this->m_CoolingCoilName);
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling) {
                state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].setToHundredPercentDOAS();
            }
        }
        // DOAS DX Cooling Coil Leaving Minimum Air Temperature
        // if (NumNumbers > 0) {
        // if (!lNumericBlanks(iDOASDXMinTempNumericNum)) {
        this->DesignMinOutletTemp = loc_DesignMinOutletTemp;
        if (this->m_ControlType != ControlType::CCMASHRAE && this->DesignMinOutletTemp == DataSizing::AutoSize) {
            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, "Invalid entry for Minimum Supply Air Temperature = AutoSize.");
            ShowContinueError(state, "AutoSizing not allowed when Control Type = Load or Setpoint");
            errorsFound = true;
        }
        if (this->m_ControlType != ControlType::CCMASHRAE && this->DesignMinOutletTemp > 7.5) {
            ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, format("Invalid entry for Minimum Supply Air Temperature = {:.4R}", this->DesignMinOutletTemp));
            ShowContinueError(state, "The minimum supply air temperature will be limited to 7.5C and the simulation continues.");
            this->DesignMinOutletTemp = 7.5;
        }
        //}
        //}

        // Get Latent Load Control flag
        if (loc_latentControlFlag != "") {
            if (UtilityRoutines::SameString(loc_latentControlFlag, "SensibleOnlyLoadControl")) {
                this->m_RunOnSensibleLoad = true;
                this->m_RunOnLatentLoad = false;
            } else if (UtilityRoutines::SameString(loc_latentControlFlag, "LatentOnlyLoadControl")) {
                this->m_RunOnSensibleLoad = false;
                this->m_RunOnLatentLoad = true;
            } else if (UtilityRoutines::SameString(loc_latentControlFlag, "LatentOrSensibleLoadControl")) {
                this->m_RunOnSensibleLoad = true;
                this->m_RunOnLatentLoad = true;
            } else if (UtilityRoutines::SameString(loc_latentControlFlag, "LatentWithSensibleLoadControl")) {
                this->m_RunOnSensibleLoad = true;
                this->m_RunOnLatentLoad = true;
                this->m_RunOnLatentOnlyWithSensible = true;
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Invalid entry for Latent Load Control = " + loc_latentControlFlag);
                ShowContinueError(state,
                                  "Must be SensibleOnlyLoadControl, LatentOnlyLoadControl, LatentOrSensibleLoadControl, or "
                                  "LatentWithSensibleLoadControl.");
            }
        }
        if (this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat || this->m_DehumidControlType_Num == DehumCtrlType::Multimode) {
            if (!this->m_RunOnLatentLoad && !this->m_RunOnLatentOnlyWithSensible && this->m_ControlType == ControlType::Load) {
                ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Inconsistent moisture control inputs.");
                ShowContinueError(state, "Dehumidification Control Type = " + loc_dehumm_ControlType);
                ShowContinueError(state, "Latent Load Control = " + loc_latentControlFlag);
                ShowContinueError(state, "Humidity/Moisture may not be controlled with these settings.");
            }
        } else {
            if ((this->m_RunOnLatentLoad || this->m_RunOnLatentOnlyWithSensible) && this->m_ControlType == ControlType::Load) {
                ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Inconsistent moisture control inputs.");
                ShowContinueError(state, "Dehumidification Control Type = " + loc_dehumm_ControlType);
                ShowContinueError(state, "Latent Load Control = " + loc_latentControlFlag);
                ShowContinueError(state, "Humidity/Moisture will not be controlled with these settings.");
                this->m_RunOnLatentLoad = false;
                this->m_RunOnLatentOnlyWithSensible = false;
            }
        }
        // Get reheat coil data if humidistat is used
        this->m_SuppHeatCoilName = loc_m_SuppHeatCoilName;
        this->m_SuppHeatCoilTypeName = loc_suppHeatCoilType;
        errFlag = false;

        if (UtilityRoutines::SameString(loc_suppHeatCoilType, "Coil:Heating:Water")) {
            this->m_SuppHeatCoilType_Num = DataHVACGlobals::Coil_HeatingWater;
        } else if (UtilityRoutines::SameString(loc_suppHeatCoilType, "Coil:Heating:Steam")) {
            this->m_SuppHeatCoilType_Num = DataHVACGlobals::Coil_HeatingSteam;
        } else if (UtilityRoutines::SameString(loc_suppHeatCoilType, "Coil:Heating:Fuel") ||
                   UtilityRoutines::SameString(loc_suppHeatCoilType, "Coil:Heating:Electric") ||
                   UtilityRoutines::SameString(loc_suppHeatCoilType, "Coil:Heating:DesuperHeater")) {
            this->m_SuppHeatCoilType_Num = HeatingCoils::GetHeatingCoilTypeNum(state, loc_suppHeatCoilType, loc_m_SuppHeatCoilName, errFlag);
        } else if (UtilityRoutines::SameString(loc_suppHeatCoilType, "Coil:UserDefined")) {
            this->m_SuppHeatCoilType_Num = DataHVACGlobals::Coil_UserDefined;
        }

        if (loc_suppHeatCoilType != "" && loc_m_SuppHeatCoilName != "") {

            if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingGasOrOtherFuel ||
                this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingElectric ||
                this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingDesuperheater) {

                this->m_SuppHeatCoilType_Num = HeatingCoils::GetHeatingCoilTypeNum(state, loc_suppHeatCoilType, loc_m_SuppHeatCoilName, errFlag);
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else {

                    ValidateComponent(state, loc_suppHeatCoilType, loc_m_SuppHeatCoilName, isNotOK, cCurrentModuleObject);
                    if (isNotOK) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;

                    } else { // mine data from reheat coil

                        // Get the heating coil index
                        this->m_SuppHeatCoilIndex = HeatingCoils::GetHeatingCoilIndex(state, loc_suppHeatCoilType, loc_m_SuppHeatCoilName, isNotOK);
                        if (isNotOK) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                        // Get the design supplemental heating capacity
                        errFlag = false;
                        this->m_DesignSuppHeatingCapacity =
                            HeatingCoils::GetCoilCapacity(state, loc_suppHeatCoilType, loc_m_SuppHeatCoilName, errFlag);
                        if (this->m_DesignSuppHeatingCapacity == DataSizing::AutoSize) this->m_RequestAutoSize = true;

                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                        // Get the Reheat Coil Inlet Node
                        errFlag = false;
                        SupHeatCoilInletNode = HeatingCoils::GetCoilInletNode(state, loc_suppHeatCoilType, loc_m_SuppHeatCoilName, errFlag);
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                        // Get the Reheat Coil Outlet Node
                        errFlag = false;
                        SupHeatCoilOutletNode = HeatingCoils::GetCoilOutletNode(state, loc_suppHeatCoilType, loc_m_SuppHeatCoilName, errFlag);
                        if (errFlag) {
                            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                            errorsFound = true;
                        }

                    } // IF (IsNotOK) THEN
                }

                this->m_SuppCoilAirInletNode = SupHeatCoilInletNode;
                this->m_SuppCoilAirOutletNode = SupHeatCoilOutletNode;

            } else if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {

                ValidateComponent(state, loc_suppHeatCoilType, loc_m_SuppHeatCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else { // mine data from heating coil object

                    // Get the Heating Coil water Inlet or control Node number
                    errFlag = false;
                    this->m_SuppCoilFluidInletNode = WaterCoils::GetCoilWaterInletNode(state, "Coil:Heating:Water", loc_m_SuppHeatCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get the ReHeat Coil hot water max volume flow rate
                    errFlag = false;
                    this->m_MaxSuppCoilFluidFlow = WaterCoils::GetCoilMaxWaterFlowRate(state, "Coil:Heating:Water", loc_m_SuppHeatCoilName, errFlag);
                    if (this->m_MaxSuppCoilFluidFlow == DataSizing::AutoSize) {
                        this->m_RequestAutoSize = true;
                        this->m_DesignSuppHeatingCapacity = DataSizing::AutoSize;
                    }

                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get the ReHeat Coil Inlet Node
                    errFlag = false;
                    SupHeatCoilInletNode = WaterCoils::GetCoilInletNode(state, "Coil:Heating:Water", loc_m_SuppHeatCoilName, errFlag);
                    this->m_SuppCoilAirInletNode = SupHeatCoilInletNode;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get the ReHeat Coil Outlet Node
                    errFlag = false;
                    SupHeatCoilOutletNode = WaterCoils::GetCoilOutletNode(state, "Coil:Heating:Water", loc_m_SuppHeatCoilName, errFlag);
                    this->m_SuppCoilAirOutletNode = SupHeatCoilOutletNode;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }
                }

            } else if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {

                ValidateComponent(state, loc_suppHeatCoilType, loc_m_SuppHeatCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else { // mine data from heating coil object

                    errFlag = false;
                    this->m_SuppHeatCoilIndex = SteamCoils::GetSteamCoilIndex(state, "COIL:HEATING:STEAM", loc_m_SuppHeatCoilName, errFlag);
                    if (this->m_SuppHeatCoilIndex == 0) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowSevereError(state, "Illegal Supplemental Heating Coil Name = " + loc_m_SuppHeatCoilName);
                        errorsFound = true;
                    }

                    // Get the Heating Coil steam inlet node number
                    errFlag = false;
                    this->m_SuppCoilFluidInletNode = SteamCoils::GetCoilSteamInletNode(state, "Coil:Heating:Steam", loc_m_SuppHeatCoilName, errFlag);
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }
                    // Get the Heating Coil steam max volume flow rate
                    this->m_MaxSuppCoilFluidFlow = SteamCoils::GetCoilMaxSteamFlowRate(state, this->m_SuppHeatCoilIndex, errFlag);
                    if (this->m_MaxSuppCoilFluidFlow == DataSizing::AutoSize) {
                        this->m_RequestAutoSize = true;
                        this->m_DesignSuppHeatingCapacity = DataSizing::AutoSize; // not sure if steam coil needs this
                    }

                    if (this->m_MaxSuppCoilFluidFlow > 0.0) {
                        int SteamIndex = 0; // Function GetSatDensityRefrig will look up steam index if 0 is passed
                        Real64 TempSteamIn = 100.0;
                        Real64 SteamDensity =
                            FluidProperties::GetSatDensityRefrig(state, fluidNameSteam, TempSteamIn, 1.0, SteamIndex, "getUnitarySystemInputData");
                        this->m_MaxSuppCoilFluidFlow = SteamCoils::GetCoilMaxSteamFlowRate(state, this->m_SuppHeatCoilIndex, errFlag) * SteamDensity;
                    }

                    // Get the Heating Coil Inlet Node
                    errFlag = false;
                    SupHeatCoilInletNode = SteamCoils::GetCoilAirInletNode(state, this->m_SuppHeatCoilIndex, loc_m_SuppHeatCoilName, errFlag);
                    this->m_SuppCoilAirInletNode = SupHeatCoilInletNode;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }

                    // Get the Heating Coil Outlet Node
                    errFlag = false;
                    SupHeatCoilOutletNode = SteamCoils::GetCoilAirOutletNode(state, this->m_SuppHeatCoilIndex, loc_m_SuppHeatCoilName, errFlag);
                    this->m_SuppCoilAirOutletNode = SupHeatCoilOutletNode;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                    }
                }

            } else if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_UserDefined) {
                ValidateComponent(state, loc_suppHeatCoilType, loc_m_SuppHeatCoilName, isNotOK, cCurrentModuleObject);
                if (isNotOK) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                } else { // mine data from Heating coil object
                    errFlag = false;
                    UserDefinedComponents::GetUserDefinedCoilIndex(
                        state, loc_m_SuppHeatCoilName, this->m_SuppHeatCoilIndex, errFlag, cCurrentModuleObject);
                    if (this->m_SuppHeatCoilIndex == 0) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowSevereError(state, "Illegal Supplemental Heating Coil Name = " + loc_m_SuppHeatCoilName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the supplemental heating Coil Inlet Node
                    errFlag = false;
                    UserDefinedComponents::GetUserDefinedCoilAirInletNode(
                        state, loc_m_SuppHeatCoilName, SupHeatCoilInletNode, errFlag, cCurrentModuleObject);
                    this->m_SuppCoilAirInletNode = SupHeatCoilInletNode;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }

                    // Get the supplemenatal heating Coil Outlet Node
                    UserDefinedComponents::GetUserDefinedCoilAirOutletNode(
                        state, loc_m_SuppHeatCoilName, SupHeatCoilOutletNode, errFlag, cCurrentModuleObject);
                    this->m_SuppCoilAirOutletNode = SupHeatCoilOutletNode;
                    if (errFlag) {
                        ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                        errorsFound = true;
                        errFlag = false;
                    }
                }

            } else { // Illegal reheating coil type
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowSevereError(state, "Illegal Supplemental Heating Coil Type = " + loc_suppHeatCoilType);
                errorsFound = true;
            } // IF (this->SuppHeatCoilType_Num == Coil_HeatingGasOrOtherFuel .OR. &, etc.

        } // IF(.NOT. lAlphaBlanks(iSuppHeatCoilTypeAlphaNum))THEN

        if (SetPointManager::NodeHasSPMCtrlVarType(state, this->AirOutNode, SetPointManager::iCtrlVarType::Temp))
            this->m_SuppHeatControlNodeNum = this->AirOutNode;
        if (SetPointManager::NodeHasSPMCtrlVarType(state, SupHeatCoilOutletNode, SetPointManager::iCtrlVarType::Temp))
            this->m_SuppHeatControlNodeNum = SupHeatCoilOutletNode;

        // Add supplemental heating coil to component sets array
        if (this->m_SuppCoilExists && this->m_SuppCompNotSetYet) {
            BranchNodeConnections::SetUpCompSets(state,
                                                 cCurrentModuleObject,
                                                 thisObjectName,
                                                 loc_suppHeatCoilType,
                                                 loc_m_SuppHeatCoilName,
                                                 state.dataLoopNodes->NodeID(SupHeatCoilInletNode),
                                                 state.dataLoopNodes->NodeID(SupHeatCoilOutletNode));
            this->m_SuppCompNotSetYet = false;
        }

        // set fan info for heating coils
        if (this->m_SuppCoilExists && this->m_FanExists) {
            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                state.dataRptCoilSelection->coilSelectionReportObj->setCoilSupplyFanInfo(state,
                                                                                         this->m_SuppHeatCoilName,
                                                                                         this->m_SuppHeatCoilTypeName,
                                                                                         this->m_FanName,
                                                                                         DataAirSystems::objectVectorOOFanSystemModel,
                                                                                         this->m_FanIndex);
            } else {
                state.dataRptCoilSelection->coilSelectionReportObj->setCoilSupplyFanInfo(state,
                                                                                         this->m_SuppHeatCoilName,
                                                                                         this->m_SuppHeatCoilTypeName,
                                                                                         this->m_FanName,
                                                                                         DataAirSystems::structArrayLegacyFanModels,
                                                                                         this->m_FanIndex);
            }
        }

        // Users may not provide SA flow input fields (below) and leave them blank. Check if other coil is AutoSized first to
        // alieviate input requirements. check if coil has no air flow input (VolFlow = 0) and other coil isDataSizing::AutoSized. If so,
        // use AutoSize for coil with 0 air flow rate. This means that the coils MUST mine the air flow rate if it exists
        if (this->m_CoolCoilExists && this->m_HeatCoilExists) {
            if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize && this->m_MaxHeatAirVolFlow == 0 && loc_m_HeatingSAFMethod == "") {
                this->m_MaxHeatAirVolFlow = DataSizing::AutoSize;
            } else if (this->m_MaxCoolAirVolFlow == 0 && this->m_MaxHeatAirVolFlow == DataSizing::AutoSize && loc_m_CoolingSAFMethod == "") {
                this->m_MaxCoolAirVolFlow = DataSizing::AutoSize;
            }
        }

        // Determine supply air flow rate sizing method for cooling mode
        if (UtilityRoutines::SameString(loc_m_CoolingSAFMethod, "SupplyAirFlowRate")) {
            this->m_CoolingSAFMethod = state.dataUnitarySystems->SupplyAirFlowRate;

            if (loc_m_CoolingSAFMethod_SAFlow != -999.0) {
                this->m_MaxCoolAirVolFlow = loc_m_CoolingSAFMethod_SAFlow;
                if (this->m_MaxCoolAirVolFlow == DataSizing::AutoSize) {
                    this->m_RequestAutoSize = true;
                } else {
                    if (this->m_MaxCoolAirVolFlow <= DataHVACGlobals::SmallAirVolFlow && this->m_CoolCoilExists) {
                        ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = SupplyAirFlowRate.");
                        ShowContinueError(
                            state,
                            format("Suspicious Cooling Supply Air Flow Rate = {:.7R} when cooling coil is present.", this->m_MaxCoolAirVolFlow));
                    }
                    if (this->m_MaxCoolAirVolFlow < 0.0) errorsFound = true;
                }

            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = SupplyAirFlowRate.");
                ShowContinueError(state, "Blank field not allowed for Cooling Supply Air Flow Rate.");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_CoolingSAFMethod, "FlowPerFloorArea")) {

            this->m_CoolingSAFMethod = state.dataUnitarySystems->FlowPerFloorArea;
            if (loc_m_CoolingSAFMethod_SAFlowPerFloorArea != -999.0) {
                this->m_MaxCoolAirVolFlow = loc_m_CoolingSAFMethod_SAFlowPerFloorArea;
                if (this->m_MaxCoolAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxCoolAirVolFlow <= 0.0001 && this->m_CoolCoilExists) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = FlowPerFloorArea.");
                        ShowContinueError(
                            state,
                            format("Suspicious Cooling Supply Air Flow Rate Per Floor Area = {:.7R} [m3/s/m2] when cooling coil is present.",
                                   this->m_MaxCoolAirVolFlow));
                        if (this->m_MaxCoolAirVolFlow < 0.0) errorsFound = true;
                    }
                    this->m_MaxCoolAirVolFlow *= TotalFloorAreaOnAirLoop;
                    this->m_RequestAutoSize = true;
                    // AutoSized input is not allowed
                } else {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = FlowPerFloorArea.");
                    ShowContinueError(state, "Illegal Cooling Supply Air Flow Rate Per Floor Area = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = FlowPerFloorArea.");
                ShowContinueError(state, "Blank field not allowed for Cooling Supply Air Flow Rate Per Floor Area.");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_CoolingSAFMethod, "FractionOfAutosizedCoolingValue")) {

            this->m_CoolingSAFMethod = state.dataUnitarySystems->FractionOfAutoSizedCoolingValue;
            if (loc_m_CoolingSAFMethod_FracOfAutosizedCoolingSAFlow != -999.0) {
                this->m_MaxCoolAirVolFlow = loc_m_CoolingSAFMethod_FracOfAutosizedCoolingSAFlow;
                if (this->m_MaxCoolAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxCoolAirVolFlow <= DataHVACGlobals::SmallAirVolFlow && this->m_CoolCoilExists) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = FractionOfAutosizedCoolingValue.");
                        ShowContinueError(state,
                                          format("Suspicious Cooling Fraction of Autosized Cooling Supply Air Flow Rate = {:.7R} [m3/s/m3] "
                                                 "when cooling coil is present.",
                                                 this->m_MaxCoolAirVolFlow));
                        if (this->m_MaxCoolAirVolFlow < 0.0) errorsFound = true;
                    }
                    this->m_RequestAutoSize = true;
                    // AutoSized input is not allowed
                } else {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = FractionOfAutosizedCoolingValue.");
                    ShowContinueError(state, "Illegal Cooling Fraction of Autosized Cooling Supply Air Flow Rate = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = FractionOfAutosizedCoolingValue.");
                ShowContinueError(state, "Blank field not allowed for Cooling Fraction of Autosized Cooling Supply Air Flow Rate.");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_CoolingSAFMethod, "FlowPerCoolingCapacity")) {

            this->m_CoolingSAFMethod = state.dataUnitarySystems->FlowPerCoolingCapacity;
            if (loc_m_CoolingSAFMethod_FlowPerCoolingCapacity != -999.0) {
                this->m_MaxCoolAirVolFlow = loc_m_CoolingSAFMethod_FlowPerCoolingCapacity;
                if (this->m_MaxCoolAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxCoolAirVolFlow <= 0.00001 && this->m_CoolCoilExists) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = FlowPerCoolingCapacity.");
                        ShowContinueError(state,
                                          format("Suspicious Cooling Supply Air Flow Rate Per Unit of Capacity = {:.7R} [m3/s/W] when "
                                                 "cooling coil is present.",
                                                 this->m_MaxCoolAirVolFlow));
                        if (this->m_MaxCoolAirVolFlow < 0.0) errorsFound = true;
                    }
                    this->m_RequestAutoSize = true;
                    // AutoSized input is not allowed
                } else {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = FlowPerCoolingCapacity.");
                    ShowContinueError(state, "Illegal Cooling Supply Air Flow Rate Per Unit of Capacity = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for Cooling Supply Air Flow Rate Method = FlowPerCoolingCapacity.");
                ShowContinueError(state, "Blank field not allowed for Cooling Supply Air Flow Rate Per Unit of Capacity.");
                errorsFound = true;
            }

        } else if (UtilityRoutines::SameString(loc_m_CoolingSAFMethod, "None") || loc_m_CoolingSAFMethod == "") {
            this->m_CoolingSAFMethod = state.dataUnitarySystems->None;
            if (this->m_CoolCoilExists && this->m_MaxCoolAirVolFlow == 0) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                if (this->m_HeatCoilExists) {
                    ShowContinueError(state, "Blank field not allowed for this coil type when heating coil air flow rate is not AutoSized.");
                } else {
                    ShowContinueError(state, "Blank field not allowed for this type of cooling coil.");
                }
                errorsFound = true;
            }
        } else {
            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, "Illegal Cooling Supply Air Flow Rate Method = " + loc_m_CoolingSAFMethod);
            ShowContinueError(state,
                              "Valid entries are: SupplyAirFlowRate, FlowPerFloorArea, FractionOfAutosizedCoolingValue, "
                              "FlowPerCoolingCapacity, or None ");
            errorsFound = true;
        }

        // Determine supply air flow rate sizing method for heating mode
        if (UtilityRoutines::SameString(loc_m_HeatingSAFMethod, "SupplyAirFlowRate")) {
            this->m_HeatingSAFMethod = state.dataUnitarySystems->SupplyAirFlowRate;
            if (loc_m_HeatingSAFMethod_SAFlow != -999.0) {
                this->m_MaxHeatAirVolFlow = loc_m_HeatingSAFMethod_SAFlow;
                if (this->m_MaxHeatAirVolFlow == DataSizing::AutoSize) {
                    this->m_RequestAutoSize = true;
                } else {
                    if (this->m_MaxHeatAirVolFlow <= DataHVACGlobals::SmallAirVolFlow && this->m_HeatCoilExists) {
                        ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = SupplyAirFlowRate.");
                        ShowContinueError(
                            state,
                            format("Suspicious Heating Supply Air Flow Rate = {:.7R} when heating coil is present.", this->m_MaxHeatAirVolFlow));
                    }
                    if (this->m_MaxHeatAirVolFlow < 0.0) errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = SupplyAirFlowRate.");
                ShowContinueError(state, "Blank field not allowed for Heating Supply Air Flow Rate.");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_HeatingSAFMethod, "FlowPerFloorArea")) {
            this->m_HeatingSAFMethod = state.dataUnitarySystems->FlowPerFloorArea;
            if (loc_m_HeatingSAFMethod_SAFlowPerFloorArea != -999.0) {
                this->m_MaxHeatAirVolFlow = loc_m_HeatingSAFMethod_SAFlowPerFloorArea;
                if (this->m_MaxHeatAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxHeatAirVolFlow <= 0.0001 && this->m_HeatCoilExists) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = FlowPerFloorArea.");
                        ShowContinueError(
                            state,
                            format("Suspicious Heating Supply Air Flow Rate Per Floor Area = {:.7R} [m3/s/m2] when heating coil is present.",
                                   this->m_MaxHeatAirVolFlow));
                    }
                    if (this->m_MaxHeatAirVolFlow < 0.0) errorsFound = true;
                    this->m_MaxHeatAirVolFlow *= TotalFloorAreaOnAirLoop;
                    this->m_RequestAutoSize = true;
                } else {
                    // AutoSized input is not allowed
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = FlowPerFloorArea.");
                    ShowContinueError(state, "Illegal Heating Supply Air Flow Rate Per Floor Area = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = FlowPerFloorArea.");
                ShowContinueError(state, "Blank field not allowed for Heating Supply Air Flow Rate Per Floor Area.");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_HeatingSAFMethod, "FractionOfAutosizedHeatingValue")) {
            this->m_HeatingSAFMethod = state.dataUnitarySystems->FractionOfAutoSizedHeatingValue;
            if (loc_m_HeatingSAFMethod_FracOfAutosizedHeatingSAFlow != -999.0) {
                this->m_MaxHeatAirVolFlow = loc_m_HeatingSAFMethod_FracOfAutosizedHeatingSAFlow;
                if (this->m_MaxHeatAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxHeatAirVolFlow <= DataHVACGlobals::SmallAirVolFlow && this->m_HeatCoilExists) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = FractionOfAutosizedHeatingValue.");
                        ShowContinueError(state,
                                          format("Suspicious Heating Fraction of Autosized Heating Supply Air Flow Rate = {:.7R} [m3/s/m3] "
                                                 "when heating coil is present.",
                                                 this->m_MaxHeatAirVolFlow));
                        if (this->m_MaxHeatAirVolFlow < 0.0) errorsFound = true;
                    }
                    this->m_RequestAutoSize = true;
                    // AutoSized input is not allowed
                } else {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = FractionOfAutosizedHeatingValue");
                    ShowContinueError(state, "Illegal input for Heating Fraction of Autosized Heating Supply Air Flow Rate = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = FractionOfAutosizedHeatingValue");
                ShowContinueError(state, "Blank field not allowed for Heating Fraction of Autosized Heating Supply Air Flow Rate");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_HeatingSAFMethod, "FlowPerHeatingCapacity")) {
            this->m_HeatingSAFMethod = state.dataUnitarySystems->FlowPerHeatingCapacity;
            if (loc_m_HeatingSAFMethod_FlowPerHeatingCapacity != -999.0) {
                this->m_MaxHeatAirVolFlow = loc_m_HeatingSAFMethod_FlowPerHeatingCapacity;
                if (this->m_MaxHeatAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxHeatAirVolFlow <= 0.00001 && this->m_HeatCoilExists) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = FlowPerHeatingCapacity.");
                        ShowContinueError(state,
                                          format("Suspicious Heating Supply Air Flow Rate Per Unit of Capacity = {:.7R} [m3/s/W] when "
                                                 "heating coil is present.",
                                                 this->m_MaxHeatAirVolFlow));
                        if (this->m_MaxHeatAirVolFlow < 0.0) errorsFound = true;
                    }
                    this->m_RequestAutoSize = true;
                    // AutoSized input is not allowed
                } else {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = FlowPerHeatingCapacity.");
                    ShowContinueError(state, "Illegal Heating Supply Air Flow Rate Per Unit of Capacity = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = FlowPerHeatingCapacity");
                ShowContinueError(state, "Blank field not allowed for Heating Supply Air Flow Rate Per Unit of Capacity");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_HeatingSAFMethod, "None") || loc_m_HeatingSAFMethod == "") {
            this->m_HeatingSAFMethod = state.dataUnitarySystems->None;
            if (this->m_HeatCoilExists && this->m_MaxHeatAirVolFlow == 0) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                if (loc_m_HeatingSAFMethod == "") {
                    ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method is blank.");
                } else {
                    ShowContinueError(state, "Input for Heating Supply Air Flow Rate Method = None.");
                }
                if (this->m_CoolCoilExists) {
                    ShowContinueError(state, "Blank field not allowed for this coil type when cooling coil air flow rate is not AutoSized.");
                } else {
                    ShowContinueError(state, "Blank field not allowed for this type of heating coil.");
                }
                errorsFound = true;
            }
        } else {
            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, "Illegal Heating Supply Air Flow Rate Method = " + loc_m_HeatingSAFMethod);
            ShowContinueError(state,
                              "Valid entries are: SupplyAirFlowRate, FlowPerFloorArea, FractionOfAutosizedHeatingValue, "
                              "FlowPerHeatingCapacity, or None ");
            errorsFound = true;
        }

        // Determine supply air flow rate sizing method when cooling or heating is not needed
        if (UtilityRoutines::SameString(loc_m_NoCoolHeatSAFMethod, "SupplyAirFlowRate")) {
            this->m_NoCoolHeatSAFMethod = state.dataUnitarySystems->SupplyAirFlowRate;
            if (loc_m_NoCoolHeatSAFMethod_SAFlow != -999.0) {
                this->m_MaxNoCoolHeatAirVolFlow = loc_m_NoCoolHeatSAFMethod_SAFlow;
                if (this->m_MaxNoCoolHeatAirVolFlow == DataSizing::AutoSize) {
                    this->m_RequestAutoSize = true;
                } else {
                    if (this->m_MaxNoCoolHeatAirVolFlow < 0.0) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = SupplyAirFlowRate");
                        ShowContinueError(state, format("Illegal No Load Supply Air Flow Rate = {:.7R}", this->m_MaxNoCoolHeatAirVolFlow));
                        errorsFound = true;
                    }
                }

            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = SupplyAirFlowRate");
                ShowContinueError(state, "Blank field not allowed for No Load Supply Air Flow Rate");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_NoCoolHeatSAFMethod, "FlowPerFloorArea")) {
            this->m_NoCoolHeatSAFMethod = state.dataUnitarySystems->FlowPerFloorArea;
            if (loc_m_NoCoolHeatSAFMethod_SAFlowPerFloorArea != -999.0) {
                this->m_MaxNoCoolHeatAirVolFlow = loc_m_NoCoolHeatSAFMethod_SAFlowPerFloorArea;
                if (this->m_MaxNoCoolHeatAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxNoCoolHeatAirVolFlow <= 0.0001) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FlowPerFloorArea.");
                        ShowContinueError(
                            state,
                            format("Suspicious No Load Supply Air Flow Rate Per Floor Area = {:.7R} [m3/s/m2]", this->m_MaxNoCoolHeatAirVolFlow));
                    }
                    if (this->m_MaxNoCoolHeatAirVolFlow < 0.0) errorsFound = true;
                    this->m_MaxNoCoolHeatAirVolFlow *= TotalFloorAreaOnAirLoop;
                    this->m_RequestAutoSize = true;
                } else {
                    // AutoSized input is not allowed
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FlowPerFloorArea.");
                    ShowContinueError(state, "Illegal No Load Supply Air Flow Rate Per Floor Area = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FlowPerFloorArea.");
                ShowContinueError(state, "Blank field not allowed for No Load Supply Air Flow Rate Per Floor Area");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_NoCoolHeatSAFMethod, "FractionOfAutosizedCoolingValue")) {
            this->m_NoCoolHeatSAFMethod = state.dataUnitarySystems->FractionOfAutoSizedCoolingValue;
            if (loc_m_NoCoolHeatSAFMethod_FracOfAutosizedCoolingSAFlow != -999.0) {
                this->m_MaxNoCoolHeatAirVolFlow = loc_m_NoCoolHeatSAFMethod_FracOfAutosizedCoolingSAFlow;
                if (this->m_MaxNoCoolHeatAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxNoCoolHeatAirVolFlow <= DataHVACGlobals::SmallAirVolFlow) {
                        ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FractionOfAutosizedCoolingValue.");
                        ShowContinueError(
                            state,
                            format("Suspicious No Load Supply Air Flow Rate Per Unit of Capacity During Cooling Operation = {:.7R} [m3/s/m3].",
                                   this->m_MaxNoCoolHeatAirVolFlow));
                        if (this->m_MaxNoCoolHeatAirVolFlow < 0.0) errorsFound = true;
                    }
                    this->m_RequestAutoSize = true;
                    // AutoSized input is not allowed
                } else {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FractionOfAutosizedCoolingValue");
                    ShowContinueError(state,
                                      "Illegal input for No Load Supply Air Flow Rate Per Unit of Capacity During Cooling Operation = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FractionOfAutosizedCoolingValue.");
                ShowContinueError(state, "Blank field not allowed for No Load Supply Air Flow Rate Per Unit of Capacity During Cooling Operation");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_NoCoolHeatSAFMethod, "FractionOfAutosizedHeatingValue")) {
            this->m_NoCoolHeatSAFMethod = state.dataUnitarySystems->FractionOfAutoSizedHeatingValue;
            if (loc_m_NoCoolHeatSAFMethod_FracOfAutosizedHeatingSAFlow != -999.0) {
                this->m_MaxNoCoolHeatAirVolFlow = loc_m_NoCoolHeatSAFMethod_FracOfAutosizedHeatingSAFlow;
                if (this->m_MaxNoCoolHeatAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxNoCoolHeatAirVolFlow <= DataHVACGlobals::SmallAirVolFlow) {
                        ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FractionOfAutosizedHeatingValue.");
                        ShowContinueError(
                            state,
                            format("Suspicious No Load Supply Air Flow Rate Per Unit of Capacity During Heating Operation = {:.7R} [m3/s/m3].",
                                   this->m_MaxNoCoolHeatAirVolFlow));
                        if (this->m_MaxNoCoolHeatAirVolFlow < 0.0) errorsFound = true;
                    }
                    this->m_RequestAutoSize = true;
                    // AutoSized input is not allowed
                } else {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FractionOfAutosizedHeatingValue");
                    ShowContinueError(state,
                                      "Illegal input for No Load Supply Air Flow Rate Per Unit of Capacity During Heating Operation = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FractionOfAutosizedHeatingValue.");
                ShowContinueError(state, "Blank field not allowed for No Load Supply Air Flow Rate Per Unit of Capacity During Heating Operation");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_NoCoolHeatSAFMethod, "FlowPerCoolingCapacity")) {
            this->m_NoCoolHeatSAFMethod = state.dataUnitarySystems->FlowPerCoolingCapacity;
            if (loc_m_NoCoolHeatSAFMethod_FlowPerCoolingCapacity != -999.0) {
                this->m_MaxNoCoolHeatAirVolFlow = loc_m_NoCoolHeatSAFMethod_FlowPerCoolingCapacity;
                if (this->m_MaxNoCoolHeatAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxNoCoolHeatAirVolFlow <= 0.00001 && this->m_CoolCoilExists) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FlowPerCoolingCapacity.");
                        ShowContinueError(
                            state,
                            format("Suspicious No Load Supply Air Flow Rate Per Unit of Capacity During Cooling Operation = {:.7R} [m3/s/W].",
                                   this->m_MaxNoCoolHeatAirVolFlow));
                        if (this->m_MaxNoCoolHeatAirVolFlow < 0.0) errorsFound = true;
                    }
                    this->m_RequestAutoSize = true;
                    // AutoSized input is not allowed
                } else {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FlowPerCoolingCapacity.");
                    ShowContinueError(state, "Illegal No Load Supply Air Flow Rate Per Unit of Capacity During Cooling Operation = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FlowPerCoolingCapacity.");
                ShowContinueError(state, "Blank field not allowed for No Load Supply Air Flow Rate Per Unit of Capacity During Cooling Operation");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_NoCoolHeatSAFMethod, "FlowPerHeatingCapacity")) {
            this->m_NoCoolHeatSAFMethod = state.dataUnitarySystems->FlowPerHeatingCapacity;
            if (loc_m_NoCoolHeatSAFMethod_FlowPerHeatingCapacity != -999.0) {
                this->m_MaxNoCoolHeatAirVolFlow = loc_m_NoCoolHeatSAFMethod_FlowPerHeatingCapacity;
                if (this->m_MaxNoCoolHeatAirVolFlow != DataSizing::AutoSize) {
                    if (this->m_MaxNoCoolHeatAirVolFlow <= 0.00001 && this->m_HeatCoilExists) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FlowPerHeatingCapacity.");
                        ShowContinueError(
                            state,
                            format("Suspicious No Load Supply Air Flow Rate Per Unit of Capacity During Heating Operation = {:.7R} [m3/s/W].",
                                   this->m_MaxNoCoolHeatAirVolFlow));
                        if (this->m_MaxNoCoolHeatAirVolFlow < 0.0) errorsFound = true;
                    }
                    this->m_RequestAutoSize = true;
                    // AutoSized input is not allowed
                } else {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FlowPerHeatingCapacity.");
                    ShowContinueError(state, "Illegal No Load Supply Air Flow Rate Per Unit of Capacity During Heating Operation = Autosize");
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Input for No Load Supply Air Flow Rate Method = FlowPerHeatingCapacity.");
                ShowContinueError(state, "Blank field not allowed for No Load Supply Air Flow Rate Per Unit of Capacity During Heating Operation");
                errorsFound = true;
            }
        } else if (UtilityRoutines::SameString(loc_m_NoCoolHeatSAFMethod, "None") || loc_m_NoCoolHeatSAFMethod == "") {
            this->m_NoCoolHeatSAFMethod = state.dataUnitarySystems->None;
            if (this->m_ControlType == ControlType::CCMASHRAE) {
                if (loc_m_NoCoolHeatSAFMethod_SAFlow == -99999.0) { // no load air flow is autosized
                    this->m_MaxNoCoolHeatAirVolFlow = DataSizing::AutoSize;
                    this->m_RequestAutoSize = true;
                } else if (loc_m_NoCoolHeatSAFMethod_SAFlow == -999.0) { // no load air flow is blank
                    this->m_MaxNoCoolHeatAirVolFlow = DataSizing::AutoSize;
                    this->m_RequestAutoSize = true;
                    ShowWarningError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
                    ShowContinueError(state, "Control Type = " + loc_m_ControlType);
                    ShowContinueError(state, "Input for No Load Supply Air Flow Rate cannot be blank.");
                    ShowContinueError(state, "Input for No Load Supply Air Flow Rate has been set to AutoSize and the simulation continues.");
                } else if (loc_m_NoCoolHeatSAFMethod_SAFlow == 0.0) { // no load air flow for SZVAV cannot be 0
                    ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
                    ShowContinueError(state, "Control Type = " + loc_m_ControlType);
                    ShowContinueError(state, "Input for No Load Supply Air Flow Rate cannot be 0.");
                    errorsFound = true;
                }
            }
        } else {
            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, "Illegal No Load Supply Air Flow Rate Method = " + loc_m_NoCoolHeatSAFMethod);
            ShowContinueError(state,
                              "Valid entries are: SupplyAirFlowRate, FlowPerFloorArea, FractionOfAutosizedCoolingValue, "
                              "FractionOfAutosizedHeatingValue, FlowPerCoolingCapacity, FlowPerHeatingCapacity, or None ");
            errorsFound = true;
        }

        // check supply air flow calculation method
        if (this->m_FanExists) {
            if (this->m_CoolCoilExists) {
                if (loc_m_CoolingSAFMethod == "") {
                    ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state,
                                      "Method used to determine the cooling supply air flow rate is not specified when cooling coil is present.");
                    // check if all cooling flow calc method fields are blank
                    if (((loc_m_CoolingSAFMethod_SAFlow == -999.0) && (loc_m_CoolingSAFMethod_SAFlowPerFloorArea == -999.0) &&
                         (loc_m_CoolingSAFMethod_FracOfAutosizedCoolingSAFlow == -999.0) &&
                         (loc_m_CoolingSAFMethod_FlowPerCoolingCapacity == -999.0))) {
                        ShowContinueError(state, "Cooling Supply Air Flow Rate field is blank.");
                        ShowContinueError(state, "Cooling Supply Air Flow Rate Per Floor Area field is blank.");
                        ShowContinueError(state, "Cooling Fraction of Autosized Cooling Supply Air Flow Rate field is blank.");
                        ShowContinueError(state, "Cooling Supply Air Flow Rate Per Unit of Capacity field is blank.");
                        ShowContinueError(state,
                                          "Blank field not allowed for all four cooling supply air flow rate calculation methods when "
                                          "cooling coil is present.");
                    }
                }
            }
            if (this->m_HeatCoilExists) {
                if (loc_m_HeatingSAFMethod == "") {
                    ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state,
                                      "Method used to determine the heating supply air flow rate is not specified when heating coil is present.");
                    // check if all heating flow calc method fields are blank
                    if (((loc_m_HeatingSAFMethod_SAFlow == -999.0) && (loc_m_HeatingSAFMethod_SAFlowPerFloorArea == -999.0) &&
                         (loc_m_HeatingSAFMethod_FracOfAutosizedHeatingSAFlow == -999.0) &&
                         (loc_m_HeatingSAFMethod_FlowPerHeatingCapacity == -999.0))) {
                        ShowContinueError(state, "Heating Supply Air Flow Rate field is blank.");
                        ShowContinueError(state, "Heating Supply Air Flow Rate Per Floor Area field is blank.");
                        ShowContinueError(state, "Heating Fraction of Autosized Heating Supply Air Flow Rate field is blank.");
                        ShowContinueError(state, "Heating Supply Air Flow Rate Per Unit of Capacity field is blank.");
                        ShowContinueError(state,
                                          "Blank field not allowed for all four heating supply air flow rate calculation methods when heating "
                                          "coil is present.");
                    }
                }
            }
        }

        //       Fan operating mode (cycling or constant) schedule. IF constant fan, then set AirFlowControl
        if (this->m_FanOpModeSchedPtr > 0) {
            if (!ScheduleManager::CheckScheduleValueMinMax(state, this->m_FanOpModeSchedPtr, ">=", 0.0, "<=", 0.0)) {
                //           set fan operating mode to continuous so sizing can set VS coil data
                this->m_FanOpMode = DataHVACGlobals::ContFanCycCoil;
                //           set air flow control mode:
                //             UseCompressorOnFlow = operate at last cooling or heating air flow requested when compressor is off
                //             UseCompressorOffFlow = operate at value specified by user
                //           AirFlowControl only valid if fan opmode = ContFanCycComp
                if (this->m_MaxNoCoolHeatAirVolFlow == 0.0) {
                    this->m_AirFlowControl = UseCompFlow::UseCompressorOnFlow;
                } else {
                    this->m_AirFlowControl = UseCompFlow::UseCompressorOffFlow;
                }
            }
        }

        if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling && this->m_DehumidControlType_Num == DehumCtrlType::Multimode) {
            int numCoolingCoilModes = state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].getNumModes();
            if (numCoolingCoilModes == 1) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Illegal Dehumidification Control Type = " + loc_dehumm_ControlType);
                ShowContinueError(state, "Multimode control must be used with a Heat Exchanger Assisted or Multimode Cooling Coil.");
                ShowContinueError(
                    state, "Cooling coil named: " + state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].name + " has only one mode");
                ShowFatalError(state, "Multimode cooling coil error causes program termination");
            }
        } else if (this->m_CoolingCoilType_Num != DataHVACGlobals::CoilDX_CoolingHXAssisted &&
                   this->m_CoolingCoilType_Num != DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl &&
                   this->m_CoolingCoilType_Num != DataHVACGlobals::CoilWater_CoolingHXAssisted &&
                   this->m_DehumidControlType_Num == DehumCtrlType::Multimode) {
            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, "Illegal Dehumidification Control Type = " + loc_dehumm_ControlType);
            ShowContinueError(state, "Multimode control must be used with a Heat Exchanger Assisted or Multimode Cooling Coil.");
            if (loc_m_SuppHeatCoilName == "" && loc_suppHeatCoilType == "") {
            } else {
                if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_UserDefined) {
                    ShowContinueError(state, "Dehumidification control type is assumed to be None and the simulation continues.");
                    this->m_DehumidControlType_Num = DehumCtrlType::None;
                } else {
                    ShowContinueError(state, "Dehumidification control type is assumed to be CoolReheat and the simulation continues.");
                    this->m_DehumidControlType_Num = DehumCtrlType::CoolReheat;
                }
            }
        }

        //       Check placement of cooling coil with respect to fan placement and dehumidification control type

        if (this->m_FanExists) {
            if (this->m_FanPlace == FanPlace::BlowThru) {
                if (FanOutletNode == HeatingCoilInletNode && this->m_DehumidControlType_Num != DehumCtrlType::CoolReheat) {
                    this->m_CoolingCoilUpstream = false;
                }
            } else if (this->m_FanPlace == FanPlace::DrawThru) {
                if (HeatingCoilOutletNode == CoolingCoilInletNode && this->m_DehumidControlType_Num != DehumCtrlType::CoolReheat) {
                    this->m_CoolingCoilUpstream = false;
                }
            }
        } else {
            if (HeatingCoilOutletNode == CoolingCoilInletNode && this->m_DehumidControlType_Num != DehumCtrlType::CoolReheat) {
                this->m_CoolingCoilUpstream = false;
            }
            if (ZoneEquipmentFound) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "ZoneHVAC equipment must contain a fan object.");
                ShowContinueError(state, "specified Supply Fan Object Type = " + loc_fanType);
                ShowContinueError(state, "specified Supply Fan Name = " + loc_m_FanName);
                errorsFound = true;
            }
        }

        // check node connections
        if (this->m_FanPlace == FanPlace::BlowThru) {

            if (FanInletNode != this->AirInNode) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state,
                                  "When a blow through fan is specified, the fan inlet node name must be the same as the unitary system "
                                  "inlet node name.");
                ShowContinueError(state, "...Fan inlet node name           = " + state.dataLoopNodes->NodeID(FanInletNode));
                ShowContinueError(state, "...UnitarySystem inlet node name = " + state.dataLoopNodes->NodeID(this->AirInNode));
                errorsFound = true;
            }
            if (this->m_CoolingCoilUpstream) {
                if (FanOutletNode != CoolingCoilInletNode && this->m_CoolCoilExists && this->m_FanExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state,
                                      "When a blow through fan is specified, the fan outlet node name must be the same as the cooling coil "
                                      "inlet node name.");
                    ShowContinueError(state, "...Fan outlet node name         = " + state.dataLoopNodes->NodeID(FanOutletNode));
                    ShowContinueError(state, "...Cooling coil inlet node name = " + state.dataLoopNodes->NodeID(CoolingCoilInletNode));
                    errorsFound = true;
                }
                if (CoolingCoilOutletNode != HeatingCoilInletNode && this->m_CoolCoilExists && this->m_HeatCoilExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "The cooling coil outlet node name must be the same as the heating coil inlet node name.");
                    ShowContinueError(state, "...Cooling coil outlet node name = " + state.dataLoopNodes->NodeID(CoolingCoilOutletNode));
                    ShowContinueError(state, "...Heating coil inlet node name  = " + state.dataLoopNodes->NodeID(HeatingCoilInletNode));
                    errorsFound = true;
                }
                if (this->m_SuppCoilExists) {
                    if (SupHeatCoilOutletNode != this->AirOutNode) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "The reheat coil outlet node name must be the same as the unitary system outlet node name.");
                        ShowContinueError(state, "...Reheat coil outlet node name   = " + state.dataLoopNodes->NodeID(SupHeatCoilOutletNode));
                        ShowContinueError(state, "...UnitarySystem outlet node name = " + state.dataLoopNodes->NodeID(this->AirOutNode));
                        errorsFound = true;
                    }
                } else { // IF((this->m_Humidistat ...
                    // Heating coil outlet node name must be the same as the Unitary system outlet node name
                    if (this->m_HeatCoilExists && HeatingCoilOutletNode != this->AirOutNode) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state,
                                          "When a blow through fan is specified, the heating coil outlet node name must be the same as the "
                                          "unitary system outlet node name.");
                        ShowContinueError(state, "...Heating coil outlet node name  = " + state.dataLoopNodes->NodeID(HeatingCoilOutletNode));
                        ShowContinueError(state, "...Unitary system outlet node name = " + state.dataLoopNodes->NodeID(this->AirOutNode));
                        errorsFound = true;
                    }
                }
            } else { // IF(this->CoolingCoilUpstream)THEN
                if (FanOutletNode != HeatingCoilInletNode && this->m_FanExists && this->m_HeatCoilExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state,
                                      "When a blow through fan is specified, the fan outlet node name must be the same as the heating coil "
                                      "inlet node name.");
                    ShowContinueError(state, "...Fan outlet node name         = " + state.dataLoopNodes->NodeID(FanOutletNode));
                    ShowContinueError(state, "...Heating coil inlet node name = " + state.dataLoopNodes->NodeID(HeatingCoilInletNode));
                    errorsFound = true;
                }
                if (HeatingCoilOutletNode != CoolingCoilInletNode && this->m_CoolCoilExists && this->m_HeatCoilExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "The heating coil outlet node name must be the same as the cooling coil inlet node name.");
                    ShowContinueError(state, "...Heating coil outlet node name = " + state.dataLoopNodes->NodeID(HeatingCoilOutletNode));
                    ShowContinueError(state, "...Cooling coil inlet node name  = " + state.dataLoopNodes->NodeID(CoolingCoilInletNode));
                    errorsFound = true;
                }
                if (CoolingCoilOutletNode != this->AirOutNode && this->m_CoolCoilExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state,
                                      "When a blow through fan is specified, the cooling coil outlet node name must be the same as the unitary "
                                      "system outlet node name.");
                    ShowContinueError(state, "...Cooling coil outlet node name   = " + state.dataLoopNodes->NodeID(CoolingCoilOutletNode));
                    ShowContinueError(state, "...UnitarySystem outlet node name  = " + state.dataLoopNodes->NodeID(this->AirOutNode));
                    errorsFound = true;
                }
            }

        } else if (this->m_FanPlace == FanPlace::DrawThru) { // ELSE from IF(this->FanPlace .EQ. BlowThru)THEN

            if (this->m_CoolingCoilUpstream) {
                if (CoolingCoilInletNode != this->AirInNode && CoolingCoilInletNode != 0 && this->m_FanExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state,
                                      "When a draw through fan is specified, the cooling coil inlet node name must be the same as the unitary "
                                      "system inlet node name.");
                    ShowContinueError(state, "...Cooling coil inlet node name  = " + state.dataLoopNodes->NodeID(CoolingCoilInletNode));
                    ShowContinueError(state, "...UnitarySystem inlet node name = " + state.dataLoopNodes->NodeID(this->AirInNode));
                    errorsFound = true;
                }
                if (CoolingCoilOutletNode != HeatingCoilInletNode && this->m_CoolCoilExists && this->m_HeatCoilExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "The cooling coil outlet node name must be the same as the heating coil inlet node name.");
                    ShowContinueError(state, "...Cooling coil outlet node name = " + state.dataLoopNodes->NodeID(CoolingCoilOutletNode));
                    ShowContinueError(state, "...Heating coil inlet node name  = " + state.dataLoopNodes->NodeID(HeatingCoilInletNode));
                    errorsFound = true;
                }
                if (HeatingCoilOutletNode != FanInletNode && this->m_HeatCoilExists && this->m_FanExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state,
                                      "When a draw through fan is specified, the heating coil outlet node name must be the same as the fan "
                                      "inlet node name.");
                    ShowContinueError(state, "...Heating coil outlet node name = " + state.dataLoopNodes->NodeID(HeatingCoilOutletNode));
                    ShowContinueError(state, "...Fan inlet node name           = " + state.dataLoopNodes->NodeID(FanInletNode));
                    errorsFound = true;
                }
                if (this->m_SuppCoilExists) {
                    if (FanOutletNode != SupHeatCoilInletNode && this->m_FanExists) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state,
                                          "When a draw through fan is specified, the fan outlet node name must be the same as the reheat coil "
                                          "inlet node name.");
                        ShowContinueError(state, "...Fan outlet node name        = " + state.dataLoopNodes->NodeID(FanOutletNode));
                        ShowContinueError(state, "...Reheat coil inlet node name = " + state.dataLoopNodes->NodeID(SupHeatCoilInletNode));
                        errorsFound = true;
                    }
                    if (SupHeatCoilOutletNode != this->AirOutNode) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state, "The reheat coil outlet node name must be the same as the unitary system outlet node name.");
                        ShowContinueError(state, "...Reheat coil outlet node name   = " + state.dataLoopNodes->NodeID(SupHeatCoilOutletNode));
                        ShowContinueError(state, "...UnitarySystem outlet node name = " + state.dataLoopNodes->NodeID(this->AirOutNode));
                        errorsFound = true;
                    }
                } else {
                    if (FanOutletNode != this->AirOutNode && this->m_FanExists) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state,
                                          "When a draw through fan is specified, the fan outlet node name must be the same as the unitary system "
                                          "outlet node name.");
                        ShowContinueError(state, "...Fan outlet node name        = " + state.dataLoopNodes->NodeID(FanOutletNode));
                        ShowContinueError(state, "...Unitary system outlet node name = " + state.dataLoopNodes->NodeID(this->AirOutNode));
                        errorsFound = true;
                    }
                }
            } else { // IF(this->CoolingCoilUpstream)THEN
                if (HeatingCoilInletNode != this->AirInNode && HeatingCoilInletNode != 0 && this->m_FanExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state,
                                      "When a draw through fan is specified, the heating coil inlet node name must be the same as the unitary "
                                      "system inlet node name.");
                    ShowContinueError(state, "...Heating coil inlet node name  = " + state.dataLoopNodes->NodeID(HeatingCoilInletNode));
                    ShowContinueError(state, "...UnitarySystem inlet node name = " + state.dataLoopNodes->NodeID(this->AirInNode));
                    errorsFound = true;
                }
                if (HeatingCoilOutletNode != CoolingCoilInletNode && this->m_HeatCoilExists && this->m_CoolCoilExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state, "The heating coil outlet node name must be the same as the cooling coil inlet node name.");
                    ShowContinueError(state, "...Heating coil outlet node name = " + state.dataLoopNodes->NodeID(HeatingCoilOutletNode));
                    ShowContinueError(state, "...Cooling coil inlet node name  = " + state.dataLoopNodes->NodeID(CoolingCoilInletNode));
                    errorsFound = true;
                }
                if (CoolingCoilOutletNode != FanInletNode && this->m_CoolCoilExists && this->m_FanExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state,
                                      "When a draw through fan is specified, the cooling coil outlet node name must be the same as the fan "
                                      "inlet node name.");
                    ShowContinueError(state, "...Cooling coil outlet node name = " + state.dataLoopNodes->NodeID(CoolingCoilOutletNode));
                    ShowContinueError(state, "...Fan inlet node name           = " + state.dataLoopNodes->NodeID(FanInletNode));
                    errorsFound = true;
                }
                if (FanOutletNode != this->AirOutNode && this->m_FanExists) {
                    ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                    ShowContinueError(state,
                                      "When a draw through fan is specified, the fan outlet node name must be the same as the unitary system "
                                      "outlet node name.");
                    ShowContinueError(state, "...Fan outlet node name           = " + state.dataLoopNodes->NodeID(FanOutletNode));
                    ShowContinueError(state, "...UnitarySystem outlet node name = " + state.dataLoopNodes->NodeID(this->AirOutNode));
                    errorsFound = true;
                }
            }
        } // ELSE from IF(this->FanPlace .EQ. BlowThru)THEN

        // Set the unitary system supplemental heater max outlet temperature
        // this field will be 0 if the input is not specified (included) in the input file
        // someone may use a default other than what we intended, allow it to be used
        // so if this field is blank, and the input field is included, read the default, otherwise use 80
        // if (!lNumericBlanks(iDesignMaxOutletTempNumericNum) && NumNumbers > (iDesignMaxOutletTempNumericNum - 1)) {
        this->DesignMaxOutletTemp = loc_DesignMaxOutletTemp;
        if (this->DesignMaxOutletTemp == DataSizing::AutoSize) this->m_RequestAutoSize = true;
        //}

        // Set maximum Outdoor air temperature for supplemental heating coil operation
        // this field will be 0 if the input is not specified (included) in the input file
        // someone may use a default other than what we intended, allow it to be used
        // so if this field is blank, and the input field is included, read the default, otherwise use 9999
        // if (!lNumericBlanks(iMaxOATSuppHeatNumericNum) && NumNumbers > (iMaxOATSuppHeatNumericNum - 1)) {
        this->m_MaxOATSuppHeat = loc_m_MaxOATSuppHeat;
        // Can't let MaxOATSuppHeat default to 21C if using cool reheat since it would shut off supp heater when dehumidifying
        // this may also allow supplemental heater to operate when in heating mode when it should not
        if (this->m_MaxOATSuppHeat == 21.0 && this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat) {
            this->m_MaxOATSuppHeat = 999.0;
        }

        if (this->m_MaxCoolAirVolFlow > 0.0 && this->m_MaxHeatAirVolFlow > 0.0 && this->m_MaxNoCoolHeatAirVolFlow >= 0.0 &&
            !this->m_RequestAutoSize) {
            this->m_DesignFanVolFlowRate = max(this->m_MaxCoolAirVolFlow, this->m_MaxHeatAirVolFlow, this->m_MaxNoCoolHeatAirVolFlow);
        } else if (this->m_MaxCoolAirVolFlow > 0.0 && this->m_MaxNoCoolHeatAirVolFlow >= 0.0 && !this->m_RequestAutoSize) {
            this->m_DesignFanVolFlowRate = max(this->m_MaxCoolAirVolFlow, this->m_MaxNoCoolHeatAirVolFlow);
        } else if (this->m_MaxHeatAirVolFlow > 0.0 && this->m_MaxNoCoolHeatAirVolFlow >= 0.0 && !this->m_RequestAutoSize) {
            this->m_DesignFanVolFlowRate = max(this->m_MaxHeatAirVolFlow, this->m_MaxNoCoolHeatAirVolFlow);
        } else {
            if (this->m_FanExists && this->m_DesignFanVolFlowRate == 0.0) {
                this->m_DesignFanVolFlowRate = DataSizing::AutoSize;
            }
            // need more of this type of warning when flow cannot be determined
            if (this->m_MaxHeatAirVolFlow == 0.0 && this->m_HeatCoilExists) {
                if (this->m_FanExists) {
                    if (this->m_CoolCoilExists && this->m_MaxCoolAirVolFlow != DataSizing::AutoSize) {
                        if (this->m_MaxCoolAirVolFlow == 0.0) {
                            this->m_MaxHeatAirVolFlow = this->m_DesignFanVolFlowRate;
                        }
                    }
                } else if (this->m_CoolCoilExists) {
                    this->m_MaxHeatAirVolFlow = this->m_MaxCoolAirVolFlow;
                } else {
                    if (this->m_HeatingCoilType_Num != DataHVACGlobals::CoilDX_HeatingEmpirical &&
                        this->m_HeatingCoilType_Num != DataHVACGlobals::CoilDX_MultiSpeedHeating &&
                        this->m_HeatingCoilType_Num != DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) {
                        ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                        ShowContinueError(state,
                                          "When non-DX heating coils are specified, the heating air flow rate must be entered in Heating "
                                          "Supply Air Flow Rate Method");
                        errorsFound = true;
                    }
                }
            } else if (this->m_MaxHeatAirVolFlow == 0.0 && !this->m_FanExists && !this->m_CoolCoilExists) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state,
                                  "When non-DX heating coils are specified, the heating air flow rate must be entered in Heating "
                                  "Supply Air Flow Rate Method");
            }
        }

        if (FanVolFlowRate != DataSizing::AutoSize && this->m_FanExists) {
            if (FanVolFlowRate < this->m_MaxCoolAirVolFlow && this->m_MaxCoolAirVolFlow != DataSizing::AutoSize && this->m_CoolCoilExists) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(
                    state,
                    format("... air flow rate = {:.7T} in fan object {} is less than the maximum HVAC system air flow rate in cooling mode.",
                           FanVolFlowRate,
                           this->m_FanName));
                ShowContinueError(state, " The Cooling Supply Air Flow Rate is reset to the fan flow rate and the simulation continues.");
                this->m_MaxCoolAirVolFlow = FanVolFlowRate;
                this->m_DesignFanVolFlowRate = FanVolFlowRate;
            }
            if (FanVolFlowRate < this->m_MaxHeatAirVolFlow && this->m_MaxHeatAirVolFlow != DataSizing::AutoSize && this->m_HeatCoilExists) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(
                    state,
                    format("... air flow rate = {:.7T} in fan object {} is less than the maximum HVAC system air flow rate in heating mode.",
                           FanVolFlowRate,
                           this->m_FanName));
                ShowContinueError(state, " The Heating Supply Air Flow Rate is reset to the fan flow rate and the simulation continues.");
                this->m_MaxHeatAirVolFlow = FanVolFlowRate;
                this->m_DesignFanVolFlowRate = FanVolFlowRate;
            }
        }

        if (this->m_FanOpModeSchedPtr > 0) {
            if (!ScheduleManager::CheckScheduleValueMinMax(state, this->m_FanOpModeSchedPtr, ">=", 0.0, "<=", 0.0)) {
                //           set air flow control mode:
                //             UseCompressorOnFlow = operate at last cooling or heating air flow requested when compressor is off
                //             UseCompressorOffFlow = operate at value specified by user
                //           AirFlowControl only valid IF fan opmode = ContFanCycComp
                if (this->m_MaxNoCoolHeatAirVolFlow == 0.0) {
                    this->m_AirFlowControl = UseCompFlow::UseCompressorOnFlow;
                } else {
                    this->m_AirFlowControl = UseCompFlow::UseCompressorOffFlow;
                }
            }
        }

        // Set minimum OAT for heat pump compressor operation in cooling mode
        // get from coil module
        errFlag = false;
        if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed) {
            this->m_MinOATCompressorCooling = DXCoils::GetMinOATCompressor(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
        } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {
            this->m_MinOATCompressorCooling = DXCoils::GetMinOATCompressor(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
        } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling) {
            this->m_MinOATCompressorCooling = DXCoils::GetMinOATCompressor(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
        } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) {
            this->m_MinOATCompressorCooling = DXCoils::GetMinOATCompressor(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
        } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {
            this->m_MinOATCompressorCooling = VariableSpeedCoils::GetVSCoilMinOATCompressor(state, loc_m_CoolingCoilName, errFlag);
        } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling) {
            // TODO: Set this->m_minOATCompressorCooling
        } else {
            this->m_MinOATCompressorCooling = -1000.0;
        }
        if (errFlag) {
            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
            errorsFound = true;
        }

        // Set minimum OAT for heat pump compressor operation in heating mode
        // get from coil module
        errFlag = false;
        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) {
            this->m_MinOATCompressorHeating = VariableSpeedCoils::GetVSCoilMinOATCompressor(state, loc_m_HeatingCoilName, errFlag);
        } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical ||
                   this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating) {
            this->m_MinOATCompressorHeating = DXCoils::GetMinOATCompressor(state, loc_heatingCoilType, loc_m_HeatingCoilName, errFlag);
            //       ELSEIF  ***... make sure we catch all possbile coil types here ...***
        } else {
            this->m_MinOATCompressorHeating = -1000.0;
        }
        if (errFlag) {
            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
            errorsFound = true;
        }

        //       Mine heatpump Outdoor condenser node from DX coil object
        errFlag = false;
        if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed) {
            this->m_CondenserNodeNum = DXCoils::GetCoilCondenserInletNode(state, loc_coolingCoilType, loc_m_CoolingCoilName, errFlag);
            // TODO: Should we add a block for the new DX Coil?
        } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {
            this->m_CondenserNodeNum = VariableSpeedCoils::GetVSCoilCondenserInletNode(state, loc_m_CoolingCoilName, errFlag);
        } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted) {
            // already filled
            // UnitarySystem( UnitarySysNum ).CondenserNodeNum = GetDXCoilCondenserInletNode( "Coil:Cooling:DX:SingleSpeed",
            // GetHXDXCoilName(state,  CoolingCoilType, loc_m_CoolingCoilName, errFlag ), errFlag );

        } else {
            if (loc_condenserInletNodeName != "") {
                this->m_CondenserNodeNum = NodeInputManager::GetOnlySingleNode(state,
                                                                               loc_condenserInletNodeName,
                                                                               errFlag,
                                                                               cCurrentModuleObject,
                                                                               thisObjectName,
                                                                               DataLoopNode::NodeFluidType::Air,
                                                                               DataLoopNode::NodeConnectionType::Inlet,
                                                                               NodeInputManager::compFluidStream::Primary,
                                                                               DataLoopNode::ObjectIsParent);
            } else {
                // do nothing?
            }
        }
        if (errFlag) {
            ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
            errorsFound = true;
        }

        // Set the heatpump cycling rate
        this->m_MaxONOFFCyclesperHour = loc_m_MaxONOFFCyclesperHour;

        // Set the heat pump time constant
        this->m_HPTimeConstant = loc_m_HPTimeConstant;

        // Set the heat pump on-cycle power use fraction
        this->m_OnCyclePowerFraction = loc_m_OnCyclePowerFraction;

        // Set the heat pump fan delay time
        this->m_FanDelayTime = loc_m_FanDelayTime;

        this->m_AncillaryOnPower = loc_m_AncillaryOnPower;
        this->m_AncillaryOffPower = loc_m_AncillaryOffPower;

        this->m_MaxHROutletWaterTemp = loc_m_MaxHROutletWaterTemp;

        if (this->m_DesignHRWaterVolumeFlow > 0.0) {
            this->m_HeatRecActive = true;
            errFlag = false;
            if (loc_heatRecoveryInletNodeName != "" && loc_heatRecoveryOutletNodeName != "") {
                this->m_HeatRecoveryInletNodeNum = NodeInputManager::GetOnlySingleNode(state,
                                                                                       loc_heatRecoveryInletNodeName,
                                                                                       errFlag,
                                                                                       cCurrentModuleObject,
                                                                                       thisObjectName,
                                                                                       DataLoopNode::NodeFluidType::Water,
                                                                                       DataLoopNode::NodeConnectionType::Inlet,
                                                                                       NodeInputManager::compFluidStream::Tertiary,
                                                                                       DataLoopNode::ObjectIsNotParent);
                this->m_HeatRecoveryOutletNodeNum = NodeInputManager::GetOnlySingleNode(state,
                                                                                        loc_heatRecoveryOutletNodeName,
                                                                                        errFlag,
                                                                                        cCurrentModuleObject,
                                                                                        thisObjectName,
                                                                                        DataLoopNode::NodeFluidType::Water,
                                                                                        DataLoopNode::NodeConnectionType::Outlet,
                                                                                        NodeInputManager::compFluidStream::Tertiary,
                                                                                        DataLoopNode::ObjectIsNotParent);

                BranchNodeConnections::TestCompSet(state,
                                                   cCurrentModuleObject,
                                                   thisObjectName,
                                                   loc_heatRecoveryInletNodeName,
                                                   loc_heatRecoveryOutletNodeName,
                                                   "Unitary System Heat Recovery Nodes");

                if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling) {
                    DXCoils::SetMSHPDXCoilHeatRecoveryFlag(state, this->m_CoolingCoilIndex);
                }
                if (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating) {
                    DXCoils::SetMSHPDXCoilHeatRecoveryFlag(state, this->m_HeatingCoilIndex);
                }
                if (errFlag) {
                    ShowContinueError(state, "Occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    errorsFound = true;
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Illegal Heat Recovery Water Inlet Node Name = " + loc_heatRecoveryInletNodeName);
                ShowContinueError(state, "Illegal Heat Recovery Water Outlet Node Name = " + loc_heatRecoveryOutletNodeName);
                ShowContinueError(state,
                                  "... heat recovery nodes must be specified when Design Heat Recovery Water Flow Rate"
                                  " is greater than 0.");
                ShowContinueError(state, format("... Design Heat Recovery Water Flow Rate = {:.7R}", this->m_DesignHRWaterVolumeFlow));
                errorsFound = true;
            }
        }

        if (loc_m_DesignSpecMultispeedHPType != "" && loc_m_DesignSpecMultispeedHPName != "") {
            this->m_DesignSpecMultispeedHPType = loc_m_DesignSpecMultispeedHPType;
            this->m_DesignSpecMultispeedHPName = loc_m_DesignSpecMultispeedHPName;
            int designSpecType_Num = 1;

            DesignSpecMSHP thisDesignSpec;
            this->m_CompPointerMSHP = thisDesignSpec.factory(state, designSpecType_Num, loc_m_DesignSpecMultispeedHPName);
            this->m_DesignSpecMSHPIndex = getDesignSpecMSHPIndex(state, this->m_DesignSpecMultispeedHPName);

            if (this->m_DesignSpecMSHPIndex > -1) {

                this->m_NoLoadAirFlowRateRatio = this->m_CompPointerMSHP->noLoadAirFlowRateRatio;

                if (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                    this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingElectric_MultiStage ||
                    this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingGas_MultiStage) {
                    this->m_NumOfSpeedHeating = this->m_CompPointerMSHP->numOfSpeedHeating;
                    this->m_HeatMassFlowRate.resize(this->m_NumOfSpeedHeating + 1);
                    this->m_HeatVolumeFlowRate.resize(this->m_NumOfSpeedHeating + 1);
                    this->m_MSHeatingSpeedRatio.resize(this->m_NumOfSpeedHeating + 1);
                    if (state.dataGlobal->DoCoilDirectSolutions && this->m_NumOfSpeedCooling < this->m_NumOfSpeedHeating) {
                        this->FullOutput.resize(this->m_NumOfSpeedHeating + 1);
                    }
                    for (int i = 1; i <= this->m_NumOfSpeedHeating; ++i) {
                        this->m_HeatMassFlowRate[i] = 0.0;
                        this->m_HeatVolumeFlowRate[i] = 0.0;
                        this->m_MSHeatingSpeedRatio[i] = 1.0;
                    }
                }

                if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling) {
                    this->m_NumOfSpeedCooling = this->m_CompPointerMSHP->numOfSpeedCooling;
                    this->m_CoolMassFlowRate.resize(this->m_NumOfSpeedCooling + 1);
                    this->m_CoolVolumeFlowRate.resize(this->m_NumOfSpeedCooling + 1);
                    this->m_MSCoolingSpeedRatio.resize(this->m_NumOfSpeedCooling + 1);
                    if (state.dataGlobal->DoCoilDirectSolutions && this->m_NumOfSpeedCooling > this->m_NumOfSpeedHeating) {
                        this->FullOutput.resize(this->m_NumOfSpeedCooling + 1);
                        DXCoils::DisableLatentDegradation(state, this->m_CoolingCoilIndex);
                    }
                    for (int i = 1; i <= this->m_NumOfSpeedCooling; ++i) {
                        this->m_CoolMassFlowRate[i] = 0.0;
                        this->m_CoolVolumeFlowRate[i] = 0.0;
                        this->m_MSCoolingSpeedRatio[i] = 1.0;
                    }
                }
            } else {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "... one or both of the following inputs are invalid.");
                ShowContinueError(state, "Field Design Specification Multispeed Object Type = " + this->m_DesignSpecMultispeedHPType);
                ShowContinueError(state, "Field Design Specification Multispeed Object Name = " + this->m_DesignSpecMultispeedHPName);
                errorsFound = true;
            }
        } else if ((loc_m_DesignSpecMultispeedHPType == "" && loc_m_DesignSpecMultispeedHPName != "") ||
                   (loc_m_DesignSpecMultispeedHPType != "" && loc_m_DesignSpecMultispeedHPName == "")) {
            ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
            ShowContinueError(state, "... one or both of the following inputs are invalid.");
            ShowContinueError(state, "Field Design Specification Multispeed Object Type = " + this->m_DesignSpecMultispeedHPType);
            ShowContinueError(state, "Field Design Specification Multispeed Object Name = " + this->m_DesignSpecMultispeedHPName);
            errorsFound = true;
            //} else if (this->m_NumOfSpeedHeating > 0) { // how do these last 2 get called?
            //    int m_NumOfSpeedHeating = this->m_NumOfSpeedHeating;

            //    this->m_HeatMassFlowRate.allocate(m_NumOfSpeedHeating);
            //    this->m_HeatVolumeFlowRate.allocate(m_NumOfSpeedHeating);
            //    this->m_MSHeatingSpeedRatio.allocate(m_NumOfSpeedHeating);
            //    this->m_MSHeatingSpeedRatio = 1.0;

            //} else if (this->m_NumOfSpeedCooling > 0) {
            //    int m_NumOfSpeedCooling = this->m_NumOfSpeedCooling;

            //    this->m_CoolMassFlowRate.allocate(m_NumOfSpeedCooling);
            //    this->m_CoolVolumeFlowRate.allocate(m_NumOfSpeedCooling);
            //    this->m_m_MSCoolingSpeedRatio.allocate(m_NumOfSpeedCooling);
            //    this->m_m_MSCoolingSpeedRatio = 1.0;
        }

        if (this->m_DiscreteSpeedCoolingCoil) {

            if (this->m_NumOfSpeedCooling == 0) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state,
                                  "... Cooling coil object type requires valid " + std::string{unitarySysHeatPumpPerformanceObjectType} +
                                      " for cooling to be specified with number of speeds > 0");
                errorsFound = true;
            }
        }
        if (this->m_MultiSpeedHeatingCoil) {

            if (this->m_DesignSpecMSHPIndex > -1) this->m_NumOfSpeedHeating = this->m_CompPointerMSHP->numOfSpeedHeating;

            if (this->m_NumOfSpeedHeating == 0) {
                ShowSevereError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state,
                                  "... Heating coil object type requires valid " + std::string{unitarySysHeatPumpPerformanceObjectType} +
                                      " for heating to be specified with number of speeds > 0");
                errorsFound = true;
            }
        }

        if ((this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating &&
             (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling ||
              this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling)) ||
            (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingGasOrOtherFuel &&
             (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling ||
              this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling))) {
            if (this->m_DesignSpecMSHPIndex > -1) {
                if (this->m_CompPointerMSHP->m_SingleModeFlag) {
                    this->m_SingleMode = 1;
                }
            }
        } else {
            if (this->m_DesignSpecMSHPIndex > -1) {
                if (this->m_CompPointerMSHP->m_SingleModeFlag) {
                    ShowSevereError(state, cCurrentModuleObject + ": " + thisObjectName);
                    ShowContinueError(state,
                                      "In order to perform Single Mode Operation, the valid cooling coil type is Coil:Cooling:DX:MultiSpeed "
                                      "or Coil:Cooling:DX and the valid heating is Coil:Heating:DX:MultiSpeed or Coil:Heating:Fuel.");
                    ShowContinueError(
                        state, "The input cooling coil type = " + loc_coolingCoilType + " and the input heating coil type = " + loc_heatingCoilType);
                }
            }
        }

        if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {
            VariableSpeedCoils::SetVarSpeedCoilData(state, this->m_CoolingCoilIndex, errorsFound, _, _, this->m_DesignSpecMSHPIndex);
        }

        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) {
            VariableSpeedCoils::SetVarSpeedCoilData(state, this->m_HeatingCoilIndex, errorsFound, _, _, this->m_DesignSpecMSHPIndex);
        }

        // set global logicals that denote coil type
        if (this->m_MultiSpeedHeatingCoil || this->m_VarSpeedHeatingCoil) {
            this->m_MultiOrVarSpeedHeatCoil = true;
        }
        if (this->m_DiscreteSpeedCoolingCoil || this->m_ContSpeedCoolingCoil) {
            this->m_MultiOrVarSpeedCoolCoil = true;
        }

        // set global variables for multi-stage chilled and hot water coils
        if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
            this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) {
            if (this->m_DesignSpecMSHPIndex > -1) {
                this->m_NumOfSpeedCooling = this->m_CompPointerMSHP->numOfSpeedCooling;
                if (this->m_NumOfSpeedCooling > 1) {
                    this->m_DiscreteSpeedCoolingCoil = true;
                    this->m_MultiOrVarSpeedCoolCoil = true;
                }
            }
        }
        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
            // designSpecIndex = this->m_DesignSpecMSHPIndex;
            if (this->m_DesignSpecMSHPIndex > -1) {
                this->m_NumOfSpeedHeating = this->m_CompPointerMSHP->numOfSpeedHeating;
                if (this->m_NumOfSpeedHeating > 1) {
                    this->m_MultiSpeedHeatingCoil = true;
                    this->m_MultiOrVarSpeedHeatCoil = true;
                }
            }
        }

        // check for specific input requirements for ASHRAE90.1 model
        if (this->m_ControlType == ControlType::CCMASHRAE) {

            // only allowed for water and DX cooling coils at this time
            if (this->m_CoolCoilExists && this->m_CoolingCoilType_Num != DataHVACGlobals::Coil_CoolingWater &&
                this->m_CoolingCoilType_Num != DataHVACGlobals::Coil_CoolingWaterDetailed &&
                this->m_CoolingCoilType_Num != DataHVACGlobals::CoilDX_CoolingSingleSpeed) {
                if (state.dataGlobal->DisplayExtraWarnings) {
                    ShowWarningError(state, cCurrentModuleObject + ": " + thisObjectName);
                    ShowContinueError(state, "ASHRAE90.1 control method requires specific cooling coil types.");
                    ShowContinueError(state,
                                      "Valid cooling coil types are Coil:Cooling:Water, Coil:Cooling:Water:DetailedGeometry and "
                                      "Coil:Cooling:DX:SingleSpeed.");
                    ShowContinueError(state,
                                      "The input cooling coil type = " + loc_coolingCoilType +
                                          ". This coil will not be modeled using the ASHRAE 90.1 algorithm.");
                }
                // mark this coil as non-ASHRAE90 type
                this->m_ValidASHRAECoolCoil = false;
            }
            // only allow for water, fuel, or electric at this time
            if (this->m_HeatCoilExists && this->m_HeatingCoilType_Num != DataHVACGlobals::Coil_HeatingWater &&
                this->m_HeatingCoilType_Num != DataHVACGlobals::Coil_HeatingGasOrOtherFuel &&
                this->m_HeatingCoilType_Num != DataHVACGlobals::Coil_HeatingElectric &&
                this->m_HeatingCoilType_Num != DataHVACGlobals::CoilDX_HeatingEmpirical) {
                if (state.dataGlobal->DisplayExtraWarnings) {
                    ShowWarningError(state, cCurrentModuleObject + ": " + thisObjectName);
                    ShowContinueError(state, "ASHRAE90.1 control method requires specific heating coil types.");
                    ShowContinueError(state,
                                      "Valid heating coil types are Coil:Heating:Water, Coil:Heating:Fuel, Coil:Heating:Electric and "
                                      "Coil:Heating:DX:SingleSpeed.");
                    ShowContinueError(state,
                                      "The input heating coil type = " + loc_heatingCoilType +
                                          ". This coil will not be modeled using the ASHRAE 90.1 algorithm.");
                }
                // mark this coil as non-ASHRAE90 type
                this->m_ValidASHRAEHeatCoil = false;
            }
            if (this->m_DehumidControlType_Num == DehumCtrlType::Multimode || this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat) {
                ShowWarningError(state, cCurrentModuleObject + ": " + thisObjectName);
                ShowContinueError(state, "Invalid entry for Dehumidification Control Type = " + loc_dehumm_ControlType);
                ShowContinueError(state,
                                  "ASHRAE90.1 control method does not support dehumidification at this time. Dehumidification control type is "
                                  "assumed to be None.");
                this->m_DehumidControlType_Num = DehumCtrlType::None;
            }
            if (this->m_RunOnLatentLoad) {
                ShowWarningError(state, cCurrentModuleObject + " = " + thisObjectName);
                ShowContinueError(state, "Invalid entry for Latent Load Control: " + loc_latentControlFlag);
                ShowContinueError(state,
                                  "ASHRAE90.1 control method does not support latent load control at this time. This input must be selected as "
                                  "SensibleOnlyLoadControl.");
                this->m_RunOnSensibleLoad = true;
                this->m_RunOnLatentLoad = false;
                this->m_RunOnLatentOnlyWithSensible = false;
            }
            if (this->m_MaxNoCoolHeatAirVolFlow == 0.0) { // 0 min air flow not allowed for SZVAV
                ShowSevereError(state, "Input errors for " + cCurrentModuleObject + ":" + thisObjectName);
                ShowContinueError(state, "Control Type = " + loc_m_ControlType);
                ShowContinueError(state, "Input for No Load Supply Air Flow Rate cannot be 0.");
                errorsFound = true;
            }
        }
    }

    void UnitarySys::getDXCoilSystemData(
        EnergyPlusData &state, std::string_view objectName, bool const ZoneEquipment, int const ZoneOAUnitNum, bool &errorsFound)
    {
        std::string cCurrentModuleObject = "CoilSystem:Cooling:DX";
        auto const instances = state.dataInputProcessing->inputProcessor->epJSON.find(cCurrentModuleObject);
        if (instances != state.dataInputProcessing->inputProcessor->epJSON.end()) {
            auto &instancesValue = instances.value();
            for (auto instance = instancesValue.begin(); instance != instancesValue.end(); ++instance) {

                auto const &thisObjectName = UtilityRoutines::MakeUPPERCase(instance.key());

                // only get the current data once all data has been read in and vector unitarySys has been initialized
                // when UnitarySystems::getInputOnceFlag is true read all unitary systems, otherwise read just the curren object
                if (!UtilityRoutines::SameString(objectName, thisObjectName) && !state.dataUnitarySystems->getInputOnceFlag) continue;

                int sysNum = getUnitarySystemIndex(state, thisObjectName);
                if (sysNum == -1) ++state.dataUnitarySystems->numUnitarySystems;
                state.dataInputProcessing->inputProcessor->markObjectAsUsed(cCurrentModuleObject, instance.key());

                // get CoilSystem:Cooling:DX object inputs
                UnitarySysInputSpec original_input_specs;
                auto const &fields = instance.value();
                original_input_specs.name = thisObjectName;
                original_input_specs.system_type = cCurrentModuleObject;
                if (fields.find("availability_schedule_name") != fields.end()) { // not required field
                    original_input_specs.availability_schedule_name =
                        UtilityRoutines::MakeUPPERCase(fields.at("availability_schedule_name").get<std::string>());
                }
                original_input_specs.air_inlet_node_name =
                    UtilityRoutines::MakeUPPERCase(fields.at("dx_cooling_coil_system_inlet_node_name").get<std::string>()); // required field
                original_input_specs.air_outlet_node_name =
                    UtilityRoutines::MakeUPPERCase(fields.at("dx_cooling_coil_system_outlet_node_name").get<std::string>()); // required field

                original_input_specs.dx_cooling_coil_system_sensor_node_name =
                    UtilityRoutines::MakeUPPERCase(fields.at("dx_cooling_coil_system_sensor_node_name").get<std::string>()); // required field

                original_input_specs.cooling_coil_object_type =
                    UtilityRoutines::MakeUPPERCase(fields.at("cooling_coil_object_type").get<std::string>()); // required field
                original_input_specs.cooling_coil_name =
                    UtilityRoutines::MakeUPPERCase(fields.at("cooling_coil_name").get<std::string>()); // required field
                // min-fields = 7, begin optional inputs
                std::string loc_dehumm_ControlType("");
                if (fields.find("dehumidification_control_type") != fields.end()) { // not required field
                    original_input_specs.dehumidification_control_type =
                        UtilityRoutines::MakeUPPERCase(fields.at("dehumidification_control_type").get<std::string>());
                } else {
                    // find default value
                    original_input_specs.dehumidification_control_type = "None";
                }
                std::string loc_RunOnSensLoad("");
                if (fields.find("run_on_sensible_load") != fields.end()) { // not required field
                    loc_RunOnSensLoad = UtilityRoutines::MakeUPPERCase(fields.at("run_on_sensible_load").get<std::string>());
                } else {
                    // find default value
                    loc_RunOnSensLoad = "YES";
                }
                std::string loc_RunOnLatLoad("");
                if (fields.find("run_on_latent_load") != fields.end()) { // not required field
                    loc_RunOnLatLoad = UtilityRoutines::MakeUPPERCase(fields.at("run_on_latent_load").get<std::string>());
                } else {
                    // find default value
                    loc_RunOnLatLoad = "NO";
                }
                if (loc_RunOnSensLoad == "YES" && loc_RunOnLatLoad == "NO") {
                    original_input_specs.latent_load_control = "SensibleOnlyLoadControl";
                } else if (loc_RunOnSensLoad == "NO" && loc_RunOnLatLoad == "YES") {
                    original_input_specs.latent_load_control = "LatentOnlyLoadControl";
                } else if (loc_RunOnSensLoad == "YES" && loc_RunOnLatLoad == "YES") {
                    // does DX system control on LatentOrSensibleLoadControl or LatentWithSensibleLoadControl?
                    original_input_specs.latent_load_control = "LatentOrSensibleLoadControl";
                }

                if (fields.find("use_outdoor_air_dx_cooling_coil") != fields.end()) { // not required field
                    original_input_specs.use_doas_dx_cooling_coil =
                        UtilityRoutines::MakeUPPERCase(fields.at("use_outdoor_air_dx_cooling_coil").get<std::string>());
                } else {
                    // find default value
                    original_input_specs.use_doas_dx_cooling_coil = "NO";
                }
                if (fields.find("outdoor_air_dx_cooling_coil_leaving_minimum_air_temperature") != fields.end()) { // not required field
                    original_input_specs.minimum_supply_air_temperature =
                        fields.at("outdoor_air_dx_cooling_coil_leaving_minimum_air_temperature").get<Real64>();
                }
                // set UnitarySystem specific inputs
                original_input_specs.control_type = "SETPOINT";

                // now translate to UnitarySystem
                UnitarySys thisSys;
                thisSys.UnitType = cCurrentModuleObject;
                thisSys.m_sysType = SysType::CoilCoolingDX;
                // TODO: figure out another way to set this next variable
                // Unitary System will not turn on unless this mode is set OR a different method is used to set air flow rate
                thisSys.m_LastMode = state.dataUnitarySystems->CoolingMode;
                thisSys.processInputSpec(state, original_input_specs, sysNum, errorsFound, ZoneEquipment, ZoneOAUnitNum);

                if (sysNum == -1) {
                    int thisSysNum = state.dataUnitarySystems->numUnitarySystems - 1;
                    state.dataUnitarySystems->unitarySys[thisSysNum] = thisSys;
                } else {
                    state.dataUnitarySystems->unitarySys[sysNum] = thisSys;
                }
            }
        }
    }

    void UnitarySys::allocateUnitarySys(EnergyPlusData &state)
    {
        if (state.dataUnitarySystems->unitarySys.size() > 0) return;
        int numUnitarySystems = state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, "AirLoopHVAC:UnitarySystem");
        int numCoilSystems = state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, "CoilSystem:Cooling:DX");
        int numCoilSystemsWater = state.dataInputProcessing->inputProcessor->getNumObjectsFound(state, "CoilSystem:Cooling:Water");
        int numAllSystemTypes = numUnitarySystems + numCoilSystems + numCoilSystemsWater;
        for (int sysCount = 0; sysCount < numAllSystemTypes; ++sysCount) {
            UnitarySys thisSys;
            state.dataUnitarySystems->unitarySys.push_back(thisSys);
        }
    }

    void UnitarySys::getCoilWaterSystemInputData(
        EnergyPlusData &state, std::string_view CoilSysName, bool const ZoneEquipment, int const ZoneOAUnitNum, bool &errorsFound)
    {

        std::string cCurrentModuleObject("CoilSystem:Cooling:Water");
        static const std::string routineName("getCoilWaterSystemInputData: ");
        auto const instances = state.dataInputProcessing->inputProcessor->epJSON.find(cCurrentModuleObject);
        if (instances != state.dataInputProcessing->inputProcessor->epJSON.end()) {
            auto &instancesValue = instances.value();
            for (auto instance = instancesValue.begin(); instance != instancesValue.end(); ++instance) {

                auto const &fields = instance.value();
                auto const &thisObjectName = UtilityRoutines::MakeUPPERCase(instance.key());

                if (!UtilityRoutines::SameString(CoilSysName, thisObjectName) && !state.dataUnitarySystems->getInputOnceFlag) continue;

                int sysNum = getUnitarySystemIndex(state, thisObjectName);
                UnitarySys thisSys;
                if (sysNum == -1) {
                    ++state.dataUnitarySystems->numUnitarySystems;
                    auto const &thisObjName = instance.key();
                    state.dataInputProcessing->inputProcessor->markObjectAsUsed(cCurrentModuleObject, thisObjName);
                } else {
                    thisSys = state.dataUnitarySystems->unitarySys[sysNum];
                }

                UnitarySysInputSpec input_specs;
                input_specs.name = thisObjectName;
                input_specs.system_type = cCurrentModuleObject;
                input_specs.control_type = "Setpoint";
                input_specs.air_inlet_node_name = UtilityRoutines::MakeUPPERCase(fields.at("air_inlet_node_name").get<std::string>());
                input_specs.air_outlet_node_name = UtilityRoutines::MakeUPPERCase(fields.at("air_outlet_node_name").get<std::string>());
                std::string availScheduleName("");
                if (fields.find("availability_schedule_name") != fields.end()) { // not required field, has default value of Always On
                    availScheduleName = UtilityRoutines::MakeUPPERCase(fields.at("availability_schedule_name").get<std::string>());
                }
                input_specs.availability_schedule_name = availScheduleName;
                input_specs.cooling_coil_object_type = UtilityRoutines::MakeUPPERCase(fields.at("cooling_coil_object_type").get<std::string>());
                input_specs.cooling_coil_name = UtilityRoutines::MakeUPPERCase(fields.at("cooling_coil_name").get<std::string>());
                // why is this cooling coil does not have a field for Design Air Vol Flow Rate
                // set it "SupplyAirFlowRate" to avoid blank, which lead to fatal out during get input
                static constexpr std::string_view loc_cooling_coil_object_type("COIL:COOLING:WATER:DETAILEDGEOMETRY");
                if (UtilityRoutines::SameString(loc_cooling_coil_object_type, input_specs.cooling_coil_object_type)) {
                    input_specs.cooling_supply_air_flow_rate_method = UtilityRoutines::MakeUPPERCase("SupplyAirFlowRate");
                    input_specs.cooling_supply_air_flow_rate = DataSizing::AutoSize;
                }
                // optional input fields
                Real64 minAir2FluidTempOffset(0.0);
                if (fields.find("minimum_air_to_water_temperature_offset") != fields.end()) { // not required field, has default value of 0.0
                    minAir2FluidTempOffset = fields.at("minimum_air_to_water_temperature_offset").get<Real64>();
                }
                std::string dehumidControlType("None");
                if (fields.find("dehumidification_control_type") != fields.end()) {
                    dehumidControlType = UtilityRoutines::MakeUPPERCase(fields.at("dehumidification_control_type").get<std::string>());
                }
                input_specs.dehumidification_control_type = dehumidControlType;

                bool runOnSensibleLoad = true;
                if (fields.find("run_on_sensible_load") != fields.end()) {
                    runOnSensibleLoad = UtilityRoutines::SameString(fields.at("run_on_sensible_load").get<std::string>(), "YES");
                }
                bool runOnLatentLoad = false;
                if (fields.find("run_on_latent_load") != fields.end()) {
                    runOnLatentLoad = UtilityRoutines::SameString(fields.at("run_on_latent_load").get<std::string>(), "YES");
                }

                if (runOnSensibleLoad && !runOnLatentLoad) {
                    input_specs.latent_load_control = "SensibleOnlyLoadControl";
                } else if (!runOnSensibleLoad && runOnLatentLoad) {
                    input_specs.latent_load_control = "LatentOnlyLoadControl";
                } else if (runOnSensibleLoad && runOnLatentLoad) {
                    input_specs.latent_load_control = "LatentOrSensibleLoadControl";
                }

                // now translate to UnitarySystem
                thisSys.UnitType = cCurrentModuleObject;
                thisSys.m_sysType = SysType::CoilCoolingWater;
                input_specs.control_type = "Setpoint";
                thisSys.m_CoolCoilExists = true; // is always true
                thisSys.m_LastMode = state.dataUnitarySystems->CoolingMode;
                // set water-side economizer temperature offset
                thisSys.m_minAirToWaterTempOffset = minAir2FluidTempOffset;
                // set water-side economizer flag
                if (thisSys.m_minAirToWaterTempOffset > 0.0) thisSys.m_TemperatureOffsetControlActive = true;

                // heat recovery loop inputs
                if (fields.find("minimum_water_loop_temperature_for_heat_recovery") != fields.end()) {
                    thisSys.m_minWaterLoopTempForHR = fields.at("minimum_water_loop_temperature_for_heat_recovery").get<Real64>();
                }
                if (fields.find("economizer_lockout") != fields.end()) { // duplicate above as default
                    bool econoFlag = UtilityRoutines::SameString(fields.at("economizer_lockout").get<std::string>(), "YES");
                    if (econoFlag) {
                        thisSys.m_waterSideEconomizerFlag = true;
                    }
                } else {
                    thisSys.m_waterSideEconomizerFlag = true;
                }
                std::string HRWaterCoolingCoilName;
                if (fields.find("companion_coil_used_for_heat_recovery") != fields.end()) {
                    HRWaterCoolingCoilName = UtilityRoutines::MakeUPPERCase(fields.at("companion_coil_used_for_heat_recovery").get<std::string>());
                    thisSys.m_WaterHRPlantLoopModel = true;
                }
                if (thisSys.m_WaterHRPlantLoopModel) {
                    std::string const HRcoolingCoilType("COIL:COOLING:WATER");
                    bool errFound = false;
                    thisSys.m_HRcoolCoilAirInNode = WaterCoils::GetCoilInletNode(state, HRcoolingCoilType, HRWaterCoolingCoilName, errFound);
                    thisSys.m_HRcoolCoilFluidInletNode =
                        WaterCoils::GetCoilWaterInletNode(state, HRcoolingCoilType, HRWaterCoolingCoilName, errFound);
                    int HRCoilIndex =
                        WaterCoils::GetWaterCoilIndex(state, UtilityRoutines::MakeUPPERCase(HRcoolingCoilType), HRWaterCoolingCoilName, errFound);
                    bool heatRecoveryCoil = true; // use local here to highlight where this parameter is set
                    WaterCoils::SetWaterCoilData(state, HRCoilIndex, errFound, _, _, heatRecoveryCoil);
                    if (errFound) {
                        if (HRCoilIndex == 0) {
                            ShowContinueError(state, "...cooling coil " + HRWaterCoolingCoilName + " must be of type Coil:Cooling:Water.");
                        }
                        ShowContinueError(state, "...occurs in " + cCurrentModuleObject + " = " + thisObjectName);
                    }
                    errorsFound = errorsFound || errFound;
                }
                // end heat recovery loop inputs

                thisSys.processInputSpec(state, input_specs, sysNum, errorsFound, ZoneEquipment, ZoneOAUnitNum);

                if (sysNum == -1) {
                    int thisSysNum = state.dataUnitarySystems->numUnitarySystems - 1;
                    state.dataUnitarySystems->unitarySys[thisSysNum] = thisSys;
                } else {
                    state.dataUnitarySystems->unitarySys[sysNum] = thisSys;
                }
            }

            if (errorsFound) {
                ShowFatalError(
                    state, routineName + "Errors found in getting " + cCurrentModuleObject + " input. Preceding condition(s) causes termination.");
            }
        }
    }

    void UnitarySys::getUnitarySystemInputData(
        EnergyPlusData &state, std::string_view objectName, bool const ZoneEquipment, int const ZoneOAUnitNum, bool &errorsFound)
    {

        std::string cCurrentModuleObject = "AirLoopHVAC:UnitarySystem";
        static std::string const getUnitarySystemInput("getUnitarySystemInputData");

        auto const instances = state.dataInputProcessing->inputProcessor->epJSON.find(cCurrentModuleObject);
        if (instances == state.dataInputProcessing->inputProcessor->epJSON.end() && state.dataUnitarySystems->numUnitarySystems == 0) {
            ShowSevereError(state, "getUnitarySystemInputData: did not find AirLoopHVAC:UnitarySystem object in input file. Check inputs");
            errorsFound = true;
        } else if (instances != state.dataInputProcessing->inputProcessor->epJSON.end()) {
            auto &instancesValue = instances.value();
            for (auto instance = instancesValue.begin(); instance != instancesValue.end(); ++instance) {

                auto const &thisObjectName = UtilityRoutines::MakeUPPERCase(instance.key());
                // only get the current data once all data has been read in and vector unitarySys has been initialized
                // when UnitarySystems::getInputOnceFlag is true read all unitary systems, otherwise read just the curren object
                if (!UtilityRoutines::SameString(objectName, thisObjectName) && !state.dataUnitarySystems->getInputOnceFlag) continue;

                int sysNum = getUnitarySystemIndex(state, thisObjectName);
                UnitarySys thisSys;
                if (sysNum == -1) {
                    ++state.dataUnitarySystems->numUnitarySystems;
                    auto const &thisObjName = instance.key();
                    state.dataInputProcessing->inputProcessor->markObjectAsUsed(cCurrentModuleObject, thisObjName);
                } else {
                    thisSys = state.dataUnitarySystems->unitarySys[sysNum];
                }

                auto const &fields = instance.value();
                thisSys.UnitType = cCurrentModuleObject;
                thisSys.m_sysType = SysType::Unitary;

                UnitarySysInputSpec input_spec;
                input_spec.name = thisObjectName;
                input_spec.system_type = cCurrentModuleObject;
                input_spec.control_type = fields.at("control_type").get<std::string>();
                if (fields.find("controlling_zone_or_thermostat_location") != fields.end()) { // not required field
                    input_spec.controlling_zone_or_thermostat_location =
                        UtilityRoutines::MakeUPPERCase(fields.at("controlling_zone_or_thermostat_location").get<std::string>());
                }
                if (fields.find("dehumidification_control_type") != fields.end()) { // not required field, has default
                    input_spec.dehumidification_control_type =
                        UtilityRoutines::MakeUPPERCase(fields.at("dehumidification_control_type").get<std::string>());
                } else {
                    input_spec.dehumidification_control_type = "NONE"; // default value
                }
                if (fields.find("availability_schedule_name") != fields.end()) { // not required field
                    input_spec.availability_schedule_name =
                        UtilityRoutines::MakeUPPERCase(fields.at("availability_schedule_name").get<std::string>());
                }
                input_spec.air_inlet_node_name = UtilityRoutines::MakeUPPERCase(fields.at("air_inlet_node_name").get<std::string>());   // required
                input_spec.air_outlet_node_name = UtilityRoutines::MakeUPPERCase(fields.at("air_outlet_node_name").get<std::string>()); // required
                if (fields.find("supply_fan_object_type") != fields.end()) { // not required field
                    input_spec.supply_fan_object_type = UtilityRoutines::MakeUPPERCase(fields.at("supply_fan_object_type").get<std::string>());
                }

                std::string loc_m_FanName;
                if (fields.find("supply_fan_name") != fields.end()) { // not required field
                    input_spec.supply_fan_name = UtilityRoutines::MakeUPPERCase(fields.at("supply_fan_name").get<std::string>());
                }
                if (fields.find("fan_placement") != fields.end()) { // not required field
                    input_spec.fan_placement = UtilityRoutines::MakeUPPERCase(fields.at("fan_placement").get<std::string>());
                }
                if (fields.find("supply_air_fan_operating_mode_schedule_name") != fields.end()) { // not required field
                    input_spec.supply_air_fan_operating_mode_schedule_name =
                        UtilityRoutines::MakeUPPERCase(fields.at("supply_air_fan_operating_mode_schedule_name").get<std::string>());
                }
                if (fields.find("heating_coil_object_type") != fields.end()) { // not required field
                    input_spec.heating_coil_object_type = UtilityRoutines::MakeUPPERCase(fields.at("heating_coil_object_type").get<std::string>());
                    thisSys.m_HeatCoilExists = true;
                }
                if (fields.find("heating_coil_name") != fields.end()) { // not required field
                    input_spec.heating_coil_name = UtilityRoutines::MakeUPPERCase(fields.at("heating_coil_name").get<std::string>());
                }
                if (fields.find("dx_heating_coil_sizing_ratio") != fields.end()) { // not required field, has default
                    input_spec.dx_heating_coil_sizing_ratio = fields.at("dx_heating_coil_sizing_ratio").get<Real64>();
                }
                if (fields.find("cooling_coil_object_type") != fields.end()) { // not required field
                    input_spec.cooling_coil_object_type = UtilityRoutines::MakeUPPERCase(fields.at("cooling_coil_object_type").get<std::string>());
                    thisSys.m_CoolCoilExists = true;
                }
                if (fields.find("cooling_coil_name") != fields.end()) { // not required field
                    input_spec.cooling_coil_name = UtilityRoutines::MakeUPPERCase(fields.at("cooling_coil_name").get<std::string>());
                }
                if (fields.find("use_doas_dx_cooling_coil") != fields.end()) { // not required field, has default
                    input_spec.use_doas_dx_cooling_coil = UtilityRoutines::MakeUPPERCase(fields.at("use_doas_dx_cooling_coil").get<std::string>());
                } else {
                    input_spec.use_doas_dx_cooling_coil = "No";
                }
                if (fields.find("minimum_supply_air_temperature") != fields.end()) { // not required field, has default (2C), and autosizable
                    auto tempFieldVal = fields.at("minimum_supply_air_temperature");
                    if (tempFieldVal == "Autosize") {
                        input_spec.minimum_supply_air_temperature = DataSizing::AutoSize;
                    } else {
                        input_spec.minimum_supply_air_temperature = fields.at("minimum_supply_air_temperature").get<Real64>();
                    }
                }
                if (fields.find("latent_load_control") != fields.end()) { // not required field, has default
                    input_spec.latent_load_control = UtilityRoutines::MakeUPPERCase(fields.at("latent_load_control").get<std::string>());
                } else {
                    input_spec.latent_load_control = "SensibleOnlyLoadControl";
                }
                if (fields.find("supplemental_heating_coil_object_type") != fields.end()) { // not required field
                    input_spec.supplemental_heating_coil_object_type =
                        UtilityRoutines::MakeUPPERCase(fields.at("supplemental_heating_coil_object_type").get<std::string>());
                }
                if (fields.find("supplemental_heating_coil_name") != fields.end()) { // not required field
                    input_spec.supplemental_heating_coil_name =
                        UtilityRoutines::MakeUPPERCase(fields.at("supplemental_heating_coil_name").get<std::string>());
                }
                if (fields.find("cooling_supply_air_flow_rate_method") != fields.end()) { // not required field
                    input_spec.cooling_supply_air_flow_rate_method =
                        UtilityRoutines::MakeUPPERCase(fields.at("cooling_supply_air_flow_rate_method").get<std::string>());
                }
                if (fields.find("cooling_supply_air_flow_rate") != fields.end()) { // not required field, autosizable
                    auto tempFieldVal = fields.at("cooling_supply_air_flow_rate");
                    if (tempFieldVal == "Autosize") {
                        input_spec.cooling_supply_air_flow_rate = DataSizing::AutoSize;
                    } else {
                        input_spec.cooling_supply_air_flow_rate = fields.at("cooling_supply_air_flow_rate").get<Real64>();
                    }
                }
                if (fields.find("cooling_supply_air_flow_rate_per_floor_area") != fields.end()) { // not required field
                    input_spec.cooling_supply_air_flow_rate_per_floor_area = fields.at("cooling_supply_air_flow_rate_per_floor_area").get<Real64>();
                }
                if (fields.find("cooling_fraction_of_autosized_cooling_supply_air_flow_rate") != fields.end()) { // not required field
                    input_spec.cooling_fraction_of_autosized_cooling_supply_air_flow_rate =
                        fields.at("cooling_fraction_of_autosized_cooling_supply_air_flow_rate").get<Real64>();
                }
                if (fields.find("cooling_supply_air_flow_rate_per_unit_of_capacity") != fields.end()) { // not required field
                    input_spec.cooling_supply_air_flow_rate_per_unit_of_capacity =
                        fields.at("cooling_supply_air_flow_rate_per_unit_of_capacity").get<Real64>();
                }
                if (fields.find("heating_supply_air_flow_rate_method") != fields.end()) { // not required field
                    input_spec.heating_supply_air_flow_rate_method =
                        UtilityRoutines::MakeUPPERCase(fields.at("heating_supply_air_flow_rate_method").get<std::string>());
                }
                if (fields.find("heating_supply_air_flow_rate") != fields.end()) { // not required field
                    auto tempFieldVal = fields.at("heating_supply_air_flow_rate");
                    if (tempFieldVal == "Autosize") {
                        input_spec.heating_supply_air_flow_rate = DataSizing::AutoSize;
                    } else {
                        input_spec.heating_supply_air_flow_rate = fields.at("heating_supply_air_flow_rate").get<Real64>();
                    }
                }
                if (fields.find("heating_supply_air_flow_rate_per_floor_area") != fields.end()) { // not required field
                    input_spec.heating_supply_air_flow_rate_per_floor_area = fields.at("heating_supply_air_flow_rate_per_floor_area").get<Real64>();
                }
                if (fields.find("heating_fraction_of_autosized_heating_supply_air_flow_rate") != fields.end()) { // not required field
                    input_spec.heating_fraction_of_autosized_heating_supply_air_flow_rate =
                        fields.at("heating_fraction_of_autosized_heating_supply_air_flow_rate").get<Real64>();
                }
                if (fields.find("heating_supply_air_flow_rate_per_unit_of_capacity") != fields.end()) { // not required field
                    input_spec.heating_supply_air_flow_rate_per_unit_of_capacity =
                        fields.at("heating_supply_air_flow_rate_per_unit_of_capacity").get<Real64>();
                }
                if (fields.find("no_load_supply_air_flow_rate_method") != fields.end()) { // not required field
                    input_spec.no_load_supply_air_flow_rate_method =
                        UtilityRoutines::MakeUPPERCase(fields.at("no_load_supply_air_flow_rate_method").get<std::string>());
                }
                if (fields.find("no_load_supply_air_flow_rate") != fields.end()) { // not required field
                    auto tempFieldVal = fields.at("no_load_supply_air_flow_rate");
                    if (tempFieldVal == "Autosize") {
                        input_spec.no_load_supply_air_flow_rate = DataSizing::AutoSize;
                    } else {
                        input_spec.no_load_supply_air_flow_rate = fields.at("no_load_supply_air_flow_rate").get<Real64>();
                    }
                }
                if (fields.find("no_load_supply_air_flow_rate_per_floor_area") != fields.end()) { // not required field
                    input_spec.no_load_supply_air_flow_rate_per_floor_area = fields.at("no_load_supply_air_flow_rate_per_floor_area").get<Real64>();
                }
                if (fields.find("no_load_fraction_of_autosized_cooling_supply_air_flow_rate") != fields.end()) { // not required field
                    input_spec.no_load_fraction_of_autosized_cooling_supply_air_flow_rate =
                        fields.at("no_load_fraction_of_autosized_cooling_supply_air_flow_rate").get<Real64>();
                }
                if (fields.find("no_load_fraction_of_autosized_heating_supply_air_flow_rate") != fields.end()) { // not required field
                    input_spec.no_load_fraction_of_autosized_heating_supply_air_flow_rate =
                        fields.at("no_load_fraction_of_autosized_heating_supply_air_flow_rate").get<Real64>();
                }
                if (fields.find("no_load_supply_air_flow_rate_per_unit_of_capacity_during_cooling_operation") != fields.end()) { // not required field
                    input_spec.no_load_supply_air_flow_rate_per_unit_of_capacity_during_cooling_operation =
                        fields.at("no_load_supply_air_flow_rate_per_unit_of_capacity_during_cooling_operation").get<Real64>();
                }
                if (fields.find("no_load_supply_air_flow_rate_per_unit_of_capacity_during_heating_operation") != fields.end()) { // not required field
                    input_spec.no_load_supply_air_flow_rate_per_unit_of_capacity_during_heating_operation =
                        fields.at("no_load_supply_air_flow_rate_per_unit_of_capacity_during_heating_operation").get<Real64>();
                }
                if (fields.find("maximum_supply_air_temperature") != fields.end()) { // not required field, has default of 80 C
                    auto tempFieldVal = fields.at("maximum_supply_air_temperature");
                    if (tempFieldVal == "Autosize") {
                        input_spec.maximum_supply_air_temperature = DataSizing::AutoSize;
                    } else {
                        input_spec.maximum_supply_air_temperature = fields.at("maximum_supply_air_temperature").get<Real64>();
                    }
                }
                if (fields.find("maximum_outdoor_dry_bulb_temperature_for_supplemental_heater_operation") !=
                    fields.end()) { // not required field, has default
                    input_spec.maximum_outdoor_dry_bulb_temperature_for_supplemental_heater_operation =
                        fields.at("maximum_outdoor_dry_bulb_temperature_for_supplemental_heater_operation").get<Real64>();
                }
                if (fields.find("outdoor_dry_bulb_temperature_sensor_node_name") != fields.end()) { // not required field
                    input_spec.outdoor_dry_bulb_temperature_sensor_node_name =
                        UtilityRoutines::MakeUPPERCase(fields.at("outdoor_dry_bulb_temperature_sensor_node_name").get<std::string>());
                }
                if (fields.find("maximum_cycling_rate") != fields.end()) { // not required field, has default
                    input_spec.maximum_cycling_rate = fields.at("maximum_cycling_rate").get<Real64>();
                }
                if (fields.find("heat_pump_time_constant") != fields.end()) { // not required field, has default
                    input_spec.heat_pump_time_constant = fields.at("heat_pump_time_constant").get<Real64>();
                }
                if (fields.find("fraction_of_on_cycle_power_use") != fields.end()) { // not required field, has default
                    input_spec.fraction_of_on_cycle_power_use = fields.at("fraction_of_on_cycle_power_use").get<Real64>();
                }
                if (fields.find("heat_pump_fan_delay_time") != fields.end()) { // not required field, has default
                    input_spec.heat_pump_fan_delay_time = fields.at("heat_pump_fan_delay_time").get<Real64>();
                }
                if (fields.find("ancillary_on_cycle_electric_power") != fields.end()) { // not required field, has default
                    input_spec.ancillary_on_cycle_electric_power = fields.at("ancillary_on_cycle_electric_power").get<Real64>();
                }
                if (fields.find("ancillary_off_cycle_electric_power") != fields.end()) { // not required field, has default
                    input_spec.ancillary_off_cycle_electric_power = fields.at("ancillary_off_cycle_electric_power").get<Real64>();
                }
                if (fields.find("design_heat_recovery_water_flow_rate") != fields.end()) { // not required field, has default
                    input_spec.design_heat_recovery_water_flow_rate = fields.at("design_heat_recovery_water_flow_rate").get<Real64>();
                }
                if (fields.find("maximum_temperature_for_heat_recovery") != fields.end()) { // not required field, has default
                    input_spec.maximum_temperature_for_heat_recovery = fields.at("maximum_temperature_for_heat_recovery").get<Real64>();
                }
                if (fields.find("heat_recovery_water_inlet_node_name") != fields.end()) { // not required field
                    input_spec.heat_recovery_water_inlet_node_name =
                        UtilityRoutines::MakeUPPERCase(fields.at("heat_recovery_water_inlet_node_name").get<std::string>());
                }
                if (fields.find("heat_recovery_water_outlet_node_name") != fields.end()) { // not required field
                    input_spec.heat_recovery_water_outlet_node_name =
                        UtilityRoutines::MakeUPPERCase(fields.at("heat_recovery_water_outlet_node_name").get<std::string>());
                }
                if (fields.find("design_specification_multispeed_object_type") != fields.end()) { // not required field
                    input_spec.design_specification_multispeed_object_type =
                        UtilityRoutines::MakeUPPERCase(fields.at("design_specification_multispeed_object_type").get<std::string>());
                }
                if (fields.find("design_specification_multispeed_object_name") != fields.end()) { // not required field
                    input_spec.design_specification_multispeed_object_name =
                        UtilityRoutines::MakeUPPERCase(fields.at("design_specification_multispeed_object_name").get<std::string>());
                }

                thisSys.processInputSpec(state, input_spec, sysNum, errorsFound, ZoneEquipment, ZoneOAUnitNum);

                if (sysNum == -1) {
                    int thisSysNum = state.dataUnitarySystems->numUnitarySystems - 1;
                    state.dataUnitarySystems->unitarySys[thisSysNum] = thisSys;
                } else {
                    state.dataUnitarySystems->unitarySys[sysNum] = thisSys;
                }
            }
        }
    }

    void UnitarySys::calcUnitarySuppSystemToSP(EnergyPlusData &state, bool const FirstHVACIteration // True when first HVAC iteration
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine manages supplemental heater component simulation for setpoint based operation scheme.

        // Locals
        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        Real64 QActual;

        std::string CompName = this->m_SuppHeatCoilName;
        int CoilType_Num = this->m_SuppHeatCoilType_Num;

        if ((CoilType_Num == DataHVACGlobals::Coil_HeatingGasOrOtherFuel) || (CoilType_Num == DataHVACGlobals::Coil_HeatingElectric)) {
            HeatingCoils::SimulateHeatingCoilComponents(
                state, CompName, FirstHVACIteration, _, this->m_SuppHeatCoilIndex, _, _, this->m_FanOpMode, this->m_SuppHeatPartLoadFrac);

        } else if (CoilType_Num == DataHVACGlobals::Coil_HeatingDesuperheater) {
            HeatingCoils::SimulateHeatingCoilComponents(
                state, CompName, FirstHVACIteration, _, this->m_SuppHeatCoilIndex, _, _, this->m_FanOpMode, this->m_SuppHeatPartLoadFrac);

        } else if (CoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
            WaterCoils::SimulateWaterCoilComponents(
                state, CompName, FirstHVACIteration, this->m_SuppHeatCoilIndex, QActual, this->m_FanOpMode, this->m_SuppHeatPartLoadFrac);

        } else if (CoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {
            SteamCoils::SimulateSteamCoilComponents(state,
                                                    CompName,
                                                    FirstHVACIteration,
                                                    this->m_SuppHeatCoilIndex,
                                                    this->m_DesignSuppHeatingCapacity * this->m_SuppHeatPartLoadFrac,
                                                    _,
                                                    this->m_FanOpMode,
                                                    this->m_SuppHeatPartLoadFrac);
        }
    }

    void UnitarySys::controlUnitarySystemtoLoad(EnergyPlusData &state,
                                                int const AirLoopNum,          // Primary air loop number
                                                bool const FirstHVACIteration, // True when first HVAC iteration
                                                int &CompOn,                   // Determines if compressor is on or off
                                                Real64 const OAUCoilOutTemp,   // the coil inlet temperature of OutdoorAirUnit
                                                bool HXUnitOn,                 // Flag to control HX for HXAssisted Cooling Coil
                                                Real64 &sysOutputProvided,     // system sensible output at supply air node
                                                Real64 &latOutputProvided      // sytsem latent output at supply air node
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        Real64 SuppPLR = 0.0;       // supplemental heating part-load ratio
        Real64 ZoneLoad = 0.0;      // zone load (W)
        Real64 SupHeaterLoad = 0.0; // additional heating required by supplemental heater (W)
        Real64 OnOffAirFlowRatio = 1.0;
        this->updateUnitarySystemControl(state,
                                         AirLoopNum,
                                         this->CoolCoilOutletNodeNum,
                                         this->m_SystemCoolControlNodeNum,
                                         OnOffAirFlowRatio,
                                         FirstHVACIteration,
                                         OAUCoilOutTemp,
                                         ZoneLoad,
                                         this->DesignMaxOutletTemp);

        // will not be running supplemental heater on this CALL (simulate with supplemental heater off)
        Real64 FullSensibleOutput = 0.0;
        // using furnace module logic
        // first check to see if cycling fan with economizer can meet the load
        if (AirLoopNum > 0) {
            if (this->m_CoolCoilExists && this->m_HeatCoilExists &&
                this->m_CoolingCoilType_Num != DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed &&
                this->m_HeatingCoilType_Num != DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed && !FirstHVACIteration &&
                this->m_FanOpMode == DataHVACGlobals::CycFanCycCoil && state.dataUnitarySystems->CoolingLoad &&
                state.dataAirLoop->AirLoopControlInfo(AirLoopNum).EconoActive) {
                CompOn = 0;
                this->controlUnitarySystemOutput(
                    state, AirLoopNum, FirstHVACIteration, OnOffAirFlowRatio, ZoneLoad, FullSensibleOutput, HXUnitOn, CompOn);
                if (this->m_CoolingPartLoadFrac >= 1.0 || this->m_HeatingPartLoadFrac >= 1.0 ||
                    (this->m_CoolingPartLoadFrac <= 0.0 && this->m_HeatingPartLoadFrac <= 0.0)) {
                    CompOn = 1;
                    this->controlUnitarySystemOutput(
                        state, AirLoopNum, FirstHVACIteration, OnOffAirFlowRatio, ZoneLoad, FullSensibleOutput, HXUnitOn, CompOn);
                }
            } else {
                CompOn = 1;
                this->controlUnitarySystemOutput(
                    state, AirLoopNum, FirstHVACIteration, OnOffAirFlowRatio, ZoneLoad, FullSensibleOutput, HXUnitOn, CompOn);
            }
        } else {
            CompOn = 1;
            this->controlUnitarySystemOutput(
                state, AirLoopNum, FirstHVACIteration, OnOffAirFlowRatio, ZoneLoad, FullSensibleOutput, HXUnitOn, CompOn);
        }
        if (state.dataLoopNodes->Node(this->AirOutNode).MassFlowRate < DataHVACGlobals::SmallMassFlow) {
            state.dataUnitarySystems->CoolingLoad = false;
            state.dataUnitarySystems->HeatingLoad = false;
            state.dataUnitarySystems->MoistureLoad = 0.0;
            this->m_CoolingPartLoadFrac = 0.0;
            this->m_HeatingPartLoadFrac = 0.0;
            if (this->CoolCoilFluidInletNode > 0) state.dataLoopNodes->Node(this->CoolCoilFluidInletNode).MassFlowRate = 0.0;
            if (this->HeatCoilFluidInletNode > 0) state.dataLoopNodes->Node(this->HeatCoilFluidInletNode).MassFlowRate = 0.0;
            this->setAverageAirFlow(state, this->m_CoolingPartLoadFrac, OnOffAirFlowRatio);
            // anything else need to be reset here when system is shut down on low flow?
        }
        Real64 CoolPLR = this->m_CoolingPartLoadFrac;
        Real64 HeatPLR = this->m_HeatingPartLoadFrac;
        Real64 HeatCoilLoad = HeatPLR * this->m_DesignHeatingCapacity;

        if (this->CoolCoilFluidInletNode > 0) {
            PlantUtilities::SetComponentFlowRate(state,
                                                 state.dataLoopNodes->Node(this->CoolCoilFluidInletNode).MassFlowRate,
                                                 this->CoolCoilFluidInletNode,
                                                 this->CoolCoilFluidOutletNodeNum,
                                                 this->CoolCoilLoopNum,
                                                 this->CoolCoilLoopSide,
                                                 this->CoolCoilBranchNum,
                                                 this->CoolCoilCompNum);
        }
        if (this->HeatCoilFluidInletNode > 0) {
            PlantUtilities::SetComponentFlowRate(state,
                                                 state.dataLoopNodes->Node(this->HeatCoilFluidInletNode).MassFlowRate,
                                                 this->HeatCoilFluidInletNode,
                                                 this->HeatCoilFluidOutletNodeNum,
                                                 this->HeatCoilLoopNum,
                                                 this->HeatCoilLoopSide,
                                                 this->HeatCoilBranchNum,
                                                 this->HeatCoilCompNum);
        }

        if (this->m_SuppCoilExists &&
            (state.dataUnitarySystems->HeatingLoad || state.dataUnitarySystems->CoolingLoad || state.dataUnitarySystems->MoistureLoad < 0.0)) {
            if ((FullSensibleOutput < (state.dataUnitarySystems->QToHeatSetPt - DataHVACGlobals::SmallLoad)) && !FirstHVACIteration) {
                SupHeaterLoad = max(0.0, state.dataUnitarySystems->QToHeatSetPt - FullSensibleOutput);
                this->m_SupHeaterLoad = 0.0;
                // what does this line even do? I know we want the supplemental heater on only if there is a dehum load,
                // but for HP's the supp heater should also run if the heating coil can't turn on
                // (i.e., this line calc's a supp heater load, then next line also calc's it?)
                if (state.dataUnitarySystems->MoistureLoad < 0.0) this->m_SupHeaterLoad = SupHeaterLoad;
                // so it look's like this next line should only be valid for HP's.
                if (this->m_DesignSuppHeatingCapacity > 0.0) {
                    this->m_SuppHeatPartLoadFrac = min(1.0, SupHeaterLoad / this->m_DesignSuppHeatingCapacity);
                }
            } else {
                SupHeaterLoad = 0.0;
                this->m_SuppHeatPartLoadFrac = 0.0;
            }
        } else {
            SupHeaterLoad = 0.0;
            this->m_SuppHeatPartLoadFrac = 0.0;
        }

        this->calcUnitarySystemToLoad(state,
                                      AirLoopNum,
                                      FirstHVACIteration,
                                      CoolPLR,
                                      HeatPLR,
                                      OnOffAirFlowRatio,
                                      sysOutputProvided,
                                      latOutputProvided,
                                      HXUnitOn,
                                      HeatCoilLoad,
                                      SupHeaterLoad,
                                      CompOn);

        // check supplemental heating coil outlet temp based on maximum allowed
        if (this->m_SuppCoilExists) {
            SuppPLR = this->m_SuppHeatPartLoadFrac;
            // only need to test for high supply air temp if supplemental coil is operating
            if (SuppPLR > 0.0) {
                this->calcUnitarySystemToLoad(state,
                                              AirLoopNum,
                                              FirstHVACIteration,
                                              CoolPLR,
                                              HeatPLR,
                                              OnOffAirFlowRatio,
                                              sysOutputProvided,
                                              latOutputProvided,
                                              HXUnitOn,
                                              HeatCoilLoad,
                                              SupHeaterLoad,
                                              CompOn);
                if (this->m_DesignSuppHeatingCapacity > 0.0) {
                    this->m_SuppHeatPartLoadFrac = SupHeaterLoad / this->m_DesignSuppHeatingCapacity;
                } else {
                    this->m_SuppHeatPartLoadFrac = 0.0;
                }
            }
        }

        if (this->m_SuppCoilFluidInletNode > 0) {
            PlantUtilities::SetComponentFlowRate(state,
                                                 state.dataLoopNodes->Node(this->m_SuppCoilFluidInletNode).MassFlowRate,
                                                 this->m_SuppCoilFluidInletNode,
                                                 this->m_SuppCoilFluidOutletNodeNum,
                                                 this->m_SuppCoilLoopNum,
                                                 this->m_SuppCoilLoopSide,
                                                 this->m_SuppCoilBranchNum,
                                                 this->m_SuppCoilCompNum);
        }

        if (this->m_HeatRecActive) {
            PlantUtilities::SetComponentFlowRate(state,
                                                 state.dataLoopNodes->Node(this->m_HeatRecoveryInletNodeNum).MassFlowRate,
                                                 this->m_HeatRecoveryInletNodeNum,
                                                 this->m_HeatRecoveryOutletNodeNum,
                                                 this->m_HRLoopNum,
                                                 this->m_HRLoopSideNum,
                                                 this->m_HRBranchNum,
                                                 this->m_HRCompNum);
        }
    }

    void UnitarySys::controlUnitarySystemtoSP(EnergyPlusData &state,
                                              int const AirLoopNum,          // Primary air loop number
                                              bool const FirstHVACIteration, // True when first HVAC iteration
                                              int &CompOn,                   // compressor on/off control
                                              Real64 const OAUCoilOutTemp,   // the coil inlet temperature of OutdoorAirUnit
                                              bool HXUnitOn,                 // Flag to control HX for HXAssisted Cooling Coil
                                              Real64 &sysOutputProvided,     // sensible output at supply air node
                                              Real64 &latOutputProvided      // latent output at supply air node
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine manages component simulation.

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        Real64 PartLoadRatio = 0.0;     // coil operating part-load ratio
        Real64 OnOffAirFlowRatio = 1.0; // Setpoint based coil control does not use this variable
        Real64 CoilCoolHeatRat = 1.0;   // ratio of cooling to heating PLR for cycling fan RH control
        Real64 ZoneLoad = 0.0;
        Real64 HeatCoilLoad = -999.0;

        // CALL the series of components that simulate a Unitary System
        if (this->ATMixerExists) {
            // There is an air terminal mixer
            if (this->ATMixerType == DataHVACGlobals::ATMixer_InletSide) { // if there is an inlet side air terminal mixer
                                                                           // set the primary air inlet mass flow rate
                state.dataLoopNodes->Node(this->m_ATMixerPriNode).MassFlowRate = min(
                    state.dataLoopNodes->Node(this->m_ATMixerPriNode).MassFlowRateMaxAvail, state.dataLoopNodes->Node(this->AirInNode).MassFlowRate);
                // now calculate the the mixer outlet conditions (and the secondary air inlet flow rate)
                // the mixer outlet flow rate has already been set above (it is the "inlet" node flow rate)
                SingleDuct::SimATMixer(state, this->m_ATMixerName, FirstHVACIteration, this->m_ATMixerIndex);
            }
        }

        if (this->m_FanExists && this->m_FanPlace == FanPlace::BlowThru) {
            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                state.dataHVACFan->fanObjs[this->m_FanIndex]->simulate(state, _, _, _, _);
            } else {
                Fans::SimulateFanComponents(state, blankString, FirstHVACIteration, this->m_FanIndex, state.dataUnitarySystems->FanSpeedRatio);
            }
        }

        if (this->m_CoolingCoilUpstream) {

            if (this->m_CoolCoilExists) {
                this->updateUnitarySystemControl(state,
                                                 AirLoopNum,
                                                 this->CoolCoilOutletNodeNum,
                                                 this->m_SystemCoolControlNodeNum,
                                                 OnOffAirFlowRatio,
                                                 FirstHVACIteration,
                                                 OAUCoilOutTemp,
                                                 ZoneLoad,
                                                 this->DesignMaxOutletTemp);
                this->controlCoolingSystemToSP(state, AirLoopNum, FirstHVACIteration, HXUnitOn, CompOn);
                PartLoadRatio = this->m_CoolingPartLoadFrac;
                CompOn = 0;
                if (PartLoadRatio > 0.0) {
                    CompOn = 1;
                    this->m_LastMode = state.dataUnitarySystems->CoolingMode;
                }
                this->calcUnitaryCoolingSystem(
                    state, AirLoopNum, FirstHVACIteration, PartLoadRatio, CompOn, OnOffAirFlowRatio, CoilCoolHeatRat, HXUnitOn);
            }
            if (this->m_HeatCoilExists) {
                this->updateUnitarySystemControl(state,
                                                 AirLoopNum,
                                                 this->HeatCoilOutletNodeNum,
                                                 this->m_SystemHeatControlNodeNum,
                                                 OnOffAirFlowRatio,
                                                 FirstHVACIteration,
                                                 OAUCoilOutTemp,
                                                 ZoneLoad,
                                                 this->DesignMaxOutletTemp);
                this->controlHeatingSystemToSP(state, AirLoopNum, FirstHVACIteration, CompOn, HeatCoilLoad);
                PartLoadRatio = this->m_HeatingPartLoadFrac;
                int CompOn = 0;
                if (PartLoadRatio > 0.0) {
                    CompOn = 1;
                    this->m_LastMode = state.dataUnitarySystems->HeatingMode;
                }
                this->calcUnitaryHeatingSystem(state, AirLoopNum, FirstHVACIteration, PartLoadRatio, CompOn, OnOffAirFlowRatio, HeatCoilLoad);
            }

        } else {

            if (this->m_HeatCoilExists) {
                this->updateUnitarySystemControl(state,
                                                 AirLoopNum,
                                                 this->HeatCoilOutletNodeNum,
                                                 this->m_SystemHeatControlNodeNum,
                                                 OnOffAirFlowRatio,
                                                 FirstHVACIteration,
                                                 OAUCoilOutTemp,
                                                 ZoneLoad,
                                                 this->DesignMaxOutletTemp);
                this->controlHeatingSystemToSP(state, AirLoopNum, FirstHVACIteration, CompOn, HeatCoilLoad);
                PartLoadRatio = this->m_HeatingPartLoadFrac;
                CompOn = 0;
                if (PartLoadRatio > 0.0) {
                    CompOn = 1;
                    this->m_LastMode = state.dataUnitarySystems->HeatingMode;
                }
                this->calcUnitaryHeatingSystem(state, AirLoopNum, FirstHVACIteration, PartLoadRatio, CompOn, OnOffAirFlowRatio, HeatCoilLoad);
            }
            if (this->m_CoolCoilExists) {
                this->updateUnitarySystemControl(state,
                                                 AirLoopNum,
                                                 this->CoolCoilOutletNodeNum,
                                                 this->m_SystemCoolControlNodeNum,
                                                 OnOffAirFlowRatio,
                                                 FirstHVACIteration,
                                                 OAUCoilOutTemp,
                                                 ZoneLoad,
                                                 this->DesignMaxOutletTemp);
                this->controlCoolingSystemToSP(state, AirLoopNum, FirstHVACIteration, HXUnitOn, CompOn);
                PartLoadRatio = this->m_CoolingPartLoadFrac;
                CompOn = 0;
                if (PartLoadRatio > 0.0) {
                    CompOn = 1;
                    this->m_LastMode = state.dataUnitarySystems->CoolingMode;
                }
                this->calcUnitaryCoolingSystem(
                    state, AirLoopNum, FirstHVACIteration, PartLoadRatio, CompOn, OnOffAirFlowRatio, CoilCoolHeatRat, HXUnitOn);
            }
        }

        if (this->m_FanExists && this->m_FanPlace == FanPlace::DrawThru) {
            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                state.dataHVACFan->fanObjs[this->m_FanIndex]->simulate(state, _, _, _, _);
            } else {
                Fans::SimulateFanComponents(state, blankString, FirstHVACIteration, this->m_FanIndex, state.dataUnitarySystems->FanSpeedRatio);
            }
        }

        if (this->m_SuppCoilExists) {
            state.dataUnitarySystems->SuppHeatingCoilFlag = true;
            this->updateUnitarySystemControl(state,
                                             AirLoopNum,
                                             this->m_SuppCoilAirOutletNode,
                                             this->m_SuppHeatControlNodeNum,
                                             OnOffAirFlowRatio,
                                             FirstHVACIteration,
                                             OAUCoilOutTemp,
                                             ZoneLoad,
                                             this->DesignMaxOutletTemp);
            this->controlSuppHeatSystemToSP(state, AirLoopNum, FirstHVACIteration);
            this->calcUnitarySuppSystemToSP(state, FirstHVACIteration);
            state.dataUnitarySystems->SuppHeatingCoilFlag = false;
        }

        // If there is a supply side air terminal mixer, calculate its output
        if (this->ATMixerExists) {
            if (this->ATMixerType == DataHVACGlobals::ATMixer_SupplySide) {
                SingleDuct::SimATMixer(state, this->m_ATMixerName, FirstHVACIteration, this->m_ATMixerIndex);
            }
        }

        calculateCapacity(state, sysOutputProvided, latOutputProvided);
        this->m_InitHeatPump = false;
    }

    void UnitarySys::updateUnitarySystemControl(EnergyPlusData &state,
                                                int const AirLoopNum,  // number of the current air loop being simulated
                                                int const OutNode,     // coil outlet node number
                                                int const ControlNode, // control node number
                                                Real64 &OnOffAirFlowRatio,
                                                bool const FirstHVACIteration,
                                                Real64 const OAUCoilOutletTemp, // "ONLY" for zoneHVAC:OutdoorAirUnit
                                                Real64 &ZoneLoad,
                                                Real64 const MaxOutletTemp // limits heating coil outlet temp [C]
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine is for sizing unitary systems.

        // METHODOLOGY EMPLOYED:
        // Either CALL the coil model to get the size or size coil.
        // Current method is to use same methodology as is used in coil objects.
        // Future changes will include a common sizing algorithm and push the calculated
        // size to the coil object prior to first call (so the coil will not DataSizing::AutoSize).

        // These initializations are done every iteration

        {
            state.dataUnitarySystems->MoistureLoad = 0.0;
            this->LoadSHR = 0.0;
            this->CoilSHR = 0.0;
            auto const SELECT_CASE_var(this->m_ControlType);
            if (SELECT_CASE_var == ControlType::Load || SELECT_CASE_var == ControlType::CCMASHRAE) {
                if (AirLoopNum == -1) { // This IF-THEN routine is just for ZoneHVAC:OutdoorAirUnit
                    ShowWarningError(state, this->UnitType + " \"" + this->Name + "\"");
                    ShowFatalError(state, "...Load based control is not allowed when used with ZoneHVAC:OutdoorAirUnit");
                }

                // here we need to deal with sequenced zone equip
                state.dataUnitarySystems->HeatingLoad = false;
                state.dataUnitarySystems->CoolingLoad = false;
                if (this->m_ZoneSequenceCoolingNum > 0 && this->m_ZoneSequenceHeatingNum > 0 && this->m_AirLoopEquipment) {
                    // air loop equipment uses sequenced variables
                    state.dataUnitarySystems->QToCoolSetPt = state.dataZoneEnergyDemand->ZoneSysEnergyDemand(this->ControlZoneNum)
                                                                 .SequencedOutputRequiredToCoolingSP(this->m_ZoneSequenceCoolingNum);
                    state.dataUnitarySystems->QToHeatSetPt = state.dataZoneEnergyDemand->ZoneSysEnergyDemand(this->ControlZoneNum)
                                                                 .SequencedOutputRequiredToHeatingSP(this->m_ZoneSequenceHeatingNum);
                    if (state.dataUnitarySystems->QToHeatSetPt > 0.0 && state.dataUnitarySystems->QToCoolSetPt > 0.0 &&
                        state.dataHeatBalFanSys->TempControlType(this->ControlZoneNum) != DataHVACGlobals::SingleCoolingSetPoint) {
                        ZoneLoad = state.dataUnitarySystems->QToHeatSetPt;
                        state.dataUnitarySystems->HeatingLoad = true;
                    } else if (state.dataUnitarySystems->QToHeatSetPt > 0.0 && state.dataUnitarySystems->QToCoolSetPt > 0.0 &&
                               state.dataHeatBalFanSys->TempControlType(this->ControlZoneNum) == DataHVACGlobals::SingleCoolingSetPoint) {
                        ZoneLoad = 0.0;
                    } else if (state.dataUnitarySystems->QToHeatSetPt < 0.0 && state.dataUnitarySystems->QToCoolSetPt < 0.0 &&
                               state.dataHeatBalFanSys->TempControlType(this->ControlZoneNum) != DataHVACGlobals::SingleHeatingSetPoint) {
                        ZoneLoad = state.dataUnitarySystems->QToCoolSetPt;
                        state.dataUnitarySystems->CoolingLoad = true;
                    } else if (state.dataUnitarySystems->QToHeatSetPt < 0.0 && state.dataUnitarySystems->QToCoolSetPt < 0.0 &&
                               state.dataHeatBalFanSys->TempControlType(this->ControlZoneNum) == DataHVACGlobals::SingleHeatingSetPoint) {
                        ZoneLoad = 0.0;
                    } else if (state.dataUnitarySystems->QToHeatSetPt <= 0.0 && state.dataUnitarySystems->QToCoolSetPt >= 0.0) {
                        ZoneLoad = 0.0;
                    }
                    state.dataUnitarySystems->MoistureLoad = state.dataZoneEnergyDemand->ZoneSysMoistureDemand(this->ControlZoneNum)
                                                                 .SequencedOutputRequiredToDehumidSP(this->m_ZoneSequenceCoolingNum);
                } else {
                    // zone equipment uses Remaining* variables
                    ZoneLoad = state.dataZoneEnergyDemand->ZoneSysEnergyDemand(this->ControlZoneNum).RemainingOutputRequired;
                    state.dataUnitarySystems->QToCoolSetPt =
                        state.dataZoneEnergyDemand->ZoneSysEnergyDemand(this->ControlZoneNum).RemainingOutputReqToCoolSP;
                    state.dataUnitarySystems->QToHeatSetPt =
                        state.dataZoneEnergyDemand->ZoneSysEnergyDemand(this->ControlZoneNum).RemainingOutputReqToHeatSP;
                    state.dataUnitarySystems->MoistureLoad =
                        state.dataZoneEnergyDemand->ZoneSysMoistureDemand(this->ControlZoneNum).RemainingOutputReqToDehumidSP;
                }

                if (ZoneLoad < 0.0 && state.dataUnitarySystems->MoistureLoad <= 0.0 &&
                    (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling &&
                     state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].SubcoolReheatFlag)) {
                    this->LoadSHR =
                        ZoneLoad / (ZoneLoad + state.dataUnitarySystems->MoistureLoad *
                                                   Psychrometrics::PsyHgAirFnWTdb(state.dataHeatBalFanSys->ZoneAirHumRat(this->ControlZoneNum),
                                                                                  state.dataHeatBalFanSys->MAT(this->ControlZoneNum)));
                    if (this->LoadSHR < 0.0) {
                        this->LoadSHR = 0.0;
                    }
                    this->CoilSHR = this->LoadSHR;
                }

                if (this->m_DehumidControlType_Num != DehumCtrlType::None) {
                    Real64 H2OHtOfVap = Psychrometrics::PsyHfgAirFnWTdb(state.dataLoopNodes->Node(this->NodeNumOfControlledZone).HumRat,
                                                                        state.dataLoopNodes->Node(this->NodeNumOfControlledZone).Temp);

                    // positive MoistureLoad means no dehumidification load
                    state.dataUnitarySystems->MoistureLoad = min(0.0, state.dataUnitarySystems->MoistureLoad * H2OHtOfVap);
                } else {
                    state.dataUnitarySystems->MoistureLoad = 0.0;
                }

                this->initLoadBasedControl(state, AirLoopNum, FirstHVACIteration, OnOffAirFlowRatio, ZoneLoad);

                // *** the location of this EMS override looks suspect. If EMS is active the load will be changed but the CoolingLoad and HeatingLoad
                // flags are not updated. suggest this be moved up above InitLoadBasedControl function on previous line so the EMS loads are used in
                // that routine EMS override point
                if (this->m_EMSOverrideSensZoneLoadRequest) ZoneLoad = this->m_EMSSensibleZoneLoadValue;
                if (this->m_EMSOverrideMoistZoneLoadRequest) state.dataUnitarySystems->MoistureLoad = this->m_EMSMoistureZoneLoadValue;

                this->m_SimASHRAEModel = false; // flag used to envoke ASHRAE 90.1 model calculations
                // allows non-ASHSRAE compliant coil types to be modeled using non-ASHAR90 method. Constant fan operating mode is required.
                if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
                    if (state.dataUnitarySystems->CoolingLoad) {
                        if (this->m_ValidASHRAECoolCoil) this->m_SimASHRAEModel = true;
                    } else if (state.dataUnitarySystems->HeatingLoad) {
                        if (this->m_ValidASHRAEHeatCoil) this->m_SimASHRAEModel = true;
                    }
                }

            } else if (SELECT_CASE_var == ControlType::Setpoint) {
                if (AirLoopNum == -1) { // This IF-THEN routine is just for ZoneHVAC:OutdoorAIRUNIT

                    if (ControlNode == 0) {
                        this->m_DesiredOutletTemp = OAUCoilOutletTemp;
                    } else if (ControlNode == OutNode) {
                        this->m_DesiredOutletTemp = OAUCoilOutletTemp;
                    }
                    // If the unitary system is an Outdoor Air Unit, the desired coil outlet humidity level is set to 1.0 (no dehum)
                    this->m_DesiredOutletHumRat = 1.0;

                } else { // Not Outdoor Air Unit. Either airloop or zone equipment
                    Real64 humRatMaxSP = 1.0;
                    this->m_DesiredOutletHumRat = humRatMaxSP;
                    if (ControlNode == 0) {
                        this->m_DesiredOutletTemp = 0.0;
                        if (OutNode > 0) {
                            if (state.dataLoopNodes->Node(OutNode).HumRatMax > 0.0) {
                                this->m_DesiredOutletHumRat = state.dataLoopNodes->Node(OutNode).HumRatMax;
                            }
                        }
                    } else if (ControlNode == OutNode) {
                        if (this->m_ISHundredPercentDOASDXCoil && this->m_RunOnSensibleLoad) {
                            if (state.dataLoopNodes->Node(ControlNode).HumRatMax > 0.0)
                                humRatMaxSP = state.dataLoopNodes->Node(ControlNode).HumRatMax;
                            this->frostControlSetPointLimit(state,
                                                            state.dataLoopNodes->Node(ControlNode).TempSetPoint,
                                                            humRatMaxSP,
                                                            state.dataEnvrn->OutBaroPress,
                                                            this->DesignMinOutletTemp,
                                                            1);
                        }
                        this->m_DesiredOutletTemp = state.dataLoopNodes->Node(ControlNode).TempSetPoint;
                        //  IF HumRatMax is zero, then there is no request from SetpointManager:SingleZone:Humidity:Maximum
                        // user might place temp SP at system outlet and HumRat set point at coil outlet
                        if (this->m_DehumidControlType_Num != DehumCtrlType::None) {
                            if (state.dataLoopNodes->Node(this->AirOutNode).HumRatMax > 0.0)
                                humRatMaxSP = state.dataLoopNodes->Node(this->AirOutNode).HumRatMax;
                            if (state.dataLoopNodes->Node(ControlNode).HumRatMax > 0.0)
                                humRatMaxSP = state.dataLoopNodes->Node(ControlNode).HumRatMax;
                            if (this->m_ISHundredPercentDOASDXCoil && this->m_RunOnLatentLoad) {
                                this->frostControlSetPointLimit(state,
                                                                state.dataLoopNodes->Node(ControlNode).TempSetPoint,
                                                                state.dataLoopNodes->Node(ControlNode).HumRatMax,
                                                                state.dataEnvrn->OutBaroPress,
                                                                this->DesignMinOutletTemp,
                                                                2);
                                humRatMaxSP = state.dataLoopNodes->Node(ControlNode).HumRatMax;
                            }
                            this->m_DesiredOutletHumRat = humRatMaxSP; // should this be outside so as to capture humrat for 100%DOASDXCoil ?
                        }
                    } else {
                        if (state.dataLoopNodes->Node(ControlNode).HumRatMax > 0.0) humRatMaxSP = state.dataLoopNodes->Node(ControlNode).HumRatMax;
                        if (state.dataLoopNodes->Node(OutNode).HumRatMax > 0.0) humRatMaxSP = state.dataLoopNodes->Node(OutNode).HumRatMax;
                        if (this->m_ISHundredPercentDOASDXCoil && this->m_RunOnSensibleLoad) {
                            this->frostControlSetPointLimit(state,
                                                            state.dataLoopNodes->Node(ControlNode).TempSetPoint,
                                                            humRatMaxSP,
                                                            state.dataEnvrn->OutBaroPress,
                                                            this->DesignMinOutletTemp,
                                                            1);
                        }
                        this->m_DesiredOutletTemp = state.dataLoopNodes->Node(ControlNode).TempSetPoint -
                                                    (state.dataLoopNodes->Node(ControlNode).Temp - state.dataLoopNodes->Node(OutNode).Temp);
                        if (this->m_DehumidControlType_Num != DehumCtrlType::None) {
                            if (this->m_ISHundredPercentDOASDXCoil && this->m_RunOnLatentLoad) {
                                this->frostControlSetPointLimit(state,
                                                                state.dataLoopNodes->Node(ControlNode).TempSetPoint,
                                                                state.dataLoopNodes->Node(ControlNode).HumRatMax,
                                                                state.dataEnvrn->OutBaroPress,
                                                                this->DesignMinOutletTemp,
                                                                2);
                                humRatMaxSP = state.dataLoopNodes->Node(ControlNode).HumRatMax;
                            }
                            this->m_DesiredOutletHumRat = humRatMaxSP; // should this be outside so as to capture humrat for 100%DOASDXCoil ?
                        }
                    }
                }
                this->m_DesiredOutletTemp = min(this->m_DesiredOutletTemp, MaxOutletTemp);

            } else {
                // should never get here, only 3 control types
            }
        }
    }
    void UnitarySys::controlUnitarySystemOutputEMS(EnergyPlusData &state,
                                                   int const AirLoopNum,          // Index to air loop
                                                   bool const FirstHVACIteration, // True when first HVAC iteration
                                                   Real64 &OnOffAirFlowRatio,     // ratio of heating PLR to cooling PLR (is this correct?)
                                                   Real64 const ZoneLoad,
                                                   Real64 &FullSensibleOutput,
                                                   bool &HXUnitOn, // Flag to control HX for HXAssisted Cooling Coil
                                                   int CompOn)
    {
        Real64 PartLoadRatio = 1.0;
        Real64 CoolPLR = 0.0;
        Real64 HeatPLR = 0.0;
        int CompressorONFlag = CompOn;
        Real64 HeatCoilLoad = 0.0;
        Real64 SupHeaterLoad = 0.0;
        Real64 SensOutput; // sensible output
        Real64 LatOutput;  // latent output
        this->FanPartLoadRatio = 0.0;
        this->setOnOffMassFlowRate(state, OnOffAirFlowRatio, PartLoadRatio);

        if (!state.dataUnitarySystems->HeatingLoad && !state.dataUnitarySystems->CoolingLoad && state.dataUnitarySystems->MoistureLoad >= 0.0) return;
        int SpeedNumEMS = ceil(this->m_EMSOverrideCoilSpeedNumValue);
        bool useMaxedSpeed = false;
        std::string useMaxedSpeedCoilName;
        if (state.dataUnitarySystems->HeatingLoad) {
            if (SpeedNumEMS > this->m_NumOfSpeedHeating) {
                SpeedNumEMS = this->m_NumOfSpeedHeating;
                useMaxedSpeed = true;
                useMaxedSpeedCoilName = this->m_HeatingCoilName;
            }
            this->m_HeatingSpeedNum = SpeedNumEMS;
        } else {
            if (SpeedNumEMS > this->m_NumOfSpeedCooling) {
                SpeedNumEMS = this->m_NumOfSpeedCooling;
                useMaxedSpeed = true;
                useMaxedSpeedCoilName = this->m_CoolingCoilName;
            }
            this->m_CoolingSpeedNum = SpeedNumEMS;
        }
        if (useMaxedSpeed) {
            this->m_CoilSpeedErrIdx++;
            ShowRecurringWarningErrorAtEnd(state,
                                           "Wrong coil speed EMS override value, for unit=\"" + useMaxedSpeedCoilName +
                                               "\". Exceeding maximum coil speed level. Speed level is set to the maximum coil speed level allowed.",
                                           this->m_CoilSpeedErrIdx,
                                           this->m_EMSOverrideCoilSpeedNumValue,
                                           this->m_EMSOverrideCoilSpeedNumValue,
                                           _,
                                           "",
                                           "");
        }

        if (state.dataUnitarySystems->HeatingLoad) {
            CoolPLR = 0.0;
            HeatPLR = 1.0;
            this->m_HeatingCoilSensDemand = ZoneLoad;

            if (this->m_HeatingSpeedNum == 1) {
                this->m_HeatingSpeedRatio = 0.0;
                this->m_HeatingCycRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                if (useMaxedSpeed || this->m_HeatingCycRatio == 0) {
                    this->m_HeatingCycRatio = 1;
                }
            } else {
                this->m_HeatingCycRatio = 1.0;
                this->m_HeatingSpeedRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                if (useMaxedSpeed || this->m_HeatingSpeedRatio == 0) {
                    this->m_HeatingSpeedRatio = 1;
                }
            }
            this->m_WSHPRuntimeFrac = HeatPLR;
        } else { // Cooling or moisture load
            HeatPLR = 0.0;
            CoolPLR = 1.0;
            if (state.dataUnitarySystems->CoolingLoad) {
                this->m_CoolingCoilSensDemand = std::abs(ZoneLoad);
            } else {
                this->m_CoolingCoilSensDemand = 0.0;
            }
            this->m_CoolingCoilLatentDemand = std::abs(state.dataUnitarySystems->MoistureLoad);

            if (this->m_CoolingSpeedNum == 1) {
                this->m_CoolingSpeedRatio = 0.0;
                this->m_CoolingCycRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                if (useMaxedSpeed || this->m_CoolingCycRatio == 0) {
                    this->m_CoolingCycRatio = 1;
                }
            } else {
                this->m_CoolingCycRatio = 1.0;
                this->m_CoolingSpeedRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                if (useMaxedSpeed || this->m_CoolingSpeedRatio == 0) {
                    this->m_CoolingSpeedRatio = 1;
                }
            }
            this->m_WSHPRuntimeFrac = CoolPLR;
        }
        this->calcUnitarySystemToLoad(state,
                                      AirLoopNum,
                                      FirstHVACIteration,
                                      CoolPLR,
                                      HeatPLR,
                                      OnOffAirFlowRatio,
                                      SensOutput,
                                      LatOutput,
                                      HXUnitOn,
                                      HeatCoilLoad,
                                      SupHeaterLoad,
                                      CompressorONFlag);

        FullSensibleOutput = SensOutput;

        if (!state.dataUnitarySystems->HeatingLoad && !state.dataUnitarySystems->CoolingLoad) {
            // no load
            if (state.dataUnitarySystems->MoistureLoad > LatOutput) return;
            // Dehumcontrol_Multimode only controls RH if there is a sensible load
            if (this->m_DehumidControlType_Num == DehumCtrlType::Multimode) return;
        }
        HXUnitOn = true;
        this->calcUnitarySystemToLoad(state,
                                      AirLoopNum,
                                      FirstHVACIteration,
                                      CoolPLR,
                                      HeatPLR,
                                      OnOffAirFlowRatio,
                                      SensOutput,
                                      LatOutput,
                                      HXUnitOn,
                                      HeatCoilLoad,
                                      SupHeaterLoad,
                                      CompressorONFlag);
        Real64 CpAir = Psychrometrics::PsyCpAirFnW(state.dataLoopNodes->Node(this->CoolCoilInletNodeNum).HumRat);
        Real64 CoolingOnlySensibleOutput =
            state.dataLoopNodes->Node(this->CoolCoilInletNodeNum).MassFlowRate * CpAir *
            ((state.dataLoopNodes->Node(this->NodeNumOfControlledZone).Temp - state.dataLoopNodes->Node(this->CoolCoilOutletNodeNum).Temp) -
             (state.dataLoopNodes->Node(this->HeatCoilOutletNodeNum).Temp - state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).Temp));
        if (state.dataUnitarySystems->QToHeatSetPt < 0.0) {
            //   Calculate the reheat coil load wrt the heating setpoint temperature. Reheat coil picks up
            //   the entire excess sensible cooling (DX cooling coil and impact of outdoor air).
            this->m_DehumidInducedHeatingDemandRate = max(0.0, (CoolingOnlySensibleOutput + state.dataUnitarySystems->QToHeatSetPt));
            //   Heating mode and dehumidification is required
        } else if (state.dataUnitarySystems->QToHeatSetPt >= 0.0) {
            //   Calculate the reheat coil load as the sensible capacity of the DX cooling coil only. Let
            //   the heating coil pick up the load due to outdoor air.
            this->m_DehumidInducedHeatingDemandRate = max(0.0, CoolingOnlySensibleOutput);
        }
    }

    void UnitarySys::controlUnitarySystemOutput(EnergyPlusData &state,
                                                int const AirLoopNum,          // Index to air loop
                                                bool const FirstHVACIteration, // True when first HVAC iteration
                                                Real64 &OnOffAirFlowRatio,     // ratio of heating PLR to cooling PLR (is this correct?)
                                                Real64 const ZoneLoad,
                                                Real64 &FullSensibleOutput,
                                                bool &HXUnitOn, // Flag to control HX for HXAssisted Cooling Coil
                                                int CompOn)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013
        //       MODIFIED       na
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine determines operating PLR and calculates the load based system output.

        // Locals
        // SUBROUTINE PARAMETER DEFINITIONS:
        int const MaxIter(100); // maximum number of iterations

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        std::vector<Real64> Par(17);      // parameters passed to RegulaFalsi function
        int SpeedNum;                     // multi-speed coil speed number
        Real64 SensOutputOn;              // sensible output at PLR = 1 [W]
        Real64 LatOutputOn;               // latent output at PLR = 1 [W]
        Real64 TempLoad;                  // represents either a sensible or latent load [W]
        Real64 TempSysOutput;             // represents either a sensible or latent capacity [W]
        Real64 TempSensOutput;            // iterative sensible capacity [W]
        Real64 TempLatOutput;             // iterative latent capacity [W]
        Real64 TempMinPLR;                // iterative minimum PLR
        Real64 TempMaxPLR;                // iterative maximum PLR
        Real64 CoolingOnlySensibleOutput; // use to calculate dehumidification induced heating [W]
        Real64 CpAir;                     // specific heat of air [J/kg_C]
        Real64 FullLoadAirOutletTemp;     // saved full load outlet air temperature [C]
        Real64 FullLoadAirOutletHumRat;   // saved full load outlet air humidity ratio [kg/kg]
        Real64 NoLoadOutletTemp;          // outlet temp of system with coils off [C]

        std::string CompName = this->Name;
        int OutletNode = this->AirOutNode;

        if (ScheduleManager::GetCurrentScheduleValue(state, this->m_SysAvailSchedPtr) <= 0.0) {
            return;
        }
        if (this->m_EMSOverrideCoilSpeedNumOn) {
            this->controlUnitarySystemOutputEMS(
                state, AirLoopNum, FirstHVACIteration, OnOffAirFlowRatio, ZoneLoad, FullSensibleOutput, HXUnitOn, CompOn);
            return;
        }

        Real64 PartLoadRatio = 0.0; // Get no load result
        // fan and coil PLR are disconnected when using ASHRAE model, don't confuse these for other models
        this->FanPartLoadRatio = 0.0;
        int SolFlag = 0;    // # of iterations IF positive, -1 means failed to converge, -2 means bounds are incorrect
        int SolFlagLat = 0; // # of iterations IF positive, -1 means failed to converge, -2 means bounds are incorrect

        Real64 SensOutputOff = 0.0;
        Real64 LatOutputOff = 0.0;
        Real64 CoolPLR = 0.0;
        Real64 HeatPLR = 0.0;
        int CompressorONFlag = 0;
        Real64 HeatCoilLoad = 0.0;
        Real64 SupHeaterLoad = 0.0;

        this->m_WSHPRuntimeFrac = 0.0;

        this->setOnOffMassFlowRate(state, OnOffAirFlowRatio, PartLoadRatio);

        if (!state.dataUnitarySystems->HeatingLoad && !state.dataUnitarySystems->CoolingLoad && state.dataUnitarySystems->MoistureLoad >= 0.0) return;

        this->calcUnitarySystemToLoad(state,
                                      AirLoopNum,
                                      FirstHVACIteration,
                                      CoolPLR,
                                      HeatPLR,
                                      OnOffAirFlowRatio,
                                      SensOutputOff,
                                      LatOutputOff,
                                      HXUnitOn,
                                      HeatCoilLoad,
                                      SupHeaterLoad,
                                      CompressorONFlag);
        FullSensibleOutput = SensOutputOff;
        NoLoadOutletTemp = state.dataLoopNodes->Node(OutletNode).Temp;

        if (!state.dataUnitarySystems->HeatingLoad && !state.dataUnitarySystems->CoolingLoad) {
            // no load
            if (state.dataUnitarySystems->MoistureLoad > LatOutputOff) return;
            // Dehumcontrol_Multimode only controls RH if there is a sensible load
            if (this->m_DehumidControlType_Num == DehumCtrlType::Multimode) return;
        }

        // determine if PLR=0 meets the load
        {
            auto const SELECT_CASE_var(state.dataHeatBalFanSys->TempControlType(this->ControlZoneNum));
            if (SELECT_CASE_var == DataHVACGlobals::SingleHeatingSetPoint) {
                if (state.dataUnitarySystems->HeatingLoad && SensOutputOff > ZoneLoad &&
                    (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                    return;
                if (!state.dataUnitarySystems->HeatingLoad &&
                    (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                    return;
            } else if (SELECT_CASE_var == DataHVACGlobals::SingleCoolingSetPoint) {
                if (state.dataUnitarySystems->CoolingLoad && SensOutputOff < ZoneLoad &&
                    (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                    return;
                if (!state.dataUnitarySystems->CoolingLoad &&
                    (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                    return;
            } else if ((SELECT_CASE_var == DataHVACGlobals::SingleHeatCoolSetPoint) ||
                       (SELECT_CASE_var == DataHVACGlobals::DualSetPointWithDeadBand)) {
                if (state.dataUnitarySystems->HeatingLoad && SensOutputOff > ZoneLoad &&
                    (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                    return;
                if (state.dataUnitarySystems->CoolingLoad && SensOutputOff < ZoneLoad &&
                    (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                    return;
                if (!state.dataUnitarySystems->HeatingLoad && !state.dataUnitarySystems->CoolingLoad &&
                    (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                    return;
            } else {
                // should never get here
            }
        }

        // if a variable speed unit, the SensOutputOff at SpeedNum=1 must be checked to see if it exceeds the ZoneLoad
        // This is still no load but at the first speed above idle
        if ((state.dataUnitarySystems->HeatingLoad && this->m_NumOfSpeedHeating > 0) ||
            (state.dataUnitarySystems->CoolingLoad && this->m_NumOfSpeedCooling > 0)) {
            if (this->m_Staged) {
                if (state.dataUnitarySystems->HeatingLoad) {
                    this->m_HeatingSpeedNum = this->m_StageNum;
                } else {
                    this->m_CoolingSpeedNum = std::abs(this->m_StageNum);
                }
            } else {
                if (state.dataUnitarySystems->HeatingLoad) {
                    this->m_HeatingSpeedNum = 1;
                } else {
                    this->m_CoolingSpeedNum = 1;
                }
            }
            this->setOnOffMassFlowRate(state, OnOffAirFlowRatio, PartLoadRatio);
            this->calcUnitarySystemToLoad(state,
                                          AirLoopNum,
                                          FirstHVACIteration,
                                          CoolPLR,
                                          HeatPLR,
                                          OnOffAirFlowRatio,
                                          SensOutputOff,
                                          LatOutputOff,
                                          HXUnitOn,
                                          HeatCoilLoad,
                                          SupHeaterLoad,
                                          CompressorONFlag);
            FullSensibleOutput = SensOutputOff;

            {
                auto const SELECT_CASE_var(state.dataHeatBalFanSys->TempControlType(this->ControlZoneNum));
                if (SELECT_CASE_var == DataHVACGlobals::SingleHeatingSetPoint) {
                    if (state.dataUnitarySystems->HeatingLoad && SensOutputOff > ZoneLoad &&
                        (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                        return;
                    if (!state.dataUnitarySystems->HeatingLoad &&
                        (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                        return;
                } else if (SELECT_CASE_var == DataHVACGlobals::SingleCoolingSetPoint) {
                    if (state.dataUnitarySystems->CoolingLoad && SensOutputOff < ZoneLoad &&
                        this->m_DehumidControlType_Num != DehumCtrlType::CoolReheat)
                        return;
                    if (state.dataUnitarySystems->CoolingLoad && SensOutputOff < ZoneLoad &&
                        (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                        return;
                    if (!state.dataUnitarySystems->CoolingLoad &&
                        (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                        return;
                } else if ((SELECT_CASE_var == DataHVACGlobals::SingleHeatCoolSetPoint) ||
                           (SELECT_CASE_var == DataHVACGlobals::DualSetPointWithDeadBand)) {
                    if (state.dataUnitarySystems->HeatingLoad && SensOutputOff > ZoneLoad &&
                        (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                        return;
                    if (state.dataUnitarySystems->CoolingLoad && SensOutputOff < ZoneLoad &&
                        this->m_DehumidControlType_Num != DehumCtrlType::CoolReheat)
                        return;
                    if (state.dataUnitarySystems->CoolingLoad && SensOutputOff < ZoneLoad &&
                        (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                        return;
                    if (!state.dataUnitarySystems->HeatingLoad && !state.dataUnitarySystems->CoolingLoad &&
                        (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOff))
                        return;
                } else {
                    // should never get here
                }
            }
        }

        PartLoadRatio = 1.0; // Get full load result
        this->FanPartLoadRatio = 1.0;
        CompressorONFlag = CompOn;

        if (state.dataUnitarySystems->HeatingLoad) {
            CoolPLR = 0.0;
            HeatPLR = 1.0;
            this->m_HeatingCoilSensDemand = ZoneLoad;
            this->m_WSHPRuntimeFrac = HeatPLR;
            if (this->m_NumOfSpeedHeating > 0) {
                this->m_HeatingSpeedRatio = 1.0;
                this->m_HeatingCycRatio = 1.0;
                this->m_HeatingSpeedNum = this->m_NumOfSpeedHeating;
            }
            if (this->m_Staged && this->m_StageNum > 0) {
                if (this->m_NumOfSpeedHeating > 0) {
                    this->m_HeatingSpeedNum = min(this->m_StageNum, this->m_NumOfSpeedHeating);
                    this->m_HeatingSpeedRatio = 0.0;
                }
                this->setOnOffMassFlowRate(state, OnOffAirFlowRatio, PartLoadRatio);
                this->calcUnitarySystemToLoad(state,
                                              AirLoopNum,
                                              FirstHVACIteration,
                                              CoolPLR,
                                              HeatPLR,
                                              OnOffAirFlowRatio,
                                              SensOutputOff,
                                              LatOutputOff,
                                              HXUnitOn,
                                              HeatCoilLoad,
                                              SupHeaterLoad,
                                              CompressorONFlag);
                if (SensOutputOff > ZoneLoad) return;
                if (this->m_NumOfSpeedHeating > 0) this->m_HeatingSpeedRatio = 1.0;
            }
        } else if (state.dataUnitarySystems->CoolingLoad || state.dataUnitarySystems->MoistureLoad < LatOutputOff) {
            CoolPLR = 1.0;
            HeatPLR = 0.0;
            if (state.dataUnitarySystems->CoolingLoad) {
                this->m_CoolingCoilSensDemand = std::abs(ZoneLoad);
            } else {
                this->m_CoolingCoilSensDemand = 0.0;
            }
            this->m_CoolingCoilLatentDemand = std::abs(state.dataUnitarySystems->MoistureLoad);
            this->m_WSHPRuntimeFrac = CoolPLR;
            if (this->m_NumOfSpeedCooling > 0) {
                this->m_CoolingSpeedRatio = 1.0;
                this->m_CoolingCycRatio = 1.0;
                this->m_CoolingSpeedNum = this->m_NumOfSpeedCooling;
            }
            if (this->m_Staged && this->m_StageNum < 0) {
                if (this->m_NumOfSpeedCooling > 0) this->m_CoolingSpeedNum = min(std::abs(this->m_StageNum), this->m_NumOfSpeedCooling);
                this->setOnOffMassFlowRate(state, OnOffAirFlowRatio, PartLoadRatio);
                this->m_CoolingSpeedRatio = 0.0;
                this->calcUnitarySystemToLoad(state,
                                              AirLoopNum,
                                              FirstHVACIteration,
                                              CoolPLR,
                                              HeatPLR,
                                              OnOffAirFlowRatio,
                                              SensOutputOff,
                                              LatOutputOff,
                                              HXUnitOn,
                                              HeatCoilLoad,
                                              SupHeaterLoad,
                                              CompressorONFlag);
                if (SensOutputOff < ZoneLoad) return;
                if (this->m_NumOfSpeedCooling > 0) this->m_CoolingSpeedRatio = 1.0;
            }
        } else {
            // will return here when no cooling or heating load and MoistureLoad > LatOutputOff (i.e., PLR=0)
            return;
        }

        this->setOnOffMassFlowRate(state, OnOffAirFlowRatio, PartLoadRatio);

        this->calcUnitarySystemToLoad(state,
                                      AirLoopNum,
                                      FirstHVACIteration,
                                      CoolPLR,
                                      HeatPLR,
                                      OnOffAirFlowRatio,
                                      SensOutputOn,
                                      LatOutputOn,
                                      HXUnitOn,
                                      HeatCoilLoad,
                                      SupHeaterLoad,
                                      CompressorONFlag);
        FullSensibleOutput = SensOutputOn;
        FullLoadAirOutletTemp = state.dataLoopNodes->Node(OutletNode).Temp;
        FullLoadAirOutletHumRat = state.dataLoopNodes->Node(OutletNode).HumRat;

        // turn on HX if dehumidm_ControlType::Multimode
        if (this->m_DehumidControlType_Num == DehumCtrlType::Multimode && state.dataUnitarySystems->MoistureLoad < 0.0 &&
            state.dataUnitarySystems->MoistureLoad < LatOutputOn && state.dataUnitarySystems->CoolingLoad) {
            HXUnitOn = true;
            this->calcUnitarySystemToLoad(state,
                                          AirLoopNum,
                                          FirstHVACIteration,
                                          CoolPLR,
                                          HeatPLR,
                                          OnOffAirFlowRatio,
                                          SensOutputOn,
                                          LatOutputOn,
                                          HXUnitOn,
                                          HeatCoilLoad,
                                          SupHeaterLoad,
                                          CompressorONFlag);
            FullSensibleOutput = SensOutputOn;
        }

        // test to see if full capacity is less than load, if so set to PLR=1 and RETURN if no moisture load
        if ((state.dataUnitarySystems->HeatingLoad && this->m_NumOfSpeedHeating <= 1) ||
            (state.dataUnitarySystems->CoolingLoad && this->m_NumOfSpeedCooling <= 1)) {
            {
                auto const SELECT_CASE_var(state.dataHeatBalFanSys->TempControlType(this->ControlZoneNum));
                if (SELECT_CASE_var == DataHVACGlobals::SingleHeatingSetPoint) {
                    if (state.dataUnitarySystems->HeatingLoad && SensOutputOn < ZoneLoad) {
                        this->m_HeatingPartLoadFrac = 1.0;
                        this->m_WSHPRuntimeFrac = 1.0;
                        if (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad < LatOutputOn) return;
                    }
                    if (!state.dataUnitarySystems->HeatingLoad &&
                        (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad < LatOutputOn))
                        return;
                } else if (SELECT_CASE_var == DataHVACGlobals::SingleCoolingSetPoint) {
                    if (state.dataUnitarySystems->CoolingLoad && SensOutputOn > ZoneLoad) {
                        this->m_CoolingPartLoadFrac = 1.0;
                        this->m_WSHPRuntimeFrac = 1.0;
                        if (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad < LatOutputOn) return;
                    }
                    if (!state.dataUnitarySystems->CoolingLoad &&
                        (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad < LatOutputOn))
                        return;
                } else if ((SELECT_CASE_var == DataHVACGlobals::SingleHeatCoolSetPoint) ||
                           (SELECT_CASE_var == DataHVACGlobals::DualSetPointWithDeadBand)) {
                    if (state.dataUnitarySystems->HeatingLoad && SensOutputOn < ZoneLoad) {
                        this->m_HeatingPartLoadFrac = 1.0;
                        this->m_WSHPRuntimeFrac = 1.0;
                        if (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad > LatOutputOn) return;
                    }
                    if (state.dataUnitarySystems->CoolingLoad && SensOutputOn > ZoneLoad) {
                        this->m_CoolingPartLoadFrac = 1.0;
                        this->m_WSHPRuntimeFrac = 1.0;
                        return;
                    }
                    if (!state.dataUnitarySystems->HeatingLoad && !state.dataUnitarySystems->CoolingLoad &&
                        (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad < LatOutputOn)) {
                        return;
                    }
                } else {
                    // no other choices for thermostat control
                }
            }
        }
        // will find speed for multispeed coils here and then RegulaFalsi on PLR at a fixed speed

        // Do the non-variable or non-multispeed coils have a NumOfSpeed = 0 ? We don't need to do this for single speed coils.
        // Check to see which speed to meet the load
        this->m_HeatingSpeedNum = 0;
        this->m_CoolingSpeedNum = 0;
        if (!this->m_Staged) {
            if (state.dataUnitarySystems->HeatingLoad) {
                for (SpeedNum = 1; SpeedNum <= this->m_NumOfSpeedHeating; ++SpeedNum) {
                    CoolPLR = 0.0;
                    HeatPLR = 1.0;
                    if (SpeedNum == 1) {
                        this->m_HeatingSpeedRatio = 0.0;
                    } else {
                        this->m_HeatingSpeedRatio = 1.0;
                    }
                    this->m_HeatingCycRatio = 1.0;
                    this->m_HeatingSpeedNum = SpeedNum;
                    this->calcUnitarySystemToLoad(state,
                                                  AirLoopNum,
                                                  FirstHVACIteration,
                                                  CoolPLR,
                                                  HeatPLR,
                                                  OnOffAirFlowRatio,
                                                  SensOutputOn,
                                                  LatOutputOn,
                                                  HXUnitOn,
                                                  HeatCoilLoad,
                                                  SupHeaterLoad,
                                                  CompressorONFlag);
                    if (state.dataGlobal->DoCoilDirectSolutions && this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating) {
                        this->FullOutput[SpeedNum] = SensOutputOn;
                    }
                    if (this->m_HeatingCoilType_Num != DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit &&
                        (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater && !this->m_MultiSpeedHeatingCoil)) {
                        this->m_HeatingSpeedRatio = 0.0;
                        this->m_HeatingSpeedNum = SpeedNum - 1;
                        if (this->m_HeatingSpeedNum == 0) {
                            this->m_HeatingCycRatio = 0.0;
                            HeatPLR = 0.0;
                        } else {
                            this->m_HeatingCycRatio = 1.0;
                            HeatPLR = 1.0;
                        }
                        this->calcUnitarySystemToLoad(state,
                                                      AirLoopNum,
                                                      FirstHVACIteration,
                                                      CoolPLR,
                                                      HeatPLR,
                                                      OnOffAirFlowRatio,
                                                      SensOutputOff,
                                                      LatOutputOff,
                                                      HXUnitOn,
                                                      HeatCoilLoad,
                                                      SupHeaterLoad,
                                                      CompressorONFlag);
                        this->m_HeatingSpeedNum = SpeedNum;
                    }
                    if (ZoneLoad <= SensOutputOn) {
                        break;
                    }
                }
            } else { // Cooling or moisture load
                for (SpeedNum = 1; SpeedNum <= this->m_NumOfSpeedCooling; ++SpeedNum) {
                    CoolPLR = 1.0;
                    HeatPLR = 0.0;
                    if (SpeedNum == 1) {
                        this->m_CoolingSpeedRatio = 0.0;
                    } else {
                        this->m_CoolingSpeedRatio = 1.0;
                    }
                    this->m_CoolingCycRatio = 1.0;
                    this->m_CoolingSpeedNum = SpeedNum;
                    this->calcUnitarySystemToLoad(state,
                                                  AirLoopNum,
                                                  FirstHVACIteration,
                                                  CoolPLR,
                                                  HeatPLR,
                                                  OnOffAirFlowRatio,
                                                  SensOutputOn,
                                                  LatOutputOn,
                                                  HXUnitOn,
                                                  HeatCoilLoad,
                                                  SupHeaterLoad,
                                                  CompressorONFlag);
                    if (state.dataGlobal->DoCoilDirectSolutions &&
                        (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling ||
                         (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling && this->m_NumOfSpeedCooling > 1))) {
                        this->FullOutput[SpeedNum] = SensOutputOn;
                    }
                    // over specified logic? it has to be a water coil? what about other VS coil models?
                    if ((this->m_CoolingCoilType_Num != DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit) &&
                        ((this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
                          this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) &&
                         !this->m_DiscreteSpeedCoolingCoil)) {
                        this->m_CoolingSpeedRatio = 0.0;
                        this->m_CoolingSpeedNum = SpeedNum - 1;
                        if (this->m_CoolingSpeedNum == 0) {
                            this->m_CoolingCycRatio = 0.0;
                            CoolPLR = 0.0;
                        } else {
                            this->m_CoolingCycRatio = 1.0;
                            this->m_CoolingSpeedRatio = 0.0;
                            if (this->m_SingleMode == 1) {
                                CoolPLR = 1.0;
                            }
                        }

                        this->calcUnitarySystemToLoad(state,
                                                      AirLoopNum,
                                                      FirstHVACIteration,
                                                      CoolPLR,
                                                      HeatPLR,
                                                      OnOffAirFlowRatio,
                                                      SensOutputOff,
                                                      LatOutputOff,
                                                      HXUnitOn,
                                                      HeatCoilLoad,
                                                      SupHeaterLoad,
                                                      CompressorONFlag);
                        this->m_CoolingSpeedNum = SpeedNum;
                    }
                    if (ZoneLoad >= SensOutputOn) {
                        break;
                    }
                }
            }
        } else { // IF (.NOT. UnitarySystem(UnitarySysNum)%Staged) THEN
            // Staged control
            if (state.dataUnitarySystems->HeatingLoad) {
                CoolPLR = 0.0;
                HeatPLR = 1.0;
                SpeedNum = this->m_StageNum;
                if (SpeedNum == 1) {
                    this->m_HeatingSpeedRatio = 0.0;
                } else {
                    this->m_HeatingSpeedRatio = 1.0;
                    SpeedNum = min(this->m_StageNum, this->m_NumOfSpeedHeating);
                }
                this->m_HeatingCycRatio = 1.0;
                this->m_HeatingSpeedNum = SpeedNum;
                this->calcUnitarySystemToLoad(state,
                                              AirLoopNum,
                                              FirstHVACIteration,
                                              CoolPLR,
                                              HeatPLR,
                                              OnOffAirFlowRatio,
                                              SensOutputOn,
                                              LatOutputOn,
                                              HXUnitOn,
                                              HeatCoilLoad,
                                              SupHeaterLoad,
                                              CompressorONFlag);
                if (this->m_HeatingCoilType_Num != DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit) {
                    this->m_HeatingSpeedRatio = 0.0;
                    this->m_HeatingSpeedNum = SpeedNum - 1;
                    if (this->m_HeatingSpeedNum == 0) {
                        this->m_HeatingCycRatio = 0.0;
                        HeatPLR = 0.0;
                    } else {
                        this->m_HeatingCycRatio = 1.0;
                        HeatPLR = 1.0;
                    }
                    this->calcUnitarySystemToLoad(state,
                                                  AirLoopNum,
                                                  FirstHVACIteration,
                                                  CoolPLR,
                                                  HeatPLR,
                                                  OnOffAirFlowRatio,
                                                  SensOutputOff,
                                                  LatOutputOff,
                                                  HXUnitOn,
                                                  HeatCoilLoad,
                                                  SupHeaterLoad,
                                                  CompressorONFlag);
                    this->m_HeatingSpeedNum = SpeedNum;
                }
                if (ZoneLoad <= SensOutputOn) {
                    //        EXIT ????????????
                }
            } else { // Cooling or moisture load
                CoolPLR = 1.0;
                HeatPLR = 0.0;
                SpeedNum = std::abs(this->m_StageNum);
                if (SpeedNum == 1) {
                    this->m_CoolingSpeedRatio = 0.0;
                } else {
                    this->m_CoolingSpeedRatio = 1.0;
                    SpeedNum = min(std::abs(this->m_StageNum), this->m_NumOfSpeedCooling);
                }
                this->m_CoolingCycRatio = 1.0;
                this->m_CoolingSpeedNum = SpeedNum;
                this->calcUnitarySystemToLoad(state,
                                              AirLoopNum,
                                              FirstHVACIteration,
                                              CoolPLR,
                                              HeatPLR,
                                              OnOffAirFlowRatio,
                                              SensOutputOn,
                                              LatOutputOn,
                                              HXUnitOn,
                                              HeatCoilLoad,
                                              SupHeaterLoad,
                                              CompressorONFlag);

                if (this->m_CoolingCoilType_Num != DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit) {
                    this->m_CoolingSpeedRatio = 0.0;
                    this->m_CoolingSpeedNum = SpeedNum - 1;
                    if (this->m_CoolingSpeedNum == 0) {
                        this->m_CoolingCycRatio = 0.0;
                        CoolPLR = 0.0;
                    } else {
                        this->m_CoolingCycRatio = 1.0;
                        CoolPLR = 1.0;
                    }
                    this->calcUnitarySystemToLoad(state,
                                                  AirLoopNum,
                                                  FirstHVACIteration,
                                                  CoolPLR,
                                                  HeatPLR,
                                                  OnOffAirFlowRatio,
                                                  SensOutputOff,
                                                  LatOutputOff,
                                                  HXUnitOn,
                                                  HeatCoilLoad,
                                                  SupHeaterLoad,
                                                  CompressorONFlag);
                    this->m_CoolingSpeedNum = SpeedNum;
                }
                if (ZoneLoad >= SensOutputOn) {
                    //        EXIT ???????????
                }
            }
        } // IF (.NOT. UnitarySystem(UnitarySysNum)%Staged) THEN

        FullSensibleOutput = SensOutputOn;

        if (!state.dataUnitarySystems->HeatingLoad && !state.dataUnitarySystems->CoolingLoad &&
            (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad < LatOutputOn)) {
            // if no load, or only a moisture load which can't be met at PLR=1, RETURN
            return;
        }

        // use the ASHRAE 90.1 method of reduced fan speed at low loads
        if (this->m_SimASHRAEModel) {

            // check to make sure unit has the capacity to meet the load
            if ((state.dataUnitarySystems->HeatingLoad && ZoneLoad < SensOutputOn) ||
                (state.dataUnitarySystems->CoolingLoad && ZoneLoad > SensOutputOn)) {
                UnitarySys &SZVAVModel(state.dataUnitarySystems->unitarySys[this->m_UnitarySysNum]);
                SZVAVModel::calcSZVAVModel(state,
                                           SZVAVModel,
                                           this->m_UnitarySysNum,
                                           FirstHVACIteration,
                                           state.dataUnitarySystems->CoolingLoad,
                                           state.dataUnitarySystems->HeatingLoad,
                                           ZoneLoad,
                                           OnOffAirFlowRatio,
                                           HXUnitOn,
                                           AirLoopNum,
                                           PartLoadRatio,
                                           CompressorONFlag);
            }

        } else { // not ASHRAE model

            // must test to see if load is bounded by capacity before calling RegulaFalsi
            if ((state.dataUnitarySystems->HeatingLoad && ZoneLoad < SensOutputOn) ||
                (state.dataUnitarySystems->CoolingLoad && ZoneLoad > SensOutputOn)) {
                if ((state.dataUnitarySystems->HeatingLoad && ZoneLoad > SensOutputOff) ||
                    (state.dataUnitarySystems->CoolingLoad && ZoneLoad < SensOutputOff)) {
                    Real64 SensOutput;
                    Real64 LatOutput;
                    if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling &&
                        state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].SubcoolReheatFlag) {
                        if (state.dataUnitarySystems->CoolingLoad && this->LoadSHR > 0.0) {
                            int CoilInletNode = state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].evapInletNodeIndex;
                            this->CoilSHR = 0.0;
                            Real64 LowSpeedCoilSen;
                            Real64 LowSpeedCoilLat;
                            CoolPLR = 0.0;
                            HeatPLR = 0.0;
                            this->m_CoolingSpeedNum = 1;
                            this->calcUnitarySystemToLoad(state,
                                                          AirLoopNum,
                                                          FirstHVACIteration,
                                                          CoolPLR,
                                                          HeatPLR,
                                                          OnOffAirFlowRatio,
                                                          SensOutputOff,
                                                          LatOutputOff,
                                                          HXUnitOn,
                                                          HeatCoilLoad,
                                                          SupHeaterLoad,
                                                          CompressorONFlag);
                            CoolPLR = 1.0;
                            HeatPLR = 0.0;
                            this->m_CoolingCycRatio = 1.0;
                            this->m_CoolingSpeedRatio = 0.0;
                            // this->m_CoolingSpeedNum = this->m_NumOfSpeedCooling;
                            this->calcUnitarySystemToLoad(state,
                                                          AirLoopNum,
                                                          FirstHVACIteration,
                                                          CoolPLR,
                                                          HeatPLR,
                                                          OnOffAirFlowRatio,
                                                          SensOutputOn,
                                                          LatOutputOn,
                                                          HXUnitOn,
                                                          HeatCoilLoad,
                                                          SupHeaterLoad,
                                                          CompressorONFlag);
                            Real64 ZoneLatLoad = ZoneLoad * (1.0 / this->LoadSHR - 1.0);
                            Real64 SenPLR = (ZoneLoad - SensOutputOff) / (SensOutputOn - SensOutputOff);
                            Real64 LatPLR = (ZoneLatLoad - LatOutputOff) / (LatOutputOn - LatOutputOff);
                            Real64 totalRate = 0.0;
                            Real64 sensRate = 0.0;
                            Real64 latRate = 0.0;
                            CalcComponentSensibleLatentOutput(state.dataLoopNodes->Node(this->AirOutNode).MassFlowRate,
                                                              state.dataLoopNodes->Node(CoilInletNode).Temp,
                                                              state.dataLoopNodes->Node(CoilInletNode).HumRat,
                                                              state.dataLoopNodes->Node(this->AirOutNode).Temp,
                                                              state.dataLoopNodes->Node(this->AirOutNode).HumRat,
                                                              sensRate,
                                                              latRate,
                                                              totalRate);
                            if (LatPLR > 1.0 || LatPLR < 0.0) {
                                this->CoilSHR = this->LoadSHR;
                            } else {
                                Real64 coilSens = sensRate * SenPLR;
                                Real64 coilLat = latRate * LatPLR;
                                this->CoilSHR = coilSens / (coilSens + coilLat);
                            }
                            if (this->m_NumOfSpeedCooling > 1) {
                                this->SpeedSHR[1] = this->CoilSHR;
                                LowSpeedCoilSen = sensRate;
                                LowSpeedCoilLat = latRate;
                                for (SpeedNum = 2; SpeedNum <= this->m_NumOfSpeedCooling; ++SpeedNum) {
                                    this->SpeedSHR[SpeedNum] = this->LoadSHR;
                                }
                            }
                            if (this->CoilSHR < 0.0) {
                                this->CoilSHR = this->LoadSHR;
                            }
                            if (this->m_NumOfSpeedCooling > 1 && ZoneLoad < SensOutputOn) {
                                Real64 SenSPR;
                                Real64 LatSPR;
                                this->FullOutput[1] = SensOutputOn;
                                this->FullLatOutput[1] = LatOutputOn;
                                for (SpeedNum = 2; SpeedNum <= this->m_NumOfSpeedCooling; ++SpeedNum) {
                                    this->CoilSHR = 0.0;
                                    CoolPLR = 1.0;
                                    HeatPLR = 0.0;
                                    this->m_CoolingSpeedRatio = 1.0;
                                    this->m_CoolingCycRatio = 1.0;
                                    this->m_CoolingSpeedNum = SpeedNum;
                                    this->calcUnitarySystemToLoad(state,
                                                                  AirLoopNum,
                                                                  FirstHVACIteration,
                                                                  CoolPLR,
                                                                  HeatPLR,
                                                                  OnOffAirFlowRatio,
                                                                  this->FullOutput[SpeedNum],
                                                                  this->FullLatOutput[SpeedNum],
                                                                  HXUnitOn,
                                                                  HeatCoilLoad,
                                                                  SupHeaterLoad,
                                                                  CompressorONFlag);
                                    CalcComponentSensibleLatentOutput(state.dataLoopNodes->Node(this->AirOutNode).MassFlowRate,
                                                                      state.dataLoopNodes->Node(CoilInletNode).Temp,
                                                                      state.dataLoopNodes->Node(CoilInletNode).HumRat,
                                                                      state.dataLoopNodes->Node(this->AirOutNode).Temp,
                                                                      state.dataLoopNodes->Node(this->AirOutNode).HumRat,
                                                                      sensRate,
                                                                      latRate,
                                                                      totalRate);
                                    SenSPR =
                                        (ZoneLoad - this->FullOutput[SpeedNum - 1]) / (this->FullOutput[SpeedNum] - this->FullOutput[SpeedNum - 1]);
                                    LatSPR = (ZoneLatLoad - this->FullLatOutput[SpeedNum - 1]) /
                                             (this->FullLatOutput[SpeedNum] - this->FullLatOutput[SpeedNum - 1]);
                                    if (LatSPR > 1.0 || LatSPR < 0.0) {
                                        this->CoilSHR = this->LoadSHR;
                                    } else {
                                        Real64 coilSens = sensRate * SenSPR + (1.0 - SenSPR) * LowSpeedCoilSen;
                                        Real64 coilLat = latRate * LatSPR + (1.0 - LatSPR) * LowSpeedCoilLat;
                                        this->CoilSHR = coilSens / (coilSens + coilLat);
                                    }
                                    this->SpeedSHR[SpeedNum] = this->CoilSHR;
                                    LowSpeedCoilSen = sensRate;
                                    LowSpeedCoilLat = latRate;
                                }
                                for (SpeedNum = 1; SpeedNum <= this->m_NumOfSpeedCooling; ++SpeedNum) {
                                    CoolPLR = 1.0;
                                    HeatPLR = 0.0;
                                    if (SpeedNum == 1) {
                                        this->m_CoolingSpeedRatio = 0.0;
                                    } else {
                                        this->m_CoolingSpeedRatio = 1.0;
                                    }
                                    this->m_CoolingCycRatio = 1.0;
                                    this->m_CoolingSpeedNum = SpeedNum;
                                    this->calcUnitarySystemToLoad(state,
                                                                  AirLoopNum,
                                                                  FirstHVACIteration,
                                                                  CoolPLR,
                                                                  HeatPLR,
                                                                  OnOffAirFlowRatio,
                                                                  SensOutputOn,
                                                                  LatOutputOn,
                                                                  HXUnitOn,
                                                                  HeatCoilLoad,
                                                                  SupHeaterLoad,
                                                                  CompressorONFlag);
                                    if (ZoneLoad >= SensOutputOn) {
                                        this->CoilSHR = this->SpeedSHR[SpeedNum];
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (state.dataGlobal->DoCoilDirectSolutions && state.dataUnitarySystems->CoolingLoad &&
                        this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed) {
                        CoolPLR = (ZoneLoad - SensOutputOff) / (SensOutputOn - SensOutputOff);
                        HeatPLR = 0.0;
                        this->calcUnitarySystemToLoad(state,
                                                      AirLoopNum,
                                                      FirstHVACIteration,
                                                      CoolPLR,
                                                      HeatPLR,
                                                      OnOffAirFlowRatio,
                                                      SensOutput,
                                                      LatOutput,
                                                      HXUnitOn,
                                                      HeatCoilLoad,
                                                      SupHeaterLoad,
                                                      CompressorONFlag);
                        PartLoadRatio = CoolPLR;
                    } else if (state.dataGlobal->DoCoilDirectSolutions && state.dataUnitarySystems->CoolingLoad &&
                               this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling && this->m_NumOfSpeedCooling == 1 &&
                               state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].SubcoolReheatFlag) {
                        HeatPLR = 0.0;
                        this->calcUnitarySystemToLoad(state,
                                                      AirLoopNum,
                                                      FirstHVACIteration,
                                                      1.0,
                                                      HeatPLR,
                                                      OnOffAirFlowRatio,
                                                      SensOutputOn,
                                                      LatOutputOn,
                                                      HXUnitOn,
                                                      HeatCoilLoad,
                                                      SupHeaterLoad,
                                                      CompressorONFlag);
                        CoolPLR = (ZoneLoad - SensOutputOff) / (SensOutputOn - SensOutputOff);
                        this->calcUnitarySystemToLoad(state,
                                                      AirLoopNum,
                                                      FirstHVACIteration,
                                                      CoolPLR,
                                                      HeatPLR,
                                                      OnOffAirFlowRatio,
                                                      SensOutput,
                                                      LatOutput,
                                                      HXUnitOn,
                                                      HeatCoilLoad,
                                                      SupHeaterLoad,
                                                      CompressorONFlag);
                        PartLoadRatio = CoolPLR;
                    } else if (state.dataGlobal->DoCoilDirectSolutions && state.dataUnitarySystems->CoolingLoad &&
                               this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling && this->m_NumOfSpeedCooling == 1) {
                        CoolPLR = (ZoneLoad - SensOutputOff) / (SensOutputOn - SensOutputOff);
                        HeatPLR = 0.0;
                        this->calcUnitarySystemToLoad(state,
                                                      AirLoopNum,
                                                      FirstHVACIteration,
                                                      CoolPLR,
                                                      HeatPLR,
                                                      OnOffAirFlowRatio,
                                                      SensOutput,
                                                      LatOutput,
                                                      HXUnitOn,
                                                      HeatCoilLoad,
                                                      SupHeaterLoad,
                                                      CompressorONFlag);
                        PartLoadRatio = CoolPLR;
                    } else if (state.dataGlobal->DoCoilDirectSolutions && state.dataUnitarySystems->HeatingLoad &&
                               (this->m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_HeatingEmpirical ||
                                this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingElectric ||
                                this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingGasOrOtherFuel)) {
                        CoolPLR = 0.0;
                        HeatPLR = (ZoneLoad - SensOutputOff) / (SensOutputOn - SensOutputOff);
                        this->calcUnitarySystemToLoad(state,
                                                      AirLoopNum,
                                                      FirstHVACIteration,
                                                      CoolPLR,
                                                      HeatPLR,
                                                      OnOffAirFlowRatio,
                                                      SensOutput,
                                                      LatOutput,
                                                      HXUnitOn,
                                                      HeatCoilLoad,
                                                      SupHeaterLoad,
                                                      CompressorONFlag);
                        PartLoadRatio = HeatPLR;
                    } else if (state.dataGlobal->DoCoilDirectSolutions && state.dataUnitarySystems->HeatingLoad &&
                               this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating) {
                        CoolPLR = 0.0;
                        if (this->m_HeatingSpeedNum == 1) {
                            this->m_HeatingCycRatio = (ZoneLoad - SensOutputOff) / (this->FullOutput[this->m_HeatingSpeedNum] - SensOutputOff);
                            HeatPLR = this->m_HeatingCycRatio;
                            this->m_HeatingSpeedRatio = 0.0;
                        } else {
                            this->m_HeatingCycRatio = 1.0;
                            this->m_HeatingSpeedRatio = (ZoneLoad - this->FullOutput[this->m_HeatingSpeedNum - 1]) /
                                                        (this->FullOutput[this->m_HeatingSpeedNum] - this->FullOutput[this->m_HeatingSpeedNum - 1]);
                            HeatPLR = this->m_HeatingSpeedRatio;
                        }
                        this->calcUnitarySystemToLoad(state,
                                                      AirLoopNum,
                                                      FirstHVACIteration,
                                                      CoolPLR,
                                                      HeatPLR,
                                                      OnOffAirFlowRatio,
                                                      SensOutput,
                                                      LatOutput,
                                                      HXUnitOn,
                                                      HeatCoilLoad,
                                                      SupHeaterLoad,
                                                      CompressorONFlag);
                        PartLoadRatio = HeatPLR;
                    } else if (state.dataGlobal->DoCoilDirectSolutions && state.dataUnitarySystems->CoolingLoad &&
                               this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling && this->m_NumOfSpeedCooling > 1) {
                        HeatPLR = 0.0;
                        if (this->m_CoolingSpeedNum == 1) {
                            this->m_CoolingCycRatio = (ZoneLoad - SensOutputOff) / (this->FullOutput[this->m_CoolingSpeedNum] - SensOutputOff);
                            CoolPLR = this->m_CoolingCycRatio;
                            this->m_CoolingSpeedRatio = 0.0;
                        } else {
                            this->m_CoolingCycRatio = 1.0;
                            this->m_CoolingSpeedRatio = (ZoneLoad - this->FullOutput[this->m_CoolingSpeedNum - 1]) /
                                                        (this->FullOutput[this->m_CoolingSpeedNum] - this->FullOutput[this->m_CoolingSpeedNum - 1]);
                            CoolPLR = this->m_CoolingSpeedRatio;
                        }
                        this->calcUnitarySystemToLoad(state,
                                                      AirLoopNum,
                                                      FirstHVACIteration,
                                                      CoolPLR,
                                                      HeatPLR,
                                                      OnOffAirFlowRatio,
                                                      SensOutput,
                                                      LatOutput,
                                                      HXUnitOn,
                                                      HeatCoilLoad,
                                                      SupHeaterLoad,
                                                      CompressorONFlag);
                        PartLoadRatio = CoolPLR;
                    } else {

                        Par[1] = double(this->m_UnitarySysNum);
                        Par[2] = 0.0; // FLAG, IF 1.0 then FirstHVACIteration equals TRUE, if 0.0 then FirstHVACIteration equals false
                        if (FirstHVACIteration) Par[2] = 1.0;
                        Par[3] = double(this->m_FanOpMode);
                        Par[4] = CompressorONFlag; // CompOp
                        Par[5] = ZoneLoad;
                        Par[6] = 0.0; // FLAG, 0.0 if heating load, 1.0 IF cooling or moisture load
                        if (state.dataUnitarySystems->CoolingLoad) Par[6] = 1.0;
                        Par[7] = 1.0;               // FLAG, 0.0 if latent load, 1.0 if sensible load to be met
                        Par[8] = OnOffAirFlowRatio; // Ratio of compressor ON mass flow rate to AVERAGE mass flow rate over time step
                        Par[9] = HXUnitOn;          // HXUnitOn turns on or off HX in coil system
                        Par[10] = this->m_HeatingPartLoadFrac;
                        Par[11] = double(AirLoopNum);

                        //     Tolerance is in fraction of load, MaxIter = 30, SolFalg = # of iterations or error as appropriate
                        General::SolveRoot(state, 0.001, MaxIter, SolFlag, PartLoadRatio, &this->calcUnitarySystemLoadResidual, 0.0, 1.0, Par);

                        if (SolFlag == -1) {
                            if (state.dataUnitarySystems->HeatingLoad) {
                                // IF iteration limit is exceeded, find tighter boundary of solution and repeat RegulaFalsi
                                // This does cause a problem when coil cannot turn on when OAT < min allowed or scheduled off
                                // If max iteration limit is exceeded, how do we know if the heating coil is operating?
                                TempMaxPLR = -0.1;
                                TempSensOutput = SensOutputOff;
                                while ((TempSensOutput - ZoneLoad) < 0.0 && TempMaxPLR < 1.0) {
                                    // find upper limit of HeatingPLR
                                    TempMaxPLR += 0.1;

                                    // SUBROUTINE SetSpeedVariables(UnitarySysNum, SensibleLoad, PartLoadRatio)
                                    this->setSpeedVariables(state, true, TempMaxPLR);
                                    this->calcUnitarySystemToLoad(state,
                                                                  AirLoopNum,
                                                                  FirstHVACIteration,
                                                                  CoolPLR,
                                                                  TempMaxPLR,
                                                                  OnOffAirFlowRatio,
                                                                  TempSensOutput,
                                                                  TempLatOutput,
                                                                  HXUnitOn,
                                                                  HeatCoilLoad,
                                                                  SupHeaterLoad,
                                                                  CompressorONFlag);
                                }
                                TempMinPLR = TempMaxPLR;
                                while ((TempSensOutput - ZoneLoad) > 0.0 && TempMinPLR > 0.0) {
                                    // pull upper limit of HeatingPLR down to last valid limit (i.e. heat output still exceeds SystemSensibleLoad)
                                    TempMaxPLR = TempMinPLR;
                                    // find minimum limit of HeatingPLR
                                    TempMinPLR -= 0.01;
                                    this->setSpeedVariables(state, true, TempMinPLR);
                                    this->calcUnitarySystemToLoad(state,
                                                                  AirLoopNum,
                                                                  FirstHVACIteration,
                                                                  CoolPLR,
                                                                  TempMinPLR,
                                                                  OnOffAirFlowRatio,
                                                                  TempSensOutput,
                                                                  TempLatOutput,
                                                                  HXUnitOn,
                                                                  HeatCoilLoad,
                                                                  SupHeaterLoad,
                                                                  CompressorONFlag);
                                }
                                // Now solve again with tighter PLR limits
                                General::SolveRoot(
                                    state, 0.001, MaxIter, SolFlag, HeatPLR, &this->calcUnitarySystemLoadResidual, TempMinPLR, TempMaxPLR, Par);
                                this->calcUnitarySystemToLoad(state,
                                                              AirLoopNum,
                                                              FirstHVACIteration,
                                                              CoolPLR,
                                                              HeatPLR,
                                                              OnOffAirFlowRatio,
                                                              TempSensOutput,
                                                              TempLatOutput,
                                                              HXUnitOn,
                                                              HeatCoilLoad,
                                                              SupHeaterLoad,
                                                              CompressorONFlag);
                            } else if (state.dataUnitarySystems->CoolingLoad) {
                                // RegulaFalsi may not find cooling PLR when the latent degradation model is used.
                                // IF iteration limit is exceeded (SolFlag = -1), find tighter boundary of solution and repeat RegulaFalsi
                                TempMaxPLR = -0.1;
                                TempSysOutput = SensOutputOff;
                                TempLoad = ZoneLoad;
                                while ((TempSysOutput - TempLoad) > 0.0 &&
                                       TempMaxPLR < 0.95) { // avoid PLR > 1 by limiting TempMaxPLR to 1 (i.e., TempMaxPLR += 0.1)
                                    // find upper limit of HeatingPLR
                                    TempMaxPLR += 0.1;
                                    if (TempMaxPLR > 0.95 && TempMaxPLR < 1.05) {
                                        TempMaxPLR = 1.0; // enforce a perfect 1.0 at the top end
                                    }
                                    this->setSpeedVariables(state, true, TempMaxPLR);
                                    this->calcUnitarySystemToLoad(state,
                                                                  AirLoopNum,
                                                                  FirstHVACIteration,
                                                                  TempMaxPLR,
                                                                  HeatPLR,
                                                                  OnOffAirFlowRatio,
                                                                  TempSensOutput,
                                                                  TempLatOutput,
                                                                  HXUnitOn,
                                                                  HeatCoilLoad,
                                                                  SupHeaterLoad,
                                                                  CompressorONFlag);
                                    TempSysOutput = TempSensOutput;
                                }
                                TempMinPLR = TempMaxPLR;
                                while ((TempSysOutput - TempLoad) < 0.0 && TempMinPLR > 0.05) {
                                    // pull upper limit of HeatingPLR down to last valid limit (i.e. heat output still exceeds SystemSensibleLoad)
                                    TempMaxPLR = TempMinPLR;
                                    // find minimum limit of HeatingPLR
                                    TempMinPLR -= 0.01;
                                    this->setSpeedVariables(state, true, TempMinPLR);
                                    this->calcUnitarySystemToLoad(state,
                                                                  AirLoopNum,
                                                                  FirstHVACIteration,
                                                                  TempMinPLR,
                                                                  HeatPLR,
                                                                  OnOffAirFlowRatio,
                                                                  TempSensOutput,
                                                                  TempLatOutput,
                                                                  HXUnitOn,
                                                                  HeatCoilLoad,
                                                                  SupHeaterLoad,
                                                                  CompressorONFlag);
                                    TempSysOutput = TempSensOutput;
                                }
                                // Now solve again with tighter PLR limits
                                General::SolveRoot(
                                    state, 0.001, MaxIter, SolFlag, CoolPLR, &this->calcUnitarySystemLoadResidual, TempMinPLR, TempMaxPLR, Par);
                                this->calcUnitarySystemToLoad(state,
                                                              AirLoopNum,
                                                              FirstHVACIteration,
                                                              CoolPLR,
                                                              HeatPLR,
                                                              OnOffAirFlowRatio,
                                                              TempSensOutput,
                                                              TempLatOutput,
                                                              HXUnitOn,
                                                              HeatCoilLoad,
                                                              SupHeaterLoad,
                                                              CompressorONFlag);
                            } // IF(HeatingLoad)THEN
                            if (SolFlag == -1) {
                                if (std::abs(ZoneLoad - TempSensOutput) > DataHVACGlobals::SmallLoad) {
                                    if (this->MaxIterIndex == 0) {
                                        ShowWarningMessage(state, "Coil control failed to converge for " + this->UnitType + ':' + this->Name);
                                        ShowContinueError(state, "  Iteration limit exceeded in calculating system sensible part-load ratio.");
                                        ShowContinueErrorTimeStamp(state,
                                                                   format("Sensible load to be met = {:.2T} (watts), sensible output = {:.2T} "
                                                                          "(watts), and the simulation continues.",
                                                                          ZoneLoad,
                                                                          TempSensOutput));
                                    }
                                    ShowRecurringWarningErrorAtEnd(state,
                                                                   this->UnitType + " \"" + this->Name +
                                                                       "\" - Iteration limit exceeded in calculating sensible part-load ratio error "
                                                                       "continues. Sensible load statistics:",
                                                                   this->MaxIterIndex,
                                                                   ZoneLoad,
                                                                   ZoneLoad);
                                }
                            } else if (SolFlag == -2) {
                                if (this->RegulaFalsiFailedIndex == 0) {
                                    ShowWarningMessage(state, "Coil control failed for " + this->UnitType + ':' + this->Name);
                                    ShowContinueError(state, "  sensible part-load ratio determined to be outside the range of 0-1.");
                                    ShowContinueErrorTimeStamp(
                                        state, format("Sensible load to be met = {:.2T} (watts), and the simulation continues.", ZoneLoad));
                                }
                                ShowRecurringWarningErrorAtEnd(
                                    state,
                                    this->UnitType + " \"" + this->Name +
                                        "\" - sensible part-load ratio out of range error continues. Sensible load statistics:",
                                    this->RegulaFalsiFailedIndex,
                                    ZoneLoad,
                                    ZoneLoad);
                            }
                        } else if (SolFlag == -2) {
                            if (this->RegulaFalsiFailedIndex == 0) {
                                ShowWarningMessage(state, "Coil control failed for " + this->UnitType + ':' + this->Name);
                                ShowContinueError(state, "  sensible part-load ratio determined to be outside the range of 0-1.");
                                ShowContinueErrorTimeStamp(
                                    state, format("Sensible load to be met = {:.2T} (watts), and the simulation continues.", ZoneLoad));
                            }
                            ShowRecurringWarningErrorAtEnd(
                                state,
                                this->UnitType + " \"" + this->Name +
                                    "\" - sensible part-load ratio out of range error continues. Sensible load statistics:",
                                this->RegulaFalsiFailedIndex,
                                ZoneLoad,
                                ZoneLoad);
                        } // IF (SolFlag == -1) THEN
                    }
                } else { // load is not bounded by capacity. Leave PLR=1 or turn off unit?
                    this->m_CoolingPartLoadFrac = 0.0;
                    this->m_HeatingPartLoadFrac = 0.0;
                    CoolPLR = 0.0;
                    HeatPLR = 0.0;
                    PartLoadRatio = 0.0;
                } // IF((HeatingLoad .AND. ZoneLoad > SensOutputOff) .OR. (CoolingLoad .AND. ZoneLoad < SensOutputOff))THEN
            }     // IF((HeatingLoad .AND. ZoneLoad < SensOutputOn) .OR. (CoolingLoad .AND. ZoneLoad > SensOutputOn))THEN
        }

        if (state.dataUnitarySystems->HeatingLoad && (this->m_MultiSpeedHeatingCoil || this->m_VarSpeedHeatingCoil)) {
            if (this->m_HeatingSpeedNum == 1) {
                this->m_HeatingCycRatio = PartLoadRatio;
                this->m_HeatingSpeedRatio = 0.0;
            } else {
                if (this->m_SingleMode == 0) {
                    this->m_HeatingCycRatio = 1.0;
                    this->m_HeatingSpeedRatio = PartLoadRatio;
                } else {
                    this->m_HeatingCycRatio = PartLoadRatio;
                    this->m_HeatingSpeedRatio = 1.0;
                }
            }
            HeatPLR = PartLoadRatio;
            CoolPLR = 0.0;
            this->m_CoolingCycRatio = 0.0;
            this->m_CoolingSpeedRatio = 0.0;
        } else if (state.dataUnitarySystems->CoolingLoad && (this->m_DiscreteSpeedCoolingCoil || this->m_ContSpeedCoolingCoil)) {
            if (this->m_CoolingSpeedNum == 1) {
                this->m_CoolingCycRatio = PartLoadRatio;
                this->m_CoolingSpeedRatio = 0.0;
            } else {
                if (this->m_SingleMode == 0) {
                    this->m_CoolingCycRatio = 1.0;
                    this->m_CoolingSpeedRatio = PartLoadRatio;
                } else {
                    this->m_CoolingCycRatio = PartLoadRatio;
                    this->m_CoolingSpeedRatio = 1.0;
                }
            }
            this->m_HeatingCycRatio = 0.0;
            this->m_HeatingSpeedRatio = 0.0;
            HeatPLR = 0.0;
            CoolPLR = PartLoadRatio;
        } else {
            HeatPLR = this->m_HeatingPartLoadFrac;
            CoolPLR = this->m_CoolingPartLoadFrac;
        }

        this->calcUnitarySystemToLoad(state,
                                      AirLoopNum,
                                      FirstHVACIteration,
                                      CoolPLR,
                                      HeatPLR,
                                      OnOffAirFlowRatio,
                                      TempSensOutput,
                                      TempLatOutput,
                                      HXUnitOn,
                                      HeatCoilLoad,
                                      SupHeaterLoad,
                                      CompressorONFlag);

        // FullSensibleOutput is used to set supplemental heater PLR in calling routine
        // OnOffAirFlowRatio is used to average air flow between ON and OFF state
        FullSensibleOutput = TempSensOutput;
        LatOutputOn = TempLatOutput;

        // RETURN if the moisture load is met
        if (state.dataUnitarySystems->MoistureLoad >= 0.0 || state.dataUnitarySystems->MoistureLoad >= TempLatOutput) return;
        // Multimode does not meet the latent load, only the sensible load with or without HX active
        // what if there is a heating load for a system using Multimode?
        if (!state.dataUnitarySystems->CoolingLoad && this->m_DehumidControlType_Num == DehumCtrlType::Multimode) return;
        // if HX was previously turned on return since sensible load is already met
        if (state.dataUnitarySystems->CoolingLoad && this->m_DehumidControlType_Num == DehumCtrlType::Multimode && HXUnitOn) return;
        //  IF(HeatingLoad .AND. UnitarySystem(UnitarySysNum)%m_DehumidControlType_Num .EQ. dehumidm_ControlType::CoolReheat)RETURN

        if ((this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat || this->m_DehumidControlType_Num == DehumCtrlType::Multimode)) {

            // find maximum latent output IF not already calculated
            if (state.dataUnitarySystems->HeatingLoad) {
                CoolPLR = 1.0;
                this->m_CoolingPartLoadFrac = 1.0;
                this->m_CoolingSpeedNum = this->m_NumOfSpeedCooling;
                this->m_CoolingSpeedRatio = 1.0;
                this->m_CoolingCycRatio = 1.0;
                this->m_WSHPRuntimeFrac = CoolPLR;
                if (this->m_CoolingSpeedNum > 0) {
                    this->m_HeatingPartLoadFrac = 0.0;
                    this->m_HeatingSpeedNum = 0;
                    HeatPLR = 0.0;
                    state.dataUnitarySystems->CoolingLoad = true;
                    state.dataUnitarySystems->HeatingLoad = false;
                    this->m_HeatingCoilSensDemand = 0.0;
                    this->m_CoolingCoilLatentDemand = state.dataUnitarySystems->MoistureLoad;
                    this->calcUnitarySystemToLoad(state,
                                                  AirLoopNum,
                                                  FirstHVACIteration,
                                                  0.0,
                                                  0.0,
                                                  OnOffAirFlowRatio,
                                                  TempSensOutput,
                                                  TempLatOutput,
                                                  HXUnitOn,
                                                  HeatCoilLoad,
                                                  SupHeaterLoad,
                                                  CompressorONFlag);
                    this->calcUnitarySystemToLoad(state,
                                                  AirLoopNum,
                                                  FirstHVACIteration,
                                                  CoolPLR,
                                                  HeatPLR,
                                                  OnOffAirFlowRatio,
                                                  TempSensOutput,
                                                  LatOutputOn,
                                                  HXUnitOn,
                                                  HeatCoilLoad,
                                                  SupHeaterLoad,
                                                  CompressorONFlag);
                } else {
                    this->m_HeatingCoilSensDemand = 0.0;
                    this->m_CoolingCoilLatentDemand = 0.0;
                    this->calcUnitarySystemToLoad(state,
                                                  AirLoopNum,
                                                  FirstHVACIteration,
                                                  0.0,
                                                  0.0,
                                                  OnOffAirFlowRatio,
                                                  TempSensOutput,
                                                  TempLatOutput,
                                                  HXUnitOn,
                                                  HeatCoilLoad,
                                                  SupHeaterLoad,
                                                  CompressorONFlag);
                    this->m_CoolingCoilLatentDemand = state.dataUnitarySystems->MoistureLoad;
                    this->calcUnitarySystemToLoad(state,
                                                  AirLoopNum,
                                                  FirstHVACIteration,
                                                  CoolPLR,
                                                  HeatPLR,
                                                  OnOffAirFlowRatio,
                                                  TempSensOutput,
                                                  LatOutputOn,
                                                  HXUnitOn,
                                                  HeatCoilLoad,
                                                  SupHeaterLoad,
                                                  CompressorONFlag);
                }
            }

            if (this->m_DehumidControlType_Num == DehumCtrlType::Multimode && state.dataUnitarySystems->MoistureLoad < LatOutputOn) {
                HXUnitOn = true;
                CoolPLR = 1.0;
                this->m_CoolingPartLoadFrac = 1.0;
                this->calcUnitarySystemToLoad(state,
                                              AirLoopNum,
                                              FirstHVACIteration,
                                              CoolPLR,
                                              HeatPLR,
                                              OnOffAirFlowRatio,
                                              TempSensOutput,
                                              LatOutputOn,
                                              HXUnitOn,
                                              HeatCoilLoad,
                                              SupHeaterLoad,
                                              CompressorONFlag);
                FullSensibleOutput = TempSensOutput;
            }

            if (state.dataUnitarySystems->MoistureLoad < LatOutputOn && this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat) {
                HXUnitOn = true; // HX is needed to meet moisture load
                if (this->m_NumOfSpeedCooling > 0) {
                    for (SpeedNum = this->m_CoolingSpeedNum; SpeedNum <= this->m_NumOfSpeedCooling; ++SpeedNum) {
                        CoolPLR = 1.0;
                        this->m_CoolingPartLoadFrac = CoolPLR;
                        this->m_CoolingSpeedRatio = 1.0;
                        this->m_CoolingCycRatio = 1.0;
                        this->m_CoolingSpeedNum = SpeedNum;
                        this->calcUnitarySystemToLoad(state,
                                                      AirLoopNum,
                                                      FirstHVACIteration,
                                                      CoolPLR,
                                                      HeatPLR,
                                                      OnOffAirFlowRatio,
                                                      SensOutputOn,
                                                      LatOutputOn,
                                                      HXUnitOn,
                                                      HeatCoilLoad,
                                                      SupHeaterLoad,
                                                      CompressorONFlag);
                        if (state.dataGlobal->DoCoilDirectSolutions && this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling) {
                            this->FullOutput[SpeedNum] = SensOutputOn;
                        }
                        // over specified logic? it has to be a water coil? what about other VS coil models?
                        if ((this->m_CoolingCoilType_Num != DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit) &&
                            ((this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
                              this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) &&
                             !this->m_DiscreteSpeedCoolingCoil)) {
                            this->m_CoolingSpeedRatio = 0.0;
                            this->m_CoolingSpeedNum = SpeedNum - 1;
                            if (this->m_CoolingSpeedNum == 0) {
                                this->m_CoolingCycRatio = 0.0;
                                CoolPLR = 0.0;
                            } else {
                                this->m_CoolingCycRatio = 1.0;
                                this->m_CoolingSpeedRatio = 0.0;
                                if (this->m_SingleMode == 1) {
                                    CoolPLR = 1.0;
                                }
                            }

                            this->calcUnitarySystemToLoad(state,
                                                          AirLoopNum,
                                                          FirstHVACIteration,
                                                          CoolPLR,
                                                          HeatPLR,
                                                          OnOffAirFlowRatio,
                                                          SensOutputOn,
                                                          LatOutputOn,
                                                          HXUnitOn,
                                                          HeatCoilLoad,
                                                          SupHeaterLoad,
                                                          CompressorONFlag);
                            this->m_CoolingSpeedNum = SpeedNum;
                        }
                        if (state.dataUnitarySystems->MoistureLoad >= LatOutputOn) {
                            break;
                        }
                    }
                } else {
                    CoolPLR = 1.0;
                    this->calcUnitarySystemToLoad(state,
                                                  AirLoopNum,
                                                  FirstHVACIteration,
                                                  CoolPLR,
                                                  HeatPLR,
                                                  OnOffAirFlowRatio,
                                                  SensOutputOn,
                                                  LatOutputOn,
                                                  HXUnitOn,
                                                  HeatCoilLoad,
                                                  SupHeaterLoad,
                                                  CompressorONFlag);
                    this->m_CoolingPartLoadFrac = CoolPLR;
                }
            }

            //    IF ((HeatingLoad .AND. MoistureLoad < TempLatOutput) .OR. &
            //        (CoolingLoad .AND. MoistureLoad < TempLatOutput .AND. MoistureLoad > LatOutputOn) .OR. &
            //        ((.NOT. HeatingLoad) .AND. (.NOT. CoolingLoad) .AND. MoistureLoad > LatOutputOn)) THEN
            if ((state.dataUnitarySystems->MoistureLoad < TempLatOutput) &&
                (state.dataUnitarySystems->MoistureLoad > LatOutputOn)) { // bounds check for RegulaFalsi

                // save heating PLR
                HeatPLR = this->m_HeatingPartLoadFrac;
                Par[1] = double(this->m_UnitarySysNum);
                Par[2] = 0.0; // FLAG, if 1.0 then FirstHVACIteration equals TRUE, if 0.0 then FirstHVACIteration equals false
                if (FirstHVACIteration) Par[2] = 1.0;
                Par[3] = double(this->m_FanOpMode);
                Par[4] = CompressorONFlag; // CompOp
                if (this->m_DehumidControlType_Num == DehumCtrlType::Multimode) {
                    Par[5] = ZoneLoad;
                    Par[7] = 1.0; // FLAG, 0.0 if latent load, 1.0 if sensible load to be met
                } else {
                    Par[5] = state.dataUnitarySystems->MoistureLoad;
                    Par[7] = 0.0; // FLAG, 0.0 if latent load, 1.0 if sensible load to be met
                }
                Par[6] = 1.0; // FLAG, 0.0 if heating load, 1.0 if cooling or moisture load
                //      IF(HeatingLoad)Par(6)  = 0.0d0
                Par[8] = OnOffAirFlowRatio; // Ratio of compressor ON mass flow rate to AVERAGE mass flow rate over time step
                if (HXUnitOn) {
                    Par[9] = 1.0;
                } else {
                    Par[9] = 0.0;
                }
                Par[10] = this->m_HeatingPartLoadFrac;
                Par[11] = double(AirLoopNum);
                // Tolerance is fraction of load, MaxIter = 30, SolFalg = # of iterations or error as appropriate
                General::SolveRoot(state, 0.001, MaxIter, SolFlagLat, PartLoadRatio, this->calcUnitarySystemLoadResidual, 0.0, 1.0, Par);
                this->m_CoolingPartLoadFrac = PartLoadRatio;
                this->m_HeatingPartLoadFrac = HeatPLR;
            } else if (state.dataUnitarySystems->MoistureLoad < LatOutputOn && state.dataUnitarySystems->CoolingLoad) {
                //     Logic below needs further look...what to do if the bounds check for RegulaFalsi fail?
                //     I'm not even sure if this should be done.
                //     It's wrong anyway, since there won't be a cooling load if multimode (see RETURN about 80 lines up).
                if (this->m_DehumidControlType_Num != DehumCtrlType::Multimode) {
                    this->m_CoolingPartLoadFrac = 1.0;
                }
            }
        }

        CoolPLR = this->m_CoolingPartLoadFrac;
        HeatPLR = this->m_HeatingPartLoadFrac;

        this->calcUnitarySystemToLoad(state,
                                      AirLoopNum,
                                      FirstHVACIteration,
                                      CoolPLR,
                                      HeatPLR,
                                      OnOffAirFlowRatio,
                                      TempSensOutput,
                                      TempLatOutput,
                                      HXUnitOn,
                                      HeatCoilLoad,
                                      SupHeaterLoad,
                                      CompressorONFlag);

        if (SolFlagLat == -1) {
            // RegulaFalsi may not find cooling PLR when the latent degradation model is used.
            // IF iteration limit is exceeded, find tighter boundary of solution and repeat RegulaFalsi
            TempMaxPLR = -0.1;
            TempLatOutput = LatOutputOff;
            while ((TempLatOutput - state.dataUnitarySystems->MoistureLoad) > 0.0 && TempMaxPLR < 1.0) {
                // find upper limit of HeatingPLR
                TempMaxPLR += 0.1;
                this->calcUnitarySystemToLoad(state,
                                              AirLoopNum,
                                              FirstHVACIteration,
                                              TempMaxPLR,
                                              HeatPLR,
                                              OnOffAirFlowRatio,
                                              TempSensOutput,
                                              TempLatOutput,
                                              HXUnitOn,
                                              HeatCoilLoad,
                                              SupHeaterLoad,
                                              CompressorONFlag);
            }
            TempMinPLR = TempMaxPLR;
            while ((TempLatOutput - state.dataUnitarySystems->MoistureLoad) < 0.0 && TempMinPLR > 0.0) {
                // pull upper limit of HeatingPLR DOwn to last valid limit (i.e. heat output still exceeds SystemSensibleLoad)
                TempMaxPLR = TempMinPLR;
                // find minimum limit of HeatingPLR
                TempMinPLR -= 0.01;
                this->calcUnitarySystemToLoad(state,
                                              AirLoopNum,
                                              FirstHVACIteration,
                                              TempMinPLR,
                                              HeatPLR,
                                              OnOffAirFlowRatio,
                                              TempSensOutput,
                                              TempLatOutput,
                                              HXUnitOn,
                                              HeatCoilLoad,
                                              SupHeaterLoad,
                                              CompressorONFlag);
            }
            // Now solve again with tighter PLR limits
            General::SolveRoot(state, 0.001, MaxIter, SolFlagLat, CoolPLR, &this->calcUnitarySystemLoadResidual, TempMinPLR, TempMaxPLR, Par);
            this->calcUnitarySystemToLoad(state,
                                          AirLoopNum,
                                          FirstHVACIteration,
                                          CoolPLR,
                                          HeatPLR,
                                          OnOffAirFlowRatio,
                                          TempSensOutput,
                                          TempLatOutput,
                                          HXUnitOn,
                                          HeatCoilLoad,
                                          SupHeaterLoad,
                                          CompressorONFlag);
            if (SolFlagLat == -1) {
                if (std::abs(state.dataUnitarySystems->MoistureLoad - TempLatOutput) > DataHVACGlobals::SmallLoad) {
                    if (this->warnIndex.m_LatMaxIterIndex == 0) {
                        ShowWarningMessage(state, "Coil control failed to converge for " + this->UnitType + ':' + this->Name);
                        ShowContinueError(state, "  Iteration limit exceeded in calculating system Latent part-load ratio.");
                        ShowContinueErrorTimeStamp(
                            state,
                            format("Latent load to be met = {:.2T} (watts), Latent output = {:.2T} (watts), and the simulation continues.",
                                   state.dataUnitarySystems->MoistureLoad,
                                   TempLatOutput));
                    }
                    ShowRecurringWarningErrorAtEnd(
                        state,
                        this->UnitType + " \"" + this->Name +
                            "\" - Iteration limit exceeded in calculating Latent part-load ratio error continues. Latent load statistics:",
                        this->warnIndex.m_LatMaxIterIndex,
                        state.dataUnitarySystems->MoistureLoad,
                        state.dataUnitarySystems->MoistureLoad);
                }
            } else if (SolFlagLat == -2) {
                if (this->warnIndex.m_LatRegulaFalsiFailedIndex == 0) {
                    ShowWarningMessage(state, "Coil control failed for " + this->UnitType + ':' + this->Name);
                    ShowContinueError(state, "  Latent part-load ratio determined to be outside the range of 0-1.");
                    ShowContinueErrorTimeStamp(
                        state,
                        format("Latent load to be met = {:.2T} (watts), and the simulation continues.", state.dataUnitarySystems->MoistureLoad));
                }
                ShowRecurringWarningErrorAtEnd(state,
                                               this->UnitType + " \"" + this->Name +
                                                   "\" - Latent part-load ratio out of range error continues. Latent load statistics:",
                                               this->warnIndex.m_LatRegulaFalsiFailedIndex,
                                               state.dataUnitarySystems->MoistureLoad,
                                               state.dataUnitarySystems->MoistureLoad);
            }
        } else if (SolFlagLat == -2) {
            if (this->warnIndex.m_LatRegulaFalsiFailedIndex == 0) {
                ShowWarningMessage(state, "Coil control failed for " + this->UnitType + ':' + this->Name);
                ShowContinueError(state, "  Latent part-load ratio determined to be outside the range of 0-1.");
                ShowContinueErrorTimeStamp(
                    state, format("Latent load to be met = {:.2T} (watts), and the simulation continues.", state.dataUnitarySystems->MoistureLoad));
            }
            ShowRecurringWarningErrorAtEnd(state,
                                           this->UnitType + " \"" + this->Name +
                                               "\" - Latent part-load ratio out of range error continues. Latent load statistics:",
                                           this->warnIndex.m_LatRegulaFalsiFailedIndex,
                                           state.dataUnitarySystems->MoistureLoad,
                                           state.dataUnitarySystems->MoistureLoad);
        }

        FullSensibleOutput = TempSensOutput;

        CpAir = Psychrometrics::PsyCpAirFnW(state.dataLoopNodes->Node(this->CoolCoilInletNodeNum).HumRat);
        CoolingOnlySensibleOutput =
            state.dataLoopNodes->Node(this->CoolCoilInletNodeNum).MassFlowRate * CpAir *
            ((state.dataLoopNodes->Node(this->NodeNumOfControlledZone).Temp - state.dataLoopNodes->Node(this->CoolCoilOutletNodeNum).Temp) -
             (state.dataLoopNodes->Node(this->HeatCoilOutletNodeNum).Temp - state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).Temp));
        if (state.dataUnitarySystems->QToHeatSetPt < 0.0) {
            //   Calculate the reheat coil load wrt the heating setpoint temperature. Reheat coil picks up
            //   the entire excess sensible cooling (DX cooling coil and impact of outdoor air).
            this->m_DehumidInducedHeatingDemandRate = max(0.0, (CoolingOnlySensibleOutput + state.dataUnitarySystems->QToHeatSetPt));
            //   Heating mode and dehumidification is required
        } else if (state.dataUnitarySystems->QToHeatSetPt >= 0.0) {
            //   Calculate the reheat coil load as the sensible capacity of the DX cooling coil only. Let
            //   the heating coil pick up the load due to outdoor air.
            this->m_DehumidInducedHeatingDemandRate = max(0.0, CoolingOnlySensibleOutput);
        }
    }

    void UnitarySys::initLoadBasedControl(EnergyPlusData &state,
                                          int const AirLoopNum, // number of the current air loop being simulated
                                          bool const FirstHVACIteration,
                                          Real64 &OnOffAirFlowRatio,
                                          Real64 &ZoneLoad)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine is for initializations of the load controlled Unitary Systems.

        // METHODOLOGY EMPLOYED:
        // Initialize mass flow rates and speed ratios. Calculate loads and adjust if necessary when using constant fan.

        // SUBROUTINE PARAMETER DEFINITIONS:
        static constexpr std::string_view routineName("InitUnitarySystems");

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        // static Array1D_bool MyEnvrnFlag; // environment flag
        // static Array1D_bool MyFanFlag;   // used for sizing fan inputs one time
        // static Array1D_bool MyCheckFlag; // Used to obtain the zone inlet node number
        // in the controlled zone
        // static Array1D_bool MyStagedFlag; // used for finding on m_Staged thermostat
        //////////// hoisted into namespace ////////////////////////////////////////////////
        // static bool MyOneTimeFlag( true ); // one time allocation flag // InitLoadBasedControlOneTimeFlag
        // static bool MyAirLoopPass( true ); // one time allocation flag // InitLoadBasedControlAirLoopPass
        // static int AirLoopPass( 0 ); // Number of air loop pass // AirLoopPassCounter
        // static bool FlowFracFlagReady( true ); // one time flag for calculating flow fraction // InitLoadBasedControlFlowFracFlagReady
        // static Real64 CntrlZoneTerminalUnitMassFlowRateMax( 0.0 ); // Maximum mass flow rate through controlled zone //
        // InitLoadBasedControlCntrlZoneTerminalUnitMassFlowRateMax
        ////////////////////////////////////////////////////////////////////////////////////
        // inlet node and system outlet node
        Real64 QZnReq = 0.0;
        Real64 QActual = 0.0;
        Real64 SensOutputOff = 0.0;
        Real64 LatOutputOff = 0.0;
        Real64 HeatCoilLoad = 0.0;
        Real64 SupHeaterLoad = 0.0;
        int CompOn = 0;

        // if (initLoadBasedControlOneTimeFlag) {

        //    // initialize the environment and sizing flags
        //    MyEnvrnFlag.allocate(NumUnitarySystem);
        //    MyFanFlag.allocate(NumUnitarySystem);
        //    MyCheckFlag.allocate(NumUnitarySystem);
        //    MyStagedFlag.allocate(NumUnitarySystem);

        //    MyEnvrnFlag = true;
        //    MyFanFlag = true;
        //    MyCheckFlag = true;
        //    InitLoadBasedControlOneTimeFlag = false;
        //    MyStagedFlag = true;
        //}

        // error flag for mining functions
        bool errorsFound = false;

        // do the Begin Environment initializations
        if (state.dataGlobal->BeginEnvrnFlag && this->m_MyEnvrnFlag2) {

            // set fluid-side hardware limits
            if (this->HeatCoilFluidInletNode > 0) {

                if (this->MaxHeatCoilFluidFlow == DataSizing::AutoSize) {
                    // IF water coil max water flow rate is DataSizing::AutoSized, simulate once in order to mine max flow rate
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
                        WaterCoils::SimulateWaterCoilComponents(state, this->m_HeatingCoilName, FirstHVACIteration, this->m_HeatingCoilIndex);
                        Real64 CoilMaxVolFlowRate =
                            WaterCoils::GetCoilMaxWaterFlowRate(state, "Coil:Heating:Water", this->m_HeatingCoilName, errorsFound);
                        if (CoilMaxVolFlowRate != DataSizing::AutoSize) {
                            Real64 rho = FluidProperties::GetDensityGlycol(state,
                                                                           state.dataPlnt->PlantLoop(this->HeatCoilLoopNum).FluidName,
                                                                           DataGlobalConstants::CWInitConvTemp,
                                                                           state.dataPlnt->PlantLoop(this->HeatCoilLoopNum).FluidIndex,
                                                                           routineName);
                            this->MaxHeatCoilFluidFlow = CoilMaxVolFlowRate * rho;
                        }
                    }
                    // IF steam coil max steam flow rate is DataSizing::AutoSized, simulate once in order to mine max flow rate
                    if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {
                        SteamCoils::SimulateSteamCoilComponents(state,
                                                                this->m_HeatingCoilName,
                                                                FirstHVACIteration,
                                                                this->m_HeatingCoilIndex,
                                                                1.0,
                                                                QActual); // QCoilReq, simulate any load > 0 to get max capacity
                        Real64 CoilMaxVolFlowRate = SteamCoils::GetCoilMaxSteamFlowRate(state, this->m_HeatingCoilIndex, errorsFound);
                        if (CoilMaxVolFlowRate != DataSizing::AutoSize) {
                            int SteamIndex = 0; // Function GetSatDensityRefrig will look up steam index if 0 is passed
                            Real64 TempSteamIn = 100.0;
                            Real64 SteamDensity =
                                FluidProperties::GetSatDensityRefrig(state, fluidNameSteam, TempSteamIn, 1.0, SteamIndex, routineName);
                            this->MaxHeatCoilFluidFlow = CoilMaxVolFlowRate * SteamDensity;
                        }
                    }
                }

                PlantUtilities::InitComponentNodes(state,
                                                   0.0,
                                                   this->MaxHeatCoilFluidFlow,
                                                   this->HeatCoilFluidInletNode,
                                                   this->HeatCoilFluidOutletNodeNum,
                                                   this->HeatCoilLoopNum,
                                                   this->HeatCoilLoopSide,
                                                   this->HeatCoilBranchNum,
                                                   this->HeatCoilCompNum);
            }
            if (this->m_SuppCoilFluidInletNode > 0) {
                if (this->m_MaxSuppCoilFluidFlow == DataSizing::AutoSize) {
                    if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingWater) {
                        // IF water coil max water flow rate is DataSizing::AutoSized, simulate once in order to mine max flow rate
                        WaterCoils::SimulateWaterCoilComponents(state, this->m_SuppHeatCoilName, FirstHVACIteration, this->m_SuppHeatCoilIndex);
                        Real64 CoilMaxVolFlowRate =
                            WaterCoils::GetCoilMaxWaterFlowRate(state, "Coil:Heating:Water", this->m_SuppHeatCoilName, errorsFound);
                        if (CoilMaxVolFlowRate != DataSizing::AutoSize) {
                            Real64 rho = FluidProperties::GetDensityGlycol(state,
                                                                           state.dataPlnt->PlantLoop(this->m_SuppCoilLoopNum).FluidName,
                                                                           DataGlobalConstants::CWInitConvTemp,
                                                                           state.dataPlnt->PlantLoop(this->m_SuppCoilLoopNum).FluidIndex,
                                                                           routineName);
                            this->m_MaxSuppCoilFluidFlow = CoilMaxVolFlowRate * rho;
                        }
                    }
                    if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {
                        SteamCoils::SimulateSteamCoilComponents(state,
                                                                this->m_SuppHeatCoilName,
                                                                FirstHVACIteration,
                                                                this->m_SuppHeatCoilIndex,
                                                                1.0,
                                                                QActual); // QCoilReq, simulate any load > 0 to get max capacity
                        Real64 CoilMaxVolFlowRate = SteamCoils::GetCoilMaxSteamFlowRate(state, this->m_SuppHeatCoilIndex, errorsFound);
                        if (CoilMaxVolFlowRate != DataSizing::AutoSize) {
                            int SteamIndex = 0; // Function GetSatDensityRefrig will look up steam index if 0 is passed
                            Real64 TempSteamIn = 100.0;
                            Real64 SteamDensity =
                                FluidProperties::GetSatDensityRefrig(state, fluidNameSteam, TempSteamIn, 1.0, SteamIndex, routineName);
                            this->m_MaxSuppCoilFluidFlow = CoilMaxVolFlowRate * SteamDensity;
                        }
                    }
                    PlantUtilities::InitComponentNodes(state,
                                                       0.0,
                                                       this->m_MaxSuppCoilFluidFlow,
                                                       this->m_SuppCoilFluidInletNode,
                                                       this->m_SuppCoilFluidOutletNodeNum,
                                                       this->m_SuppCoilLoopNum,
                                                       this->m_SuppCoilLoopSide,
                                                       this->m_SuppCoilBranchNum,
                                                       this->m_SuppCoilCompNum);
                }
            }
            this->m_MyEnvrnFlag2 = false;
        }

        if (allocated(state.dataZoneEquip->ZoneEquipConfig) && this->m_MyCheckFlag) {
            if (this->m_AirLoopEquipment) {
                int zoneNum = state.dataHeatBal->Zone(this->ControlZoneNum).ZoneEqNum;
                int zoneInlet = this->m_ZoneInletNode;
                if (zoneInlet == 0) {
                    this->m_ThisSysInputShouldBeGotten = true; // need to find zone inlet node once data is available
                    this->m_MySizingCheckFlag = true;          // need to resize after getInput is read in again
                    this->m_OKToPrintSizing = true;            // hope first time back through finds the data, else multiple prints to the eio
                    this->m_airLoopReturnCounter += 1;
                    if (this->m_airLoopReturnCounter < 3) return;
                }
                int coolingPriority = 0;
                int heatingPriority = 0;
                // setup zone equipment sequence information based on finding matching air terminal
                if (state.dataZoneEquip->ZoneEquipConfig(zoneNum).EquipListIndex > 0) {
                    state.dataZoneEquip->ZoneEquipList(state.dataZoneEquip->ZoneEquipConfig(zoneNum).EquipListIndex)
                        .getPrioritiesForInletNode(state, zoneInlet, coolingPriority, heatingPriority);
                    this->m_ZoneSequenceCoolingNum = coolingPriority;
                    this->m_ZoneSequenceHeatingNum = heatingPriority;
                }
                this->m_MyCheckFlag = false;
                if (this->m_ZoneSequenceCoolingNum == 0 || this->m_ZoneSequenceHeatingNum == 0) {
                    ShowSevereError(state,
                                    this->UnitType + " \"" + this->Name + "\": Airloop air terminal in the zone equipment list for zone = " +
                                        state.dataHeatBal->Zone(this->ControlZoneNum).Name +
                                        " not found or is not allowed Zone Equipment Cooling or Heating Sequence = 0.");
                    ShowFatalError(state,
                                   "Subroutine InitLoadBasedControl: Errors found in getting " + this->UnitType +
                                       " input.  Preceding condition(s) causes termination.");
                }
            }
            if (this->m_ZoneInletNode == 0) {
                ShowSevereError(state,
                                this->UnitType + " \"" + this->Name + "\": The zone inlet node in the controlled zone (" +
                                    state.dataHeatBal->Zone(this->ControlZoneNum).Name + ") is not found.");
                ShowFatalError(state,
                               "Subroutine InitLoadBasedControl: Errors found in getting " + this->UnitType +
                                   " input.  Preceding condition(s) causes termination.");
            }
        }

        // What type of logic is this? Is the point to go through the main IF once? or every other time?
        // RR: This was used with AirflowNetwork to calculate duct losses.
        // RR: AFN counts the number of passes through airloop equipment (same logic in Furnaces and other modules) and resets the counter to 0 on
        // BeginEnvrnFlag. RR: This has been changed in this module and AFN to use AirflowNetworkFanActivated if AirflowNetworkUnitarySystem is seen
        // by AFN. RR: Search for AirflowNetworkFanActivated in this module to see usage. The following lines of code can probably be removed although
        // it would require a AFN input file to test.
        if (state.dataGlobal->BeginEnvrnFlag && m_initLoadBasedControlAirLoopPass) {
            m_airLoopPassCounter = 0;
            m_initLoadBasedControlAirLoopPass = false;
        }
        if (!state.dataGlobal->BeginEnvrnFlag) {
            this->m_MyEnvrnFlag2 = true; // this does not appear to be needed, only initializes autosized coil fluid flow rates
            m_initLoadBasedControlAirLoopPass = true;
        }

        ++m_airLoopPassCounter;
        if (m_airLoopPassCounter > 2) m_airLoopPassCounter = 1;

        // reset duct losses from previous iteration
        if (FirstHVACIteration) {
            this->m_SenLoadLoss = 0.0;
            this->m_LatLoadLoss = 0.0;
        }

        // Calcuate air distribution losses
        //  IF (.NOT. FirstHVACIteration .AND. AirLoopPass .EQ. 1 .AND. AirflowNetworkFanActivated) THEN
        if (!FirstHVACIteration && state.dataAirflowNetwork->AirflowNetworkFanActivated) {
            Real64 DeltaMassRate = 0.0;
            Real64 TotalOutput = 0.0;         // total output rate, {W}
            Real64 SensibleOutputDelta = 0.0; // delta sensible output rate, {W}
            Real64 LatentOutputDelta = 0.0;   // delta latent output rate, {W}
            Real64 TotalOutputDelta = 0.0;    // delta total output rate, {W}
            int ZoneInNode = this->m_ZoneInletNode;
            Real64 MassFlowRate = state.dataLoopNodes->Node(ZoneInNode).MassFlowRate / this->ControlZoneMassFlowFrac;
            if (state.dataAirflowNetwork->SimulateAirflowNetwork > AirflowNetwork::AirflowNetworkControlMultizone) {
                DeltaMassRate = state.dataLoopNodes->Node(this->AirOutNode).MassFlowRate -
                                state.dataLoopNodes->Node(ZoneInNode).MassFlowRate / this->ControlZoneMassFlowFrac;
                if (DeltaMassRate < 0.0) DeltaMassRate = 0.0;
            } else {
                MassFlowRate = state.dataLoopNodes->Node(this->AirOutNode).MassFlowRate;
                DeltaMassRate = 0.0;
            }
            CalcComponentSensibleLatentOutput(MassFlowRate,
                                              state.dataLoopNodes->Node(this->AirOutNode).Temp,
                                              state.dataLoopNodes->Node(this->AirOutNode).HumRat,
                                              state.dataLoopNodes->Node(ZoneInNode).Temp,
                                              state.dataLoopNodes->Node(ZoneInNode).HumRat,
                                              this->m_SenLoadLoss,
                                              this->m_LatLoadLoss,
                                              TotalOutput);
            CalcComponentSensibleLatentOutput(DeltaMassRate,
                                              state.dataLoopNodes->Node(this->AirOutNode).Temp,
                                              state.dataLoopNodes->Node(this->AirOutNode).HumRat,
                                              state.dataLoopNodes->Node(this->NodeNumOfControlledZone).Temp,
                                              state.dataLoopNodes->Node(this->NodeNumOfControlledZone).HumRat,
                                              SensibleOutputDelta,
                                              LatentOutputDelta,
                                              TotalOutputDelta);
            this->m_SenLoadLoss = this->m_SenLoadLoss + SensibleOutputDelta;
            if (std::abs(this->m_SensibleLoadMet) > 0.0) {
                if (std::abs(this->m_SenLoadLoss / this->m_SensibleLoadMet) < 0.001) this->m_SenLoadLoss = 0.0;
            }
            if (this->m_Humidistat) {
                this->m_LatLoadLoss = this->m_LatLoadLoss + LatentOutputDelta;
                if (std::abs(this->m_LatentLoadMet) > 0.0) {
                    if (std::abs(this->m_LatLoadLoss / this->m_LatentLoadMet) < 0.001) this->m_LatLoadLoss = 0.0;
                }
            }
        }

        if (this->m_FanOpModeSchedPtr > 0) {
            if (ScheduleManager::GetCurrentScheduleValue(state, this->m_FanOpModeSchedPtr) == 0.0) {
                this->m_FanOpMode = DataHVACGlobals::CycFanCycCoil;
            } else {
                this->m_FanOpMode = DataHVACGlobals::ContFanCycCoil;
                state.dataHVACGlobal->OnOffFanPartLoadFraction = 1.0;
            }
        }

        // System load calculation for cycling fan systems
        if (this->ControlZoneMassFlowFrac > 0.0) {
            QZnReq = ZoneLoad / this->ControlZoneMassFlowFrac;
            state.dataUnitarySystems->MoistureLoad /= this->ControlZoneMassFlowFrac;
            state.dataUnitarySystems->QToCoolSetPt /= this->ControlZoneMassFlowFrac;
            state.dataUnitarySystems->QToHeatSetPt /= this->ControlZoneMassFlowFrac;
            ZoneLoad = QZnReq;
        } else {
            QZnReq = ZoneLoad;
            this->ControlZoneMassFlowFrac = 1.0;
        }

        state.dataUnitarySystems->CoolingLoad = false;
        state.dataUnitarySystems->HeatingLoad = false;

        if (QZnReq > this->m_SmallLoadTolerance) { // no need to check deadband flag, QZnReq is correct.
            if (state.dataHeatBalFanSys->TempControlType(this->ControlZoneNum) != DataHVACGlobals::SingleCoolingSetPoint) {
                state.dataUnitarySystems->HeatingLoad = true;
            }
        } else if (QZnReq < -this->m_SmallLoadTolerance) {
            if (state.dataHeatBalFanSys->TempControlType(this->ControlZoneNum) != DataHVACGlobals::SingleHeatingSetPoint) {
                state.dataUnitarySystems->CoolingLoad = true;
            }
        }

        // System load calculation for constant fan systems
        if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
            bool HXUnitOn = false;
            this->FanPartLoadRatio = 0.0; // sets fan to minimum for ASHRAE model
            this->setOnOffMassFlowRate(state, OnOffAirFlowRatio,
                                       0.0); // CompOnMassFlow and CompOffMassFlow are scalar, reset to this system's values
            this->calcUnitarySystemToLoad(state,
                                          AirLoopNum,
                                          FirstHVACIteration,
                                          0.0,
                                          0.0,
                                          OnOffAirFlowRatio,
                                          SensOutputOff,
                                          LatOutputOff,
                                          HXUnitOn,
                                          HeatCoilLoad,
                                          SupHeaterLoad,
                                          CompOn);
            {
                auto const SELECT_CASE_var(state.dataHeatBalFanSys->TempControlType(this->ControlZoneNum));
                if (SELECT_CASE_var == DataHVACGlobals::SingleHeatingSetPoint) {
                    state.dataUnitarySystems->CoolingLoad = false;
                    // No heating load and constant fan pushes zone below heating set point
                    if (SensOutputOff < 0.0 && state.dataUnitarySystems->QToHeatSetPt < 0.0 &&
                        SensOutputOff - state.dataUnitarySystems->QToHeatSetPt < -DataHVACGlobals::SmallLoad) {
                        state.dataUnitarySystems->HeatingLoad = true;
                        state.dataUnitarySystems->CoolingLoad = false;
                        ZoneLoad = state.dataUnitarySystems->QToHeatSetPt;
                    }
                } else if (SELECT_CASE_var == DataHVACGlobals::SingleCoolingSetPoint) {
                    state.dataUnitarySystems->HeatingLoad = false;
                    // No heating load and constant fan pushes zone above cooling set point
                    if (SensOutputOff > 0.0 && state.dataUnitarySystems->QToCoolSetPt > 0.0 &&
                        SensOutputOff - state.dataUnitarySystems->QToCoolSetPt > DataHVACGlobals::SmallLoad) {
                        state.dataUnitarySystems->HeatingLoad = false;
                        state.dataUnitarySystems->CoolingLoad = true;
                        ZoneLoad = state.dataUnitarySystems->QToCoolSetPt;
                    }
                } else if (SELECT_CASE_var == DataHVACGlobals::SingleHeatCoolSetPoint) {
                    // zone temp above cooling and heating set point temps
                    if (state.dataUnitarySystems->QToHeatSetPt < 0.0 && state.dataUnitarySystems->QToCoolSetPt < 0.0) {
                        // zone pushed below heating set point
                        if (SensOutputOff < 0.0 && state.dataUnitarySystems->QToHeatSetPt - SensOutputOff > DataHVACGlobals::SmallLoad) {
                            state.dataUnitarySystems->HeatingLoad = true;
                            state.dataUnitarySystems->CoolingLoad = false;
                            ZoneLoad = state.dataUnitarySystems->QToHeatSetPt;
                        }
                        // zone temp below heating set point temp
                    } else if (state.dataUnitarySystems->QToHeatSetPt > 0.0 && state.dataUnitarySystems->QToCoolSetPt > 0.0) {
                        // zone pushed above cooling set point
                        if (SensOutputOff > 0.0 && state.dataUnitarySystems->QToCoolSetPt - SensOutputOff > DataHVACGlobals::SmallLoad) {
                            state.dataUnitarySystems->HeatingLoad = false;
                            state.dataUnitarySystems->CoolingLoad = true;
                            ZoneLoad = state.dataUnitarySystems->QToCoolSetPt;
                        }
                    }
                } else if (SELECT_CASE_var == DataHVACGlobals::DualSetPointWithDeadBand) {
                    // zone temp above cooling and heating set point temps
                    if (state.dataUnitarySystems->QToHeatSetPt < 0.0 && state.dataUnitarySystems->QToCoolSetPt < 0.0) {
                        // zone pushed into deadband
                        if (SensOutputOff < 0.0 && state.dataUnitarySystems->QToCoolSetPt - SensOutputOff > DataHVACGlobals::SmallLoad) {
                            state.dataUnitarySystems->HeatingLoad = false;
                            state.dataUnitarySystems->CoolingLoad = false;
                            ZoneLoad = 0.0;
                        }
                        // zone pushed below heating set point
                        if (SensOutputOff < 0.0 && state.dataUnitarySystems->QToHeatSetPt - SensOutputOff > DataHVACGlobals::SmallLoad) {
                            state.dataUnitarySystems->HeatingLoad = true;
                            state.dataUnitarySystems->CoolingLoad = false;
                            ZoneLoad = state.dataUnitarySystems->QToHeatSetPt;
                        }
                        // zone temp below heating set point temp
                    } else if (state.dataUnitarySystems->QToHeatSetPt > 0.0 && state.dataUnitarySystems->QToCoolSetPt > 0.0) {
                        // zone pushed into deadband
                        if (SensOutputOff > 0.0 && SensOutputOff - state.dataUnitarySystems->QToHeatSetPt > DataHVACGlobals::SmallLoad) {
                            state.dataUnitarySystems->HeatingLoad = false;
                            state.dataUnitarySystems->CoolingLoad = false;
                            ZoneLoad = 0.0;
                        }
                        // zone pushed above cooling set point
                        if (SensOutputOff > 0.0 && SensOutputOff - state.dataUnitarySystems->QToCoolSetPt > DataHVACGlobals::SmallLoad) {
                            state.dataUnitarySystems->HeatingLoad = false;
                            state.dataUnitarySystems->CoolingLoad = true;
                            ZoneLoad = state.dataUnitarySystems->QToCoolSetPt;
                        }
                        // zone temp between set point temps
                    } else if (state.dataUnitarySystems->QToHeatSetPt < 0.0 && state.dataUnitarySystems->QToCoolSetPt > 0.0) {
                        // zone pushed below heating set point
                        if (SensOutputOff < 0.0 && SensOutputOff - state.dataUnitarySystems->QToHeatSetPt < -DataHVACGlobals::SmallLoad) {
                            state.dataUnitarySystems->HeatingLoad = true;
                            state.dataUnitarySystems->CoolingLoad = false;
                            ZoneLoad = state.dataUnitarySystems->QToHeatSetPt;
                            // zone pushed above cooling set point
                        } else if (SensOutputOff > 0.0 && SensOutputOff - state.dataUnitarySystems->QToCoolSetPt > DataHVACGlobals::SmallLoad) {
                            state.dataUnitarySystems->HeatingLoad = false;
                            state.dataUnitarySystems->CoolingLoad = true;
                            ZoneLoad = state.dataUnitarySystems->QToCoolSetPt;
                        }
                    }
                } else {
                }
            }

            // push iteration mode stack and set current mode
            this->m_IterationMode[2] = this->m_IterationMode[1];
            this->m_IterationMode[1] = this->m_IterationMode[0];
            if (state.dataUnitarySystems->CoolingLoad) {
                this->m_IterationMode[0] = state.dataUnitarySystems->CoolingMode;
            } else if (state.dataUnitarySystems->HeatingLoad) {
                this->m_IterationMode[0] = state.dataUnitarySystems->HeatingMode;
            } else {
                this->m_IterationMode[0] = state.dataUnitarySystems->NoCoolHeat;
            }
            // IF small loads to meet or not converging, just shut down unit
            if (std::abs(ZoneLoad) < this->m_SmallLoadTolerance) {
                ZoneLoad = 0.0;
                state.dataUnitarySystems->CoolingLoad = false;
                state.dataUnitarySystems->HeatingLoad = false;
            } else if (this->m_IterationCounter > (state.dataHVACGlobal->MinAirLoopIterationsAfterFirst + 6)) {
                // attempt to lock output (air flow) if oscillations are detected
                int OperatingMode = this->m_IterationMode[0]; // VS systems can take a few more iterations than single-speed systems
                int OperatingModeMinusOne = this->m_IterationMode[1];
                int OperatingModeMinusTwo = this->m_IterationMode[2];
                bool Oscillate = true;
                if (OperatingMode == OperatingModeMinusOne && OperatingMode == OperatingModeMinusTwo) Oscillate = false;
                if (Oscillate) {
                    if (state.dataUnitarySystems->QToCoolSetPt < 0.0) {
                        state.dataUnitarySystems->HeatingLoad = false;
                        state.dataUnitarySystems->CoolingLoad = true;
                        ZoneLoad = state.dataUnitarySystems->QToCoolSetPt;
                    } else if (state.dataUnitarySystems->QToHeatSetPt > 0.0) {
                        state.dataUnitarySystems->HeatingLoad = true;
                        state.dataUnitarySystems->CoolingLoad = false;
                        ZoneLoad = state.dataUnitarySystems->QToHeatSetPt;
                    } else {
                        state.dataUnitarySystems->HeatingLoad = false;
                        state.dataUnitarySystems->CoolingLoad = false;
                        ZoneLoad = 0.0;
                    }
                }
            }
        }

        // Determine the m_Staged status
        if (allocated(state.dataZoneCtrls->StageZoneLogic) && this->m_DesignSpecMSHPIndex > 0) {
            if (state.dataZoneCtrls->StageZoneLogic(this->ControlZoneNum)) {
                this->m_Staged = true;
                this->m_StageNum = state.dataZoneEnergyDemand->ZoneSysEnergyDemand(this->ControlZoneNum).StageNum;
            } else {
                if (this->m_MyStagedFlag) {
                    ShowWarningError(state,
                                     "ZoneControl:Thermostat:StagedDualSetpoint is found, but is not applied to this UnitarySystem "
                                     "object with UnitarySystemPerformance:Multispeed type = ");
                    ShowContinueError(state, this->Name + ". Please make correction. Simulation continues...");
                    this->m_MyStagedFlag = false;
                }
            }
        }

        // Staged control
        if (this->m_Staged) {
            if (this->m_StageNum == 0) {
                state.dataUnitarySystems->HeatingLoad = false;
                state.dataUnitarySystems->CoolingLoad = false;
                QZnReq = 0.0;
            } else {
                QZnReq =
                    state.dataZoneEnergyDemand->ZoneSysEnergyDemand(this->ControlZoneNum).RemainingOutputRequired / this->ControlZoneMassFlowFrac;
                if (this->m_StageNum > 0) {
                    state.dataUnitarySystems->HeatingLoad = true;
                    state.dataUnitarySystems->CoolingLoad = false;
                } else {
                    state.dataUnitarySystems->HeatingLoad = false;
                    state.dataUnitarySystems->CoolingLoad = true;
                }
            }
        }

        if (this->m_DehumidControlType_Num == DehumCtrlType::Multimode) {
            if (state.dataUnitarySystems->HeatingLoad) state.dataUnitarySystems->MoistureLoad = 0.0;
        }

        // Check load control
        if (this->m_RunOnLatentOnlyWithSensible && ZoneLoad == 0.0) state.dataUnitarySystems->MoistureLoad = 0.0;
        if (!this->m_RunOnSensibleLoad) {
            ZoneLoad = 0.0;
            state.dataUnitarySystems->CoolingLoad = false;
            state.dataUnitarySystems->HeatingLoad = false;
        }
        if (!this->m_RunOnLatentLoad) state.dataUnitarySystems->MoistureLoad = 0.0;

        // Testing heat pump air to air with RH control with CoolReheat dehumidifaction control showed that when there was heating
        // and moisture load, the cooling coil was turning on to meet the moisture load and reheat was then turning on to meet both
        // heating load and excess cooling load caused by cooling coil. Adding the logic below caused the zone temperature,
        // relative humidity, cooling/heating rate to line up for both the orignal and new file with unitary system object.

        if (this->m_SuppCoilExists) {
            if (this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat) {
                if (state.dataUnitarySystems->MoistureLoad < 0.0 && this->m_HeatPump) {
                    state.dataUnitarySystems->HeatingLoad = false;
                    state.dataUnitarySystems->CoolingLoad = true;
                }
            }
        }

        // set report variables for predicted sensible and latent load
        this->m_SensibleLoadPredicted = ZoneLoad;
        this->m_MoistureLoadPredicted = state.dataUnitarySystems->MoistureLoad;
    }

    void UnitarySys::setOnOffMassFlowRate(EnergyPlusData &state,
                                          Real64 &OnOffAirFlowRatio, // ratio of coil on to coil off air flow rate
                                          Real64 const PartLoadRatio // coil part-load ratio
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Chandan Sharma
        //       DATE WRITTEN   May 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine is for initializations of the components.

        // METHODOLOGY EMPLOYED:
        // The unitarysystem may have alternate air flow rates
        // in cooling, heating, and when no cooling or heating is needed. Set up the coil (comp) ON and OFF
        // air flow rates. Use these flow rates during the Calc routines to set the average mass flow rates
        // based on PLR.

        // REFERENCES:
        // Based on SetOnOffMassFlowRate by Richard Raustad

        int HeatSpeedNum = 0;
        int CoolSpeedNum = 0;

        state.dataUnitarySystems->CompOffMassFlow = 0.0;
        state.dataUnitarySystems->CompOffFlowRatio = 0.0;
        state.dataUnitarySystems->m_massFlow1 = 0.0;
        state.dataUnitarySystems->m_massFlow2 = 0.0;

        // Set the compressor or coil ON mass flow rate
        if (state.dataUnitarySystems->HeatingLoad) {

            this->m_LastMode = state.dataUnitarySystems->HeatingMode;

            if (this->m_MultiOrVarSpeedHeatCoil) {

                HeatSpeedNum = this->m_HeatingSpeedNum;

                if (HeatSpeedNum == 0) {
                    state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                    state.dataUnitarySystems->CompOnFlowRatio = this->m_NoLoadAirFlowRateRatio;
                } else if (HeatSpeedNum == 1) {
                    state.dataUnitarySystems->CompOnMassFlow = this->m_HeatMassFlowRate[1];
                    state.dataUnitarySystems->CompOnFlowRatio = this->m_MSHeatingSpeedRatio[1];
                } else if (HeatSpeedNum > 1) {
                    state.dataUnitarySystems->CompOnMassFlow = this->m_HeatMassFlowRate[HeatSpeedNum];
                    state.dataUnitarySystems->CompOnFlowRatio = this->m_MSHeatingSpeedRatio[HeatSpeedNum];
                }
                // Set the compressor or coil OFF mass flow rate based on LOGICAL flag
                // UseCompressorOnFlow is used when the user does not enter a value for no cooling or heating flow rate
                if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
                    if (state.dataUnitarySystems->MoistureLoad < 0.0 && this->m_Humidistat &&
                        this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat) {
                        if (this->m_MultiOrVarSpeedCoolCoil) {
                            CoolSpeedNum = this->m_CoolingSpeedNum;
                            if (CoolSpeedNum < 1) {
                                state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_NoLoadAirFlowRateRatio;
                            } else if (CoolSpeedNum == 1) {
                                state.dataUnitarySystems->CompOnMassFlow = this->m_CoolMassFlowRate[1];
                                state.dataUnitarySystems->CompOffMassFlow = this->m_CoolMassFlowRate[1];
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_MSCoolingSpeedRatio[1];
                            } else if (CoolSpeedNum > 1) {
                                state.dataUnitarySystems->CompOnMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum];
                                state.dataUnitarySystems->CompOffMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum - 1];
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_MSCoolingSpeedRatio[CoolSpeedNum - 1];
                            }
                        } else {
                            state.dataUnitarySystems->CompOffMassFlow = this->MaxCoolAirMassFlow;
                            state.dataUnitarySystems->CompOffFlowRatio = this->m_CoolingFanSpeedRatio;
                        }
                    } else {
                        if (HeatSpeedNum == 0) {
                            state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                            state.dataUnitarySystems->CompOffFlowRatio = this->m_NoLoadAirFlowRateRatio;
                        } else if (HeatSpeedNum == 1) {
                            state.dataUnitarySystems->CompOffMassFlow = this->m_HeatMassFlowRate[HeatSpeedNum];
                            state.dataUnitarySystems->CompOffFlowRatio = this->m_HeatMassFlowRate[HeatSpeedNum];
                        } else {
                            state.dataUnitarySystems->CompOffMassFlow = this->m_HeatMassFlowRate[HeatSpeedNum - 1];
                            state.dataUnitarySystems->CompOffFlowRatio = this->m_MSHeatingSpeedRatio[HeatSpeedNum - 1];
                        }
                    }
                } else { // cycling fan mode
                    if (HeatSpeedNum <= 1) {
                        state.dataUnitarySystems->CompOffMassFlow = 0.0; // #5518
                        state.dataUnitarySystems->CompOffFlowRatio = 0.0;
                    } else {
                        state.dataUnitarySystems->CompOffMassFlow = this->m_HeatMassFlowRate[HeatSpeedNum - 1];
                        state.dataUnitarySystems->CompOffFlowRatio = this->m_MSHeatingSpeedRatio[HeatSpeedNum - 1];
                    }
                }
            } else { // IF(MultiOrVarSpeedHeatCoil) THEN
                //   If a heating and moisture load exists, operate at the cooling mass flow rate ELSE operate at the heating flow rate
                if (state.dataUnitarySystems->MoistureLoad < 0.0 && this->m_Humidistat &&
                    this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat && !this->m_DXHeatingCoil) {
                    if (this->m_MultiOrVarSpeedCoolCoil) {
                        CoolSpeedNum = this->m_CoolingSpeedNum;
                        if (CoolSpeedNum < 1) {
                            state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                            state.dataUnitarySystems->CompOnFlowRatio = this->m_NoLoadAirFlowRateRatio;
                        } else if (CoolSpeedNum == 1) {
                            state.dataUnitarySystems->CompOnMassFlow = this->m_CoolMassFlowRate[1];
                            state.dataUnitarySystems->CompOnFlowRatio = this->m_MSCoolingSpeedRatio[1];
                        } else {
                            state.dataUnitarySystems->CompOnMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum];
                            state.dataUnitarySystems->CompOnFlowRatio = this->m_MSCoolingSpeedRatio[CoolSpeedNum];
                        }
                    } else { // IF (MultiOrVarSpeedCoolCoil) THEN
                        state.dataUnitarySystems->CompOnMassFlow = this->MaxCoolAirMassFlow;
                        state.dataUnitarySystems->CompOnFlowRatio = this->m_CoolingFanSpeedRatio;
                        if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
                            state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                            state.dataUnitarySystems->CompOffFlowRatio = this->m_CoolingFanSpeedRatio;
                        }
                    }
                } else { // Heating load but no moisture load
                    state.dataUnitarySystems->CompOnMassFlow = this->MaxHeatAirMassFlow;
                    state.dataUnitarySystems->CompOnFlowRatio = this->m_HeatingFanSpeedRatio;
                    if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
                        if (this->m_AirFlowControl == UseCompFlow::UseCompressorOnFlow) {
                            state.dataUnitarySystems->CompOffMassFlow = this->MaxHeatAirMassFlow;
                            state.dataUnitarySystems->CompOffFlowRatio = this->m_HeatingFanSpeedRatio;
                        } else {
                            state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                            state.dataUnitarySystems->CompOffFlowRatio = this->m_HeatingFanSpeedRatio;
                        }
                    }
                }
            }

            // If a cooling load exists, operate at the cooling mass flow rate
        } else if (state.dataUnitarySystems->CoolingLoad) {

            this->m_LastMode = state.dataUnitarySystems->CoolingMode;

            if (this->m_MultiOrVarSpeedCoolCoil) {

                CoolSpeedNum = this->m_CoolingSpeedNum;

                if (CoolSpeedNum == 0) {
                    state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                    state.dataUnitarySystems->CompOnFlowRatio = this->m_NoLoadAirFlowRateRatio;
                } else if (CoolSpeedNum == 1) {
                    state.dataUnitarySystems->CompOnMassFlow = this->m_CoolMassFlowRate[1];
                    state.dataUnitarySystems->CompOnFlowRatio = this->m_MSCoolingSpeedRatio[1];
                } else if (CoolSpeedNum > 1) {
                    state.dataUnitarySystems->CompOnMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum];
                    state.dataUnitarySystems->CompOnFlowRatio = this->m_MSCoolingSpeedRatio[CoolSpeedNum];
                }
                // Set the compressor or coil OFF mass flow rate based on LOGICAL flag
                // UseCompressorOnFlow is used when the user does not enter a value for no cooling or heating flow rate
                //    IF(UnitarySystem(UnitarySysNum)%FanOpMode == DataHVACGlobals::ContFanCycCoil)THEN
                //      IF (UnitarySystem(UnitarySysNum)%AirFlowControl .EQ. UseCompressorOnFlow) THEN
                if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
                    if (CoolSpeedNum == 0) {
                        state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                        state.dataUnitarySystems->CompOffFlowRatio = this->m_NoLoadAirFlowRateRatio;
                    } else if (CoolSpeedNum == 1) {
                        state.dataUnitarySystems->CompOffMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum];
                        state.dataUnitarySystems->CompOffFlowRatio = this->m_CoolMassFlowRate[CoolSpeedNum];
                    } else {
                        state.dataUnitarySystems->CompOffMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum - 1];
                        state.dataUnitarySystems->CompOffFlowRatio = this->m_MSCoolingSpeedRatio[CoolSpeedNum - 1];
                    }
                } else { // cycling fan mode
                    if (CoolSpeedNum <= 1) {
                        state.dataUnitarySystems->CompOffMassFlow = 0.0; // #5518
                        state.dataUnitarySystems->CompOffFlowRatio = 0.0;
                    } else {
                        state.dataUnitarySystems->CompOffMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum - 1];
                        state.dataUnitarySystems->CompOffFlowRatio = this->m_MSCoolingSpeedRatio[CoolSpeedNum - 1];
                    }
                }
            } else { // IF(MultiOrVarSpeedCoolCoil(UnitarySysNum)) THEN
                state.dataUnitarySystems->CompOnMassFlow = this->MaxCoolAirMassFlow;
                state.dataUnitarySystems->CompOnFlowRatio = this->m_CoolingFanSpeedRatio;
                if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
                    if (this->m_AirFlowControl == UseCompFlow::UseCompressorOnFlow) {
                        state.dataUnitarySystems->CompOffMassFlow = this->MaxCoolAirMassFlow;
                        state.dataUnitarySystems->CompOffFlowRatio = this->m_CoolingFanSpeedRatio;
                    } else {
                        state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                        state.dataUnitarySystems->CompOffFlowRatio = this->m_CoolingFanSpeedRatio;
                    }
                }
            }

        } else { // No load
            // If no load exists, set the compressor on mass flow rate.
            // Set equal the mass flow rate when no heating or cooling is needed If no moisture load exists.
            // If the user has set the off mass flow rate to 0, set according to the last operating mode.

            if (state.dataUnitarySystems->MoistureLoad < 0.0 && this->m_Humidistat && this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat) {
                if (this->m_MultiOrVarSpeedCoolCoil) {
                    CoolSpeedNum = this->m_CoolingSpeedNum;
                    if (CoolSpeedNum < 1) {
                        state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                        state.dataUnitarySystems->CompOnFlowRatio = this->m_NoLoadAirFlowRateRatio;
                    } else if (CoolSpeedNum == 1) {
                        state.dataUnitarySystems->CompOnMassFlow = this->m_CoolMassFlowRate[1];
                        state.dataUnitarySystems->CompOnFlowRatio = this->m_MSCoolingSpeedRatio[1];
                    } else {
                        state.dataUnitarySystems->CompOnMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum];
                        state.dataUnitarySystems->CompOnFlowRatio = this->m_MSCoolingSpeedRatio[CoolSpeedNum];
                    }

                    if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
                        if (this->m_AirFlowControl == UseCompFlow::UseCompressorOnFlow) {
                            if (CoolSpeedNum <= 1) {
                                state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_NoLoadAirFlowRateRatio;
                            } else {
                                state.dataUnitarySystems->CompOffMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum - 1];
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_MSCoolingSpeedRatio[CoolSpeedNum - 1];
                            }
                        } else {
                            state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                            state.dataUnitarySystems->CompOffFlowRatio = this->m_NoLoadAirFlowRateRatio;
                        }
                    }

                } else { // IF (MultiOrVarSpeedCoolCoil(UnitarySysNum)) THEN
                    state.dataUnitarySystems->CompOnMassFlow = this->MaxCoolAirMassFlow;
                    state.dataUnitarySystems->CompOnFlowRatio = this->m_CoolingFanSpeedRatio;
                    if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
                        if (this->m_AirFlowControl == UseCompFlow::UseCompressorOnFlow) {
                            state.dataUnitarySystems->CompOffMassFlow = this->MaxCoolAirMassFlow;
                            state.dataUnitarySystems->CompOffFlowRatio = this->m_CoolingFanSpeedRatio;
                        } else {
                            state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                            state.dataUnitarySystems->CompOffFlowRatio = this->m_CoolingFanSpeedRatio;
                        }
                    }
                }

            } else { // No Moisture Load

                if (this->m_LastMode == state.dataUnitarySystems->HeatingMode) {
                    if (this->m_MultiOrVarSpeedHeatCoil) {
                        state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                        state.dataUnitarySystems->CompOnFlowRatio = this->m_NoLoadAirFlowRateRatio;
                    } else {
                        state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                        state.dataUnitarySystems->CompOnFlowRatio = 1.0;
                    }
                } else {
                    if (this->m_MultiOrVarSpeedCoolCoil) {
                        state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                        state.dataUnitarySystems->CompOnFlowRatio = this->m_NoLoadAirFlowRateRatio;
                    } else {
                        state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                        state.dataUnitarySystems->CompOnFlowRatio = 1.0;
                    }
                }
                if (state.dataUnitarySystems->CompOnMassFlow == 0.0) {
                    if (this->m_LastMode == state.dataUnitarySystems->HeatingMode) {
                        if (this->m_MultiOrVarSpeedHeatCoil) {
                            HeatSpeedNum = this->m_HeatingSpeedNum;
                            if (HeatSpeedNum == 0) {
                                state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                state.dataUnitarySystems->CompOnFlowRatio = this->m_NoLoadAirFlowRateRatio;
                            } else if (HeatSpeedNum == 1) {
                                state.dataUnitarySystems->CompOnMassFlow = this->m_HeatMassFlowRate[1];
                                state.dataUnitarySystems->CompOnFlowRatio = this->m_MSHeatingSpeedRatio[1];
                            } else if (HeatSpeedNum > 1) {
                                state.dataUnitarySystems->CompOnMassFlow = this->m_HeatMassFlowRate[HeatSpeedNum];
                                state.dataUnitarySystems->CompOnFlowRatio = this->m_MSHeatingSpeedRatio[HeatSpeedNum];
                            }
                        } else { // IF(MultiOrVarSpeedHeatCoil) THEN
                            state.dataUnitarySystems->CompOnMassFlow = this->MaxHeatAirMassFlow;
                            state.dataUnitarySystems->CompOnFlowRatio = this->m_HeatingFanSpeedRatio;
                        }
                    } else { // IF(UnitarySystem(UnitarySysNum)%LastMode .EQ. HeatingMode)THEN
                        if (this->m_MultiOrVarSpeedCoolCoil) {
                            CoolSpeedNum = this->m_CoolingSpeedNum;
                            if (CoolSpeedNum == 0) {
                                state.dataUnitarySystems->CompOnMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                state.dataUnitarySystems->CompOnFlowRatio = this->m_NoLoadAirFlowRateRatio;
                            } else if (CoolSpeedNum == 1) {
                                state.dataUnitarySystems->CompOnMassFlow = this->m_CoolMassFlowRate[1];
                                state.dataUnitarySystems->CompOnFlowRatio = this->m_MSCoolingSpeedRatio[1];
                            } else if (CoolSpeedNum > 1) {
                                state.dataUnitarySystems->CompOnMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum];
                                state.dataUnitarySystems->CompOnFlowRatio = this->m_MSCoolingSpeedRatio[CoolSpeedNum];
                            }
                        } else { // IF(MultiOrVarSpeedCoolCoil) THEN
                            state.dataUnitarySystems->CompOnMassFlow = this->MaxCoolAirMassFlow;
                            state.dataUnitarySystems->CompOnFlowRatio = this->m_CoolingFanSpeedRatio;
                        } // IF(MultiOrVarSpeedCoolCoil) THEN
                    }     // IF(UnitarySystem(UnitarySysNum)%LastMode .EQ. HeatingMode)THEN
                }         // IF(CompOnMassFlow .EQ. 0.0d0)THEN

                if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
                    if (this->m_AirFlowControl == UseCompFlow::UseCompressorOnFlow) {
                        if (this->m_LastMode == state.dataUnitarySystems->HeatingMode) {
                            if (this->m_MultiOrVarSpeedHeatCoil) {
                                HeatSpeedNum = this->m_HeatingSpeedNum;
                                if (HeatSpeedNum < 1) {
                                    state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                    state.dataUnitarySystems->CompOffFlowRatio = this->m_NoLoadAirFlowRateRatio;
                                } else if (HeatSpeedNum == 1) {
                                    state.dataUnitarySystems->CompOffMassFlow = this->m_HeatMassFlowRate[1];
                                    state.dataUnitarySystems->CompOffFlowRatio = this->m_MSHeatingSpeedRatio[1];
                                } else {
                                    state.dataUnitarySystems->CompOffMassFlow = this->m_HeatMassFlowRate[HeatSpeedNum - 1];
                                    state.dataUnitarySystems->CompOffFlowRatio = this->m_MSHeatingSpeedRatio[HeatSpeedNum - 1];
                                }
                            } else {
                                state.dataUnitarySystems->CompOffMassFlow = this->MaxHeatAirMassFlow;
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_HeatingFanSpeedRatio;
                            }
                        } else { // IF(UnitarySystem(UnitarySysNum)%LastMode .EQ. HeatingMode)THEN
                            if (this->m_MultiOrVarSpeedCoolCoil) {
                                CoolSpeedNum = this->m_CoolingSpeedNum;
                                if (CoolSpeedNum < 1) {
                                    state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                    state.dataUnitarySystems->CompOffFlowRatio = this->m_NoLoadAirFlowRateRatio;
                                } else if (CoolSpeedNum == 1) {
                                    state.dataUnitarySystems->CompOffMassFlow = this->m_CoolMassFlowRate[1];
                                    state.dataUnitarySystems->CompOffFlowRatio = this->m_MSCoolingSpeedRatio[1];
                                } else {
                                    state.dataUnitarySystems->CompOffMassFlow = this->m_CoolMassFlowRate[CoolSpeedNum - 1];
                                    state.dataUnitarySystems->CompOffFlowRatio = this->m_MSCoolingSpeedRatio[CoolSpeedNum - 1];
                                }
                            } else {
                                state.dataUnitarySystems->CompOffMassFlow = this->MaxCoolAirMassFlow;
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_CoolingFanSpeedRatio;
                            }
                        }    // IF(UnitarySystem(UnitarySysNum)%LastMode .EQ. HeatingMode)THEN
                    } else { // IF (UnitarySystem(UnitarySysNum)%AirFlowControl .EQ. UseCompressorOnFlow) THEN
                        if (this->m_LastMode == state.dataUnitarySystems->HeatingMode) {
                            if (this->m_MultiOrVarSpeedHeatCoil) {
                                state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_NoLoadAirFlowRateRatio;
                            } else {
                                state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_HeatingFanSpeedRatio;
                            }
                        } else {
                            if (this->m_MultiOrVarSpeedCoolCoil) {
                                state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_NoLoadAirFlowRateRatio;
                            } else {
                                state.dataUnitarySystems->CompOffMassFlow = this->MaxNoCoolHeatAirMassFlow;
                                state.dataUnitarySystems->CompOffFlowRatio = this->m_CoolingFanSpeedRatio;
                            }
                        }
                    } // IF (UnitarySystem(UnitarySysNum)%AirFlowControl .EQ. UseCompressorOnFlow) THEN
                }     // IF(UnitarySystem(UnitarySysNum)%FanOpMode == DataHVACGlobals::ContFanCycCoil)THEN
            }         // ELSE ! No Moisture Load
        }             // No Heating/Cooling Load

        if (this->m_MultiSpeedHeatingCoil && (state.dataUnitarySystems->HeatingLoad && HeatSpeedNum == 1)) {
            state.dataHVACGlobal->MSHPMassFlowRateLow = state.dataUnitarySystems->CompOnMassFlow;
        } else if (this->m_DiscreteSpeedCoolingCoil && (state.dataUnitarySystems->CoolingLoad && CoolSpeedNum == 1)) {
            state.dataHVACGlobal->MSHPMassFlowRateLow = state.dataUnitarySystems->CompOnMassFlow;
        } else {
            state.dataHVACGlobal->MSHPMassFlowRateLow = state.dataUnitarySystems->CompOffMassFlow; // these need to be set for multi-speed coils
        }
        state.dataHVACGlobal->MSHPMassFlowRateHigh =
            state.dataUnitarySystems->CompOnMassFlow; // doesn't hurt to set these if multi-speed coils are not used

        state.dataUnitarySystems->m_massFlow1 = state.dataUnitarySystems->CompOnMassFlow;
        state.dataUnitarySystems->m_massFlow2 = state.dataUnitarySystems->CompOffMassFlow;

        // Set the system mass flow rates
        this->setAverageAirFlow(state, PartLoadRatio, OnOffAirFlowRatio);
    }

    void UnitarySys::setAverageAirFlow(EnergyPlusData &state,
                                       Real64 const PartLoadRatio, // unit part load ratio
                                       Real64 &OnOffAirFlowRatio   // ratio of compressor ON airflow to AVERAGE airflow over timestep
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad
        //       DATE WRITTEN   July 2005

        // PURPOSE OF THIS SUBROUTINE:
        // Set the average air mass flow rates using the part-load fraction of the HVAC system for this time step
        // Set OnOffAirFlowRatio to be used by DX coils

        // METHODOLOGY EMPLOYED:
        // The air flow rate in cooling, heating, and no cooling or heating can be dIFferent.
        // Calculate the air flow rate based on initializations.

        Real64 AverageUnitMassFlow = 0.0; // average supply air mass flow rate over time step
        bool FanOn = false;

        state.dataUnitarySystems->m_runTimeFraction1 = 0.0;
        state.dataUnitarySystems->m_runTimeFraction2 = 0.0;

        Real64 FanPartLoadRatio = PartLoadRatio;
        if (this->m_SimASHRAEModel) FanPartLoadRatio = this->FanPartLoadRatio;
        int SpeedNum = max(this->m_CoolingSpeedNum, this->m_HeatingSpeedNum);
        int InletNode = this->AirInNode;

        if (SpeedNum > 1) {
            if ((state.dataUnitarySystems->CoolingLoad && this->m_MultiOrVarSpeedCoolCoil) ||
                (state.dataUnitarySystems->HeatingLoad && this->m_MultiOrVarSpeedHeatCoil)) {
                AverageUnitMassFlow = FanPartLoadRatio * state.dataUnitarySystems->CompOnMassFlow +
                                      (1.0 - FanPartLoadRatio) * state.dataUnitarySystems->CompOffMassFlow;
            } else {
                AverageUnitMassFlow = state.dataUnitarySystems->CompOnMassFlow;
            }
        } else {
            AverageUnitMassFlow = (FanPartLoadRatio * state.dataUnitarySystems->CompOnMassFlow) +
                                  ((1.0 - FanPartLoadRatio) * state.dataUnitarySystems->CompOffMassFlow);
        }

        if (state.dataUnitarySystems->CompOffFlowRatio > 0.0) {
            if (SpeedNum > 1) {
                if ((state.dataUnitarySystems->CoolingLoad && this->m_MultiOrVarSpeedCoolCoil) ||
                    (state.dataUnitarySystems->HeatingLoad && this->m_MultiOrVarSpeedHeatCoil)) {
                    state.dataUnitarySystems->FanSpeedRatio = FanPartLoadRatio * state.dataUnitarySystems->CompOnFlowRatio +
                                                              (1.0 - FanPartLoadRatio) * state.dataUnitarySystems->CompOffFlowRatio;
                    state.dataUnitarySystems->m_runTimeFraction1 = FanPartLoadRatio;
                    state.dataUnitarySystems->m_runTimeFraction2 = 1.0 - FanPartLoadRatio;
                } else {
                    state.dataUnitarySystems->FanSpeedRatio = state.dataUnitarySystems->CompOnFlowRatio;
                    state.dataUnitarySystems->m_runTimeFraction1 = FanPartLoadRatio;
                    state.dataUnitarySystems->m_runTimeFraction2 = 0.0;
                }
            } else {
                state.dataUnitarySystems->FanSpeedRatio = (FanPartLoadRatio * state.dataUnitarySystems->CompOnFlowRatio) +
                                                          ((1.0 - FanPartLoadRatio) * state.dataUnitarySystems->CompOffFlowRatio);
                state.dataUnitarySystems->m_runTimeFraction1 = FanPartLoadRatio;
                state.dataUnitarySystems->m_runTimeFraction2 = 1.0 - FanPartLoadRatio;
            }
        } else {
            state.dataUnitarySystems->FanSpeedRatio = state.dataUnitarySystems->CompOnFlowRatio;
            state.dataUnitarySystems->m_runTimeFraction1 = FanPartLoadRatio;
            state.dataUnitarySystems->m_runTimeFraction2 = 0.0;
        }

        if (!(state.dataUnitarySystems->HeatingLoad && this->m_NumOfSpeedHeating == 0)) {
            if (this->m_SingleMode == 1) {
                if (this->m_FanOpMode == DataHVACGlobals::ContFanCycCoil) {
                    AverageUnitMassFlow = state.dataUnitarySystems->CompOnMassFlow;
                    state.dataUnitarySystems->FanSpeedRatio = state.dataUnitarySystems->CompOnFlowRatio;
                    state.dataUnitarySystems->m_runTimeFraction1 = 1.0;
                    state.dataUnitarySystems->m_runTimeFraction2 = 0.0;
                } else {
                    AverageUnitMassFlow = FanPartLoadRatio * state.dataUnitarySystems->CompOnMassFlow;
                    state.dataUnitarySystems->FanSpeedRatio = FanPartLoadRatio * state.dataUnitarySystems->CompOnFlowRatio;
                    state.dataUnitarySystems->m_runTimeFraction1 = FanPartLoadRatio;
                    state.dataUnitarySystems->m_runTimeFraction2 = 0.0;
                }
            }
        }

        // If the unitary system is scheduled on or nightime cycle overrides fan schedule. Uses same logic as fan.
        if (this->m_FanExists) {
            FanOn = false;
            if (ScheduleManager::GetCurrentScheduleValue(state, this->m_FanAvailSchedPtr) > 0) FanOn = true;
        } else {
            FanOn = true;
        }
        if (ScheduleManager::GetCurrentScheduleValue(state, this->m_SysAvailSchedPtr) > 0.0 &&
            ((FanOn || state.dataHVACGlobal->TurnFansOn) && !state.dataHVACGlobal->TurnFansOff)) {
            if (this->m_ControlType == ControlType::Setpoint) {
                // set point based equipment should use VAV terminal units to set the flow.
                // zone equipment needs to set flow since no other device regulates flow (ZoneHVAC /= AirLoopEquipment)
                if (!this->m_AirLoopEquipment) {
                    state.dataLoopNodes->Node(InletNode).MassFlowRate = AverageUnitMassFlow;
                    state.dataLoopNodes->Node(InletNode).MassFlowRateMaxAvail =
                        AverageUnitMassFlow; // #5531 zone equipment needs MaxAvail set or fan will not turn ON
                }
                if (AverageUnitMassFlow > 0.0) {
                    OnOffAirFlowRatio = 1.0;
                } else {
                    OnOffAirFlowRatio = 0.0;
                }
            } else {
                state.dataLoopNodes->Node(InletNode).MassFlowRate = AverageUnitMassFlow;
                if (!this->m_AirLoopEquipment) {
                    state.dataLoopNodes->Node(InletNode).MassFlowRateMaxAvail =
                        AverageUnitMassFlow; // #5531 zone equipment needs MaxAvail set or fan will not turn ON
                }
                if (AverageUnitMassFlow > 0.0) {
                    if (SpeedNum > 1) {
                        OnOffAirFlowRatio = 1.0;
                    } else {
                        OnOffAirFlowRatio = state.dataUnitarySystems->CompOnMassFlow / AverageUnitMassFlow;
                    }
                } else {
                    OnOffAirFlowRatio = 0.0;
                }
            }
        } else {
            state.dataLoopNodes->Node(InletNode).MassFlowRate = 0.0;
            OnOffAirFlowRatio = 1.0;
        }
    }

    void UnitarySys::calcUnitarySystemToLoad(EnergyPlusData &state,
                                             int const AirLoopNum,          // index to air loop
                                             bool const FirstHVACIteration, // True when first HVAC iteration
                                             Real64 const CoolPLR,          // operating cooling part-load ratio []
                                             Real64 const HeatPLR,          // operating cooling part-load ratio []
                                             Real64 &OnOffAirFlowRatio,     // ratio of heating PLR to cooling PLR (is this correct?)
                                             Real64 &SensOutput,            // sensible capacity (W)
                                             Real64 &LatOutput,             // latent capacity (W)
                                             bool HXUnitOn,                 // Flag to control HX for HXAssisted Cooling Coil
                                             Real64 HeatCoilLoad,           // Adjusted load to heating coil when SAT exceeds max limit (W)
                                             Real64 SuppCoilLoad,           // Adjusted load to supp heating coil when SAT exceeds max limit (W)
                                             int const CompOn               // Determines if compressor is on or off
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine calculates the resulting performance of the unitary system given
        // the operating PLR. System output is calculated with respect to zone condition.

        Real64 CoilCoolHeatRat = 0.0; // ratio of cooling to heating PLR for cycling fan RH control

        int InletNode = this->AirInNode;

        int CoolingCompOn = 0;
        if (CoolPLR > 0) {
            CoolingCompOn = CompOn;
            // for multispeed coils, comp is on IF speed > 1
        } else if (this->m_CoolingSpeedNum > 1) {
            CoolingCompOn = 1;
        }

        int HeatingCompOn = 0;
        if (HeatPLR > 0) {
            HeatingCompOn = CompOn;
            CoilCoolHeatRat = min(1.0, CoolPLR / HeatPLR);
        } else {
            CoilCoolHeatRat = 1.0;
        }
        // for multispeed coils, comp is on at PLR=0 IF speed > 1
        if (this->m_HeatingSpeedNum > 1) HeatingCompOn = 1;

        // set the operating flow rate
        if (this->m_NumOfSpeedCooling > 0 || this->m_NumOfSpeedHeating > 0) {
            this->setOnOffMassFlowRate(state, OnOffAirFlowRatio, max(CoolPLR, HeatPLR));
        } else {
            this->setAverageAirFlow(state, max(CoolPLR, HeatPLR), OnOffAirFlowRatio);
        }

        // Call the series of components that simulate a Unitary System
        if (this->ATMixerExists) {
            // There is an air terminal mixer
            if (this->ATMixerType == DataHVACGlobals::ATMixer_InletSide) { // if there is an inlet side air terminal mixer
                // set the primary air inlet mass flow rate
                state.dataLoopNodes->Node(this->m_ATMixerPriNode).MassFlowRate =
                    min(state.dataLoopNodes->Node(this->m_ATMixerPriNode).MassFlowRateMaxAvail, state.dataLoopNodes->Node(InletNode).MassFlowRate);
                // now calculate the the mixer outlet conditions (and the secondary air inlet flow rate)
                // the mixer outlet flow rate has already been set above (it is the "inlet" node flow rate)
                SingleDuct::SimATMixer(state, this->m_ATMixerName, FirstHVACIteration, this->m_ATMixerIndex);
            }
        }

        if (this->m_FanExists && this->m_FanPlace == FanPlace::BlowThru) {
            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                state.dataHVACFan->fanObjs[this->m_FanIndex]->simulate(state,
                                                                       _,
                                                                       _,
                                                                       _,
                                                                       _,
                                                                       state.dataUnitarySystems->m_massFlow1,
                                                                       state.dataUnitarySystems->m_runTimeFraction1,
                                                                       state.dataUnitarySystems->m_massFlow2,
                                                                       state.dataUnitarySystems->m_runTimeFraction2,
                                                                       _);
            } else {
                Fans::SimulateFanComponents(state, blankString, FirstHVACIteration, this->m_FanIndex, state.dataUnitarySystems->FanSpeedRatio);
            }
        }

        if (this->m_CoolingCoilUpstream) {

            if (this->m_CoolCoilExists) {
                this->calcUnitaryCoolingSystem(
                    state, AirLoopNum, FirstHVACIteration, CoolPLR, CoolingCompOn, OnOffAirFlowRatio, CoilCoolHeatRat, HXUnitOn);
            }
            if (this->m_HeatCoilExists) {
                // operate the heating coil without regard to coil outlet temperature
                this->calcUnitaryHeatingSystem(state, AirLoopNum, FirstHVACIteration, HeatPLR, HeatingCompOn, OnOffAirFlowRatio, HeatCoilLoad);
                if (state.dataLoopNodes->Node(this->HeatCoilOutletNodeNum).Temp > this->DesignMaxOutletTemp && !this->m_SimASHRAEModel) {
                    Real64 MDotAir = state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).MassFlowRate;
                    Real64 CpAir = Psychrometrics::PsyCpAirFnW(0.5 * (state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).HumRat +
                                                                      state.dataLoopNodes->Node(this->HeatCoilOutletNodeNum).HumRat));
                    Real64 HCDeltaT = this->DesignMaxOutletTemp - state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).Temp;
                    Real64 MaxHeatCoilLoad = MDotAir * CpAir * HCDeltaT;
                    this->calcUnitaryHeatingSystem(state, AirLoopNum, FirstHVACIteration, HeatPLR, HeatingCompOn, OnOffAirFlowRatio, MaxHeatCoilLoad);
                    HeatCoilLoad = MaxHeatCoilLoad;
                }
            }

            // If blow thru fan is used, the fan must be simulated after coil sets OnOffFanPartLoadFraction
            if (this->m_FanExists && this->m_FanPlace == FanPlace::BlowThru && state.dataHVACGlobal->OnOffFanPartLoadFraction < 1.0) {
                if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                    state.dataHVACFan->fanObjs[this->m_FanIndex]->simulate(state,
                                                                           _,
                                                                           _,
                                                                           _,
                                                                           _,
                                                                           state.dataUnitarySystems->m_massFlow1,
                                                                           state.dataUnitarySystems->m_runTimeFraction1,
                                                                           state.dataUnitarySystems->m_massFlow2,
                                                                           state.dataUnitarySystems->m_runTimeFraction2,
                                                                           _);
                } else {
                    Fans::SimulateFanComponents(state, blankString, FirstHVACIteration, this->m_FanIndex, state.dataUnitarySystems->FanSpeedRatio);
                }
                if (this->m_CoolCoilExists) {
                    this->calcUnitaryCoolingSystem(
                        state, AirLoopNum, FirstHVACIteration, CoolPLR, CoolingCompOn, OnOffAirFlowRatio, CoilCoolHeatRat, HXUnitOn);
                }
                if (this->m_HeatCoilExists) {
                    this->calcUnitaryHeatingSystem(state, AirLoopNum, FirstHVACIteration, HeatPLR, HeatingCompOn, OnOffAirFlowRatio, HeatCoilLoad);
                    if (state.dataLoopNodes->Node(this->HeatCoilOutletNodeNum).Temp > this->DesignMaxOutletTemp && !this->m_SimASHRAEModel) {
                        Real64 MDotAir = state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).MassFlowRate;
                        Real64 CpAir = Psychrometrics::PsyCpAirFnW(0.5 * (state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).HumRat +
                                                                          state.dataLoopNodes->Node(this->HeatCoilOutletNodeNum).HumRat));
                        Real64 HCDeltaT = this->DesignMaxOutletTemp - state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).Temp;
                        Real64 MaxHeatCoilLoad = MDotAir * CpAir * HCDeltaT;
                        this->calcUnitaryHeatingSystem(
                            state, AirLoopNum, FirstHVACIteration, HeatPLR, HeatingCompOn, OnOffAirFlowRatio, MaxHeatCoilLoad);
                    }
                }
            }

        } else {

            if (this->m_HeatCoilExists) {
                this->calcUnitaryHeatingSystem(state, AirLoopNum, FirstHVACIteration, HeatPLR, HeatingCompOn, OnOffAirFlowRatio, HeatCoilLoad);
                if (state.dataLoopNodes->Node(this->HeatCoilOutletNodeNum).Temp > this->DesignMaxOutletTemp && !this->m_SimASHRAEModel) {
                    Real64 MDotAir = state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).MassFlowRate;
                    Real64 CpAir = Psychrometrics::PsyCpAirFnW(0.5 * (state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).HumRat +
                                                                      state.dataLoopNodes->Node(this->HeatCoilOutletNodeNum).HumRat));
                    Real64 HCDeltaT = this->DesignMaxOutletTemp - state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).Temp;
                    Real64 MaxHeatCoilLoad = MDotAir * CpAir * HCDeltaT;
                    this->calcUnitaryHeatingSystem(state, AirLoopNum, FirstHVACIteration, HeatPLR, HeatingCompOn, OnOffAirFlowRatio, MaxHeatCoilLoad);
                }
            }
            if (this->m_CoolCoilExists) {
                this->calcUnitaryCoolingSystem(
                    state, AirLoopNum, FirstHVACIteration, CoolPLR, CoolingCompOn, OnOffAirFlowRatio, CoilCoolHeatRat, HXUnitOn);
            }

            // If blow thru fan is used, the fan must be simulated after coil sets OnOffFanPartLoadFraction
            if (this->m_FanExists && this->m_FanPlace == FanPlace::BlowThru && state.dataHVACGlobal->OnOffFanPartLoadFraction < 1.0) {
                if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                    state.dataHVACFan->fanObjs[this->m_FanIndex]->simulate(state,
                                                                           _,
                                                                           _,
                                                                           _,
                                                                           _,
                                                                           state.dataUnitarySystems->m_massFlow1,
                                                                           state.dataUnitarySystems->m_runTimeFraction1,
                                                                           state.dataUnitarySystems->m_massFlow2,
                                                                           state.dataUnitarySystems->m_runTimeFraction2,
                                                                           _);
                } else {
                    Fans::SimulateFanComponents(state, blankString, FirstHVACIteration, this->m_FanIndex, state.dataUnitarySystems->FanSpeedRatio);
                }
                if (this->m_HeatCoilExists) {
                    this->calcUnitaryHeatingSystem(state, AirLoopNum, FirstHVACIteration, HeatPLR, HeatingCompOn, OnOffAirFlowRatio, HeatCoilLoad);
                    if (state.dataLoopNodes->Node(this->HeatCoilOutletNodeNum).Temp > this->DesignMaxOutletTemp && !this->m_SimASHRAEModel) {
                        Real64 MDotAir = state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).MassFlowRate;
                        Real64 CpAir = Psychrometrics::PsyCpAirFnW(0.5 * (state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).HumRat +
                                                                          state.dataLoopNodes->Node(this->HeatCoilOutletNodeNum).HumRat));
                        Real64 HCDeltaT = this->DesignMaxOutletTemp - state.dataLoopNodes->Node(this->HeatCoilInletNodeNum).Temp;
                        Real64 MaxHeatCoilLoad = MDotAir * CpAir * HCDeltaT;
                        this->calcUnitaryHeatingSystem(
                            state, AirLoopNum, FirstHVACIteration, HeatPLR, HeatingCompOn, OnOffAirFlowRatio, MaxHeatCoilLoad);
                    }
                }
                if (this->m_CoolCoilExists) {
                    this->calcUnitaryCoolingSystem(
                        state, AirLoopNum, FirstHVACIteration, CoolPLR, CoolingCompOn, OnOffAirFlowRatio, CoilCoolHeatRat, HXUnitOn);
                }
            }
        }

        if (this->m_FanExists && this->m_FanPlace == FanPlace::DrawThru) {
            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                state.dataHVACFan->fanObjs[this->m_FanIndex]->simulate(state,
                                                                       _,
                                                                       _,
                                                                       _,
                                                                       _,
                                                                       state.dataUnitarySystems->m_massFlow1,
                                                                       state.dataUnitarySystems->m_runTimeFraction1,
                                                                       state.dataUnitarySystems->m_massFlow2,
                                                                       state.dataUnitarySystems->m_runTimeFraction2,
                                                                       _);
            } else {
                Fans::SimulateFanComponents(state, blankString, FirstHVACIteration, this->m_FanIndex, state.dataUnitarySystems->FanSpeedRatio);
            }
        }

        Real64 SuppPLR = this->m_SuppHeatPartLoadFrac;
        if (this->m_SuppCoilExists) {
            this->calcUnitarySuppHeatingSystem(state, FirstHVACIteration, SuppPLR, SuppCoilLoad);
            if ((state.dataLoopNodes->Node(this->m_SuppCoilAirOutletNode).Temp > this->DesignMaxOutletTemp) && SuppPLR > 0.0 &&
                !this->m_SimASHRAEModel) {
                Real64 MDotAir = state.dataLoopNodes->Node(this->m_SuppCoilAirInletNode).MassFlowRate;
                Real64 CpAir = Psychrometrics::PsyCpAirFnW(0.5 * (state.dataLoopNodes->Node(this->m_SuppCoilAirInletNode).HumRat +
                                                                  state.dataLoopNodes->Node(this->m_SuppCoilAirOutletNode).HumRat));
                Real64 HCDeltaT = max(0.0, this->DesignMaxOutletTemp - state.dataLoopNodes->Node(this->m_SuppCoilAirInletNode).Temp);
                Real64 MaxHeatCoilLoad = MDotAir * CpAir * HCDeltaT;
                this->calcUnitarySuppHeatingSystem(state, FirstHVACIteration, SuppPLR, MaxHeatCoilLoad);
                SuppCoilLoad = MaxHeatCoilLoad;
            }
        }

        // If there is a supply side air terminal mixer, calculate its output
        if (this->ATMixerExists) {
            if (this->ATMixerType == DataHVACGlobals::ATMixer_SupplySide) {
                SingleDuct::SimATMixer(state, this->m_ATMixerName, FirstHVACIteration, this->m_ATMixerIndex);
            }
        }

        calculateCapacity(state, SensOutput, LatOutput);
    }

    void UnitarySys::calculateCapacity(EnergyPlusData &state, Real64 &SensOutput, Real64 &LatOutput)
    {

        // Check delta T (outlet to reference temp), IF positive use reference HumRat ELSE outlet humrat to calculate
        // sensible capacity as MdotDeltaH at constant humidity ratio
        int OutletNode = this->AirOutNode;
        Real64 AirMassFlow = state.dataLoopNodes->Node(OutletNode).MassFlowRate;
        Real64 RefTemp = 0.0;
        Real64 RefHumRat = 0.0;
        if (this->m_ControlType == ControlType::Setpoint) {
            RefTemp = state.dataLoopNodes->Node(this->AirInNode).Temp;
            RefHumRat = state.dataLoopNodes->Node(this->AirInNode).HumRat;
        } else {
            RefTemp = state.dataLoopNodes->Node(this->NodeNumOfControlledZone).Temp;
            RefHumRat = state.dataLoopNodes->Node(this->NodeNumOfControlledZone).HumRat;
        }
        Real64 SensibleOutput(0.0); // sensible output rate, {W}
        Real64 LatentOutput(0.0);   // latent output rate, {W}
        Real64 TotalOutput(0.0);    // total output rate, {W}
        // calculate sensible load met
        if (this->ATMixerExists) {
            if (this->ATMixerType == DataHVACGlobals::ATMixer_SupplySide) {
                // Air terminal supply side mixer
                int ATMixOutNode = this->ATMixerOutNode;
                CalcZoneSensibleLatentOutput(state.dataLoopNodes->Node(ATMixOutNode).MassFlowRate,
                                             state.dataLoopNodes->Node(ATMixOutNode).Temp,
                                             state.dataLoopNodes->Node(ATMixOutNode).HumRat,
                                             RefTemp,
                                             RefHumRat,
                                             SensibleOutput,
                                             LatentOutput,
                                             TotalOutput);
                SensOutput = SensibleOutput - this->m_SenLoadLoss;
                if (this->m_Humidistat) {
                    LatOutput = LatentOutput - this->m_LatLoadLoss;
                } else {
                    LatOutput = 0.0;
                }
            } else {
                // Air terminal inlet side mixer
                CalcZoneSensibleLatentOutput(AirMassFlow,
                                             state.dataLoopNodes->Node(OutletNode).Temp,
                                             state.dataLoopNodes->Node(OutletNode).HumRat,
                                             RefTemp,
                                             RefHumRat,
                                             SensibleOutput,
                                             LatentOutput,
                                             TotalOutput);
                SensOutput = SensibleOutput - this->m_SenLoadLoss;
                if (this->m_Humidistat) {
                    LatOutput = LatentOutput - this->m_LatLoadLoss;
                } else {
                    LatOutput = 0.0;
                }
            }
        } else {
            // Calculate sensible load met
            CalcZoneSensibleLatentOutput(AirMassFlow,
                                         state.dataLoopNodes->Node(OutletNode).Temp,
                                         state.dataLoopNodes->Node(OutletNode).HumRat,
                                         RefTemp,
                                         RefHumRat,
                                         SensibleOutput,
                                         LatentOutput,
                                         TotalOutput);
            SensOutput = SensibleOutput - this->m_SenLoadLoss;
            if (this->m_Humidistat) {
                LatOutput = LatentOutput - this->m_LatLoadLoss;
            } else {
                LatOutput = 0.0;
            }
        }
        this->m_SensibleLoadMet = SensOutput;
        this->m_LatentLoadMet = LatOutput;
    }

    void UnitarySys::calcUnitaryCoolingSystem(EnergyPlusData &state,
                                              int const AirLoopNum,          // index to air loop
                                              bool const FirstHVACIteration, // True when first HVAC iteration
                                              Real64 const PartLoadRatio,    // coil operating part-load ratio
                                              int const CompOn,              // compressor control (0=off, 1=on)
                                              Real64 const OnOffAirFlowRatio,
                                              Real64 const CoilCoolHeatRat, // ratio of cooling to heating PLR for cycling fan RH control
                                              bool const HXUnitOn           // Flag to control HX for HXAssisted Cooling Coil
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine manages unitary cooling system component simulation.

        // Locals
        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        Real64 OutsideDryBulbTemp; // outdoor temperature (C)
        Real64 mdot;               // water side flow rate (kg/s)
        Real64 QActual;            // actual coil output (W)
        Real64 OutdoorPressure;    // Outdoor barometric pressure at condenser (Pa)
        bool errFlag;              // returned flag from called routine
        bool HeatingActive;        // dummy variable for UserDefined coil which are passed back indicating if coil is on or off. Not needed here since
                                   // coil is wrapped by UnitarySystem.
        bool CoolingActive;        // dummy variable for UserDefined coil which are passed back indicating if coil is on or off. Not needed here since
                                   // coil is wrapped by UnitarySystem.

        // Simulate the coil component
        std::string CompName = this->m_CoolingCoilName;
        int CompIndex = this->m_CoolingCoilIndex;
        Real64 CoilPLR = 1.0;
        if (this->m_CondenserNodeNum != 0) {
            OutdoorPressure = state.dataLoopNodes->Node(this->m_CondenserNodeNum).Press;
            // IF node is not connected to anything, pressure = default, use weather data
            if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press) {
                OutsideDryBulbTemp = state.dataEnvrn->OutDryBulbTemp;
                //      OutdoorHumRat   = OutHumRat
                //      OutdoorPressure = OutBaroPress
                //      OutdoorWetBulb  = OutWetBulbTemp
            } else {
                OutsideDryBulbTemp = state.dataLoopNodes->Node(this->m_CondenserNodeNum).Temp;
                //      OutdoorHumRat   = state.dataLoopNodes->Node(UnitarySystem(UnitarySysNum)%CondenserNodeNum)%HumRat
                //      OutdoorWetBulb  = PsyTwbFnTdbWPb(state, OutdoorDryBulb,OutdoorHumRat,OutdoorPressure,RoutineName)
            }
        } else {
            OutsideDryBulbTemp = state.dataEnvrn->OutDryBulbTemp;
            //    OutdoorHumRat   = OutHumRat
            //    OutdoorPressure = OutBaroPress
            //    OutdoorWetBulb  = OutWetBulbTemp
        }

        {
            auto const SELECT_CASE_var(this->m_CoolingCoilType_Num);

            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_CoolingSingleSpeed) { // Coil:Cooling:DX:SingleSpeed

                DXCoils::SimDXCoil(
                    state, blankString, CompOn, FirstHVACIteration, CompIndex, this->m_FanOpMode, PartLoadRatio, OnOffAirFlowRatio, CoilCoolHeatRat);
                this->m_CoolCompPartLoadRatio = PartLoadRatio * double(CompOn);

            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_Cooling) { // CoilCoolingDX

                bool const singleMode = (this->m_SingleMode == 1);
                if (this->m_ControlType == ControlType::Setpoint) {
                    if (this->m_CoolingSpeedNum > 1) {
                        CoilPLR = 1.0 * double(CompOn);
                    } else {
                        CoilPLR = PartLoadRatio * double(CompOn);
                    }
                } else {
                    if (state.dataUnitarySystems->CoolingLoad) {
                        if (this->m_CoolingSpeedNum > 1) {
                            if (!singleMode) {
                                CoilPLR = 1.0 * double(CompOn);
                                this->m_CoolingSpeedRatio = PartLoadRatio * double(CompOn);
                            } else {
                                CoilPLR = PartLoadRatio * double(CompOn);
                            }
                        } else {
                            CoilPLR = PartLoadRatio * double(CompOn);
                        }
                    } else {
                        CoilPLR = 0.0;
                    }
                }
                int OperationMode = DataHVACGlobals::coilNormalMode;
                if (state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].SubcoolReheatFlag) {
                    OperationMode = DataHVACGlobals::coilSubcoolReheatMode;
                } else if (this->m_DehumidificationMode == 1) {
                    OperationMode = DataHVACGlobals::coilEnhancedMode;
                }

                state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].simulate(
                    state, OperationMode, CoilPLR, this->m_CoolingSpeedNum, this->m_CoolingSpeedRatio, this->m_FanOpMode, singleMode, this->CoilSHR);

                if (this->m_CoolingSpeedNum > 1) {
                    if (this->m_SingleMode == 0) {
                        this->m_CoolCompPartLoadRatio = double(CompOn);
                    } else {
                        this->m_CoolCompPartLoadRatio = PartLoadRatio * double(CompOn);
                        // this->m_CoolingCycRatio = this->m_CoolingSpeedRatio;
                        this->m_CoolingSpeedRatio = 1.0;
                    }
                } else {
                    this->m_CoolCompPartLoadRatio = this->m_CoolingCycRatio * double(CompOn);
                    // this->m_CoolingCycRatio = this->m_CoolingSpeedRatio;
                    this->m_CoolingSpeedRatio = 0.0;
                }

            } else if ((SELECT_CASE_var == DataHVACGlobals::CoilDX_CoolingHXAssisted) ||
                       (SELECT_CASE_var == DataHVACGlobals::CoilWater_CoolingHXAssisted)) {

                if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilWater_CoolingHXAssisted) {
                    Real64 mdot = min(state.dataLoopNodes->Node(this->CoolCoilFluidOutletNodeNum).MassFlowRateMaxAvail,
                                      this->MaxCoolCoilFluidFlow * PartLoadRatio);
                    state.dataLoopNodes->Node(this->CoolCoilFluidInletNode).MassFlowRate = mdot;
                }
                HVACHXAssistedCoolingCoil::SimHXAssistedCoolingCoil(state,
                                                                    blankString,
                                                                    FirstHVACIteration,
                                                                    CompOn,
                                                                    PartLoadRatio,
                                                                    CompIndex,
                                                                    this->m_FanOpMode,
                                                                    HXUnitOn,
                                                                    OnOffAirFlowRatio,
                                                                    state.dataUnitarySystems->economizerFlag);
                if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted)
                    this->m_CoolCompPartLoadRatio = PartLoadRatio * double(CompOn);

            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_CoolingTwoSpeed) { // Coil:Cooling:DX:TwoSpeed
                // formerly (v3 and beyond)COIL:DX:MULTISPEED:COOLINGEMPIRICAL

                DXCoils::SimDXCoilMultiSpeed(state, blankString, this->m_CoolingSpeedRatio, this->m_CoolingCycRatio, CompIndex);
                if (this->m_CoolingSpeedRatio > 0.0) {
                    this->m_CoolCompPartLoadRatio = this->m_CoolingSpeedRatio * double(CompOn);
                } else {
                    this->m_CoolCompPartLoadRatio = this->m_CoolingCycRatio * double(CompOn);
                }

            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedCooling) { // Coil:Cooling:DX:Multispeed

                if (OutsideDryBulbTemp > this->m_MinOATCompressorCooling) {
                    DXCoils::SimDXCoilMultiSpeed(state,
                                                 CompName,
                                                 this->m_CoolingSpeedRatio,
                                                 this->m_CoolingCycRatio,
                                                 CompIndex,
                                                 this->m_CoolingSpeedNum,
                                                 this->m_FanOpMode,
                                                 CompOn,
                                                 this->m_SingleMode);
                    if (this->m_CoolingSpeedNum > 1) {
                        if (this->m_SingleMode == 0) {
                            this->m_CoolCompPartLoadRatio = double(CompOn);
                        } else {
                            this->m_CoolCompPartLoadRatio = this->m_CoolingCycRatio * double(CompOn);
                        }
                    } else {
                        this->m_CoolCompPartLoadRatio = this->m_CoolingCycRatio * double(CompOn);
                    }
                } else {
                    DXCoils::SimDXCoilMultiSpeed(state, CompName, 0.0, 0.0, CompIndex, this->m_CoolingSpeedNum, this->m_FanOpMode, CompOn);
                    this->m_CoolCompPartLoadRatio = 0.0;
                }

            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) {
                // formerly (v3 and beyond) COIL:DX:MULTIMODE:COOLINGEMPIRICAL

                DXCoils::SimDXCoilMultiMode(
                    state, CompName, CompOn, FirstHVACIteration, PartLoadRatio, this->m_DehumidificationMode, CompIndex, this->m_FanOpMode);
                this->m_CoolCompPartLoadRatio = PartLoadRatio * double(CompOn);

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_UserDefined) {

                HeatingActive = false; // set to arbitrary value on entry to function
                CoolingActive = false; // set to arbitrary value on entry to function

                UserDefinedComponents::SimCoilUserDefined(state, CompName, CompIndex, AirLoopNum, HeatingActive, CoolingActive);

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWater) || (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterDetailed)) {

                if (this->CoolCoilWaterFlowRatio == 0.0) {
                    mdot = this->MaxCoolCoilFluidFlow * PartLoadRatio;
                } else {
                    mdot = this->CoolCoilWaterFlowRatio * this->MaxCoolCoilFluidFlow;
                }
                state.dataLoopNodes->Node(this->CoolCoilFluidInletNode).MassFlowRate = mdot;
                WaterCoils::SimulateWaterCoilComponents(
                    state, CompName, FirstHVACIteration, this->m_CoolingCoilIndex, QActual, this->m_FanOpMode, PartLoadRatio);

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {
                if (this->m_CoolingSpeedNum > 1) {
                    CoilPLR = 1.0;
                } else {
                    CoilPLR = PartLoadRatio;
                }
                VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                          CompName,
                                                          CompIndex,
                                                          this->m_FanOpMode,
                                                          this->m_MaxONOFFCyclesperHour,
                                                          this->m_HPTimeConstant,
                                                          this->m_FanDelayTime,
                                                          CompOn,
                                                          CoilPLR,
                                                          this->m_CoolingSpeedNum,
                                                          this->m_CoolingSpeedRatio,
                                                          this->m_CoolingCoilSensDemand,
                                                          this->m_CoolingCoilLatentDemand,
                                                          OnOffAirFlowRatio);
                if (this->m_CoolingSpeedNum > 1) {
                    this->m_CoolCompPartLoadRatio = 1.0;
                } else {
                    this->m_CoolCompPartLoadRatio = PartLoadRatio * double(CompOn);
                }

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) {

                if (PartLoadRatio > 0.0 && this->m_WSHPRuntimeFrac > 0.0 && this->m_FanOpMode == DataHVACGlobals::CycFanCycCoil) {
                    state.dataHVACGlobal->OnOffFanPartLoadFraction = PartLoadRatio / this->m_WSHPRuntimeFrac;
                }

                WaterToAirHeatPumpSimple::SimWatertoAirHPSimple(state,
                                                                blankString,
                                                                this->m_CoolingCoilIndex,
                                                                this->m_CoolingCoilSensDemand,
                                                                this->m_CoolingCoilLatentDemand,
                                                                this->m_FanOpMode,
                                                                this->m_WSHPRuntimeFrac,
                                                                this->m_MaxONOFFCyclesperHour,
                                                                this->m_HPTimeConstant,
                                                                this->m_FanDelayTime,
                                                                CompOn,
                                                                PartLoadRatio,
                                                                FirstHVACIteration);

                this->m_CoolCompPartLoadRatio = PartLoadRatio * double(CompOn);

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterToAirHP) {

                this->heatPumpRunFrac(PartLoadRatio, errFlag, this->m_WSHPRuntimeFrac);

                if (PartLoadRatio > 0.0 && this->m_WSHPRuntimeFrac > 0.0 && this->m_FanOpMode == DataHVACGlobals::CycFanCycCoil) {
                    state.dataHVACGlobal->OnOffFanPartLoadFraction = PartLoadRatio / this->m_WSHPRuntimeFrac;
                }

                WaterToAirHeatPump::SimWatertoAirHP(state,
                                                    blankString,
                                                    this->m_CoolingCoilIndex,
                                                    this->MaxCoolAirMassFlow,
                                                    this->m_FanOpMode,
                                                    FirstHVACIteration,
                                                    this->m_WSHPRuntimeFrac,
                                                    this->m_MaxONOFFCyclesperHour,
                                                    this->m_HPTimeConstant,
                                                    this->m_FanDelayTime,
                                                    this->m_InitHeatPump,
                                                    this->m_CoolingCoilSensDemand,
                                                    this->m_CoolingCoilLatentDemand,
                                                    CompOn,
                                                    PartLoadRatio);

                this->m_CoolCompPartLoadRatio = PartLoadRatio * double(CompOn);

            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling) {

                PackagedThermalStorageCoil::SimTESCoil(
                    state, CompName, this->m_CoolingCoilIndex, this->m_FanOpMode, this->m_TESOpMode, PartLoadRatio);
            }
        }

        this->m_CoolingPartLoadFrac = PartLoadRatio;
    }

    void UnitarySys::calcUnitaryHeatingSystem(EnergyPlusData &state,
                                              int const AirLoopNum,           // index to air loop
                                              bool const FirstHVACIteration,  // True when first HVAC iteration
                                              Real64 const PartLoadRatio,     // coil operating part-load ratio
                                              int const CompOn,               // compressor control (0=off, 1=on)
                                              Real64 const OnOffAirFlowRatio, // ratio of on to off flow rate
                                              Real64 HeatCoilLoad             // adjusted heating coil load if outlet temp exceeds max (W)
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine manages unitary heating system component simulation.

        // Locals
        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        Real64 OutsideDryBulbTemp; // outdoor temperature (C)
        Real64 mdot;               // water side flow rate (kg/s)
        Real64 QActual;            // actual output of coil (W)
        Real64 OutdoorPressure;    // Outdoor barometric pressure at condenser (Pa)
        bool errFlag;              // returned flag from called routine
        bool HeatingActive;        // dummy variable for UserDefined coil which are passed back indicating if coil is on or off. Not needed here since
                                   // coil is wrapped by UnitarySystem.
        bool CoolingActive;        // dummy variable for UserDefined coil which are passed back indicating if coil is on or off. Not needed here since
                                   // coil is wrapped by UnitarySystem.

        std::string CompName = this->m_HeatingCoilName;
        Real64 dummy = 0.0;
        Real64 HeatPLR = 1.0;
        if (this->m_CondenserNodeNum != 0) {
            OutdoorPressure = state.dataLoopNodes->Node(this->m_CondenserNodeNum).Press;
            // IF node is not connected to anything, pressure = default, use weather data
            if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press) {
                OutsideDryBulbTemp = state.dataEnvrn->OutDryBulbTemp;
                //      OutdoorHumRat   = OutHumRat
                //      OutdoorPressure = OutBaroPress
                //      OutdoorWetBulb  = OutWetBulbTemp
            } else {
                OutsideDryBulbTemp = state.dataLoopNodes->Node(this->m_CondenserNodeNum).Temp;
                //      OutdoorHumRat   = state.dataLoopNodes->Node(UnitarySystem(UnitarySysNum)%CondenserNodeNum)%HumRat
                //      OutdoorWetBulb  = PsyTwbFnTdbWPb(state, OutdoorDryBulb,OutdoorHumRat,OutdoorPressure,RoutineName)
            }
        } else {
            OutsideDryBulbTemp = state.dataEnvrn->OutDryBulbTemp;
            //    OutdoorHumRat   = OutHumRat
            //    OutdoorPressure = OutBaroPress
            //    OutdoorWetBulb  = OutWetBulbTemp
        }

        {
            auto const SELECT_CASE_var(this->m_HeatingCoilType_Num);

            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_HeatingEmpirical) { // COIL:HEATING:DX:SINGLESPEED

                DXCoils::SimDXCoil(
                    state, CompName, CompOn, FirstHVACIteration, this->m_HeatingCoilIndex, this->m_FanOpMode, PartLoadRatio, OnOffAirFlowRatio);
                this->m_HeatCompPartLoadRatio = PartLoadRatio * double(CompOn);

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_UserDefined) {

                HeatingActive = false; // set to arbitrary value on entry to function
                CoolingActive = true;  // set to arbitrary value on entry to function

                UserDefinedComponents::SimCoilUserDefined(state, CompName, this->m_HeatingCoilIndex, AirLoopNum, HeatingActive, CoolingActive);

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGasOrOtherFuel) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric)) {
                HeatCoilLoad = PartLoadRatio * m_DesignHeatingCapacity;
                HeatingCoils::SimulateHeatingCoilComponents(
                    state, CompName, FirstHVACIteration, HeatCoilLoad, this->m_HeatingCoilIndex, _, false, this->m_FanOpMode, PartLoadRatio);
            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingDesuperheater) {
                HeatingCoils::SimulateHeatingCoilComponents(
                    state, CompName, FirstHVACIteration, HeatCoilLoad, this->m_HeatingCoilIndex, _, false, this->m_FanOpMode, PartLoadRatio);

            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedHeating) {

                if (OutsideDryBulbTemp > this->m_MinOATCompressorHeating) {
                    DXCoils::SimDXCoilMultiSpeed(state,
                                                 CompName,
                                                 this->m_HeatingSpeedRatio,
                                                 this->m_HeatingCycRatio,
                                                 this->m_HeatingCoilIndex,
                                                 this->m_HeatingSpeedNum,
                                                 this->m_FanOpMode,
                                                 CompOn,
                                                 this->m_SingleMode);
                    this->m_HeatCompPartLoadRatio = PartLoadRatio * double(CompOn);
                } else {
                    DXCoils::SimDXCoilMultiSpeed(
                        state, CompName, 0.0, 0.0, this->m_HeatingCoilIndex, this->m_HeatingSpeedNum, this->m_FanOpMode, CompOn);
                    this->m_HeatCompPartLoadRatio = 0.0;
                }

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric_MultiStage) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGas_MultiStage)) {
                HeatingCoils::SimulateHeatingCoilComponents(state,
                                                            CompName,
                                                            FirstHVACIteration,
                                                            _,
                                                            0,
                                                            _,
                                                            _,
                                                            this->m_FanOpMode,
                                                            PartLoadRatio,
                                                            this->m_HeatingSpeedNum,
                                                            this->m_HeatingSpeedRatio);
                this->m_HeatingCycRatio = PartLoadRatio;
            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWater) {
                if (this->HeatCoilWaterFlowRatio == 0.0) {
                    mdot = this->MaxHeatCoilFluidFlow * PartLoadRatio;
                } else {
                    mdot = this->HeatCoilWaterFlowRatio * this->MaxHeatCoilFluidFlow;
                }
                state.dataLoopNodes->Node(this->HeatCoilFluidInletNode).MassFlowRate = mdot;
                WaterCoils::SimulateWaterCoilComponents(
                    state, CompName, FirstHVACIteration, this->m_HeatingCoilIndex, QActual, this->m_FanOpMode, PartLoadRatio);
            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingSteam) {
                // this same CALL is made in the steam coil calc routine
                mdot =
                    min(state.dataLoopNodes->Node(this->HeatCoilFluidOutletNodeNum).MassFlowRateMaxAvail, this->MaxHeatCoilFluidFlow * PartLoadRatio);
                state.dataLoopNodes->Node(this->HeatCoilFluidInletNode).MassFlowRate = mdot;
                SteamCoils::SimulateSteamCoilComponents(state,
                                                        CompName,
                                                        FirstHVACIteration,
                                                        this->m_HeatingCoilIndex,
                                                        this->m_DesignHeatingCapacity * PartLoadRatio,
                                                        _,
                                                        this->m_FanOpMode,
                                                        PartLoadRatio);

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit)) {

                if (this->m_HeatingSpeedNum > 1) {
                    HeatPLR = 1.0;
                } else {
                    HeatPLR = PartLoadRatio;
                }
                VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                          CompName,
                                                          this->m_HeatingCoilIndex,
                                                          this->m_FanOpMode,
                                                          this->m_MaxONOFFCyclesperHour,
                                                          this->m_HPTimeConstant,
                                                          this->m_FanDelayTime,
                                                          CompOn,
                                                          HeatPLR,
                                                          this->m_HeatingSpeedNum,
                                                          this->m_HeatingSpeedRatio,
                                                          this->m_HeatingCoilSensDemand,
                                                          dummy,
                                                          OnOffAirFlowRatio);
                if (this->m_HeatingSpeedNum > 1) {
                    this->m_HeatCompPartLoadRatio = 1.0;
                } else {
                    this->m_HeatCompPartLoadRatio = PartLoadRatio * double(CompOn);
                }
            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple) {

                if (PartLoadRatio > 0.0 && this->m_WSHPRuntimeFrac > 0.0 && this->m_FanOpMode == DataHVACGlobals::CycFanCycCoil) {
                    state.dataHVACGlobal->OnOffFanPartLoadFraction = PartLoadRatio / this->m_WSHPRuntimeFrac;
                }

                WaterToAirHeatPumpSimple::SimWatertoAirHPSimple(state,
                                                                blankString,
                                                                this->m_HeatingCoilIndex,
                                                                this->m_HeatingCoilSensDemand,
                                                                dummy,
                                                                this->m_FanOpMode,
                                                                this->m_WSHPRuntimeFrac,
                                                                this->m_MaxONOFFCyclesperHour,
                                                                this->m_HPTimeConstant,
                                                                this->m_FanDelayTime,
                                                                CompOn,
                                                                PartLoadRatio,
                                                                FirstHVACIteration);
                this->m_HeatCompPartLoadRatio = PartLoadRatio * double(CompOn);

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHP) {

                this->heatPumpRunFrac(PartLoadRatio, errFlag, this->m_WSHPRuntimeFrac);

                if (PartLoadRatio > 0.0 && this->m_WSHPRuntimeFrac > 0.0 && this->m_FanOpMode == DataHVACGlobals::CycFanCycCoil) {
                    state.dataHVACGlobal->OnOffFanPartLoadFraction = PartLoadRatio / this->m_WSHPRuntimeFrac;
                }

                WaterToAirHeatPump::SimWatertoAirHP(state,
                                                    blankString,
                                                    this->m_HeatingCoilIndex,
                                                    this->MaxHeatAirMassFlow,
                                                    this->m_FanOpMode,
                                                    FirstHVACIteration,
                                                    this->m_WSHPRuntimeFrac,
                                                    this->m_MaxONOFFCyclesperHour,
                                                    this->m_HPTimeConstant,
                                                    this->m_FanDelayTime,
                                                    this->m_InitHeatPump,
                                                    this->m_HeatingCoilSensDemand,
                                                    dummy,
                                                    CompOn,
                                                    PartLoadRatio);
                this->m_HeatCompPartLoadRatio = PartLoadRatio * double(CompOn);

            } else {
                ShowFatalError(state,
                               "CalcUnitaryHeatingSystem: Invalid Unitary System coil type = " +
                                   DataHVACGlobals::cAllCoilTypes(this->m_HeatingCoilType_Num));
            }
        }

        this->m_HeatingPartLoadFrac = PartLoadRatio;
    }

    void UnitarySys::calcUnitarySuppHeatingSystem(EnergyPlusData &state,
                                                  bool const FirstHVACIteration, // True when first HVAC iteration
                                                  Real64 const PartLoadRatio,    // coil operating part-load ratio
                                                  Real64 const SuppCoilLoad      // adjusted supp coil load when outlet temp exceeds max (W)
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine manages supplemental heater simulation.

        // Locals
        // SUBROUTINE PARAMETER DEFINITIONS:
        int const MaxIte(500);   // Maximum number of iterations for solver
        Real64 const Acc(1.e-3); // Accuracy of solver result

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        // std::string CompName;    // Name of Unitary System object
        Real64 SuppHeatCoilLoad; // load passed to supplemental heating coil (W)
        Real64 QActual;          // actual coil output (W)
        Real64 mdot;             // water coil water mass flow rate (kg/s)
        std::vector<Real64> Par; // Parameter array passed to solver
        int SolFla;              // Flag of solver, num iterations if >0, else error index
        Real64 PartLoadFrac;     // temporary PLR variable

        Par.resize(5);
        // work is needed to figure out how to adjust other coil types if outlet temp exceeds maximum
        // this works for gas and electric heating coils
        std::string CompName = this->m_SuppHeatCoilName;
        if (state.dataEnvrn->OutDryBulbTemp <= this->m_MaxOATSuppHeat ||
            (state.dataUnitarySystems->MoistureLoad < 0.0 && this->m_CoolingPartLoadFrac > 0.0)) {
            SuppHeatCoilLoad = SuppCoilLoad;
            //} else {
            //    SuppHeatCoilLoad = this->m_DesignSuppHeatingCapacity * PartLoadRatio;
            //}
        } else {
            SuppHeatCoilLoad = 0.0;
        }

        {
            auto const SELECT_CASE_var(this->m_SuppHeatCoilType_Num);

            if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGasOrOtherFuel) || (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric)) {
                {
                    auto const SELECT_CASE_var1(this->m_ControlType);
                    if (SELECT_CASE_var1 == ControlType::Setpoint) {
                        HeatingCoils::SimulateHeatingCoilComponents(
                            state, CompName, FirstHVACIteration, _, this->m_SuppHeatCoilIndex, _, true, this->m_FanOpMode, PartLoadRatio);
                    } else {
                        HeatingCoils::SimulateHeatingCoilComponents(state,
                                                                    CompName,
                                                                    FirstHVACIteration,
                                                                    SuppHeatCoilLoad,
                                                                    this->m_SuppHeatCoilIndex,
                                                                    _,
                                                                    true,
                                                                    this->m_FanOpMode,
                                                                    PartLoadRatio);
                    }
                }
            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingDesuperheater) {
                HeatingCoils::SimulateHeatingCoilComponents(
                    state, CompName, FirstHVACIteration, SuppHeatCoilLoad, this->m_SuppHeatCoilIndex, _, true, this->m_FanOpMode, PartLoadRatio);

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWater) {
                // if (present(SuppCoilLoad)) {
                if (SuppHeatCoilLoad > 0.0) {
                    // see if HW coil has enough capacity to meet the load
                    mdot = min(state.dataLoopNodes->Node(this->m_SuppCoilFluidOutletNodeNum).MassFlowRateMaxAvail, this->m_MaxSuppCoilFluidFlow);
                    state.dataLoopNodes->Node(this->m_SuppCoilFluidInletNode).MassFlowRate = mdot;
                    //     simulate water coil to find operating capacity
                    WaterCoils::SimulateWaterCoilComponents(
                        state, this->m_SuppHeatCoilName, FirstHVACIteration, this->m_SuppHeatCoilIndex, QActual, this->m_FanOpMode, PartLoadRatio);
                    if (QActual > SuppHeatCoilLoad) {
                        Par[1] = double(this->m_UnitarySysNum);
                        if (FirstHVACIteration) {
                            Par[2] = 1.0;
                        } else {
                            Par[2] = 0.0;
                        }
                        Par[3] = SuppHeatCoilLoad;
                        Par[4] = 1.0; // SuppHeatingCoilFlag
                        Par[5] = 1.0; // Load based control
                        General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, &this->hotWaterHeatingCoilResidual, 0.0, 1.0, Par);
                        this->m_SuppHeatPartLoadFrac = PartLoadFrac;
                    } else {
                        this->m_SuppHeatPartLoadFrac = 1.0;
                    }
                }
                //} else {
                //    mdot = min(state.dataLoopNodes->Node(this->m_SuppCoilFluidOutletNodeNum).MassFlowRateMaxAvail, this->m_MaxSuppCoilFluidFlow *
                //    PartLoadRatio); state.dataLoopNodes->Node(this->m_SuppCoilFluidInletNode).MassFlowRate = mdot;

                //    WaterCoils::SimulateWaterCoilComponents(
                //        CompName, FirstHVACIteration, this->m_SuppHeatCoilIndex, QActual, this->m_FanOpMode, PartLoadRatio);
                //}
            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingSteam) {
                mdot = min(state.dataLoopNodes->Node(this->m_SuppCoilFluidOutletNodeNum).MassFlowRateMaxAvail,
                           this->m_MaxSuppCoilFluidFlow * PartLoadRatio);
                state.dataLoopNodes->Node(this->m_SuppCoilFluidInletNode).MassFlowRate = mdot;
                SteamCoils::SimulateSteamCoilComponents(
                    state, CompName, FirstHVACIteration, this->m_SuppHeatCoilIndex, SuppHeatCoilLoad, _, this->m_FanOpMode, PartLoadRatio);

            } else {
            }
        }

        //  UnitarySystem(UnitarySysNum)%SuppHeatPartLoadFrac = PartLoadRatio
    }

    void UnitarySys::controlCoolingSystemToSP(EnergyPlusData &state,
                                              int const AirLoopNum,          // index to air loop
                                              bool const FirstHVACIteration, // First HVAC iteration flag
                                              bool &HXUnitOn,                // flag to enable heat exchanger heat recovery
                                              int &CompOn                    // compressor on/off control
    )
    {
        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013
        //       MODIFIED       Nov. 2016, R. Zhang, LBNL. Applied the coil supply air temperature sensor offset fault model

        // PURPOSE OF THIS SUBROUTINE:
        //  Simulate the coil object at the required PLR.

        // METHODOLOGY EMPLOYED:
        //  Calculate operating PLR and adjust speed when using multispeed coils.
        //  Meet moisture load if required to do so.

        // Locals
        // SUBROUTINE PARAMETER DEFINITIONS:
        int const MaxIte(500);         // Maximum number of iterations for solver
        Real64 const Acc(1.e-3);       // Accuracy of solver result
        Real64 const HumRatAcc(1.e-6); // Accuracy of solver result

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        Real64 ReqOutput; // Sensible capacity (outlet - inlet) required to meet load or setpoint temperature
        // for variable speed or 2 speed compressors
        Real64 OutletTempDXCoil;     // Actual outlet temperature of the DX cooling coil
        Real64 OutletHumRatLS;       // Actual outlet humrat of the variable speed DX cooling coil at low speed
        Real64 OutletHumRatHS;       // Actual outlet humrat of the variable speed DX cooling coil at high speed
        Real64 OutletHumRatDXCoil;   // Actual outlet humidity ratio of the DX cooling coil
        std::vector<Real64> Par(14); // Parameter array passed to solver
        Real64 TempMinPLR;           // Used to find latent PLR when max iterations exceeded
        Real64 TempMaxPLR;           // Used to find latent PLR when max iterations exceeded
        Real64 TempOutletTempDXCoil; // Used to find latent PLR when max iterations exceeded
        Real64 OutletTemp;
        bool HeatingActive;     // dummy variable for UserDefined coil which are passed back indicating if coil is on or off.
        bool CoolingActive;     // dummy variable for UserDefined coil which are passed back indicating if coil is on or off.
        Real64 OutdoorDryBulb;  // local variable for OutDryBulbTemp
        Real64 maxPartLoadFrac; // calculated maximum water side PLR for RegulaFalsi call (when plant limits flow max PLR != 1)

        // Set local variables
        // Retrieve the load on the controlled zone
        int OutletNode = this->CoolCoilOutletNodeNum;
        int InletNode = this->CoolCoilInletNodeNum;
        Real64 DesOutTemp = this->m_DesiredOutletTemp;
        Real64 DesOutHumRat = this->m_DesiredOutletHumRat;
        int CoilType_Num = this->m_CoolingCoilType_Num;
        Real64 LoopDXCoilMaxRTFSave = 0.0;
        if (state.dataAirflowNetwork->SimulateAirflowNetwork > AirflowNetwork::AirflowNetworkControlMultizone) {
            LoopDXCoilMaxRTFSave = state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF;
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF = 0.0;
        }

        std::string CompName = this->m_CoolingCoilName;
        int FanOpMode = this->m_FanOpMode;
        Real64 SpeedRatio = 0.0;
        int SpeedNum = 0;
        Real64 CycRatio = 0.0;
        Real64 PartLoadFrac = 0.0;
        int DehumidMode = 0;
        bool SensibleLoad = false;
        bool LatentLoad = false;
        Real64 m_WSHPRuntimeFrac = 0.0;
        Real64 dummy = 0.0;
        Real64 SensLoad = 0.0;
        int SolFla = 0;
        int SolFlaLat = 0;
        Real64 NoLoadTempOut = 0.0;
        Real64 NoLoadHumRatOut = 0.0;
        // #8849, FullLoadHumRatOut set only at max speed
        Real64 FullLoadHumRatOut = 0.0;
        Real64 FullOutput = 0.0;        // Sensible capacity (outlet - inlet) when the compressor is on
        Real64 OnOffAirFlowRatio = 0.0; // Autodesk:Init Patch to prevent use uninitialized in calls to SimVariableSpeedCoils
        Real64 mdot = 0.0;              // water coil water flow rate [kg/s]

        if (this->m_CondenserNodeNum != 0) {
            OutdoorDryBulb = state.dataLoopNodes->Node(this->m_CondenserNodeNum).Temp;
        } else {
            OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
        }

        // Check the dehumidification control type. IF it's multimode, turn off the HX to find the sensible PLR. Then check to
        // see if the humidity load is met without the use of the HX. Always run the HX for the other modes.
        if (this->m_DehumidControlType_Num != DehumCtrlType::Multimode && this->m_CoolingCoilType_Num != DataHVACGlobals::CoilDX_Cooling) {
            HXUnitOn = true;
        } else {
            HXUnitOn = false;
        }

        // IF there is a fault of coil SAT Sensor
        if (this->m_FaultyCoilSATFlag) {
            // calculate the sensor offset using fault information
            int FaultIndex = this->m_FaultyCoilSATIndex;
            this->m_FaultyCoilSATOffset = state.dataFaultsMgr->FaultsCoilSATSensor(FaultIndex).CalFaultOffsetAct(state);
            // update the DesOutTemp
            DesOutTemp -= this->m_FaultyCoilSATOffset;
        }

        // IF UnitarySystem is scheduled on and there is flow
        if ((ScheduleManager::GetCurrentScheduleValue(state, this->m_SysAvailSchedPtr) > 0.0) &&
            ScheduleManager::GetCurrentScheduleValue(state, this->m_CoolingCoilAvailSchPtr) > 0.0 &&
            (state.dataLoopNodes->Node(InletNode).MassFlowRate > DataHVACGlobals::SmallAirVolFlow)) {

            bool unitSys = false;
            Real64 tempHumRatAcc = HumRatAcc;
            Real64 tempAcc = Acc;
            // Determine if there is a sensible load on this system
            if (this->m_sysType == SysType::CoilCoolingDX) {
                if ((state.dataLoopNodes->Node(InletNode).Temp > state.dataLoopNodes->Node(this->m_SystemCoolControlNodeNum).TempSetPoint) &&
                    (state.dataLoopNodes->Node(InletNode).Temp > DesOutTemp) &&
                    (std::abs(state.dataLoopNodes->Node(InletNode).Temp - DesOutTemp) > DataHVACGlobals::TempControlTol)) {
                    SensibleLoad = true;
                }
                tempAcc = 0.0;
                tempHumRatAcc = 0.0;
            } else {
                unitSys = true;
                if (state.dataLoopNodes->Node(InletNode).Temp - DesOutTemp > DataHVACGlobals::TempControlTol) SensibleLoad = true;
            }

            // if a heat pump and other coil is on, disable this coil
            if (this->m_HeatPump && this->m_HeatingPartLoadFrac > 0.0) SensibleLoad = false;

            // Determine if there is a latent load on this system - for future use to serve latent-only loads
            if (this->m_sysType == SysType::CoilCoolingDX) {
                if ((state.dataLoopNodes->Node(InletNode).HumRat > state.dataLoopNodes->Node(InletNode).HumRatMax) &&
                    (state.dataLoopNodes->Node(InletNode).HumRat > DesOutHumRat))
                    LatentLoad = true;
            } else {
                if (state.dataLoopNodes->Node(InletNode).HumRat > DesOutHumRat) LatentLoad = true;
            }

            // disable latent dehumidification if there is no sensible load and latent only is not allowed
            if (this->m_RunOnLatentOnlyWithSensible && !SensibleLoad) LatentLoad = false;

            // disable compressor if OAT is below minimum outdoor temperature
            if (OutdoorDryBulb < this->m_MinOATCompressorCooling) {
                SensibleLoad = false;
                LatentLoad = false;
            }

            // activate heat recovery loop coil if scheduled on and there is air flow
            if (this->m_WaterHRPlantLoopModel) {
                if (this->temperatureOffsetControlStatus == 1) {
                    PartLoadFrac = 1.0;
                    mdot = this->MaxCoolCoilFluidFlow;
                }
                PlantUtilities::SetComponentFlowRate(state,
                                                     mdot,
                                                     this->CoolCoilFluidInletNode,
                                                     this->CoolCoilFluidOutletNodeNum,
                                                     this->CoolCoilLoopNum,
                                                     this->CoolCoilLoopSide,
                                                     this->CoolCoilBranchNum,
                                                     this->CoolCoilCompNum);

                WaterCoils::SimulateWaterCoilComponents(
                    state, CompName, FirstHVACIteration, this->m_CoolingCoilIndex, _, this->m_FanOpMode, PartLoadFrac);
                SensibleLoad = false; // fall through remaining checks
                LatentLoad = false;
            } else if (this->m_TemperatureOffsetControlActive) {
                // disable waterside economizer if the condition is NOT favorable
                if (this->temperatureOffsetControlStatus == 0) {
                    SensibleLoad = false;
                    LatentLoad = false;
                    HXUnitOn = false;
                }
            }

            // IF DXCoolingSystem runs with a cooling load then set PartLoadFrac on Cooling System and the Mass Flow
            // Multimode coil will switch to enhanced dehumidification IF available and needed, but it
            // still runs to meet the sensible load. Multimode applies to Multimode or HXAssistedCooling coils.
            if ((SensibleLoad && this->m_RunOnSensibleLoad) || (LatentLoad && this->m_RunOnLatentLoad)) {
                // calculate sensible PLR, don't care IF latent is true here but need to gaurd for
                // when LatentLoad=TRUE and SensibleLoad=FALSE
                ReqOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                            Psychrometrics::PsyDeltaHSenFnTdb2W2Tdb1W1(DesOutTemp,
                                                                       state.dataLoopNodes->Node(OutletNode).HumRat,
                                                                       state.dataLoopNodes->Node(InletNode).Temp,
                                                                       state.dataLoopNodes->Node(InletNode).HumRat);

                PartLoadFrac = 0.0;
                CompOn = 0;

                if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed) { // COIL:DX:COOLINGBYPASSFACTOREMPIRICAL
                    this->m_CompPartLoadRatio = PartLoadFrac;

                    DXCoils::SimDXCoil(
                        state, CompName, state.dataUnitarySystems->On, FirstHVACIteration, this->m_CoolingCoilIndex, FanOpMode, PartLoadFrac);

                } else if ((CoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted) ||
                           (CoilType_Num == DataHVACGlobals::CoilWater_CoolingHXAssisted)) { // CoilSystem:Cooling:DX:HeatExchangerAssisted

                    if (this->CoolCoilFluidInletNode > 0) state.dataLoopNodes->Node(this->CoolCoilFluidInletNode).MassFlowRate = 0.0;

                    HVACHXAssistedCoolingCoil::SimHXAssistedCoolingCoil(state,
                                                                        CompName,
                                                                        FirstHVACIteration,
                                                                        state.dataUnitarySystems->On,
                                                                        PartLoadFrac,
                                                                        this->m_CoolingCoilIndex,
                                                                        FanOpMode,
                                                                        HXUnitOn,
                                                                        _,
                                                                        state.dataUnitarySystems->economizerFlag);
                    if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted) this->m_CompPartLoadRatio = PartLoadFrac;
                } else if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {

                    DXCoils::SimDXCoilMultiSpeed(state, CompName, 0.0, PartLoadFrac, this->m_CoolingCoilIndex);

                } else if (CoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling) {
                    if (this->m_EMSOverrideCoilSpeedNumOn) {
                        this->m_CoolingSpeedNum = ceil(this->m_EMSOverrideCoilSpeedNumValue);
                        this->m_SpeedNum = this->m_CoolingSpeedNum;
                        bool useMaxedSpeed = false;
                        if (this->m_SpeedNum > this->m_NumOfSpeedCooling) {
                            this->m_CoolingSpeedNum = this->m_NumOfSpeedCooling;
                            this->m_SpeedNum = this->m_NumOfSpeedCooling;
                            this->m_CoilSpeedErrIdx++;
                            useMaxedSpeed = true;
                            ShowRecurringWarningErrorAtEnd(
                                state,
                                "Wrong coil speed EMS override value, for unit=\"" + this->m_CoolingCoilName +
                                    "\". Exceeding maximum coil speed level. Speed level is set to the maximum coil speed level allowed.",
                                this->m_CoilSpeedErrIdx,
                                this->m_EMSOverrideCoilSpeedNumValue,
                                this->m_EMSOverrideCoilSpeedNumValue,
                                _,
                                "",
                                "");
                        }
                        if (this->m_CoolingSpeedNum == 1) {
                            this->m_CoolingSpeedRatio = 0.0;
                            this->m_CoolingCycRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                            if (useMaxedSpeed || this->m_CoolingCycRatio == 0) {
                                this->m_CoolingCycRatio = 1;
                            }
                        } else {
                            this->m_CoolingCycRatio = 1.0;
                            this->m_CoolingSpeedRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                            if (useMaxedSpeed || this->m_CoolingSpeedRatio == 0) {
                                this->m_CoolingSpeedRatio = 1;
                            }
                        }
                    }
                    this->simMultiSpeedCoils(state,
                                             AirLoopNum,
                                             FirstHVACIteration,
                                             CompOn,
                                             SensibleLoad,
                                             LatentLoad,
                                             PartLoadFrac,
                                             state.dataUnitarySystems->CoolingCoil,
                                             this->m_SpeedNum);

                } else if ((CoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) ||
                           (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {

                    this->m_CoolingCoilSensDemand = ReqOutput;
                    VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                              "",
                                                              this->m_CoolingCoilIndex,
                                                              FanOpMode,
                                                              this->m_MaxONOFFCyclesperHour,
                                                              this->m_HPTimeConstant,
                                                              this->m_FanDelayTime,
                                                              CompOn,
                                                              CycRatio,
                                                              SpeedNum,
                                                              SpeedRatio,
                                                              SensLoad,
                                                              dummy,
                                                              OnOffAirFlowRatio);

                } else if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) {

                    DXCoils::SimDXCoilMultiMode(state,
                                                CompName,
                                                state.dataUnitarySystems->On,
                                                FirstHVACIteration,
                                                PartLoadFrac,
                                                DehumidMode,
                                                this->m_CoolingCoilIndex,
                                                FanOpMode);
                    this->m_CompPartLoadRatio = PartLoadFrac;
                } else if (CoilType_Num == DataHVACGlobals::CoilDX_Cooling) { // CoilCoolingDX
                    // SP control (tentatively) operates at constant air flow regardless of speed
                    // speed n uses MSHPMassFlowRateHigh and speed n-1 uses MSHPMassFlowRateLow
                    state.dataHVACGlobal->MSHPMassFlowRateLow = this->m_DesignMassFlowRate;
                    state.dataHVACGlobal->MSHPMassFlowRateHigh = this->m_DesignMassFlowRate;
                    int OperationMode = DataHVACGlobals::coilNormalMode;
                    if (state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].SubcoolReheatFlag) {
                        OperationMode = DataHVACGlobals::coilSubcoolReheatMode;
                    } else if (this->m_DehumidificationMode == 1) {
                        OperationMode = DataHVACGlobals::coilEnhancedMode;
                    }
                    bool const singleMode = (this->m_SingleMode == 1);
                    state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].simulate(
                        state, OperationMode, PartLoadFrac, this->m_CoolingSpeedNum, this->m_CoolingSpeedRatio, this->m_FanOpMode, singleMode);
                    this->m_CoolCompPartLoadRatio = PartLoadFrac;
                } else if ((CoilType_Num == DataHVACGlobals::Coil_CoolingWater) ||
                           (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed)) { // COIL:COOLING:WATER

                    WaterCoils::SimulateWaterCoilComponents(
                        state, CompName, FirstHVACIteration, this->m_CoolingCoilIndex, _, this->m_FanOpMode, PartLoadFrac);

                } else if (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) {

                    WaterToAirHeatPumpSimple::SimWatertoAirHPSimple(state,
                                                                    blankString,
                                                                    this->m_CoolingCoilIndex,
                                                                    ReqOutput,
                                                                    dummy,
                                                                    FanOpMode,
                                                                    m_WSHPRuntimeFrac,
                                                                    this->m_MaxONOFFCyclesperHour,
                                                                    this->m_HPTimeConstant,
                                                                    this->m_FanDelayTime,
                                                                    0,
                                                                    PartLoadFrac,
                                                                    FirstHVACIteration);
                    this->m_CoolingCoilSensDemand = 0.0;

                } else if (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHP) {

                    WaterToAirHeatPump::SimWatertoAirHP(state,
                                                        blankString,
                                                        this->m_CoolingCoilIndex,
                                                        this->MaxCoolAirMassFlow,
                                                        FanOpMode,
                                                        FirstHVACIteration,
                                                        m_WSHPRuntimeFrac,
                                                        this->m_MaxONOFFCyclesperHour,
                                                        this->m_HPTimeConstant,
                                                        this->m_FanDelayTime,
                                                        this->m_InitHeatPump,
                                                        ReqOutput,
                                                        dummy,
                                                        0,
                                                        PartLoadFrac);

                } else if (CoilType_Num == DataHVACGlobals::Coil_UserDefined) {

                    HeatingActive = false; // set to arbitrary value on entry to function
                    CoolingActive = true;  // set to arbitrary value on entry to function
                    UserDefinedComponents::SimCoilUserDefined(state, CompName, this->m_CoolingCoilIndex, AirLoopNum, HeatingActive, CoolingActive);
                    if (CoolingActive) PartLoadFrac = 1.0;

                } else if (CoilType_Num == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling) {

                    PackagedThermalStorageCoil::SimTESCoil(state, CompName, this->m_CoolingCoilIndex, FanOpMode, this->m_TESOpMode, PartLoadFrac);

                } else {
                }

                //      NoOutput = state.dataLoopNodes->Node(InletNode)%MassFlowRate *  &
                //                   (PsyHFnTdbW(Node(OutletNode)%Temp,Node(OutletNode)%HumRat)  &
                //                    - PsyHFnTdbW(Node(InletNode)%Temp,Node(OutletNode)%HumRat))
                NoLoadTempOut = state.dataLoopNodes->Node(OutletNode).Temp;
                NoLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;

                Real64 NoOutput = 0.0; // CoilSystem:Cooling:DX
                Real64 ReqOutput = 0.0;
                FullOutput = 0.0;
                if (this->m_sysType == SysType::CoilCoolingDX) {
                    NoOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                               (Psychrometrics::PsyHFnTdbW(state.dataLoopNodes->Node(OutletNode).Temp, state.dataLoopNodes->Node(OutletNode).HumRat) -
                                Psychrometrics::PsyHFnTdbW(state.dataLoopNodes->Node(InletNode).Temp, state.dataLoopNodes->Node(OutletNode).HumRat));
                    ReqOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                                (Psychrometrics::PsyHFnTdbW(DesOutTemp, state.dataLoopNodes->Node(OutletNode).HumRat) -
                                 Psychrometrics::PsyHFnTdbW(state.dataLoopNodes->Node(InletNode).Temp, state.dataLoopNodes->Node(OutletNode).HumRat));
                }

                //     Changed logic to use temperature instead of load. The Psyc calcs can cause slight errors.
                //     For example it's possible that (NoOutput-ReqOutput) > Acc while (Node(OutletNode)%Temp-DesOutTemp) is not
                //     This can (and did) lead to RegulaFalsi errors

                //      IF ((NoOutput-ReqOutput) .LT. Acc) THEN
                //     IF outlet temp at no load is lower than DesOutTemp (set point), do not operate the coil
                //      and if coolReheat, check hum rat as well
                bool doIt = false; // CoilSystem:Cooling:DX
                if (this->m_sysType == SysType::CoilCoolingDX) {
                    if ((NoOutput - ReqOutput) < Acc) {
                        PartLoadFrac = 0.0;
                    } else {
                        doIt = true;
                    }
                } else if (((NoLoadTempOut - DesOutTemp) < Acc) && ((NoLoadHumRatOut - DesOutHumRat) < HumRatAcc)) {
                    PartLoadFrac = 0.0;
                } else {         // need to turn on compressor to see if load is met
                    doIt = true; // CoilSystem:Cooling:DX
                }                // CoilSystem:Cooling:DX

                if (doIt) { // CoilSystem:Cooling:DX
                    PartLoadFrac = 1.0;
                    CompOn = 1;
                    m_WSHPRuntimeFrac = 1.0;

                    if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed) { // COIL:DX:COOLINGBYPASSFACTOREMPIRICAL

                        DXCoils::SimDXCoil(
                            state, CompName, state.dataUnitarySystems->On, FirstHVACIteration, this->m_CoolingCoilIndex, FanOpMode, PartLoadFrac);
                        this->m_CompPartLoadRatio = PartLoadFrac;
                        FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;

                    } else if ((CoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted) ||
                               (CoilType_Num == DataHVACGlobals::CoilWater_CoolingHXAssisted)) { // CoilSystem:Cooling:DX:HeatExchangerAssisted

                        if (this->CoolCoilFluidInletNode > 0)
                            state.dataLoopNodes->Node(this->CoolCoilFluidInletNode).MassFlowRate = max(0.0, this->MaxCoolCoilFluidFlow);
                        HVACHXAssistedCoolingCoil::SimHXAssistedCoolingCoil(state,
                                                                            CompName,
                                                                            FirstHVACIteration,
                                                                            state.dataUnitarySystems->On,
                                                                            PartLoadFrac,
                                                                            this->m_CoolingCoilIndex,
                                                                            FanOpMode,
                                                                            HXUnitOn,
                                                                            _,
                                                                            state.dataUnitarySystems->economizerFlag);

                        if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted) this->m_CompPartLoadRatio = PartLoadFrac;
                        FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;

                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {

                        CycRatio = 1.0;
                        for (int speedRatio = 0; speedRatio < this->m_NumOfSpeedCooling; ++speedRatio) {
                            SpeedRatio = Real64(speedRatio);
                            DXCoils::SimDXCoilMultiSpeed(state, CompName, SpeedRatio, CycRatio, this->m_CoolingCoilIndex);
                            OutletTemp = state.dataDXCoils->DXCoilOutletTemp(this->m_CoolingCoilIndex);
                            if (SpeedRatio == 1) {
                                FullLoadHumRatOut = state.dataDXCoils->DXCoilOutletHumRat(this->m_CoolingCoilIndex);
                                break;
                            }
                            if (OutletTemp < DesOutTemp && SensibleLoad) break;
                        }

                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling) {

                        CycRatio = 1.0;
                        SpeedRatio = 0.0;
                        if (this->m_EMSOverrideCoilSpeedNumOn) {
                            this->m_CoolingSpeedNum = ceil(this->m_EMSOverrideCoilSpeedNumValue);
                            SpeedNum = this->m_CoolingSpeedNum;

                            if (this->m_CoolingSpeedNum == 1) {
                                this->m_CoolingSpeedRatio = SpeedRatio = 0.0;
                                CycRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                                if (CycRatio == 0) {
                                    this->m_CoolingCycRatio = 1;
                                } else {
                                    this->m_CoolingCycRatio = CycRatio;
                                }
                            } else {
                                this->m_CoolingCycRatio = CycRatio = 1.0;
                                SpeedRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                                if (SpeedRatio == 0) {
                                    this->m_CoolingSpeedRatio = 1;
                                } else {
                                    this->m_CoolingSpeedRatio = SpeedRatio;
                                }
                            }
                            if (SpeedNum > this->m_NumOfSpeedCooling) {
                                this->m_CoolingSpeedNum = this->m_NumOfSpeedCooling;
                                SpeedNum = this->m_NumOfSpeedCooling;
                                this->m_CoolingCycRatio = CycRatio = 1.0;
                                if (this->m_CoolingSpeedNum == 1) {
                                    this->m_CoolingSpeedRatio = SpeedRatio = 0.0;
                                } else {
                                    this->m_CoolingSpeedRatio = SpeedRatio = 1.0;
                                }
                            }

                            this->simMultiSpeedCoils(state,
                                                     AirLoopNum,
                                                     FirstHVACIteration,
                                                     CompOn,
                                                     SensibleLoad,
                                                     LatentLoad,
                                                     PartLoadFrac,
                                                     state.dataUnitarySystems->CoolingCoil,
                                                     SpeedNum);
                            OutletTemp = state.dataLoopNodes->Node(OutletNode).Temp;
                            if (SpeedNum == this->m_NumOfSpeedCooling) {
                                FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;
                            }
                        } else {
                            for (SpeedNum = 1; SpeedNum <= this->m_NumOfSpeedCooling; ++SpeedNum) {
                                if (SpeedNum > 1) CycRatio = 0.0;
                                if (SpeedNum > 1) SpeedRatio = 1.0;
                                this->m_CoolingSpeedNum = SpeedNum;
                                this->simMultiSpeedCoils(state,
                                                         AirLoopNum,
                                                         FirstHVACIteration,
                                                         CompOn,
                                                         SensibleLoad,
                                                         LatentLoad,
                                                         PartLoadFrac,
                                                         state.dataUnitarySystems->CoolingCoil,
                                                         SpeedNum);
                                OutletTemp = state.dataLoopNodes->Node(OutletNode).Temp;
                                if (SpeedNum == this->m_NumOfSpeedCooling) {
                                    FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;
                                }
                                if (OutletTemp < DesOutTemp && SensibleLoad) break;
                            }
                        }

                    } else if ((CoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) ||
                               (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {

                        CycRatio = 1.0;
                        SpeedRatio = 1.0;
                        SensLoad = -1.0; // turns on coil
                        this->m_CoolingSpeedRatio = SpeedRatio;
                        this->m_CoolingPartLoadFrac = PartLoadFrac;
                        for (SpeedNum = 1; SpeedNum <= this->m_NumOfSpeedCooling; ++SpeedNum) {
                            this->m_CoolingSpeedNum = SpeedNum;
                            VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                                      "",
                                                                      this->m_CoolingCoilIndex,
                                                                      FanOpMode,
                                                                      this->m_MaxONOFFCyclesperHour,
                                                                      this->m_HPTimeConstant,
                                                                      this->m_FanDelayTime,
                                                                      CompOn,
                                                                      CycRatio,
                                                                      SpeedNum,
                                                                      SpeedRatio,
                                                                      SensLoad,
                                                                      dummy,
                                                                      OnOffAirFlowRatio);
                            OutletTemp = state.dataLoopNodes->Node(OutletNode).Temp;
                            if (SpeedNum == this->m_NumOfSpeedCooling) {
                                FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;
                            }
                            if (OutletTemp < DesOutTemp && SensibleLoad) break;
                        }
                        if (SpeedNum == 1) {
                            CycRatio = 1.0;
                            SpeedRatio = 0.0;
                        } else {
                            CycRatio = 0.0;
                            SpeedRatio = 1.0;
                        }

                    } else if (CoilType_Num ==
                               DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) { // Coil:Cooling:DX:TwoStageWithHumidityControlMode

                        DXCoils::SimDXCoilMultiMode(state,
                                                    CompName,
                                                    state.dataUnitarySystems->On,
                                                    FirstHVACIteration,
                                                    PartLoadFrac,
                                                    DehumidMode,
                                                    this->m_CoolingCoilIndex,
                                                    FanOpMode);
                        this->m_CompPartLoadRatio = PartLoadFrac;

                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_Cooling) { // CoilCoolingDX
                        int OperationMode = DataHVACGlobals::coilNormalMode;
                        if (state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].SubcoolReheatFlag) {
                            OperationMode = DataHVACGlobals::coilSubcoolReheatMode;
                        } else if (this->m_DehumidificationMode == 1) {
                            OperationMode = DataHVACGlobals::coilEnhancedMode;
                        }
                        this->m_CoolingSpeedRatio = 1.0;
                        bool const singleMode = (this->m_SingleMode == 1);
                        for (int speedNum = 1; speedNum <= this->m_NumOfSpeedCooling; speedNum++) {
                            this->m_CoolingSpeedNum = speedNum;
                            state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].simulate(state,
                                                                                                      OperationMode,
                                                                                                      PartLoadFrac,
                                                                                                      this->m_CoolingSpeedNum,
                                                                                                      this->m_CoolingSpeedRatio,
                                                                                                      this->m_FanOpMode,
                                                                                                      singleMode);
                            if (speedNum == this->m_NumOfSpeedCooling) {
                                FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;
                            }
                            if ((state.dataLoopNodes->Node(OutletNode).Temp - DesOutTemp) < Acc) break;
                        }
                        if (this->m_CoolingSpeedNum == 1) {
                            this->m_CompPartLoadRatio = PartLoadFrac;
                            this->m_CoolCompPartLoadRatio = PartLoadFrac; // why is the set only for a few?
                            SpeedRatio = 0.0;
                        } else {
                            SpeedRatio = PartLoadFrac;
                            PartLoadFrac = 1.0;
                            this->m_CompPartLoadRatio = 1.0;
                            this->m_CoolCompPartLoadRatio = 1.0;
                        }
                    } else if ((CoilType_Num == DataHVACGlobals::Coil_CoolingWater) ||
                               (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed)) { // COIL:COOLING:WATER

                        mdot = this->MaxCoolCoilFluidFlow;
                        PlantUtilities::SetComponentFlowRate(state,
                                                             mdot,
                                                             this->CoolCoilFluidInletNode,
                                                             this->CoolCoilFluidOutletNodeNum,
                                                             this->CoolCoilLoopNum,
                                                             this->CoolCoilLoopSide,
                                                             this->CoolCoilBranchNum,
                                                             this->CoolCoilCompNum);

                        WaterCoils::SimulateWaterCoilComponents(
                            state, CompName, FirstHVACIteration, this->m_CoolingCoilIndex, _, this->m_FanOpMode, PartLoadFrac);
                        FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;

                    } else if (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) {

                        WaterToAirHeatPumpSimple::SimWatertoAirHPSimple(state,
                                                                        blankString,
                                                                        this->m_CoolingCoilIndex,
                                                                        ReqOutput,
                                                                        dummy,
                                                                        FanOpMode,
                                                                        m_WSHPRuntimeFrac,
                                                                        this->m_MaxONOFFCyclesperHour,
                                                                        this->m_HPTimeConstant,
                                                                        this->m_FanDelayTime,
                                                                        1,
                                                                        PartLoadFrac,
                                                                        FirstHVACIteration);
                        this->m_CoolingCoilSensDemand = ReqOutput;
                        FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;

                    } else if (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHP) {

                        WaterToAirHeatPump::SimWatertoAirHP(state,
                                                            blankString,
                                                            this->m_CoolingCoilIndex,
                                                            this->MaxCoolAirMassFlow,
                                                            FanOpMode,
                                                            FirstHVACIteration,
                                                            m_WSHPRuntimeFrac,
                                                            this->m_MaxONOFFCyclesperHour,
                                                            this->m_HPTimeConstant,
                                                            this->m_FanDelayTime,
                                                            this->m_InitHeatPump,
                                                            ReqOutput,
                                                            dummy,
                                                            0,
                                                            PartLoadFrac);
                        FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;

                    } else if (CoilType_Num == DataHVACGlobals::Coil_UserDefined) {
                        HeatingActive = false; // set to arbitrary value on entry to function
                        CoolingActive = false; // set to arbitrary value on entry to function

                        UserDefinedComponents::SimCoilUserDefined(
                            state, CompName, this->m_CoolingCoilIndex, AirLoopNum, HeatingActive, CoolingActive);
                        if (CoolingActive) PartLoadFrac = 1.0;

                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling) {

                        // TES coil simulated above with PLR=0. Operating mode is known here, no need to simulate again to determine operating
                        // mode.
                        if (this->m_TESOpMode == PackagedThermalStorageCoil::OffMode ||
                            this->m_TESOpMode == PackagedThermalStorageCoil::ChargeOnlyMode) { // cannot cool
                            PartLoadFrac = 0.0;
                        } else {
                            // Get full load result
                            PackagedThermalStorageCoil::SimTESCoil(
                                state, CompName, this->m_CoolingCoilIndex, FanOpMode, this->m_TESOpMode, PartLoadFrac);
                        }

                    } else {
                    }

                    ReqOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                                (Psychrometrics::PsyHFnTdbW(DesOutTemp, state.dataLoopNodes->Node(OutletNode).HumRat) -
                                 Psychrometrics::PsyHFnTdbW(state.dataLoopNodes->Node(InletNode).Temp, state.dataLoopNodes->Node(OutletNode).HumRat));
                    FullOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                                 Psychrometrics::PsyDeltaHSenFnTdb2W2Tdb1W1(state.dataLoopNodes->Node(OutletNode).Temp,
                                                                            state.dataLoopNodes->Node(OutletNode).HumRat,
                                                                            state.dataLoopNodes->Node(InletNode).Temp,
                                                                            state.dataLoopNodes->Node(InletNode).HumRat);
                }

                //        IF ((FullOutput - ReqOutput) .GT. Acc) THEN ! old method
                //        IF ((Node(OutletNode)%Temp-DesOutTemp) .GT. Acc) THEN ! new method gets caught when temps are very close
                if (this->m_sysType == SysType::CoilCoolingDX) {
                    if ((FullOutput - ReqOutput) > tempAcc) {
                        PartLoadFrac = 1.0;
                        doIt = false;
                    } else {
                        doIt = true;
                    }
                }
                if (this->m_EMSOverrideCoilSpeedNumOn) doIt = false;

                if (doIt) {
                    if (unitSys && state.dataLoopNodes->Node(OutletNode).Temp > DesOutTemp - tempAcc) {
                        PartLoadFrac = 1.0;
                        if (CoilType_Num == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling &&
                            (this->m_TESOpMode == PackagedThermalStorageCoil::OffMode ||
                             this->m_TESOpMode == PackagedThermalStorageCoil::ChargeOnlyMode)) {
                            PartLoadFrac = 0.0;
                        }
                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling &&
                               (this->m_TESOpMode == PackagedThermalStorageCoil::OffMode ||
                                this->m_TESOpMode == PackagedThermalStorageCoil::ChargeOnlyMode)) {
                        PartLoadFrac = 0.0;
                    } else if (!SensibleLoad) {
                        PartLoadFrac = 0.0;
                    } else if (SensibleLoad) {

                        Par[9] = double(AirLoopNum);
                        Par[10] = 0.0;
                        if (FirstHVACIteration) Par[10] = 1.0;

                        if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed) {

                            Par[1] = double(this->m_CoolingCoilIndex);
                            Par[2] = DesOutTemp;
                            Par[5] = double(FanOpMode);
                            General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->DOE2DXCoilResidual, 0.0, 1.0, Par);
                            this->m_CompPartLoadRatio = PartLoadFrac;

                        } else if ((CoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted) ||
                                   (CoilType_Num == DataHVACGlobals::CoilWater_CoolingHXAssisted)) {

                            Par[1] = double(this->m_CoolingCoilIndex);
                            Par[2] = DesOutTemp;
                            // FirstHVACIteration is a logical, Par is REAL(r64), so make TRUE = 1 and FALSE = 0
                            if (FirstHVACIteration) {
                                Par[3] = 1.0;
                            } else {
                                Par[3] = 0.0;
                            }
                            if (HXUnitOn) {
                                Par[4] = 1.0;
                            } else {
                                Par[4] = 0.0;
                            }
                            Par[5] = double(FanOpMode);
                            Par[6] = double(this->m_UnitarySysNum);
                            General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->HXAssistedCoolCoilTempResidual, 0.0, 1.0, Par);
                            if (SolFla == -1) {

                                //                 RegulaFalsi may not find sensible PLR when the latent degradation model is used.
                                //                 IF iteration limit is exceeded, find tighter boundary of solution and repeat RegulaFalsi
                                TempMaxPLR = -0.1;
                                TempOutletTempDXCoil = state.dataLoopNodes->Node(InletNode).Temp;
                                while ((TempOutletTempDXCoil - DesOutTemp) > 0.0 && TempMaxPLR <= 1.0) {
                                    //                   find upper limit of PLR
                                    TempMaxPLR += 0.1;
                                    HVACHXAssistedCoolingCoil::SimHXAssistedCoolingCoil(state,
                                                                                        CompName,
                                                                                        FirstHVACIteration,
                                                                                        state.dataUnitarySystems->On,
                                                                                        TempMaxPLR,
                                                                                        this->m_CoolingCoilIndex,
                                                                                        FanOpMode,
                                                                                        HXUnitOn,
                                                                                        _,
                                                                                        state.dataUnitarySystems->economizerFlag);
                                    TempOutletTempDXCoil = state.dataHVACAssistedCC->HXAssistedCoilOutletTemp(this->m_CoolingCoilIndex);
                                }
                                TempMinPLR = TempMaxPLR;
                                while ((TempOutletTempDXCoil - DesOutTemp) < 0.0 && TempMinPLR >= 0.0) {
                                    // pull upper limit of PLR DOwn to last valid limit (i.e. outlet temp still exceeds DesOutTemp)
                                    TempMaxPLR = TempMinPLR;
                                    // find minimum limit of PLR
                                    TempMinPLR -= 0.01;
                                    HVACHXAssistedCoolingCoil::SimHXAssistedCoolingCoil(state,
                                                                                        CompName,
                                                                                        FirstHVACIteration,
                                                                                        state.dataUnitarySystems->On,
                                                                                        TempMinPLR,
                                                                                        this->m_CoolingCoilIndex,
                                                                                        FanOpMode,
                                                                                        HXUnitOn,
                                                                                        _,
                                                                                        state.dataUnitarySystems->economizerFlag);
                                    TempOutletTempDXCoil = state.dataHVACAssistedCC->HXAssistedCoilOutletTemp(this->m_CoolingCoilIndex);
                                }
                                // Relax boundary slightly to assure a solution can be found using RegulaFalsi (i.e. one boundary may
                                // be very near the desired result)
                                TempMinPLR = max(0.0, (TempMinPLR - 0.01));
                                TempMaxPLR = min(1.0, (TempMaxPLR + 0.01));
                                //                 tighter boundary of solution has been found, CALL RegulaFalsi a second time
                                General::SolveRoot(
                                    state, Acc, MaxIte, SolFla, PartLoadFrac, this->HXAssistedCoolCoilTempResidual, TempMinPLR, TempMaxPLR, Par);
                                if (SolFla == -1) {
                                    if (!state.dataGlobal->WarmupFlag) {
                                        if (this->warnIndex.m_HXAssistedSensPLRIter < 1) {
                                            ++this->warnIndex.m_HXAssistedSensPLRIter;
                                            ShowWarningError(
                                                state,
                                                this->UnitType +
                                                    " - Iteration limit exceeded calculating DX unit sensible part-load ratio for unit = " +
                                                    this->Name);
                                            ShowContinueError(state, format("Estimated part-load ratio   = {:.3R}", (ReqOutput / FullOutput)));
                                            ShowContinueError(state, format("Calculated part-load ratio = {:.3R}", PartLoadFrac));
                                            ShowContinueErrorTimeStamp(
                                                state, "The calculated part-load ratio will be used and the simulation continues. Occurrence info:");
                                        }
                                        ShowRecurringWarningErrorAtEnd(state,
                                                                       this->UnitType + " \"" + this->Name +
                                                                           "\" - Iteration limit exceeded calculating sensible part-load ratio "
                                                                           "error continues. Sensible PLR "
                                                                           "statistics follow.",
                                                                       this->warnIndex.m_HXAssistedSensPLRIterIndex,
                                                                       PartLoadFrac,
                                                                       PartLoadFrac);
                                    }
                                } else if (SolFla == -2) {
                                    PartLoadFrac = ReqOutput / FullOutput;
                                    if (!state.dataGlobal->WarmupFlag) {
                                        if (this->warnIndex.m_HXAssistedSensPLRFail < 1) {
                                            ++this->warnIndex.m_HXAssistedSensPLRFail;
                                            ShowWarningError(
                                                state,
                                                this->UnitType +
                                                    " - DX unit sensible part-load ratio calculation unexpectedly failed: part-load ratio "
                                                    "limits exceeded, for unit = " +
                                                    this->Name);
                                            ShowContinueError(state, format("Estimated part-load ratio = {:.3R}", PartLoadFrac));
                                            ShowContinueErrorTimeStamp(
                                                state, "The estimated part-load ratio will be used and the simulation continues. Occurrence info:");
                                        }
                                        ShowRecurringWarningErrorAtEnd(state,
                                                                       this->UnitType + " \"" + this->Name +
                                                                           "\" - DX unit sensible part-load ratio calculation unexpectedly "
                                                                           "failed error continues. Sensible PLR "
                                                                           "statistics follow.",
                                                                       this->warnIndex.m_HXAssistedSensPLRFailIndex,
                                                                       PartLoadFrac,
                                                                       PartLoadFrac);
                                    }
                                }
                            } else if (SolFla == -2) {
                                PartLoadFrac = ReqOutput / FullOutput;
                                if (!state.dataGlobal->WarmupFlag) {
                                    if (this->warnIndex.m_HXAssistedSensPLRFail2 < 1) {
                                        ++this->warnIndex.m_HXAssistedSensPLRFail2;
                                        ShowWarningError(state,
                                                         this->UnitType +
                                                             " - DX unit sensible part-load ratio calculation failed: part-load ratio limits "
                                                             "exceeded, for unit = " +
                                                             this->Name);
                                        ShowContinueError(state, format("Estimated part-load ratio = {:.3R}", PartLoadFrac));
                                        ShowContinueErrorTimeStamp(
                                            state, "The estimated part-load ratio will be used and the simulation continues. Occurrence info:");
                                    }
                                    ShowRecurringWarningErrorAtEnd(state,
                                                                   this->UnitType + " \"" + this->Name +
                                                                       "\" - DX unit sensible part-load ratio calculation failed error continues. "
                                                                       "Sensible PLR statistics follow.",
                                                                   this->warnIndex.m_HXAssistedSensPLRFailIndex2,
                                                                   PartLoadFrac,
                                                                   PartLoadFrac);
                                }
                            }
                            if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted) this->m_CompPartLoadRatio = PartLoadFrac;

                        } else if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {
                            Par[1] = double(this->m_CoolingCoilIndex);
                            Par[2] = DesOutTemp;
                            // Par(3) is only needed for variable speed coils (see DXCoilVarSpeedResidual and DXCoilCyclingResidual)
                            Par[3] = double(this->m_UnitarySysNum);
                            this->m_CoolingSpeedRatio = SpeedRatio;
                            if (SpeedRatio == 1.0) {
                                General::SolveRoot(state, Acc, MaxIte, SolFla, SpeedRatio, this->DXCoilVarSpeedResidual, 0.0, 1.0, Par);
                                PartLoadFrac = SpeedRatio;
                            } else {
                                General::SolveRoot(state, Acc, MaxIte, SolFla, CycRatio, this->DXCoilCyclingResidual, 0.0, 1.0, Par);
                                PartLoadFrac = CycRatio;
                            }

                        } else if (CoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling) {

                            Par[1] = double(this->m_CoolingCoilIndex);
                            Par[2] = DesOutTemp;
                            Par[3] = double(this->m_UnitarySysNum);
                            // Par[4] = CycRatio or SpeedRatio
                            Par[5] = this->m_CoolingSpeedNum;
                            Par[6] = 1.0; // UnitarySystem(UnitarySysNum)%FanOpMode
                            Par[7] = 1.0; // CompOp
                            Par[8] = ReqOutput;

                            if (this->m_CoolingSpeedNum > 1.0) {
                                Par[4] = CycRatio;
                                General::SolveRoot(state, Acc, MaxIte, SolFla, SpeedRatio, this->DXCoilVarSpeedResidual, 0.0, 1.0, Par);
                                PartLoadFrac = SpeedRatio;
                            } else {
                                SpeedRatio = 0.0;
                                this->m_CoolingSpeedRatio = SpeedRatio;
                                Par[4] = SpeedRatio;
                                General::SolveRoot(state, Acc, MaxIte, SolFla, CycRatio, this->DXCoilCyclingResidual, 0.0, 1.0, Par);
                                PartLoadFrac = CycRatio;
                            }

                        } else if ((CoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) ||
                                   (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {

                            CycRatio = 1.0;
                            SpeedRatio = 1.0;
                            Par[1] = double(this->m_CoolingCoilIndex);
                            Par[2] = DesOutTemp;
                            Par[3] = double(this->m_UnitarySysNum);
                            // Par[4] = CycRatio or SpeedRatio
                            Par[5] = this->m_CoolingSpeedNum;
                            Par[6] = double(m_FanOpMode);
                            Par[7] = 1.0; // CompOp
                            Par[8] = ReqOutput;

                            if (this->m_CoolingSpeedNum > 1.0) {
                                Par[4] = CycRatio;
                                General::SolveRoot(state, Acc, MaxIte, SolFla, SpeedRatio, this->DXCoilVarSpeedResidual, 0.0, 1.0, Par);
                                this->m_CoolingCycRatio = CycRatio;
                                this->m_CoolingSpeedRatio = SpeedRatio;
                                this->m_CoolingPartLoadFrac = SpeedRatio;
                                this->calcPassiveSystem(state, AirLoopNum, FirstHVACIteration);
                                PartLoadFrac = SpeedRatio;
                            } else {
                                this->m_CoolingSpeedRatio = SpeedRatio;
                                Par[4] = SpeedRatio;
                                General::SolveRoot(state, Acc, MaxIte, SolFla, CycRatio, this->DXCoilCyclingResidual, 0.0, 1.0, Par);
                                SpeedRatio = 0.0;
                                this->m_CoolingCycRatio = CycRatio;
                                this->m_CoolingPartLoadFrac = CycRatio;
                                this->calcPassiveSystem(state, AirLoopNum, FirstHVACIteration);
                                PartLoadFrac = CycRatio;
                            }

                        } else if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) {

                            Par[1] = double(this->m_CoolingCoilIndex);
                            Par[2] = DesOutTemp;
                            // dehumidification mode = 0 for normal mode, 1+ for enhanced mode
                            Par[3] = double(DehumidMode);
                            Par[4] = double(FanOpMode);
                            General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, &this->multiModeDXCoilResidual, 0.0, 1.0, Par);
                            this->m_CompPartLoadRatio = PartLoadFrac;

                        } else if (CoilType_Num == DataHVACGlobals::CoilDX_Cooling) { // CoilCoolingDX
                            std::array<Real64, 8> Par2 = {
                                double(this->m_CoolingCoilIndex),
                                DesOutTemp,
                                double(DehumidMode), // dehumidification mode = 0 for normal mode, 1+ for enhanced mode
                                double(FanOpMode),
                                double(this->m_CoolingSpeedNum),
                                this->m_CoolingSpeedRatio,
                                0.0,
                                0.0,
                            };
                            if (this->m_SingleMode == 1) Par[7] = 1.0;
                            General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, &this->genericDXCoilResidual, 0.0, 1.0, Par2);
                            if (this->m_CoolingSpeedNum == 1) {
                                this->m_CompPartLoadRatio = PartLoadFrac;
                                SpeedRatio = 0.0;
                            } else {
                                SpeedRatio = PartLoadFrac;
                                PartLoadFrac = 1.0;
                                this->m_CompPartLoadRatio = 1.0;
                            }
                        } else if ((CoilType_Num == DataHVACGlobals::Coil_CoolingWater) ||
                                   (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed)) {

                            Par[1] = double(this->m_UnitarySysNum);
                            if (FirstHVACIteration) {
                                Par[2] = 1.0;
                            } else {
                                Par[2] = 0.0;
                            }
                            Par[3] = DesOutTemp;

                            // calculate max waterside PLR from mdot request above in case plant chokes water flow
                            maxPartLoadFrac =
                                min(1.0,
                                    ((mdot / this->MaxCoolCoilFluidFlow) +
                                     0.001)); // plant can limit flow and RegulaFalsi could hit max iteration limit (leave a little slop, 0.001)
                            General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->coolWaterTempResidual, 0.0, maxPartLoadFrac, Par);

                        } else if ((CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) ||
                                   (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHP)) {
                            Par[1] = double(this->m_UnitarySysNum);
                            if (FirstHVACIteration) {
                                Par[2] = 1.0;
                            } else {
                                Par[2] = 0.0;
                            }
                            Par[3] = DesOutTemp;
                            Par[4] = ReqOutput;
                            this->m_CoolingCoilSensDemand = ReqOutput;
                            General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->coolWatertoAirHPTempResidual, 0.0, 1.0, Par);

                        } else if (CoilType_Num == DataHVACGlobals::Coil_UserDefined) {
                            // do nothing, user defined coil cannot be controlled

                        } else if (CoilType_Num == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling) {

                            Par[1] = double(this->m_UnitarySysNum);
                            Par[2] = DesOutTemp;
                            Par[3] = 0.0; // DesOutHumRat; set to 0 if temp controlled
                            General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->TESIceStorageCoilOutletResidual, 0.0, 1.0, Par);

                        } else {
                            ShowMessage(state, " For :" + this->UnitType + "=\"" + this->Name + "\"");
                            ShowFatalError(state,
                                           "ControlCoolingSystemToSP: Invalid cooling coil type = " + DataHVACGlobals::cAllCoilTypes(CoilType_Num));
                        }
                    }
                }
            }

            //     IF system does not operate to meet sensible load, use no load humidity ratio to test against humidity setpoint,
            //     ELSE use operating humidity ratio to test against humidity setpoint
            if (PartLoadFrac == 0.0) {
                OutletHumRatDXCoil = NoLoadHumRatOut;
            } else {
                OutletHumRatDXCoil = state.dataLoopNodes->Node(OutletNode).HumRat;
            }

            // IF humidity setpoint is not satisfied and humidity control type is MultiMode,
            // then enable heat exchanger and run to meet sensible load

            if ((OutletHumRatDXCoil > (DesOutHumRat + tempHumRatAcc)) && (!unitSys || PartLoadFrac < 1.0) &&
                (this->m_DehumidControlType_Num == DehumCtrlType::Multimode)) {

                if ((CoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted) ||
                    (CoilType_Num == DataHVACGlobals::CoilWater_CoolingHXAssisted)) { // CoilSystem:Cooling:DX:HeatExchangerAssisted,
                                                                                      // CoilSystem:Cooling:Water:HeatExchangerAssisted
                    // Determine required part load when heat exchanger is ON
                    HXUnitOn = true;
                    PartLoadFrac = 1.0;
                    HVACHXAssistedCoolingCoil::SimHXAssistedCoolingCoil(state,
                                                                        CompName,
                                                                        FirstHVACIteration,
                                                                        state.dataUnitarySystems->On,
                                                                        PartLoadFrac,
                                                                        this->m_CoolingCoilIndex,
                                                                        FanOpMode,
                                                                        HXUnitOn,
                                                                        _,
                                                                        state.dataUnitarySystems->economizerFlag);

                    OutletTempDXCoil = state.dataHVACAssistedCC->HXAssistedCoilOutletTemp(this->m_CoolingCoilIndex);

                    //               FullOutput will be different than the FullOutput determined above during sensible PLR calculations
                    FullOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                                 Psychrometrics::PsyDeltaHSenFnTdb2W2Tdb1W1(state.dataLoopNodes->Node(OutletNode).Temp,
                                                                            state.dataLoopNodes->Node(OutletNode).HumRat,
                                                                            state.dataLoopNodes->Node(InletNode).Temp,
                                                                            state.dataLoopNodes->Node(InletNode).HumRat);
                    FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;

                    //   Check to see if the system can meet the load with the compressor off
                    //   If NoOutput is lower than (more cooling than required) or very near the ReqOutput, do not run the compressor
                    if ((NoLoadTempOut - DesOutTemp) < Acc) {
                        PartLoadFrac = 0.0;
                        //          OutletTempDXCoil is the full capacity outlet temperature at PartLoadFrac = 1 from the CALL above.
                        //          if this temp is greater than or very near the desired outlet temp, then run the compressor at PartLoadFrac
                        //          = 1.
                        //            ELSEIF ((OutletTempDXCoil > DesOutTemp) .OR. ABS(OutletTempDXCoil - DesOutTemp) .LE. (Acc*2.0d0)) THEN
                    } else if (OutletTempDXCoil > DesOutTemp - (tempAcc * 2.0)) {
                        PartLoadFrac = 1.0;
                    } else {
                        Par[1] = double(this->m_CoolingCoilIndex);
                        Par[2] = DesOutTemp;
                        // FirstHVACIteration is a logical, Par is REAL(r64), so make TRUE = 1.0 and FALSE = 0.0
                        if (FirstHVACIteration) {
                            Par[3] = 1.0;
                        } else {
                            Par[3] = 0.0;
                        }
                        if (HXUnitOn) {
                            Par[4] = 1.0;
                        } else {
                            Par[4] = 0.0;
                        }
                        Par[5] = double(FanOpMode);
                        General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->HXAssistedCoolCoilTempResidual, 0.0, 1.0, Par);
                    }
                    this->m_CompPartLoadRatio = PartLoadFrac;

                } else if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) {

                    // Get full load result
                    PartLoadFrac = 1.0;
                    DehumidMode = 1;
                    this->m_DehumidificationMode = DehumidMode;
                    DXCoils::SimDXCoilMultiMode(state,
                                                CompName,
                                                state.dataUnitarySystems->On,
                                                FirstHVACIteration,
                                                PartLoadFrac,
                                                DehumidMode,
                                                this->m_CoolingCoilIndex,
                                                FanOpMode);
                    FullOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                                 Psychrometrics::PsyDeltaHSenFnTdb2W2Tdb1W1(state.dataLoopNodes->Node(OutletNode).Temp,
                                                                            state.dataLoopNodes->Node(OutletNode).HumRat,
                                                                            state.dataLoopNodes->Node(InletNode).Temp,
                                                                            state.dataLoopNodes->Node(InletNode).HumRat);
                    FullLoadHumRatOut = state.dataLoopNodes->Node(OutletNode).HumRat;

                    // Since we are cooling, we expect FullOutput to be < 0 and FullOutput < NoCoolOutput
                    // Check that this is the case; IF not set PartLoadFrac = 0.0 (off) and return
                    // Calculate the part load fraction
                    if (FullOutput >= 0) {
                        PartLoadFrac = 0.0;
                    } else {
                        OutletTempDXCoil = state.dataDXCoils->DXCoilOutletTemp(this->m_CoolingCoilIndex);
                        OutletHumRatDXCoil = state.dataDXCoils->DXCoilOutletHumRat(this->m_CoolingCoilIndex);
                        // If sensible load and setpoint cannot be met, set PLR = 1. if no sensible load and
                        // latent load exists and setpoint cannot be met, set PLR = 1.
                        if ((OutletTempDXCoil > (DesOutTemp - (tempAcc * 2.0)) && SensibleLoad && this->m_RunOnSensibleLoad) ||
                            (OutletHumRatDXCoil >= (DesOutHumRat - (tempHumRatAcc * 2.0)) && !SensibleLoad && LatentLoad &&
                             this->m_RunOnLatentLoad)) {
                            PartLoadFrac = 1.0;
                            //                  ELSEIF ((SensibleLoad .and. LatentLoad .AND. .NOT. UnitarySystem(UnitarySysNum)%RunOnLatentLoad
                            //                  .AND. &
                            //                       OutletHumRatDXCoil < DesOutHumRat)) THEN
                        } else if (!SensibleLoad && (OutletHumRatDXCoil < DesOutHumRat && LatentLoad && this->m_RunOnLatentLoad)) {
                            PartLoadFrac = ReqOutput / FullOutput;
                            Par[1] = double(this->m_CoolingCoilIndex);
                            Par[2] = DesOutHumRat;
                            // dehumidification mode = 0 for normal mode, 1+ for enhanced mode
                            Par[3] = double(DehumidMode);
                            Par[4] = double(FanOpMode);
                            General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->multiModeDXCoilHumRatResidual, 0.0, 1.0, Par);
                        } else { // must be a sensible load so find PLR
                            PartLoadFrac = ReqOutput / FullOutput;
                            Par[1] = double(this->m_CoolingCoilIndex);
                            Par[2] = DesOutTemp;
                            // Dehumidification mode = 0 for normal mode, 1+ for enhanced mode
                            Par[3] = double(DehumidMode);
                            Par[4] = double(FanOpMode);
                            General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->multiModeDXCoilResidual, 0.0, 1.0, Par);
                        }
                    }
                    this->m_CompPartLoadRatio = PartLoadFrac;

                } else if (CoilType_Num == DataHVACGlobals::CoilDX_Cooling) { // CoilCoolingDX
                    int OperationMode = DataHVACGlobals::coilEnhancedMode;
                    if (state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].SubcoolReheatFlag) {
                        OperationMode = DataHVACGlobals::coilSubcoolReheatMode;
                    }
                    if (this->m_CoolingSpeedNum == 0) this->m_CoolingSpeedNum = 1;
                    bool const singleMode = (this->m_SingleMode == 1);
                    for (int speedNum = this->m_CoolingSpeedNum; speedNum <= this->m_NumOfSpeedCooling; speedNum++) {
                        this->m_CoolingSpeedNum = speedNum;
                        state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].simulate(
                            state, OperationMode, PartLoadFrac, this->m_CoolingSpeedNum, this->m_CoolingSpeedRatio, this->m_FanOpMode, singleMode);
                        if ((state.dataLoopNodes->Node(OutletNode).Temp - DesOutTemp) < Acc) break;
                    }

                    std::array<Real64, 8> Par2 = {double(this->m_CoolingCoilIndex),
                                                  DesOutTemp,
                                                  // dehumidification mode = 0 for normal mode, 1+ for enhanced mode
                                                  // need to test what happens when Alt mode doesn't exist, or somehow test for it,
                                                  // or fatal out in GetInput
                                                  1.0, // DehumidMode
                                                  double(FanOpMode),
                                                  double(this->m_CoolingSpeedNum),
                                                  1.0, //  this->m_CoolingSpeedRatio;
                                                  0.0,
                                                  0.0};
                    General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, &this->genericDXCoilResidual, 0.0, 1.0, Par2);
                    if (this->m_CoolingSpeedNum == 1) {
                        this->m_CompPartLoadRatio = PartLoadFrac;
                        SpeedRatio = 0.0;
                    } else {
                        SpeedRatio = PartLoadFrac;
                        PartLoadFrac = 1.0;
                        this->m_CompPartLoadRatio = 1.0;
                    }

                } else {
                }
            } // END IF humidity ratio setpoint not met - Multimode humidity control

            // IF humidity setpoint is not satisfied and humidity control type is CoolReheat,
            // then overcool to meet moisture load

            if ((OutletHumRatDXCoil > DesOutHumRat) && (!unitSys || PartLoadFrac < 1.0) && LatentLoad &&
                (this->m_DehumidControlType_Num == DehumCtrlType::CoolReheat)) {

                //           IF NoLoadHumRatOut is lower than (more dehumidification than required) or very near the DesOutHumRat,
                //           do not run the compressor
                if ((NoLoadHumRatOut - DesOutHumRat) < tempHumRatAcc) {
                    // PartLoadFrac = PartLoadFrac; // keep part-load fraction from sensible calculation // Self-assignment commented out
                    //           If the FullLoadHumRatOut is greater than (insufficient dehumidification) or very near the DesOutHumRat,
                    //           run the compressor at PartLoadFrac = 1.
                    //        ELSEIF ((DesOutHumRat-FullLoadHumRatOut) .LT. HumRatAcc) THEN
                } else if (FullLoadHumRatOut > (DesOutHumRat - tempHumRatAcc)) {
                    PartLoadFrac = 1.0;
                    SpeedRatio = 1.0; // #8849, need to set properties of multi-speed/2-speed coils
                    if (this->m_IsDXCoil) {
                        this->m_CompPartLoadRatio = PartLoadFrac;
                    }
                    //           ELSE find the PLR to meet the load

                } else {

                    if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingSingleSpeed) {

                        Par[1] = double(this->m_CoolingCoilIndex);
                        Par[2] = DesOutHumRat;
                        Par[5] = double(FanOpMode);
                        General::SolveRoot(state, HumRatAcc, MaxIte, SolFlaLat, PartLoadFrac, this->DOE2DXCoilHumRatResidual, 0.0, 1.0, Par);
                        this->m_CompPartLoadRatio = PartLoadFrac;

                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingHXAssisted) {

                        //               IF NoLoadHumRatOut is lower than (more dehumidification than required) or very near the DesOutHumRat,
                        //               do not run the compressor
                        if ((NoLoadHumRatOut - DesOutHumRat) < tempHumRatAcc * 2.0) {
                            // PartLoadFrac = PartLoadFrac; // keep part-load fraction from sensible calculation // Self-assignment commented out
                            //                If the FullLoadHumRatOut is greater than (insufficient dehumidification) or very near the
                            //                DesOutHumRat, run the compressor at PartLoadFrac = 1.
                        } else if ((DesOutHumRat - FullLoadHumRatOut) < tempHumRatAcc * 2.0) {
                            PartLoadFrac = 1.0;
                            //               ELSE find the PLR to meet the load
                        } else {
                            Par[1] = double(this->m_CoolingCoilIndex);
                            Par[2] = DesOutHumRat;
                            // FirstHVACIteration is a logical, Par is REAL(r64), so make TRUE = 1 and FALSE = 0
                            if (FirstHVACIteration) {
                                Par[3] = 1.0;
                            } else {
                                Par[3] = 0.0;
                            }
                            if (HXUnitOn) {
                                Par[4] = 1.0;
                            } else {
                                Par[4] = 0.0;
                            }
                            Par[5] = double(FanOpMode);
                            General::SolveRoot(state, HumRatAcc, MaxIte, SolFla, PartLoadFrac, this->HXAssistedCoolCoilHRResidual, 0.0, 1.0, Par);
                            if (SolFla == -1) {

                                //                   RegulaFalsi may not find latent PLR when the latent degradation model is used.
                                //                   IF iteration limit is exceeded, find tighter boundary of solution and repeat RegulaFalsi
                                TempMaxPLR = -0.1;
                                while ((OutletHumRatDXCoil - DesOutHumRat) >= 0.0 && TempMaxPLR <= 1.0) {
                                    //                     find upper limit of LatentPLR
                                    TempMaxPLR += 0.1;
                                    HVACHXAssistedCoolingCoil::SimHXAssistedCoolingCoil(state,
                                                                                        CompName,
                                                                                        FirstHVACIteration,
                                                                                        state.dataUnitarySystems->On,
                                                                                        TempMaxPLR,
                                                                                        this->m_CoolingCoilIndex,
                                                                                        FanOpMode,
                                                                                        HXUnitOn,
                                                                                        _,
                                                                                        state.dataUnitarySystems->economizerFlag);
                                    OutletHumRatDXCoil = state.dataHVACAssistedCC->HXAssistedCoilOutletHumRat(this->m_CoolingCoilIndex);
                                }
                                TempMaxPLR = min(1.0, TempMaxPLR + 0.1);
                                TempMinPLR = TempMaxPLR;
                                while ((OutletHumRatDXCoil - DesOutHumRat) <= 0.0 && TempMinPLR >= 0.0) {
                                    //                     pull upper limit of LatentPLR DOwn to last valid limit (i.e. latent output still
                                    //                     exceeds SystemMoisuterLoad)
                                    //                     find minimum limit of Latent PLR
                                    TempMinPLR -= 0.02;
                                    HVACHXAssistedCoolingCoil::SimHXAssistedCoolingCoil(state,
                                                                                        CompName,
                                                                                        FirstHVACIteration,
                                                                                        state.dataUnitarySystems->On,
                                                                                        TempMinPLR,
                                                                                        this->m_CoolingCoilIndex,
                                                                                        FanOpMode,
                                                                                        HXUnitOn,
                                                                                        _,
                                                                                        state.dataUnitarySystems->economizerFlag);
                                    OutletHumRatDXCoil = state.dataHVACAssistedCC->HXAssistedCoilOutletHumRat(this->m_CoolingCoilIndex);
                                }
                                TempMinPLR = max(0.0, TempMinPLR - 0.1);
                                //                   tighter boundary of solution has been found, CALL RegulaFalsi a second time
                                General::SolveRoot(
                                    state, HumRatAcc, MaxIte, SolFla, PartLoadFrac, this->HXAssistedCoolCoilHRResidual, TempMinPLR, TempMaxPLR, Par);
                                if (SolFla == -1) {
                                    if (!state.dataGlobal->WarmupFlag) {
                                        if (this->warnIndex.m_HXAssistedCRLatPLRIter < 1) {
                                            ++this->warnIndex.m_HXAssistedCRLatPLRIter;
                                            ShowWarningError(
                                                state,
                                                this->UnitType +
                                                    " - Iteration limit exceeded calculating DX unit latent part-load ratio for unit = " +
                                                    this->Name);
                                            ShowContinueError(state, format("Estimated latent part-load ratio  = {:.3R}", (ReqOutput / FullOutput)));
                                            ShowContinueError(state, format("Calculated latent part-load ratio = {:.3R}", PartLoadFrac));
                                            ShowContinueErrorTimeStamp(state,
                                                                       "The calculated latent part-load ratio will be used and the simulation "
                                                                       "continues. Occurrence info:");
                                        }
                                        ShowRecurringWarningErrorAtEnd(state,
                                                                       this->UnitType + " \"" + this->Name +
                                                                           "\" - Iteration limit exceeded calculating latent part-load ratio "
                                                                           "error continues. Latent PLR "
                                                                           "statistics follow.",
                                                                       this->warnIndex.m_HXAssistedCRLatPLRIterIndex,
                                                                       PartLoadFrac,
                                                                       PartLoadFrac);
                                    }

                                } else if (SolFla == -2) {

                                    PartLoadFrac = ReqOutput / FullOutput;
                                    if (!state.dataGlobal->WarmupFlag) {
                                        if (this->warnIndex.m_HXAssistedCRLatPLRFail < 1) {
                                            ++this->warnIndex.m_HXAssistedCRLatPLRFail;
                                            ShowWarningError(state,
                                                             this->UnitType +
                                                                 " - DX unit latent part-load ratio calculation failed unexpectedly: part-load ratio "
                                                                 "limits exceeded, for unit = " +
                                                                 this->Name);
                                            ShowContinueError(state, format("Estimated part-load ratio = {:.3R}", PartLoadFrac));
                                            ShowContinueErrorTimeStamp(
                                                state, "The estimated part-load ratio will be used and the simulation continues. Occurrence info:");
                                        }
                                        ShowRecurringWarningErrorAtEnd(state,
                                                                       this->UnitType + " \"" + this->Name +
                                                                           "\" - DX unit latent part-load ratio calculation failed "
                                                                           "unexpectedly error continues. Latent PLR "
                                                                           "statistics follow.",
                                                                       this->warnIndex.m_HXAssistedCRLatPLRFailIndex,
                                                                       PartLoadFrac,
                                                                       PartLoadFrac);
                                    }
                                }
                            } else if (SolFla == -2) {
                                PartLoadFrac = ReqOutput / FullOutput;
                                if (!state.dataGlobal->WarmupFlag) {
                                    if (this->warnIndex.m_HXAssistedCRLatPLRFail2 < 1) {
                                        ++this->warnIndex.m_HXAssistedCRLatPLRFail2;
                                        ShowWarningError(state,
                                                         this->UnitType +
                                                             " - DX unit latent part-load ratio calculation failed: part-load ratio limits "
                                                             "exceeded, for unit = " +
                                                             this->Name);
                                        ShowContinueError(state, format("Estimated part-load ratio = {:.3R}", PartLoadFrac));
                                        ShowContinueErrorTimeStamp(
                                            state, "The estimated part-load ratio will be used and the simulation continues. Occurrence info:");
                                    }
                                    ShowRecurringWarningErrorAtEnd(
                                        state,
                                        this->UnitType + " \"" + this->Name +
                                            "\" - DX unit latent part-load ratio calculation failed error continues. Latent PLR statistics "
                                            "follow.",
                                        this->warnIndex.m_HXAssistedCRLatPLRFailIndex2,
                                        PartLoadFrac,
                                        PartLoadFrac);
                                }
                            }
                        }
                        this->m_CompPartLoadRatio = PartLoadFrac;

                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {

                        //               Simulate MultiSpeed DX coil at sensible result
                        DXCoils::SimDXCoilMultiSpeed(state, CompName, SpeedRatio, CycRatio, this->m_CoolingCoilIndex);

                        OutletHumRatDXCoil = state.dataDXCoils->DXCoilOutletHumRat(this->m_CoolingCoilIndex);
                        // IF humidity setpoint is not satisfied and humidity control type is CoolReheat,
                        // then overcool to meet moisture load

                        if (OutletHumRatDXCoil > DesOutHumRat) {

                            CycRatio = 0.0;
                            SpeedRatio = 0.0;

                            DXCoils::SimDXCoilMultiSpeed(state, CompName, 0.0, 1.0, this->m_CoolingCoilIndex);
                            OutletHumRatLS = state.dataDXCoils->DXCoilOutletHumRat(this->m_CoolingCoilIndex);
                            if (OutletHumRatLS > DesOutHumRat) {
                                CycRatio = 1.0;
                                DXCoils::SimDXCoilMultiSpeed(state, CompName, 1.0, 1.0, this->m_CoolingCoilIndex);
                                OutletHumRatHS = state.dataDXCoils->DXCoilOutletHumRat(this->m_CoolingCoilIndex);
                                if (OutletHumRatHS < DesOutHumRat) {
                                    Par[1] = double(this->m_CoolingCoilIndex);
                                    Par[2] = DesOutHumRat;
                                    General::SolveRoot(
                                        state, HumRatAcc, MaxIte, SolFla, SpeedRatio, this->DXCoilVarSpeedHumRatResidual, 0.0, 1.0, Par);
                                } else {
                                    SpeedRatio = 1.0;
                                }
                                PartLoadFrac = SpeedRatio;
                            } else {
                                SpeedRatio = 0.0;
                                Par[1] = double(this->m_CoolingCoilIndex);
                                Par[2] = DesOutHumRat;
                                General::SolveRoot(state, HumRatAcc, MaxIte, SolFla, CycRatio, this->DXCoilCyclingHumRatResidual, 0.0, 1.0, Par);
                                PartLoadFrac = CycRatio;
                            }
                        }

                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling) {

                        DXCoils::SimDXCoilMultiSpeed(state, CompName, SpeedRatio, CycRatio, this->m_CoolingCoilIndex);
                        OutletHumRatDXCoil = state.dataDXCoils->DXCoilOutletHumRat(this->m_CoolingCoilIndex);

                        // IF humidity setpoint is not satisfied and humidity control type is CoolReheat,
                        // then overcool to meet moisture load

                        if (OutletHumRatDXCoil > DesOutHumRat) {

                            CycRatio = 0.0;
                            SpeedRatio = 0.0;

                            DXCoils::SimDXCoilMultiSpeed(state, CompName, 0.0, 1.0, this->m_CoolingCoilIndex);
                            OutletHumRatLS = state.dataDXCoils->DXCoilOutletHumRat(this->m_CoolingCoilIndex);
                            if (OutletHumRatLS > DesOutHumRat) {
                                CycRatio = 1.0;
                                DXCoils::SimDXCoilMultiSpeed(state, CompName, 1.0, 1.0, this->m_CoolingCoilIndex);
                                OutletHumRatHS = state.dataDXCoils->DXCoilOutletHumRat(this->m_CoolingCoilIndex);
                                if (OutletHumRatHS < DesOutHumRat) {
                                    Par[1] = double(this->m_CoolingCoilIndex);
                                    Par[2] = DesOutHumRat;
                                    Par[3] = ReqOutput;
                                    General::SolveRoot(
                                        state, HumRatAcc, MaxIte, SolFla, SpeedRatio, this->DXCoilVarSpeedHumRatResidual, 0.0, 1.0, Par);
                                } else {
                                    SpeedRatio = 1.0;
                                }
                            } else {
                                SpeedRatio = 0.0;
                                Par[1] = double(this->m_CoolingCoilIndex);
                                Par[2] = DesOutHumRat;
                                Par[3] = ReqOutput;
                                General::SolveRoot(state, HumRatAcc, MaxIte, SolFla, CycRatio, this->DXCoilCyclingHumRatResidual, 0.0, 1.0, Par);
                            }
                        }
                    } else if ((CoilType_Num == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) ||
                               (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {
                        VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                                  CompName,
                                                                  this->m_CoolingCoilIndex,
                                                                  this->m_FanOpMode,
                                                                  this->m_MaxONOFFCyclesperHour,
                                                                  this->m_HPTimeConstant,
                                                                  this->m_FanDelayTime,
                                                                  1,
                                                                  CycRatio,
                                                                  SpeedNum,
                                                                  SpeedRatio,
                                                                  ReqOutput,
                                                                  dummy,
                                                                  OnOffAirFlowRatio);
                        OutletHumRatLS = state.dataLoopNodes->Node(this->CoolCoilOutletNodeNum).HumRat;

                        if (OutletHumRatLS > DesOutHumRat) {
                            CycRatio = 1.0;

                            for (int speedNum = SpeedNum; speedNum <= this->m_NumOfSpeedCooling; ++speedNum) {
                                VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                                          CompName,
                                                                          this->m_CoolingCoilIndex,
                                                                          this->m_FanOpMode,
                                                                          this->m_MaxONOFFCyclesperHour,
                                                                          this->m_HPTimeConstant,
                                                                          this->m_FanDelayTime,
                                                                          1,
                                                                          1.0,
                                                                          speedNum,
                                                                          1.0,
                                                                          ReqOutput,
                                                                          dummy,
                                                                          OnOffAirFlowRatio);
                                OutletHumRatHS = state.dataLoopNodes->Node(this->CoolCoilOutletNodeNum).HumRat;
                                if (OutletHumRatHS < DesOutHumRat || speedNum == this->m_NumOfSpeedCooling) {
                                    SpeedNum = speedNum;
                                    this->m_CoolingSpeedNum = speedNum;
                                    break;
                                }
                            }

                            if (OutletHumRatHS < DesOutHumRat) {
                                Par[1] = double(this->m_CoolingCoilIndex);
                                Par[2] = DesOutHumRat;
                                Par[3] = double(this->m_UnitarySysNum);
                                Par[5] = SpeedNum;
                                if (SpeedNum == 1) {
                                    General::SolveRoot(state, HumRatAcc, MaxIte, SolFla, CycRatio, this->DXCoilCyclingHumRatResidual, 0.0, 1.0, Par);
                                } else {
                                    General::SolveRoot(
                                        state, HumRatAcc, MaxIte, SolFla, SpeedRatio, this->DXCoilVarSpeedHumRatResidual, 0.0, 1.0, Par);
                                }
                            } else {
                                if (SpeedNum == 1) {
                                    CycRatio = 1.0;
                                } else {
                                    SpeedRatio = 1.0;
                                }
                            }
                        } else {
                            SpeedRatio = 0.0;
                            Par[1] = double(this->m_CoolingCoilIndex);
                            Par[2] = DesOutHumRat;
                            Par[3] = double(this->m_UnitarySysNum);
                            General::SolveRoot(state, HumRatAcc, MaxIte, SolFla, CycRatio, this->DXCoilVarSpeedHumRatResidual, 0.0, 1.0, Par);
                        }
                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoStageWHumControl) {

                        Par[1] = double(this->m_CoolingCoilIndex);
                        Par[2] = DesOutHumRat;
                        // dehumidification mode = 0 for normal mode, 1+ for enhanced mode
                        Par[3] = double(DehumidMode);
                        Par[4] = double(FanOpMode);
                        General::SolveRoot(state, Acc, MaxIte, SolFlaLat, PartLoadFrac, this->multiModeDXCoilHumRatResidual, 0.0, 1.0, Par);
                        this->m_CompPartLoadRatio = PartLoadFrac;

                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_Cooling) { // CoilCoolingDX
                        int OperationMode = DataHVACGlobals::coilNormalMode;
                        if (this->m_CoolingSpeedNum == 0) this->m_CoolingSpeedNum = 1;
                        bool const singleMode = (this->m_SingleMode == 1);
                        PartLoadFrac = 1.0;
                        for (int speedNum = this->m_CoolingSpeedNum; speedNum <= this->m_NumOfSpeedCooling; speedNum++) {
                            this->m_CoolingSpeedNum = speedNum;
                            state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].simulate(state,
                                                                                                      OperationMode,
                                                                                                      PartLoadFrac,
                                                                                                      this->m_CoolingSpeedNum,
                                                                                                      this->m_CoolingSpeedRatio,
                                                                                                      this->m_FanOpMode,
                                                                                                      singleMode);
                            if ((state.dataLoopNodes->Node(OutletNode).HumRat - DesOutHumRat) < Acc) break;
                        }

                        std::array<Real64, 8> Par2 = {
                            double(this->m_CoolingCoilIndex),
                            DesOutHumRat,
                            // dehumidification mode = 0 for normal mode, 1+ for enhanced mode
                            // need to test what happens when Alt mode doesn't exist, or somehow test for it,
                            // or fatal out in GetInput
                            0.0, // DehumidMode
                            double(FanOpMode),
                            double(this->m_CoolingSpeedNum),
                            1.0, //  this->m_CoolingSpeedRatio;
                            1.0, // run on latent, check coil outlet node HumRat
                            0.0  // dummy because genericDXCoilResidual takes 8 parameters
                        };

                        General::SolveRoot(state, HumRatAcc, MaxIte, SolFla, PartLoadFrac, &this->genericDXCoilResidual, 0.0, 1.0, Par2);
                        if (this->m_CoolingSpeedNum == 1) {
                            this->m_CompPartLoadRatio = PartLoadFrac;
                            SpeedRatio = 0.0;
                        } else {
                            SpeedRatio = PartLoadFrac;
                            PartLoadFrac = 1.0;
                            this->m_CompPartLoadRatio = 1.0;
                        }

                    } else if ((CoilType_Num == DataHVACGlobals::Coil_CoolingWater) ||
                               (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed)) { // COIL:COOLING:WATER

                        Par[1] = double(this->m_UnitarySysNum);
                        if (FirstHVACIteration) {
                            Par[2] = 1.0;
                        } else {
                            Par[2] = 0.0;
                        }
                        Par[3] = DesOutHumRat;

                        General::SolveRoot(state, HumRatAcc, MaxIte, SolFlaLat, PartLoadFrac, this->coolWaterHumRatResidual, 0.0, 1.0, Par);

                    } else if ((CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) ||
                               (CoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHP)) {

                        Par[1] = double(this->m_UnitarySysNum);
                        if (FirstHVACIteration) {
                            Par[2] = 1.0;
                        } else {
                            Par[2] = 0.0;
                        }
                        Par[3] = DesOutHumRat;
                        Par[4] = ReqOutput;

                        General::SolveRoot(state, HumRatAcc, MaxIte, SolFlaLat, PartLoadFrac, this->coolWatertoAirHPHumRatResidual, 0.0, 1.0, Par);

                    } else if (CoilType_Num == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling) {

                        if (CoilType_Num == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling &&
                            (this->m_TESOpMode != PackagedThermalStorageCoil::OffMode &&
                             this->m_TESOpMode != PackagedThermalStorageCoil::ChargeOnlyMode)) {
                            Par[1] = double(this->m_UnitarySysNum);
                            Par[2] = 0.0; // DesOutTemp; set to 0 if humrat controlled
                            Par[3] = DesOutHumRat;
                            General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->TESIceStorageCoilOutletResidual, 0.0, 1.0, Par);
                        }

                    } else {
                    }
                }
            }
        }

        if (SolFla == -1) {
            if (!state.dataGlobal->WarmupFlag) {
                if (this->warnIndex.m_SensPLRIter < 1) {
                    ++this->warnIndex.m_SensPLRIter;
                    ShowWarningError(state, this->UnitType + " - Iteration limit exceeded calculating part-load ratio for unit = " + this->Name);
                    ShowContinueError(state, format("Estimated part-load ratio  = {:.3R}", (ReqOutput / FullOutput)));
                    ShowContinueError(state, format("Calculated part-load ratio = {:.3R}", PartLoadFrac));
                    ShowContinueErrorTimeStamp(state, "The calculated part-load ratio will be used and the simulation continues. Occurrence info:");
                } else {
                    ShowRecurringWarningErrorAtEnd(
                        state,
                        this->UnitType + " \"" + this->Name +
                            "\" - Iteration limit exceeded calculating sensible part-load ratio error continues. Sensible PLR statistics follow.",
                        this->warnIndex.m_SensPLRIterIndex,
                        PartLoadFrac,
                        PartLoadFrac);
                }
            }
        } else if (SolFla == -2) {
            PartLoadFrac = ReqOutput / FullOutput;
            if (!state.dataGlobal->WarmupFlag) {
                if (this->warnIndex.m_SensPLRFail < 1) {
                    ++this->warnIndex.m_SensPLRFail;
                    ShowWarningError(state,
                                     this->UnitType +
                                         " - sensible part-load ratio calculation failed: part-load ratio limits exceeded, for unit = " + this->Name);
                    ShowContinueError(state, format("Estimated part-load ratio = {:.3R}", PartLoadFrac));
                    ShowContinueErrorTimeStamp(state, "The estimated part-load ratio will be used and the simulation continues. Occurrence info:");
                } else {
                    ShowRecurringWarningErrorAtEnd(
                        state,
                        this->UnitType + " \"" + this->Name +
                            "\" - sensible part-load ratio calculation failed error continues. Sensible PLR statistics follow.",
                        this->warnIndex.m_SensPLRFailIndex,
                        PartLoadFrac,
                        PartLoadFrac);
                }
            }
        }

        if (SolFlaLat == -1 && SolFla != -1) {
            if (!state.dataGlobal->WarmupFlag) {
                if (this->warnIndex.m_LatPLRIter < 1) {
                    ++this->warnIndex.m_LatPLRIter;
                    ShowWarningError(state,
                                     this->UnitType + " - Iteration limit exceeded calculating latent part-load ratio for unit = " + this->Name);
                    ShowContinueError(state, format("Estimated part-load ratio   = {:.3R}", (ReqOutput / FullOutput)));
                    ShowContinueError(state, format("Calculated part-load ratio = {:.3R}", PartLoadFrac));
                    ShowContinueErrorTimeStamp(state, "The calculated part-load ratio will be used and the simulation continues. Occurrence info:");
                }
                ShowRecurringWarningErrorAtEnd(
                    state,
                    this->UnitType + " \"" + this->Name +
                        "\" - Iteration limit exceeded calculating latent part-load ratio error continues. Latent PLR statistics follow.",
                    this->warnIndex.m_LatPLRIterIndex,
                    PartLoadFrac,
                    PartLoadFrac);
            }
        } else if (SolFlaLat == -2 && SolFla != -2) {
            //               RegulaFalsi returns PLR = minPLR when a solution cannot be found, recalculate PartLoadFrac.
            if (NoLoadHumRatOut - FullLoadHumRatOut != 0.0) {
                PartLoadFrac = (NoLoadHumRatOut - DesOutHumRat) / (NoLoadHumRatOut - FullLoadHumRatOut);
            } else {
                PartLoadFrac = 1.0;
            }
            if (!state.dataGlobal->WarmupFlag) {
                if (this->warnIndex.m_LatPLRFail < 1) {
                    ++this->warnIndex.m_LatPLRFail;
                    ShowWarningError(state,
                                     this->UnitType +
                                         " - latent part-load ratio calculation failed: part-load ratio limits exceeded, for unit = " + this->Name);
                    ShowContinueError(state, format("Estimated part-load ratio = {:.3R}", PartLoadFrac));
                    ShowContinueErrorTimeStamp(state, "The estimated part-load ratio will be used and the simulation continues. Occurrence info:");
                }
                ShowRecurringWarningErrorAtEnd(state,
                                               this->UnitType + " \"" + this->Name +
                                                   "\" - latent part-load ratio calculation failed error continues. Latent PLR statistics follow.",
                                               this->warnIndex.m_LatPLRFailIndex,
                                               PartLoadFrac,
                                               PartLoadFrac);
            }
        }
        // Set the final results

        if (PartLoadFrac > 1.0) {
            PartLoadFrac = 1.0;
        } else if (PartLoadFrac < 0.0) {
            PartLoadFrac = 0.0;
        }

        this->m_CoolingPartLoadFrac = PartLoadFrac;
        this->m_CoolingSpeedRatio = SpeedRatio;
        this->m_CoolingCycRatio = CycRatio;
        this->m_DehumidificationMode = DehumidMode;

        if (state.dataAirflowNetwork->SimulateAirflowNetwork > AirflowNetwork::AirflowNetworkControlMultizone) {
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF =
                max(state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF, LoopDXCoilMaxRTFSave);
        }

        if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
            this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) {
            mdot = PartLoadFrac * this->MaxCoolCoilFluidFlow;
            PlantUtilities::SetComponentFlowRate(state,
                                                 mdot,
                                                 this->CoolCoilFluidInletNode,
                                                 this->CoolCoilFluidOutletNodeNum,
                                                 this->CoolCoilLoopNum,
                                                 this->CoolCoilLoopSide,
                                                 this->CoolCoilBranchNum,
                                                 this->CoolCoilCompNum);
        }
    } // namespace UnitarySystems

    void UnitarySys::controlHeatingSystemToSP(EnergyPlusData &state,
                                              int const AirLoopNum,          // index to air loop
                                              bool const FirstHVACIteration, // First HVAC iteration flag
                                              int &CompOn,                   // compressor on/off control
                                              Real64 &HeatCoilLoad           // load met by heating coil
    )
    {
        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        //  Simulate the coil object at the required PLR.

        // METHODOLOGY EMPLOYED:
        //  Calculate operating PLR and adjust speed when using multispeed coils.

        // Locals
        bool const SuppHeatingCoilFlag(false);

        // SUBROUTINE PARAMETER DEFINITIONS:
        int const MaxIte(500);    // Maximum number of iterations for solver
        Real64 const Acc(1.0e-3); // Accuracy of solver result

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        Real64 FullOutput; // Sensible capacity (outlet - inlet) when the compressor is on
        Real64 ReqOutput;  // Sensible capacity (outlet - inlet) required to meet load or set point temperature

        std::vector<Real64> Par(11);    // Parameter array passed to solver
        Real64 m_WSHPRuntimeFrac = 0.0; // Run time fraction of water to air hp
        Real64 OutdoorDryBulb = 0.0;    // local variable for OutDryBulbTemp
        Real64 OutdoorHumRat = 0.0;     // local variable for OutHumRat
        Real64 OutdoorPressure = 0.0;   // local variable for OutBaroPress
        Real64 OutdoorWetBulb = 0.0;    // local variable for OutWetBulbTemp
        bool HeatingActive = false;     // dummy variable for UserDefined coil which are passed back indicating if coil is on or off.
        bool CoolingActive = false;     // dummy variable for UserDefined coil which are passed back indicating if coil is on or off.
        Real64 mdot = 0.0;              // water coil water flow rate [kg/s]
        Real64 maxPartLoadFrac = 0.0;   // calculated maximum water side PLR for RegulaFalsi call (when plant limits flow max PLR != 1)

        // Set local variables
        // Retrieve the load on the controlled zone
        int InletNode = this->HeatCoilInletNodeNum;
        int OutletNode = this->HeatCoilOutletNodeNum;
        std::string CompName = this->m_HeatingCoilName;
        int CompIndex = this->m_HeatingCoilIndex;
        int FanOpMode = this->m_FanOpMode;
        Real64 DesOutTemp = this->m_DesiredOutletTemp;

        Real64 LoopHeatingCoilMaxRTFSave = 0.0;
        Real64 LoopDXCoilMaxRTFSave = 0.0;
        if (state.dataAirflowNetwork->SimulateAirflowNetwork > AirflowNetwork::AirflowNetworkControlMultizone) {
            LoopHeatingCoilMaxRTFSave = state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopHeatingCoilMaxRTF;
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopHeatingCoilMaxRTF = 0.0;
            LoopDXCoilMaxRTFSave = state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF;
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF = 0.0;
        }

        Real64 PartLoadFrac = 0.0;
        Real64 SpeedRatio = 0.0;
        Real64 CycRatio = 0.0;
        int SpeedNum = 0;
        Real64 dummy = 0.0;
        int SolFla = 0;
        bool SensibleLoad = false;
        Real64 SensLoad = 0.0;
        bool LatentLoad = false;
        Real64 OutletTemp = 0.0;

        if (this->m_CondenserNodeNum != 0) {
            OutdoorDryBulb = state.dataLoopNodes->Node(this->m_CondenserNodeNum).Temp;
            if (this->m_CondenserType == DataHeatBalance::RefrigCondenserType::Water) {
                OutdoorHumRat = state.dataEnvrn->OutHumRat;
                OutdoorPressure = state.dataEnvrn->OutBaroPress;
                OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
            } else {
                OutdoorPressure = state.dataLoopNodes->Node(this->m_CondenserNodeNum).Press;
                // IF node is not connected to anything, pressure = default, use weather data
                if (OutdoorPressure == state.dataLoopNodes->DefaultNodeValues.Press) {
                    OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
                    OutdoorHumRat = state.dataEnvrn->OutHumRat;
                    OutdoorPressure = state.dataEnvrn->OutBaroPress;
                    OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
                } else {
                    OutdoorHumRat = state.dataLoopNodes->Node(this->m_CondenserNodeNum).HumRat;
                    //     this should use Node%WetBulbTemp or a PSYC function, not OAWB
                    OutdoorWetBulb = state.dataLoopNodes->Node(this->m_CondenserNodeNum).OutAirWetBulb;
                }
            }
        } else {
            OutdoorDryBulb = state.dataEnvrn->OutDryBulbTemp;
            OutdoorHumRat = state.dataEnvrn->OutHumRat;
            OutdoorPressure = state.dataEnvrn->OutBaroPress;
            OutdoorWetBulb = state.dataEnvrn->OutWetBulbTemp;
        }

        // IF there is a fault of coil SAT Sensor
        if (this->m_FaultyCoilSATFlag) {
            // calculate the sensor offset using fault information
            int FaultIndex = this->m_FaultyCoilSATIndex;
            this->m_FaultyCoilSATOffset = state.dataFaultsMgr->FaultsCoilSATSensor(FaultIndex).CalFaultOffsetAct(state);
            // update the DesOutTemp
            DesOutTemp -= this->m_FaultyCoilSATOffset;
        }

        // IF DXHeatingSystem is scheduled on and there is flow
        if (ScheduleManager::GetCurrentScheduleValue(state, this->m_SysAvailSchedPtr) > 0.0 &&
            ScheduleManager::GetCurrentScheduleValue(state, this->m_HeatingCoilAvailSchPtr) > 0.0 &&
            state.dataLoopNodes->Node(InletNode).MassFlowRate > DataHVACGlobals::SmallAirVolFlow) {

            // Determine if there is a sensible load on this system
            if (DesOutTemp - state.dataLoopNodes->Node(InletNode).Temp > DataHVACGlobals::TempControlTol) SensibleLoad = true;
            // if a heat pump and other coil is on, disable this coil
            if (this->m_HeatPump && this->m_CoolingPartLoadFrac > 0.0) SensibleLoad = false;

            // disable compressor if OAT is below minimum outdoor temperature
            if (OutdoorDryBulb < this->m_MinOATCompressorHeating) {
                SensibleLoad = false;
            }

            // IF DXHeatingSystem runs with a heating load then set PartLoadFrac on Heating System
            if (SensibleLoad) {

                ReqOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                            Psychrometrics::PsyDeltaHSenFnTdb2W2Tdb1W1(DesOutTemp,
                                                                       state.dataLoopNodes->Node(InletNode).HumRat,
                                                                       state.dataLoopNodes->Node(InletNode).Temp,
                                                                       state.dataLoopNodes->Node(InletNode).HumRat);
                ReqOutput = max(0.0, ReqOutput);

                // Get no load result
                PartLoadFrac = 0.0;
                m_WSHPRuntimeFrac = 0.0;
                CompOn = 0;

                {
                    auto const SELECT_CASE_var(this->m_HeatingCoilType_Num);

                    if (SELECT_CASE_var == DataHVACGlobals::CoilDX_HeatingEmpirical) {

                        DXCoils::SimDXCoil(state, CompName, state.dataUnitarySystems->On, FirstHVACIteration, CompIndex, FanOpMode, PartLoadFrac);
                        this->m_CompPartLoadRatio = PartLoadFrac;

                    } else if (SELECT_CASE_var == DataHVACGlobals::Coil_UserDefined) { // do nothing, user defined coil cannot be controlled

                        UserDefinedComponents::SimCoilUserDefined(state, CompName, CompIndex, AirLoopNum, HeatingActive, CoolingActive);
                        if (HeatingActive) PartLoadFrac = 1.0;

                    } else if ((SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedHeating) ||
                               (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric_MultiStage) ||
                               (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGas_MultiStage)) {
                        if (this->m_EMSOverrideCoilSpeedNumOn) {
                            this->m_HeatingSpeedNum = ceil(this->m_EMSOverrideCoilSpeedNumValue);
                            this->m_SpeedNum = this->m_HeatingSpeedNum;
                            bool useMaxedSpeed = false;
                            if (this->m_SpeedNum > this->m_NumOfSpeedHeating) {
                                this->m_HeatingSpeedNum = this->m_NumOfSpeedHeating;
                                this->m_SpeedNum = this->m_NumOfSpeedHeating;
                                this->m_CoilSpeedErrIdx++;
                                useMaxedSpeed = true;
                                ShowRecurringWarningErrorAtEnd(
                                    state,
                                    "Wrong coil speed EMS override value, for unit=\"" + this->m_HeatingCoilName +
                                        "\". Exceeding maximum coil speed level. Speed level is set to the maximum coil speed level allowed.",
                                    this->m_CoilSpeedErrIdx,
                                    this->m_EMSOverrideCoilSpeedNumValue,
                                    this->m_EMSOverrideCoilSpeedNumValue,
                                    _,
                                    "",
                                    "");
                            }
                            if (this->m_HeatingSpeedNum == 1) {
                                this->m_HeatingSpeedRatio = 0.0;
                                CycRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                                this->m_HeatingCycRatio = CycRatio;
                                if (useMaxedSpeed || CycRatio == 0) {
                                    this->m_HeatingCycRatio = 1;
                                } else {
                                    this->m_HeatingCycRatio = CycRatio;
                                }
                            } else {
                                this->m_HeatingCycRatio = 1.0;
                                SpeedRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                                this->m_HeatingSpeedRatio = SpeedRatio;
                                if (useMaxedSpeed || SpeedRatio == 0) {
                                    this->m_HeatingSpeedRatio = 1;
                                } else {
                                    this->m_HeatingSpeedRatio = SpeedRatio;
                                }
                            }
                        }
                        this->simMultiSpeedCoils(state,
                                                 AirLoopNum,
                                                 FirstHVACIteration,
                                                 CompOn,
                                                 SensibleLoad,
                                                 LatentLoad,
                                                 PartLoadFrac,
                                                 state.dataUnitarySystems->HeatingCoil,
                                                 this->m_SpeedNum);

                    } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) ||
                               (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit)) {

                        this->m_HeatingCoilSensDemand = ReqOutput;
                        VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                                  "",
                                                                  this->m_HeatingCoilIndex,
                                                                  FanOpMode,
                                                                  this->m_MaxONOFFCyclesperHour,
                                                                  this->m_HPTimeConstant,
                                                                  this->m_FanDelayTime,
                                                                  CompOn,
                                                                  CycRatio,
                                                                  SpeedNum,
                                                                  SpeedRatio,
                                                                  SensLoad,
                                                                  dummy);

                    } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGasOrOtherFuel) ||
                               (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric) ||
                               (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingDesuperheater)) {

                        HeatingCoils::SimulateHeatingCoilComponents(state, CompName, FirstHVACIteration, PartLoadFrac, CompIndex, _, _, FanOpMode);

                    } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWater) {

                        WaterCoils::SimulateWaterCoilComponents(
                            state, CompName, FirstHVACIteration, this->m_HeatingCoilIndex, _, this->m_FanOpMode, PartLoadFrac);

                    } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingSteam) {

                        SteamCoils::SimulateSteamCoilComponents(state,
                                                                CompName,
                                                                FirstHVACIteration,
                                                                this->m_HeatingCoilIndex,
                                                                1.0,
                                                                _,
                                                                this->m_FanOpMode,
                                                                PartLoadFrac); // QCoilReq, simulate any load > 0 to get max capacity

                    } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple) {

                        if (FirstHVACIteration) this->m_CompPartLoadRatio = 1;
                        WaterToAirHeatPumpSimple::SimWatertoAirHPSimple(state,
                                                                        blankString,
                                                                        CompIndex,
                                                                        ReqOutput,
                                                                        dummy,
                                                                        FanOpMode,
                                                                        this->m_CompPartLoadRatio,
                                                                        this->m_MaxONOFFCyclesperHour,
                                                                        this->m_HPTimeConstant,
                                                                        this->m_FanDelayTime,
                                                                        0,
                                                                        PartLoadFrac,
                                                                        FirstHVACIteration);
                        this->m_CompPartLoadRatio = PartLoadFrac;
                        this->m_HeatingCoilSensDemand = 0.0;

                    } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHP) {

                        WaterToAirHeatPump::SimWatertoAirHP(state,
                                                            blankString,
                                                            CompIndex,
                                                            this->MaxHeatAirMassFlow,
                                                            FanOpMode,
                                                            FirstHVACIteration,
                                                            m_WSHPRuntimeFrac,
                                                            this->m_MaxONOFFCyclesperHour,
                                                            this->m_HPTimeConstant,
                                                            this->m_FanDelayTime,
                                                            this->m_InitHeatPump,
                                                            ReqOutput,
                                                            dummy,
                                                            0,
                                                            PartLoadFrac);
                        this->m_CompPartLoadRatio = PartLoadFrac;

                    } else {
                    }
                }

                //     IF outlet temp at no load is within ACC of set point, do not run the coil

                if (std::abs(state.dataLoopNodes->Node(OutletNode).Temp - DesOutTemp) < Acc ||
                    this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_UserDefined) {
                    // do nothing, coil is at the set point.
                } else if ((state.dataLoopNodes->Node(OutletNode).Temp - DesOutTemp) > Acc) { // IF outlet temp is above set point turn off coil
                    PartLoadFrac = 0.0;
                } else { // ELSE get full load result

                    // Get full load result
                    PartLoadFrac = 1.0;
                    m_WSHPRuntimeFrac = 1.0;
                    CompOn = 1;

                    {
                        auto const SELECT_CASE_var(this->m_HeatingCoilType_Num);

                        if (SELECT_CASE_var == DataHVACGlobals::CoilDX_HeatingEmpirical) { // Coil:Heating:DX:SingleSpeed

                            DXCoils::SimDXCoil(
                                state, CompName, state.dataUnitarySystems->On, FirstHVACIteration, this->m_HeatingCoilIndex, FanOpMode, PartLoadFrac);
                            this->m_CompPartLoadRatio = PartLoadFrac;

                        } else if (SELECT_CASE_var == DataHVACGlobals::Coil_UserDefined) {

                            //  should never get here, coil cannot be controlled and has already been simulated

                        } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedHeating) {

                            CycRatio = 1.0;
                            SpeedRatio = 0.0;
                            if (this->m_EMSOverrideCoilSpeedNumOn) {
                                this->m_HeatingSpeedNum = ceil(this->m_EMSOverrideCoilSpeedNumValue);
                                SpeedNum = this->m_HeatingSpeedNum;
                                if (this->m_HeatingSpeedNum == 1) {
                                    this->m_HeatingSpeedRatio = SpeedRatio = 0.0;
                                    CycRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                                    this->m_HeatingCycRatio = CycRatio;
                                    if (CycRatio == 0) {
                                        this->m_HeatingCycRatio = 1;
                                    } else {
                                        this->m_HeatingCycRatio = CycRatio;
                                    }
                                } else {
                                    this->m_HeatingCycRatio = CycRatio = 1.0;
                                    SpeedRatio = this->m_EMSOverrideCoilSpeedNumValue - floor(this->m_EMSOverrideCoilSpeedNumValue);
                                    this->m_HeatingSpeedRatio = SpeedRatio;
                                    if (SpeedRatio == 0) {
                                        this->m_HeatingSpeedRatio = 1;
                                    } else {
                                        this->m_HeatingSpeedRatio = SpeedRatio;
                                    }
                                }
                                if (SpeedNum > this->m_NumOfSpeedHeating) {
                                    this->m_HeatingSpeedNum = this->m_NumOfSpeedHeating;
                                    SpeedNum = this->m_NumOfSpeedHeating;
                                    this->m_HeatingCycRatio = CycRatio = 1.0;
                                    if (this->m_HeatingSpeedNum == 1) {
                                        this->m_HeatingSpeedRatio = SpeedRatio = 0.0;
                                    } else {
                                        this->m_HeatingSpeedRatio = SpeedRatio = 1.0;
                                    }
                                }
                                this->simMultiSpeedCoils(state,
                                                         AirLoopNum,
                                                         FirstHVACIteration,
                                                         CompOn,
                                                         SensibleLoad,
                                                         LatentLoad,
                                                         PartLoadFrac,
                                                         state.dataUnitarySystems->HeatingCoil,
                                                         SpeedNum);
                                OutletTemp = state.dataLoopNodes->Node(OutletNode).Temp;
                            } else {
                                for (SpeedNum = 1; SpeedNum <= this->m_NumOfSpeedHeating; ++SpeedNum) {
                                    if (SpeedNum > 1) CycRatio = 0.0;
                                    if (SpeedNum > 1) SpeedRatio = 1.0;
                                    this->m_HeatingSpeedNum = SpeedNum;
                                    this->simMultiSpeedCoils(state,
                                                             AirLoopNum,
                                                             FirstHVACIteration,
                                                             CompOn,
                                                             SensibleLoad,
                                                             LatentLoad,
                                                             PartLoadFrac,
                                                             state.dataUnitarySystems->HeatingCoil,
                                                             SpeedNum);
                                    OutletTemp = state.dataLoopNodes->Node(OutletNode).Temp;
                                    if (OutletTemp > DesOutTemp && SensibleLoad) break;
                                }
                            }

                        } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric_MultiStage) ||
                                   (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGas_MultiStage)) {

                            CycRatio = 1.0;
                            SpeedRatio = 1.0;
                            SensLoad = 1.0; // turns on coil
                            this->m_HeatingSpeedRatio = SpeedRatio;
                            this->m_HeatingPartLoadFrac = PartLoadFrac;
                            for (SpeedNum = 1; SpeedNum <= this->m_NumOfSpeedHeating; ++SpeedNum) {
                                this->m_HeatingSpeedNum = SpeedNum;
                                this->simMultiSpeedCoils(state,
                                                         AirLoopNum,
                                                         FirstHVACIteration,
                                                         CompOn,
                                                         SensibleLoad,
                                                         LatentLoad,
                                                         PartLoadFrac,
                                                         state.dataUnitarySystems->HeatingCoil,
                                                         SpeedNum);
                                OutletTemp = state.dataLoopNodes->Node(OutletNode).Temp;
                                SpeedRatio = double(SpeedNum) - 1.0;
                                if (OutletTemp > DesOutTemp && SensibleLoad) break;
                            }

                        } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) ||
                                   (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit)) {

                            CycRatio = 1.0;
                            SpeedRatio = 1.0;
                            SensLoad = 1.0; // turns on coil
                            this->m_HeatingSpeedRatio = SpeedRatio;
                            this->m_HeatingPartLoadFrac = PartLoadFrac;
                            for (SpeedNum = 1; SpeedNum <= this->m_NumOfSpeedHeating; ++SpeedNum) {
                                this->m_HeatingSpeedNum = SpeedNum;
                                VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                                          "",
                                                                          this->m_HeatingCoilIndex,
                                                                          FanOpMode,
                                                                          this->m_MaxONOFFCyclesperHour,
                                                                          this->m_HPTimeConstant,
                                                                          this->m_FanDelayTime,
                                                                          CompOn,
                                                                          CycRatio,
                                                                          SpeedNum,
                                                                          SpeedRatio,
                                                                          SensLoad,
                                                                          dummy);
                                OutletTemp = state.dataLoopNodes->Node(OutletNode).Temp;
                                if (OutletTemp > DesOutTemp && SensibleLoad) break;
                            }

                        } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGasOrOtherFuel) ||
                                   (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric)) {

                            HeatingCoils::SimulateHeatingCoilComponents(
                                state, CompName, FirstHVACIteration, this->m_DesignHeatingCapacity, CompIndex, _, _, FanOpMode);

                        } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingDesuperheater) {

                            HeatingCoils::SimulateHeatingCoilComponents(state, CompName, FirstHVACIteration, ReqOutput, CompIndex, _, _, FanOpMode);

                        } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWater) {

                            mdot = this->MaxHeatCoilFluidFlow;
                            PlantUtilities::SetComponentFlowRate(state,
                                                                 mdot,
                                                                 this->HeatCoilFluidInletNode,
                                                                 this->HeatCoilFluidOutletNodeNum,
                                                                 this->HeatCoilLoopNum,
                                                                 this->HeatCoilLoopSide,
                                                                 this->HeatCoilBranchNum,
                                                                 this->HeatCoilCompNum);

                            WaterCoils::SimulateWaterCoilComponents(
                                state, CompName, FirstHVACIteration, this->m_HeatingCoilIndex, _, this->m_FanOpMode, PartLoadFrac);

                        } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingSteam) {

                            mdot = this->MaxHeatCoilFluidFlow;
                            PlantUtilities::SetComponentFlowRate(state,
                                                                 mdot,
                                                                 this->HeatCoilFluidInletNode,
                                                                 this->HeatCoilFluidOutletNodeNum,
                                                                 this->HeatCoilLoopNum,
                                                                 this->HeatCoilLoopSide,
                                                                 this->HeatCoilBranchNum,
                                                                 this->HeatCoilCompNum);

                            SteamCoils::SimulateSteamCoilComponents(state,
                                                                    CompName,
                                                                    FirstHVACIteration,
                                                                    this->m_HeatingCoilIndex,
                                                                    1.0,
                                                                    _,
                                                                    this->m_FanOpMode,
                                                                    PartLoadFrac); // QCoilReq, simulate any load > 0 to get max capacity

                        } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple) {

                            WaterToAirHeatPumpSimple::SimWatertoAirHPSimple(state,
                                                                            blankString,
                                                                            CompIndex,
                                                                            ReqOutput,
                                                                            dummy,
                                                                            FanOpMode,
                                                                            m_WSHPRuntimeFrac,
                                                                            this->m_MaxONOFFCyclesperHour,
                                                                            this->m_HPTimeConstant,
                                                                            this->m_FanDelayTime,
                                                                            1,
                                                                            PartLoadFrac,
                                                                            FirstHVACIteration);
                            this->m_HeatingCoilSensDemand = ReqOutput;
                            this->m_CompPartLoadRatio = PartLoadFrac;

                        } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHP) {
                            WaterToAirHeatPump::SimWatertoAirHP(state,
                                                                blankString,
                                                                CompIndex,
                                                                this->MaxHeatAirMassFlow,
                                                                FanOpMode,
                                                                FirstHVACIteration,
                                                                m_WSHPRuntimeFrac,
                                                                this->m_MaxONOFFCyclesperHour,
                                                                this->m_HPTimeConstant,
                                                                this->m_FanDelayTime,
                                                                this->m_InitHeatPump,
                                                                ReqOutput,
                                                                dummy,
                                                                0,
                                                                PartLoadFrac);
                            this->m_CompPartLoadRatio = PartLoadFrac;

                        } else {
                        }
                    }

                    FullOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                                 Psychrometrics::PsyDeltaHSenFnTdb2W2Tdb1W1(state.dataLoopNodes->Node(OutletNode).Temp,
                                                                            state.dataLoopNodes->Node(OutletNode).HumRat,
                                                                            state.dataLoopNodes->Node(InletNode).Temp,
                                                                            state.dataLoopNodes->Node(InletNode).HumRat);
                    //       If the outlet temp is within ACC of set point,
                    if (std::abs(state.dataLoopNodes->Node(OutletNode).Temp - DesOutTemp) < Acc ||
                        this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_UserDefined) {
                        // do nothing, coil is at set point
                    } else if (state.dataLoopNodes->Node(OutletNode).Temp < (DesOutTemp - Acc)) { // IF outlet temp is below set point coil must be on
                        PartLoadFrac = 1.0;
                    } else { // ELSE find the PLR to meet the set point

                        {
                            auto const SELECT_CASE_var(this->m_HeatingCoilType_Num);

                            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_HeatingEmpirical) { // Coil:Heating:DX:SingleSpeed

                                Par[1] = double(CompIndex);
                                Par[2] = DesOutTemp;
                                Par[3] = 1.0;               // OnOffAirFlowFrac assume = 1.0 for continuous fan dx system
                                Par[5] = double(FanOpMode); // this does nothing since set point based control requires constant fan
                                General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->DXHeatingCoilResidual, 0.0, 1.0, Par);
                                this->m_CompPartLoadRatio = PartLoadFrac;

                            } else if ((SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedHeating) ||
                                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) ||
                                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit) ||
                                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric_MultiStage) ||
                                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGas_MultiStage)) {

                                Par[1] = double(this->m_HeatingCoilIndex);
                                Par[2] = DesOutTemp;
                                Par[3] = double(this->m_UnitarySysNum);
                                // Par(4) = CycRatio or SpeedRatio
                                Par[5] = this->m_HeatingSpeedNum;
                                Par[6] = double(FanOpMode);
                                Par[7] = 1.0; // UnitarySystem(UnitarySysNum)%CompOp
                                Par[8] = ReqOutput;
                                if (this->m_HeatingSpeedNum > 1.0) {
                                    Par[4] = CycRatio;
                                    General::SolveRoot(state, Acc, MaxIte, SolFla, SpeedRatio, this->heatingCoilVarSpeedResidual, 0.0, 1.0, Par);
                                    this->m_HeatingCycRatio = CycRatio;
                                    this->m_HeatingSpeedRatio = SpeedRatio;
                                    this->m_HeatingPartLoadFrac = SpeedRatio;
                                    this->calcPassiveSystem(state, AirLoopNum, FirstHVACIteration);
                                    PartLoadFrac = SpeedRatio;
                                } else {
                                    SpeedRatio = 0.0;
                                    this->m_HeatingSpeedRatio = SpeedRatio;
                                    Par[4] = SpeedRatio;
                                    General::SolveRoot(state, Acc, MaxIte, SolFla, CycRatio, this->heatingCoilVarSpeedCycResidual, 0.0, 1.0, Par);
                                    this->m_HeatingCycRatio = CycRatio;
                                    this->m_HeatingPartLoadFrac = CycRatio;
                                    this->calcPassiveSystem(state, AirLoopNum, FirstHVACIteration);
                                    PartLoadFrac = CycRatio;
                                }

                            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGasOrOtherFuel) {

                                HeatingCoils::SimulateHeatingCoilComponents(
                                    state, this->m_HeatingCoilName, FirstHVACIteration, ReqOutput, CompIndex, _, true, FanOpMode, PartLoadFrac);
                                PartLoadFrac = ReqOutput / FullOutput;
                                HeatCoilLoad = ReqOutput;

                            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric) ||
                                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingDesuperheater)) {

                                Par[1] = double(this->m_UnitarySysNum);
                                if (FirstHVACIteration) {
                                    Par[2] = 1.0;
                                } else {
                                    Par[2] = 0.0;
                                }
                                Par[3] = DesOutTemp;
                                if (SuppHeatingCoilFlag) {
                                    Par[4] = 1.0;
                                } else {
                                    Par[4] = 0.0;
                                }
                                Par[5] = double(FanOpMode);
                                Par[6] = this->m_DesignHeatingCapacity;
                                General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->gasElecHeatingCoilResidual, 0.0, 1.0, Par);

                            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWater) {

                                Par[1] = double(this->m_UnitarySysNum);
                                if (FirstHVACIteration) {
                                    Par[2] = 1.0;
                                } else {
                                    Par[2] = 0.0;
                                }
                                Par[3] = DesOutTemp;
                                if (SuppHeatingCoilFlag) {
                                    Par[4] = 1.0;
                                } else {
                                    Par[4] = 0.0;
                                }
                                Par[5] = 0.0;

                                // calculate max waterside PLR from mdot request above in case plant chokes water flow
                                maxPartLoadFrac =
                                    min(1.0,
                                        ((mdot / this->MaxHeatCoilFluidFlow) +
                                         0.001)); // plant can limit flow and RegulaFalsi could hit max iteration limit (leave a little slop, 0.001)
                                General::SolveRoot(
                                    state, Acc, MaxIte, SolFla, PartLoadFrac, this->hotWaterHeatingCoilResidual, 0.0, maxPartLoadFrac, Par);

                            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingSteam) {

                                Par[1] = double(this->m_UnitarySysNum);
                                if (FirstHVACIteration) {
                                    Par[2] = 1.0;
                                } else {
                                    Par[2] = 0.0;
                                }
                                Par[3] = DesOutTemp;
                                if (SuppHeatingCoilFlag) {
                                    Par[4] = 1.0;
                                } else {
                                    Par[4] = 0.0;
                                }

                                // calculate max waterside PLR from mdot request above in case plant chokes water flow
                                maxPartLoadFrac =
                                    min(1.0,
                                        ((mdot / this->MaxHeatCoilFluidFlow) +
                                         0.001)); // plant can limit flow and RegulaFalsi could hit max iteration limit (leave a little slop, 0.001)
                                General::SolveRoot(
                                    state, Acc, MaxIte, SolFla, PartLoadFrac, this->steamHeatingCoilResidual, 0.0, maxPartLoadFrac, Par);

                            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple) ||
                                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHP)) {

                                Par[1] = double(this->m_UnitarySysNum);
                                if (FirstHVACIteration) {
                                    Par[2] = 1.0;
                                } else {
                                    Par[2] = 0.0;
                                }
                                Par[3] = DesOutTemp;
                                Par[4] = ReqOutput;
                                this->m_HeatingCoilSensDemand = ReqOutput;

                                General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->heatWatertoAirHPTempResidual, 0.0, 1.0, Par);

                            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_UserDefined) {

                                // should never get here, user defined coil cannot be controlled and has already been simulated

                            } else {
                                ShowMessage(state, " For :" + this->UnitType + "=\"" + this->Name + "\"");
                                ShowFatalError(state,
                                               "ControlHeatingSystemToSP: Invalid heating coil type = " +
                                                   DataHVACGlobals::cAllCoilTypes(this->m_HeatingCoilType_Num));
                            }
                        }
                    }
                }
            }
        }

        if (PartLoadFrac > 1.0) {
            PartLoadFrac = 1.0;
        } else if (PartLoadFrac < 0.0) {
            PartLoadFrac = 0.0;
        }

        if (SolFla < 0) {
            if (SolFla == -1) {
                if (!state.dataGlobal->WarmupFlag) {
                    if (this->warnIndex.m_HeatCoilSensPLRIter < 1) {
                        ++this->warnIndex.m_HeatCoilSensPLRIter;
                        ShowWarningError(
                            state, this->UnitType + " - Iteration limit exceeded calculating sensible part-load ratio for unit = " + this->Name);
                        ShowContinueError(state, format("Estimated part-load ratio  = {:.3R}", (ReqOutput / FullOutput)));
                        ShowContinueError(state, format("Calculated part-load ratio = {:.3R}", PartLoadFrac));
                        ShowContinueErrorTimeStamp(state,
                                                   "The calculated part-load ratio will be used and the simulation continues. Occurrence info:");
                    } else {
                        ShowRecurringWarningErrorAtEnd(state,
                                                       this->UnitType + " \"" + this->Name +
                                                           "\" - Iteration limit exceeded calculating sensible part-load ratio error continues. "
                                                           "Sensible PLR statistics follow.",
                                                       this->warnIndex.m_HeatCoilSensPLRIterIndex,
                                                       PartLoadFrac,
                                                       PartLoadFrac);
                    }
                }
            } else if (SolFla == -2) {
                PartLoadFrac = ReqOutput / FullOutput;
                if (!state.dataGlobal->WarmupFlag) {
                    if (this->warnIndex.m_HeatCoilSensPLRFail < 1) {
                        ++this->warnIndex.m_HeatCoilSensPLRFail;
                        ShowWarningError(
                            state,
                            this->UnitType +
                                " - sensible part-load ratio calculation failed: part-load ratio limits exceeded, for unit = " + this->Name);
                        ShowContinueError(state, format("Estimated part-load ratio = {:.3R}", PartLoadFrac));
                        ShowContinueErrorTimeStamp(state,
                                                   "The estimated part-load ratio will be used and the simulation continues. Occurrence info:");
                    } else {
                        ShowRecurringWarningErrorAtEnd(
                            state,
                            this->UnitType + " \"" + this->Name +
                                "\" - sensible part-load ratio calculation failed error continues. Sensible PLR statistics follow.",
                            this->warnIndex.m_HeatCoilSensPLRFailIndex,
                            PartLoadFrac,
                            PartLoadFrac);
                    }
                }
            }
        }

        // Set the final results
        this->m_HeatingPartLoadFrac = PartLoadFrac;
        this->m_HeatingSpeedRatio = SpeedRatio;
        this->m_HeatingCycRatio = CycRatio;

        if (state.dataAirflowNetwork->SimulateAirflowNetwork > AirflowNetwork::AirflowNetworkControlMultizone) {
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopHeatingCoilMaxRTF =
                max(state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopHeatingCoilMaxRTF, LoopHeatingCoilMaxRTFSave);
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF =
                max(state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF, LoopDXCoilMaxRTFSave);
        }

        if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater || this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {
            mdot = PartLoadFrac * this->MaxHeatCoilFluidFlow;
            PlantUtilities::SetComponentFlowRate(state,
                                                 mdot,
                                                 this->HeatCoilFluidInletNode,
                                                 this->HeatCoilFluidOutletNodeNum,
                                                 this->HeatCoilLoopNum,
                                                 this->HeatCoilLoopSide,
                                                 this->HeatCoilBranchNum,
                                                 this->HeatCoilCompNum);
        }
    }

    void UnitarySys::controlSuppHeatSystemToSP(EnergyPlusData &state,
                                               int const AirLoopNum,         // index to air loop
                                               bool const FirstHVACIteration // First HVAC iteration flag
    )
    {
        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013
        //       MODIFIED       Nov. 2016, R. Zhang, LBNL. Applied the coil supply air temperature sensor offset fault model
        //       RE-ENGINEERED  na

        // PURPOSE OF THIS SUBROUTINE:
        //  This subroutine updates the System outlet nodes.

        // METHODOLOGY EMPLOYED:
        //  Data is moved from the System data structure to the System outlet nodes.

        // Locals
        const bool SuppHeatingCoilFlag(true);

        // SUBROUTINE PARAMETER DEFINITIONS:
        int const MaxIte(500);    // Maximum number of iterations for solver
        Real64 const Acc(1.0e-3); // Accuracy of solver result
        int const SolveMaxIter(50);

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        Real64 FullOutput = 0.0;      // Sensible capacity (outlet - inlet) when the compressor is on
        Real64 ReqOutput = 0.0;       // Sensible capacity (outlet - inlet) required to meet load or set point temperature
        Real64 QCoilActual = 0.0;     // Heating coil operating capacity [W]
        std::vector<Real64> Par(8);   // Parameter array passed to solver
        Real64 NoLoadTempOut = 0.0;   // save outlet temp when coil is off (C)
        bool HeatingActive = false;   // dummy variable for UserDefined coil which are passed back indicating if coil is on or off.
        bool CoolingActive = false;   // dummy variable for UserDefined coil which are passed back indicating if coil is on or off.
        Real64 mdot = 0.0;            // water coil water flow rate [kg/s]
        Real64 maxPartLoadFrac = 0.0; // calculated maximum water side PLR for RegulaFalsi call (when plant limits flow max PLR != 1)
        Real64 PartLoadFrac = 0.0;
        int SolFla = 0.0;
        bool SensibleLoad = false;

        // Set local variables
        int OutletNode = this->m_SuppCoilAirOutletNode;
        int InletNode = this->m_SuppCoilAirInletNode;
        Real64 DesOutTemp = this->m_DesiredOutletTemp;
        std::string CompName = this->m_SuppHeatCoilName;
        int CompIndex = this->m_SuppHeatCoilIndex;
        int FanOpMode = this->m_FanOpMode;

        Real64 LoopHeatingCoilMaxRTFSave = 0.0;
        Real64 LoopDXCoilMaxRTFSave = 0.0;
        if (state.dataAirflowNetwork->SimulateAirflowNetwork > AirflowNetwork::AirflowNetworkControlMultizone) {
            LoopHeatingCoilMaxRTFSave = state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopHeatingCoilMaxRTF;
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopHeatingCoilMaxRTF = 0.0;
            LoopDXCoilMaxRTFSave = state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF;
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF = 0.0;
        }

        // IF there is a fault of coil SAT Sensor
        if (this->m_FaultyCoilSATFlag) {
            // calculate the sensor offset using fault information
            int FaultIndex = this->m_FaultyCoilSATIndex;
            this->m_FaultyCoilSATOffset = state.dataFaultsMgr->FaultsCoilSATSensor(FaultIndex).CalFaultOffsetAct(state);
            // update the DesOutTemp
            DesOutTemp -= this->m_FaultyCoilSATOffset;
        }

        if ((ScheduleManager::GetCurrentScheduleValue(state, this->m_SysAvailSchedPtr) > 0.0) &&
            (state.dataLoopNodes->Node(InletNode).MassFlowRate > DataHVACGlobals::SmallAirVolFlow)) {

            // Determine if there is a sensible load on this system
            if ((state.dataLoopNodes->Node(InletNode).Temp < DesOutTemp) &&
                (std::abs(state.dataLoopNodes->Node(InletNode).Temp - DesOutTemp) > DataHVACGlobals::TempControlTol))
                SensibleLoad = true;

            if (SensibleLoad) {

                ReqOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                            Psychrometrics::PsyDeltaHSenFnTdb2W2Tdb1W1(DesOutTemp,
                                                                       state.dataLoopNodes->Node(InletNode).HumRat,
                                                                       state.dataLoopNodes->Node(InletNode).Temp,
                                                                       state.dataLoopNodes->Node(InletNode).HumRat);
                // Get no load result
                PartLoadFrac = 0.0;

                {
                    auto const SELECT_CASE_var(this->m_SuppHeatCoilType_Num);

                    if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGasOrOtherFuel) ||
                        (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric) ||
                        (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingDesuperheater)) {
                        HeatingCoils::SimulateHeatingCoilComponents(state,
                                                                    CompName,
                                                                    FirstHVACIteration,
                                                                    DataLoopNode::SensedLoadFlagValue,
                                                                    CompIndex,
                                                                    QCoilActual,
                                                                    SuppHeatingCoilFlag,
                                                                    FanOpMode,
                                                                    PartLoadFrac); // QCoilReq= 0.0d0,  &
                        if (!(SELECT_CASE_var == DataHVACGlobals::Coil_HeatingDesuperheater)) {
                            PartLoadFrac = QCoilActual / this->m_DesignSuppHeatingCapacity;
                        } else {
                            if (QCoilActual > DataHVACGlobals::SmallLoad) {
                                PartLoadFrac = 1.0;
                            } else {
                                PartLoadFrac = 0.0;
                            }
                        }
                    } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWater) {

                        WaterCoils::SimulateWaterCoilComponents(
                            state, CompName, FirstHVACIteration, this->m_SuppHeatCoilIndex, _, this->m_FanOpMode, PartLoadFrac);

                    } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingSteam) {

                        SteamCoils::SimulateSteamCoilComponents(state,
                                                                CompName,
                                                                FirstHVACIteration,
                                                                this->m_SuppHeatCoilIndex,
                                                                1.0,
                                                                _,
                                                                this->m_FanOpMode,
                                                                PartLoadFrac); // QCoilReq, simulate any load > 0 to get max capacity

                    } else if (SELECT_CASE_var == DataHVACGlobals::Coil_UserDefined) { // do nothing, user defined coil cannot be controlled
                        UserDefinedComponents::SimCoilUserDefined(state, CompName, CompIndex, AirLoopNum, HeatingActive, CoolingActive);
                        if (HeatingActive) PartLoadFrac = 1.0;

                    } else {
                    }
                }

                NoLoadTempOut = state.dataLoopNodes->Node(OutletNode).Temp;
                //      NoOutput = state.dataLoopNodes->Node(InletNode)%MassFlowRate *  &
                //                       (PsyHFnTdbW(NoLoadTempOut,Node(OutletNode)%HumRat)  &
                //                        - PsyHFnTdbW(Node(InletNode)%Temp,Node(OutletNode)%HumRat))

                //     If OutletTemp is within ACC of set point, either coil operated or is not needed
                if (std::abs(state.dataLoopNodes->Node(OutletNode).Temp - DesOutTemp) < Acc ||
                    this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_UserDefined) {
                    // do nothing, coil is at set point (i.e., gas/elec/steam/user coil will try to hit set point)
                } else if (PartLoadFrac > 0.0) {
                    // do nothing, coil tried to hit set point (i.e., gas/elec/steam/user coil tried to hit set point but missed
                } else if (NoLoadTempOut > (DesOutTemp - Acc)) {
                    PartLoadFrac = 0.0; // outlet temp > set point, coil is not needed
                } else {                // outlet temp too low, turn on coil

                    // Get full load result
                    PartLoadFrac = 1.0;

                    {
                        auto const SELECT_CASE_var(this->m_SuppHeatCoilType_Num);

                        if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGasOrOtherFuel) ||
                            (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric)) {

                            HeatingCoils::SimulateHeatingCoilComponents(state,
                                                                        CompName,
                                                                        FirstHVACIteration,
                                                                        DataLoopNode::SensedLoadFlagValue,
                                                                        CompIndex,
                                                                        QCoilActual,
                                                                        SuppHeatingCoilFlag,
                                                                        FanOpMode,
                                                                        PartLoadFrac);
                            PartLoadFrac = QCoilActual / this->m_DesignSuppHeatingCapacity;

                        } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingDesuperheater) {

                            HeatingCoils::SimulateHeatingCoilComponents(
                                state, CompName, FirstHVACIteration, DataLoopNode::SensedLoadFlagValue, CompIndex, _, SuppHeatingCoilFlag, FanOpMode);

                        } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWater) {

                            mdot = this->m_MaxSuppCoilFluidFlow;
                            PlantUtilities::SetComponentFlowRate(state,
                                                                 mdot,
                                                                 this->m_SuppCoilFluidInletNode,
                                                                 this->m_SuppCoilFluidOutletNodeNum,
                                                                 this->m_SuppCoilLoopNum,
                                                                 this->m_SuppCoilLoopSide,
                                                                 this->m_SuppCoilBranchNum,
                                                                 this->m_SuppCoilCompNum);

                            WaterCoils::SimulateWaterCoilComponents(
                                state, CompName, FirstHVACIteration, this->m_SuppHeatCoilIndex, _, this->m_FanOpMode, PartLoadFrac);

                        } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingSteam) {

                            mdot = this->m_MaxSuppCoilFluidFlow;
                            PlantUtilities::SetComponentFlowRate(state,
                                                                 mdot,
                                                                 this->m_SuppCoilFluidInletNode,
                                                                 this->m_SuppCoilFluidOutletNodeNum,
                                                                 this->m_SuppCoilLoopNum,
                                                                 this->m_SuppCoilLoopSide,
                                                                 this->m_SuppCoilBranchNum,
                                                                 this->m_SuppCoilCompNum);

                            SteamCoils::SimulateSteamCoilComponents(state,
                                                                    CompName,
                                                                    FirstHVACIteration,
                                                                    this->m_SuppHeatCoilIndex,
                                                                    1.0,
                                                                    _,
                                                                    this->m_FanOpMode,
                                                                    PartLoadFrac); // QCoilReq, simulate any load > 0 to get max capacity

                        } else if (SELECT_CASE_var == DataHVACGlobals::Coil_UserDefined) {

                            //  should never get here, coil has already been simulated

                        } else {
                        }
                    }

                    FullOutput = state.dataLoopNodes->Node(InletNode).MassFlowRate *
                                 Psychrometrics::PsyDeltaHSenFnTdb2W2Tdb1W1(state.dataLoopNodes->Node(OutletNode).Temp,
                                                                            state.dataLoopNodes->Node(OutletNode).HumRat,
                                                                            state.dataLoopNodes->Node(InletNode).Temp,
                                                                            state.dataLoopNodes->Node(InletNode).HumRat);

                    //         If the FullOutput outlet temp is less than (insufficient heating) or very near set point,
                    //         run the coil at PartLoadFrac = 1.
                    if (state.dataLoopNodes->Node(OutletNode).Temp < (DesOutTemp + Acc)) {
                        PartLoadFrac = 1.0;
                    } else {

                        {
                            auto const SELECT_CASE_var(this->m_SuppHeatCoilType_Num);

                            if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGasOrOtherFuel) ||
                                (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric) ||
                                (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingDesuperheater)) {

                                Par[1] = double(this->m_UnitarySysNum);
                                if (FirstHVACIteration) {
                                    Par[2] = 1.0;
                                } else {
                                    Par[2] = 0.0;
                                }
                                Par[3] = DesOutTemp;
                                if (SuppHeatingCoilFlag) {
                                    Par[4] = 1.0;
                                } else {
                                    Par[4] = 0.0;
                                }
                                Par[5] = double(FanOpMode);
                                Par[6] = this->m_DesignSuppHeatingCapacity;
                                General::SolveRoot(state, Acc, MaxIte, SolFla, PartLoadFrac, this->gasElecHeatingCoilResidual, 0.0, 1.0, Par);

                            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWater) {

                                Par[1] = double(this->m_UnitarySysNum);
                                if (FirstHVACIteration) {
                                    Par[2] = 1.0;
                                } else {
                                    Par[2] = 0.0;
                                }
                                Par[3] = DesOutTemp;
                                if (SuppHeatingCoilFlag) {
                                    Par[4] = 1.0;
                                } else {
                                    Par[4] = 0.0;
                                }
                                Par[5] = 0.0;

                                // calculate max waterside PLR from mdot request above in case plant chokes water flow
                                maxPartLoadFrac =
                                    min(1.0,
                                        ((mdot / this->m_MaxSuppCoilFluidFlow) +
                                         0.001)); // plant can limit flow and RegulaFalsi could hit max iteration limit (leave a little slop, 0.001)
                                General::SolveRoot(
                                    state, Acc, SolveMaxIter, SolFla, PartLoadFrac, this->hotWaterHeatingCoilResidual, 0.0, maxPartLoadFrac, Par);

                            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingSteam) {

                                Par[1] = double(this->m_UnitarySysNum);
                                if (FirstHVACIteration) {
                                    Par[2] = 1.0;
                                } else {
                                    Par[2] = 0.0;
                                }
                                Par[3] = DesOutTemp;
                                if (SuppHeatingCoilFlag) {
                                    Par[4] = 1.0;
                                } else {
                                    Par[4] = 0.0;
                                }

                                // calculate max waterside PLR from mdot request above in case plant chokes water flow
                                maxPartLoadFrac =
                                    min(1.0,
                                        ((mdot / this->m_MaxSuppCoilFluidFlow) +
                                         0.001)); // plant can limit flow and RegulaFalsi could hit max iteration limit (leave a little slop, 0.001)
                                General::SolveRoot(
                                    state, Acc, MaxIte, SolFla, PartLoadFrac, this->steamHeatingCoilResidual, 0.0, maxPartLoadFrac, Par);

                            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_UserDefined) {

                                //  do nothing, coil has already been simulated

                            } else {
                            }
                        }

                    } // IF ((FullOutput - ReqOutput) < Acc) THEN
                }     // IF ((NoOutput-ReqOutput) > Acc) THEN
            }         // IF (SensibleLoad ) THEN
        }             // IF((GetCurrentScheduleValue(state, UnitarySystem(UnitarySysNum)%m_SysAvailSchedPtr) > 0.0d0) .AND. &

        if (PartLoadFrac > 1.0) {
            PartLoadFrac = 1.0;
        } else if (PartLoadFrac < 0.0) {
            PartLoadFrac = 0.0;
        }

        if (SolFla == -1) {
            if (!state.dataGlobal->WarmupFlag) {
                if (this->warnIndex.m_SuppHeatCoilSensPLRIter < 1) {
                    ++this->warnIndex.m_SuppHeatCoilSensPLRIter;
                    ShowWarningError(state,
                                     this->UnitType + " - Iteration limit exceeded calculating sensible part-load ratio for unit = " + this->Name);
                    ShowContinueError(state, format("Estimated part-load ratio  = {:.3R}", (ReqOutput / FullOutput)));
                    ShowContinueError(state, format("Calculated part-load ratio = {:.3R}", PartLoadFrac));
                    ShowContinueErrorTimeStamp(state, "The calculated part-load ratio will be used and the simulation continues. Occurrence info:");
                } else {
                    ShowRecurringWarningErrorAtEnd(
                        state,
                        this->UnitType + " \"" + this->Name +
                            "\" - Iteration limit exceeded calculating sensible part-load ratio error continues. Sensible PLR statistics follow.",
                        this->warnIndex.m_SuppHeatCoilSensPLRIterIndex,
                        PartLoadFrac,
                        PartLoadFrac);
                }
            } // IF(.NOT. WarmupFlag)THEN
        } else if (SolFla == -2) {
            PartLoadFrac = ReqOutput / FullOutput;
            if (!state.dataGlobal->WarmupFlag) {
                if (this->warnIndex.m_SuppHeatCoilSensPLRFail < 1) {
                    ++this->warnIndex.m_SuppHeatCoilSensPLRFail;
                    ShowWarningError(state,
                                     this->UnitType +
                                         " - sensible part-load ratio calculation failed: part-load ratio limits exceeded, for unit = " + this->Name);
                    ShowContinueError(state, format("Estimated part-load ratio = {:.3R}", PartLoadFrac));
                    ShowContinueErrorTimeStamp(state, "The estimated part-load ratio will be used and the simulation continues. Occurrence info:");
                } else {
                    ShowRecurringWarningErrorAtEnd(
                        state,
                        this->UnitType + " \"" + this->Name +
                            "\" - sensible part-load ratio calculation failed error continues. Sensible PLR statistics follow.",
                        this->warnIndex.m_SuppHeatCoilSensPLRFailIndex,
                        PartLoadFrac,
                        PartLoadFrac);
                }
            } // IF(.NOT. WarmupFlag)THEN
        }     // IF (SolFla == -1) THEN

        this->m_SuppHeatPartLoadFrac = PartLoadFrac;

        // LoopHeatingCoilMaxRTF used for AirflowNetwork gets set in child components (gas and fuel)
        if (state.dataAirflowNetwork->SimulateAirflowNetwork > AirflowNetwork::AirflowNetworkControlMultizone) {
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopHeatingCoilMaxRTF =
                max(state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopHeatingCoilMaxRTF, LoopHeatingCoilMaxRTFSave);
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF =
                max(state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).AFNLoopDXCoilRTF, LoopDXCoilMaxRTFSave);
        }

        if (this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingWater ||
            this->m_SuppHeatCoilType_Num == DataHVACGlobals::Coil_HeatingSteam) {
            mdot = PartLoadFrac * this->m_MaxSuppCoilFluidFlow;
            PlantUtilities::SetComponentFlowRate(state,
                                                 mdot,
                                                 this->m_SuppCoilFluidInletNode,
                                                 this->m_SuppCoilFluidOutletNodeNum,
                                                 this->m_SuppCoilLoopNum,
                                                 this->m_SuppCoilLoopSide,
                                                 this->m_SuppCoilBranchNum,
                                                 this->m_SuppCoilCompNum);
        }
    }

    void UnitarySys::simMultiSpeedCoils(EnergyPlusData &state,
                                        int const AirLoopNum,          // Index to air loop
                                        bool const FirstHVACIteration, // True when first HVAC iteration
                                        int &CompOn,                   // compresor on/off control
                                        bool const SensibleLoad,
                                        bool const LatentLoad,
                                        Real64 const PartLoadFrac,
                                        int const CoilType,
                                        int const SpeedNumber)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Chandan Sharma, FSEC
        //       DATE WRITTEN   March 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine manages multispeed and variable speed cooling coil simulation.

        // Locals
        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        std::string CompName; // Name of Unitary System object
        Real64 SensLoad = 0.0;
        Real64 LatLoad = 0.0;
        int CoilTypeNum = 0;
        int SpeedNum = 0;
        int CoilOutletNodeNum = 0;
        int CompIndex = 0;
        Real64 SpeedRatio = 0.0;
        Real64 CycRatio = 0.0;

        Real64 dummy = 0.0;

        // if (present(SpeedNumber)) {
        SpeedNum = SpeedNumber;
        //} else {
        //    SpeedNum = 1;
        //}

        if (CoilType == state.dataUnitarySystems->CoolingCoil) {

            CompName = this->m_CoolingCoilName;
            CompIndex = this->m_CoolingCoilIndex;
            CoilTypeNum = this->m_CoolingCoilType_Num;
            CoilOutletNodeNum = this->CoolCoilOutletNodeNum;
            if (SensibleLoad) {
                SensLoad = -1.0;
                state.dataUnitarySystems->CoolingLoad = true;
                state.dataUnitarySystems->HeatingLoad = false;
            }
            if (LatentLoad) LatLoad = -1.0;

        } else {

            CompName = this->m_HeatingCoilName;
            CompIndex = this->m_HeatingCoilIndex;
            CoilTypeNum = this->m_HeatingCoilType_Num;
            CoilOutletNodeNum = this->HeatCoilOutletNodeNum;

            if (SensibleLoad) {
                SensLoad = 1.0;
                state.dataUnitarySystems->CoolingLoad = false;
                state.dataUnitarySystems->HeatingLoad = true;
            } else {
                SensLoad = 0.0;
                state.dataUnitarySystems->HeatingLoad = false;
            }
            LatLoad = 0.0;
            this->m_FanOpMode = 1; // why is this here?
        }

        Real64 OnOffAirFlowRatio = 1.0;
        this->setOnOffMassFlowRate(state, OnOffAirFlowRatio, PartLoadFrac); // 1.0d0 = PartLoadRatio

        this->calcPassiveSystem(state, AirLoopNum, FirstHVACIteration);

        if ((CoilTypeNum == DataHVACGlobals::CoilDX_MultiSpeedCooling) || (CoilTypeNum == DataHVACGlobals::CoilDX_MultiSpeedHeating)) {

            // TODO: THIS IF SECTION DOES NOTHING
            if (CoilType == DataHVACGlobals::Cooling) {
                if (this->m_CoolingSpeedNum <= 1.0) {
                    SpeedRatio = 0.0;
                    CycRatio = PartLoadFrac;
                } else {
                    if (this->m_SingleMode == 0) {
                        SpeedRatio = PartLoadFrac;
                        CycRatio = 0.0;
                    } else {
                        SpeedRatio = 1.0;
                        CycRatio = PartLoadFrac;
                    }
                }
            } else {
                if (this->m_HeatingSpeedNum <= 1.0) {
                    SpeedRatio = 0.0;
                    CycRatio = PartLoadFrac;
                } else {
                    if (this->m_SingleMode == 0) {
                        SpeedRatio = PartLoadFrac;
                        CycRatio = 0.0;
                    } else {
                        SpeedRatio = 1.0;
                        CycRatio = PartLoadFrac;
                    }
                }
            }
            DXCoils::SimDXCoilMultiSpeed(state, CompName, 0.0, PartLoadFrac, CompIndex, SpeedNum, this->m_FanOpMode, 1, this->m_SingleMode);

        } else if (CoilTypeNum == DataHVACGlobals::CoilDX_Cooling) {

            if (CoilType == DataHVACGlobals::Cooling) {
                if (this->m_CoolingSpeedNum <= 1.0) {
                    SpeedRatio = 0.0;
                    CycRatio = PartLoadFrac;
                } else {
                    if (this->m_SingleMode == 0) {
                        SpeedRatio = PartLoadFrac;
                        CycRatio = 0.0;
                    } else {
                        SpeedRatio = 1.0;
                        CycRatio = PartLoadFrac;
                    }
                }
            }
            bool const singleMode = (this->m_SingleMode == 1);
            int OperationMode = DataHVACGlobals::coilNormalMode;
            if (state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].SubcoolReheatFlag) {
                OperationMode = DataHVACGlobals::coilSubcoolReheatMode;
            } else if (this->m_DehumidificationMode == 1) {
                OperationMode = DataHVACGlobals::coilEnhancedMode;
            }

            state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].simulate(
                state, OperationMode, CycRatio, this->m_CoolingSpeedNum, SpeedRatio, this->m_FanOpMode, singleMode, this->CoilSHR);

        } else if (CoilTypeNum == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {

            VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                      CompName,
                                                      CompIndex,
                                                      this->m_FanOpMode,
                                                      this->m_MaxONOFFCyclesperHour,
                                                      this->m_HPTimeConstant,
                                                      this->m_FanDelayTime,
                                                      CompOn,
                                                      PartLoadFrac,
                                                      SpeedNum,
                                                      this->m_CoolingSpeedRatio,
                                                      SensLoad,
                                                      dummy,
                                                      OnOffAirFlowRatio);

        } else if (CoilTypeNum == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) {

            VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                      CompName,
                                                      CompIndex,
                                                      this->m_FanOpMode,
                                                      this->m_MaxONOFFCyclesperHour,
                                                      this->m_HPTimeConstant,
                                                      this->m_FanDelayTime,
                                                      CompOn,
                                                      PartLoadFrac,
                                                      SpeedNum,
                                                      this->m_HeatingSpeedRatio,
                                                      SensLoad,
                                                      dummy,
                                                      OnOffAirFlowRatio);

        } else if (CoilTypeNum == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit) {

            VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                      CompName,
                                                      CompIndex,
                                                      this->m_FanOpMode,
                                                      this->m_MaxONOFFCyclesperHour,
                                                      this->m_HPTimeConstant,
                                                      this->m_FanDelayTime,
                                                      CompOn,
                                                      PartLoadFrac,
                                                      SpeedNum,
                                                      this->m_CoolingSpeedRatio,
                                                      SensLoad,
                                                      dummy,
                                                      OnOffAirFlowRatio);

        } else if (CoilTypeNum == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit) {

            VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                      CompName,
                                                      CompIndex,
                                                      this->m_FanOpMode,
                                                      this->m_MaxONOFFCyclesperHour,
                                                      this->m_HPTimeConstant,
                                                      this->m_FanDelayTime,
                                                      CompOn,
                                                      PartLoadFrac,
                                                      SpeedNum,
                                                      this->m_HeatingSpeedRatio,
                                                      SensLoad,
                                                      dummy,
                                                      OnOffAirFlowRatio);

        } else if ((CoilTypeNum == DataHVACGlobals::Coil_HeatingElectric_MultiStage) ||
                   (CoilTypeNum == DataHVACGlobals::Coil_HeatingGas_MultiStage)) {

            HeatingCoils::SimulateHeatingCoilComponents(
                state, CompName, FirstHVACIteration, _, CompIndex, _, _, this->m_FanOpMode, PartLoadFrac, SpeedNum, this->m_HeatingSpeedRatio);
        } else {
        }
    }

    void UnitarySys::calcPassiveSystem(EnergyPlusData &state,
                                       int const AirLoopNum,         // index to air loop
                                       bool const FirstHVACIteration // True when first HVAC iteration
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine calculates the set point based output of the unitary system.

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        Real64 PartLoadRatio = 0.0; // coil operating part-load ratio
        int CompOn = 0;             // compressor control (0=off, 1=on)
        bool HXUnitOn = false;

        Real64 OnOffAirFlowRatio = 1.0;
        Real64 CoilCoolHeatRat = 1.0;
        Real64 HeatCoilLoad = 0.0;
        // CALL the series of components that simulate a Unitary System
        if (this->m_FanExists && this->m_FanPlace == FanPlace::BlowThru) {
            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                state.dataHVACFan->fanObjs[this->m_FanIndex]->simulate(state,
                                                                       _,
                                                                       _,
                                                                       _,
                                                                       _,
                                                                       state.dataUnitarySystems->m_massFlow1,
                                                                       state.dataUnitarySystems->m_runTimeFraction1,
                                                                       state.dataUnitarySystems->m_massFlow2,
                                                                       state.dataUnitarySystems->m_runTimeFraction2,
                                                                       _);
            } else {
                Fans::SimulateFanComponents(state, blankString, FirstHVACIteration, this->m_FanIndex, state.dataUnitarySystems->FanSpeedRatio);
            }
        }

        if (this->m_CoolingCoilUpstream) {

            if (this->m_CoolCoilExists) {
                PartLoadRatio = this->m_CoolingPartLoadFrac;
                CompOn = 0;
                if (PartLoadRatio > 0.0) CompOn = 1;
                HXUnitOn = false;
                this->calcUnitaryCoolingSystem(
                    state, AirLoopNum, FirstHVACIteration, PartLoadRatio, CompOn, OnOffAirFlowRatio, CoilCoolHeatRat, HXUnitOn);
            }
            if (this->m_HeatCoilExists) {
                PartLoadRatio = this->m_HeatingPartLoadFrac;
                CompOn = 0;
                if (PartLoadRatio > 0.0) CompOn = 1;
                this->calcUnitaryHeatingSystem(state, AirLoopNum, FirstHVACIteration, PartLoadRatio, CompOn, OnOffAirFlowRatio, HeatCoilLoad);
            }

        } else {

            if (this->m_HeatCoilExists) {
                PartLoadRatio = this->m_HeatingPartLoadFrac;
                CompOn = 0;
                if (PartLoadRatio > 0.0) CompOn = 1;
                this->calcUnitaryHeatingSystem(state, AirLoopNum, FirstHVACIteration, PartLoadRatio, CompOn, OnOffAirFlowRatio, HeatCoilLoad);
            }
            if (this->m_CoolCoilExists) {
                PartLoadRatio = this->m_CoolingPartLoadFrac;
                CompOn = 0;
                if (PartLoadRatio > 0.0) CompOn = 1;
                HXUnitOn = false;
                this->calcUnitaryCoolingSystem(
                    state, AirLoopNum, FirstHVACIteration, PartLoadRatio, CompOn, OnOffAirFlowRatio, CoilCoolHeatRat, HXUnitOn);
            }
        }

        if (this->m_FanExists && this->m_FanPlace == FanPlace::DrawThru) {
            if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
                state.dataHVACFan->fanObjs[this->m_FanIndex]->simulate(state,
                                                                       _,
                                                                       _,
                                                                       _,
                                                                       _,
                                                                       state.dataUnitarySystems->m_massFlow1,
                                                                       state.dataUnitarySystems->m_runTimeFraction1,
                                                                       state.dataUnitarySystems->m_massFlow2,
                                                                       state.dataUnitarySystems->m_runTimeFraction2,
                                                                       _);
            } else {
                Fans::SimulateFanComponents(state, blankString, FirstHVACIteration, this->m_FanIndex, state.dataUnitarySystems->FanSpeedRatio);
            }
        }

        // CALL reheat coils next
        if (this->m_SuppCoilExists) {
            state.dataUnitarySystems->SuppHeatingCoilFlag = true;
            this->calcUnitarySuppSystemToSP(state, FirstHVACIteration);
            state.dataUnitarySystems->SuppHeatingCoilFlag = false;
        }
    }

    void UnitarySys::reportUnitarySystem(EnergyPlusData &state, int const AirLoopNum)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Chandan Sharma
        //       DATE WRITTEN   July 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine updates the report variable for the coils.

        auto &OASysEqSizing(state.dataSize->OASysEqSizing);
        auto &CurOASysNum(state.dataSize->CurOASysNum);

        Real64 ReportingConstant = state.dataHVACGlobal->TimeStepSys * DataGlobalConstants::SecInHour;

        Real64 SensibleOutput = 0.0; // sensible output rate, {W}
        Real64 LatentOutput = 0.0;   // latent output rate, {W}
        Real64 TotalOutput = 0.0;    // total output rate, {W}
        Real64 QTotUnitOut = 0.0;
        Real64 QSensUnitOut = 0.0;
        this->m_PartLoadFrac = 0.0;
        this->m_CompPartLoadRatio = 0.0;
        this->m_CycRatio = 0.0;
        this->m_SpeedRatio = 0.0;
        this->FanPartLoadRatio = 0.0;
        this->m_TotalAuxElecPower = 0.0;
        this->m_HeatingAuxElecConsumption = 0.0;
        this->m_CoolingAuxElecConsumption = 0.0;
        this->m_ElecPower = 0.0;
        this->m_ElecPowerConsumption = 0.0;

        int OutletNode = this->AirOutNode;

        Real64 AirMassFlow = state.dataLoopNodes->Node(OutletNode).MassFlowRate;
        auto const SELECT_CASE_var(this->m_ControlType);
        // Noticed that these are calculated differently.
        // That doesn't make sense except that NodeNumOfControlledZone = 0 for set point control because the control zone name is not required.
        if (SELECT_CASE_var == ControlType::Setpoint) {
            if (OutletNode > 0) {
                int InletNode = this->AirInNode;
                CalcComponentSensibleLatentOutput(AirMassFlow,
                                                  state.dataLoopNodes->Node(OutletNode).Temp,
                                                  state.dataLoopNodes->Node(OutletNode).HumRat,
                                                  state.dataLoopNodes->Node(InletNode).Temp,
                                                  state.dataLoopNodes->Node(InletNode).HumRat,
                                                  SensibleOutput,
                                                  LatentOutput,
                                                  TotalOutput);
                QSensUnitOut = SensibleOutput - this->m_SenLoadLoss;
                QTotUnitOut = TotalOutput;
            }
        } else {
            if (OutletNode > 0 && this->NodeNumOfControlledZone > 0) {
                CalcZoneSensibleLatentOutput(AirMassFlow,
                                             state.dataLoopNodes->Node(OutletNode).Temp,
                                             state.dataLoopNodes->Node(OutletNode).HumRat,
                                             state.dataLoopNodes->Node(this->NodeNumOfControlledZone).Temp,
                                             state.dataLoopNodes->Node(this->NodeNumOfControlledZone).HumRat,
                                             SensibleOutput,
                                             LatentOutput,
                                             TotalOutput);
                QSensUnitOut = SensibleOutput - this->m_SenLoadLoss;
                QTotUnitOut = TotalOutput;
            }
        }

        // set the system part-load ratio report variable
        this->m_PartLoadFrac = max(this->m_CoolingPartLoadFrac, this->m_HeatingPartLoadFrac);
        // set the compressor part-load ratio report variable
        this->m_CompPartLoadRatio = max(this->m_CoolCompPartLoadRatio, this->m_HeatCompPartLoadRatio);

        if (state.dataUnitarySystems->HeatingLoad) {
            if (QTotUnitOut > 0.0) { // heating
                this->m_TotCoolEnergyRate = 0.0;
                this->m_SensCoolEnergyRate = 0.0;
                this->m_LatCoolEnergyRate = 0.0;
                this->m_TotHeatEnergyRate = QTotUnitOut;
                this->m_SensHeatEnergyRate = std::abs(max(0.0, QSensUnitOut));
                this->m_LatHeatEnergyRate = std::abs(max(0.0, (QTotUnitOut - QSensUnitOut)));
            } else {
                this->m_TotCoolEnergyRate = std::abs(QTotUnitOut);
                this->m_SensCoolEnergyRate = std::abs(min(0.0, QSensUnitOut));
                this->m_LatCoolEnergyRate = std::abs(min(0.0, (QTotUnitOut - QSensUnitOut)));
                this->m_TotHeatEnergyRate = 0.0;
                this->m_SensHeatEnergyRate = 0.0;
                this->m_LatHeatEnergyRate = 0.0;
            }
        } else {
            if (QTotUnitOut <= 0.0) { // cooling
                this->m_TotCoolEnergyRate = std::abs(min(0.0, QTotUnitOut));
                this->m_SensCoolEnergyRate = std::abs(min(0.0, QSensUnitOut));
                this->m_LatCoolEnergyRate = std::abs(min(0.0, (QTotUnitOut - QSensUnitOut)));
                this->m_TotHeatEnergyRate = 0.0;
                this->m_SensHeatEnergyRate = 0.0;
                this->m_LatHeatEnergyRate = 0.0;
            } else {
                this->m_TotCoolEnergyRate = 0.0;
                this->m_SensCoolEnergyRate = 0.0;
                this->m_LatCoolEnergyRate = 0.0;
                this->m_TotHeatEnergyRate = QTotUnitOut;
                this->m_SensHeatEnergyRate = std::abs(max(0.0, QSensUnitOut));
                this->m_LatHeatEnergyRate = std::abs(max(0.0, (QTotUnitOut - QSensUnitOut)));
            }
        }

        if (this->m_FanExists && OutletNode > 0) {
            if (state.dataUnitarySystems->CompOnMassFlow > 0.0) {
                this->FanPartLoadRatio = state.dataLoopNodes->Node(OutletNode).MassFlowRate / state.dataUnitarySystems->CompOnMassFlow;
            }
            if (AirLoopNum > 0) {
                if (this->m_FanOpMode == DataHVACGlobals::CycFanCycCoil) {
                    state.dataAirLoop->AirLoopFlow(AirLoopNum).FanPLR = this->FanPartLoadRatio;
                } else {
                    state.dataAirLoop->AirLoopFlow(AirLoopNum).FanPLR = 1.0;
                }
            }
        }

        Real64 locFanElecPower = 0.0;
        if (this->m_FanType_Num == DataHVACGlobals::FanType_SystemModelObject) {
            locFanElecPower = state.dataHVACFan->fanObjs[this->m_FanIndex]->fanPower();
        } else {
            locFanElecPower = Fans::GetFanPower(state, this->m_FanIndex);
        }

        Real64 elecCoolingPower = 0.0;
        Real64 elecHeatingPower = 0.0;
        Real64 suppHeatingPower = 0.0;

        {
            auto const SELECT_CASE_var(this->m_CoolingCoilType_Num);

            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {
                // need to make sure these are 0 for non-variable speed coils (or not report these variables)
                this->m_CycRatio = max(this->m_CoolingCycRatio, this->m_HeatingCycRatio);
                this->m_SpeedRatio = max(this->m_CoolingSpeedRatio, this->m_HeatingSpeedRatio);
                this->m_SpeedNum = max(this->m_CoolingSpeedNum, this->m_HeatingSpeedNum);
                // see :setSpeedVariables
                if (state.dataUnitarySystems->CoolingLoad && this->m_SpeedNum <= 1) {
                    this->m_TotalAuxElecPower = this->m_AncillaryOnPower * this->m_CycRatio + this->m_AncillaryOffPower * (1.0 - this->m_CycRatio);
                    this->m_CoolingAuxElecConsumption = this->m_AncillaryOnPower * this->m_CycRatio * ReportingConstant;
                }
                if (this->m_LastMode == state.dataUnitarySystems->CoolingMode) {
                    this->m_CoolingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - this->m_CycRatio) * ReportingConstant;
                }
                elecCoolingPower = state.dataHVACGlobal->DXElecCoolingPower;

            } else if ((SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedCooling) ||
                       ((SELECT_CASE_var == DataHVACGlobals::CoilDX_Cooling) && (this->m_NumOfSpeedCooling > 1))) {
                this->m_CycRatio = max(this->m_CoolingCycRatio, this->m_HeatingCycRatio);
                this->m_SpeedRatio = max(this->m_CoolingSpeedRatio, this->m_HeatingSpeedRatio);
                this->m_SpeedNum = max(this->m_CoolingSpeedNum, this->m_HeatingSpeedNum);

                Real64 CompPartLoadFrac = this->m_CompPartLoadRatio;
                if (state.dataUnitarySystems->CoolingLoad) {
                    this->m_TotalAuxElecPower = this->m_AncillaryOnPower * CompPartLoadFrac + this->m_AncillaryOffPower * (1.0 - CompPartLoadFrac);
                    this->m_CoolingAuxElecConsumption = this->m_AncillaryOnPower * CompPartLoadFrac * ReportingConstant;
                }
                if (this->m_LastMode == state.dataUnitarySystems->CoolingMode) {
                    this->m_CoolingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - CompPartLoadFrac) * ReportingConstant;
                }
                elecCoolingPower = state.dataHVACGlobal->DXElecCoolingPower;

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWater || SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterDetailed) {

                if (this->m_DiscreteSpeedCoolingCoil) {
                    this->m_CycRatio = max(this->m_CoolingCycRatio, this->m_HeatingCycRatio);
                    this->m_SpeedRatio = max(this->m_CoolingSpeedRatio, this->m_HeatingSpeedRatio);
                    this->m_SpeedNum = max(this->m_CoolingSpeedNum, this->m_HeatingSpeedNum);
                    if (state.dataUnitarySystems->CoolingLoad) {
                        // if discrete, the coil cycles on and off
                        this->m_TotalAuxElecPower =
                            this->m_AncillaryOnPower * this->m_CycRatio + this->m_AncillaryOffPower * (1.0 - this->m_CycRatio);
                        this->m_CoolingAuxElecConsumption = this->m_AncillaryOnPower * this->m_CycRatio * ReportingConstant;
                    }
                    if (this->m_LastMode == state.dataUnitarySystems->CoolingMode) {
                        this->m_CoolingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - this->m_CycRatio) * ReportingConstant;
                    }
                } else {
                    if (state.dataUnitarySystems->CoolingLoad) {
                        // if not discrete, the coil runs the entire time step.
                        this->m_TotalAuxElecPower =
                            this->m_AncillaryOnPower * this->m_PartLoadFrac + this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac);
                        this->m_CoolingAuxElecConsumption = this->m_AncillaryOnPower * this->m_PartLoadFrac * ReportingConstant;
                    }
                    if (this->m_LastMode == state.dataUnitarySystems->CoolingMode) {
                        this->m_CoolingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac) * ReportingConstant;
                    }
                }
                this->m_ElecPower = locFanElecPower;
                this->m_ElecPowerConsumption = this->m_ElecPower * ReportingConstant;
            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_Cooling && (this->m_NumOfSpeedCooling <= 1)) {
                if (state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].SubcoolReheatFlag) {
                    if (state.dataUnitarySystems->CoolingLoad && this->LoadSHR == 0.0) {
                        this->LoadSHR = 1.0;
                        this->CoilSHR = state.dataCoilCooingDX->coilCoolingDXs[this->m_CoolingCoilIndex].performance.NormalSHR;
                    }
                }
                Real64 CompPartLoadFrac = this->m_CompPartLoadRatio;
                if (state.dataUnitarySystems->CoolingLoad) {
                    this->m_TotalAuxElecPower = this->m_AncillaryOnPower * CompPartLoadFrac + this->m_AncillaryOffPower * (1.0 - CompPartLoadFrac);
                    this->m_CoolingAuxElecConsumption = this->m_AncillaryOnPower * CompPartLoadFrac * ReportingConstant;
                }
                if (this->m_LastMode == state.dataUnitarySystems->CoolingMode) {
                    this->m_CoolingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - CompPartLoadFrac) * ReportingConstant;
                }
                elecCoolingPower = state.dataHVACGlobal->DXElecCoolingPower;
            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_UserDefined || SELECT_CASE_var == DataHVACGlobals::CoilWater_CoolingHXAssisted ||
                       SELECT_CASE_var == DataHVACGlobals::CoilDX_PackagedThermalStorageCooling) {
                if (state.dataUnitarySystems->CoolingLoad) {
                    this->m_TotalAuxElecPower =
                        this->m_AncillaryOnPower * this->m_PartLoadFrac + this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac);
                    this->m_CoolingAuxElecConsumption = this->m_AncillaryOnPower * this->m_PartLoadFrac * ReportingConstant;
                }
                if (this->m_LastMode == state.dataUnitarySystems->CoolingMode) {
                    this->m_CoolingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac) * ReportingConstant;
                }
                // these coil types do not consume electricity or report electricity at the plant
            } else { // all other DX cooling coils
                Real64 CompPartLoadFrac = this->m_CompPartLoadRatio;
                if (state.dataUnitarySystems->CoolingLoad) {
                    this->m_TotalAuxElecPower = this->m_AncillaryOnPower * CompPartLoadFrac + this->m_AncillaryOffPower * (1.0 - CompPartLoadFrac);
                    this->m_CoolingAuxElecConsumption = this->m_AncillaryOnPower * CompPartLoadFrac * ReportingConstant;
                }
                if (this->m_LastMode == state.dataUnitarySystems->CoolingMode) {
                    this->m_CoolingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - CompPartLoadFrac) * ReportingConstant;
                }
                elecCoolingPower = state.dataHVACGlobal->DXElecCoolingPower;
            }
        }

        {
            auto const SELECT_CASE_var(this->m_HeatingCoilType_Num);

            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedHeating) {
                this->m_CycRatio = max(this->m_CoolingCycRatio, this->m_HeatingCycRatio);
                this->m_SpeedRatio = max(this->m_CoolingSpeedRatio, this->m_HeatingSpeedRatio);
                this->m_SpeedNum = max(this->m_CoolingSpeedNum, this->m_HeatingSpeedNum);

                Real64 CompPartLoadFrac = this->m_CompPartLoadRatio;
                if (state.dataUnitarySystems->HeatingLoad) {
                    this->m_TotalAuxElecPower = this->m_AncillaryOnPower * CompPartLoadFrac + this->m_AncillaryOffPower * (1.0 - CompPartLoadFrac);
                    this->m_HeatingAuxElecConsumption = this->m_AncillaryOnPower * CompPartLoadFrac * ReportingConstant;
                }
                if (this->m_LastMode == state.dataUnitarySystems->HeatingMode) {
                    this->m_HeatingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - CompPartLoadFrac) * ReportingConstant;
                }
                elecHeatingPower = state.dataHVACGlobal->DXElecHeatingPower;

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGas_MultiStage) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric_MultiStage)) {
                this->m_CycRatio = max(this->m_CoolingCycRatio, this->m_HeatingCycRatio);
                this->m_SpeedRatio = max(this->m_CoolingSpeedRatio, this->m_HeatingSpeedRatio);

                if (state.dataUnitarySystems->HeatingLoad) {
                    this->m_TotalAuxElecPower =
                        this->m_AncillaryOnPower * this->m_PartLoadFrac + this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac);
                    this->m_HeatingAuxElecConsumption = this->m_AncillaryOnPower * this->m_PartLoadFrac * ReportingConstant;
                }
                if (this->m_LastMode == state.dataUnitarySystems->HeatingMode) {
                    this->m_HeatingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac) * ReportingConstant;
                }

                elecHeatingPower = state.dataHVACGlobal->ElecHeatingCoilPower;

            } else if ((SELECT_CASE_var == DataHVACGlobals::CoilDX_HeatingEmpirical) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHP) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed)) {

                if (state.dataUnitarySystems->HeatingLoad) {
                    this->m_TotalAuxElecPower =
                        this->m_AncillaryOnPower * this->m_PartLoadFrac + this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac);
                    this->m_HeatingAuxElecConsumption = this->m_AncillaryOnPower * this->m_PartLoadFrac * ReportingConstant;
                }
                if (this->m_LastMode == state.dataUnitarySystems->HeatingMode) {
                    this->m_HeatingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac) * ReportingConstant;
                }

                elecHeatingPower = state.dataHVACGlobal->DXElecHeatingPower;

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_UserDefined) || (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWater) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingSteam) || (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingDesuperheater)) {

                if (state.dataUnitarySystems->HeatingLoad) {
                    this->m_TotalAuxElecPower =
                        this->m_AncillaryOnPower * this->m_PartLoadFrac + this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac);
                    this->m_HeatingAuxElecConsumption = this->m_AncillaryOnPower * this->m_PartLoadFrac * ReportingConstant;
                }
                if (this->m_LastMode == state.dataUnitarySystems->HeatingMode) {
                    this->m_HeatingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac) * ReportingConstant;
                }

            } else if (this->m_HeatCoilExists) {
                if (state.dataUnitarySystems->HeatingLoad) {
                    // if discrete, the coil cycles on and off
                    this->m_TotalAuxElecPower =
                        this->m_AncillaryOnPower * this->m_PartLoadFrac + this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac);
                    this->m_HeatingAuxElecConsumption = this->m_AncillaryOnPower * this->m_PartLoadFrac * ReportingConstant;
                }
                if (this->m_LastMode == state.dataUnitarySystems->HeatingMode) {
                    this->m_HeatingAuxElecConsumption += this->m_AncillaryOffPower * (1.0 - this->m_PartLoadFrac) * ReportingConstant;
                }
                elecHeatingPower = state.dataHVACGlobal->ElecHeatingCoilPower;
            }
        }

        if (!state.dataUnitarySystems->HeatingLoad && !state.dataUnitarySystems->CoolingLoad) {
            this->m_TotalAuxElecPower = this->m_AncillaryOffPower;
        }

        if (this->m_SuppCoilExists) {
            auto const SELECT_CASE_var(this->m_HeatingCoilType_Num);
            if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric) {
                suppHeatingPower = state.dataHVACGlobal->SuppHeatingCoilPower;
            }
        }

        this->m_ElecPower = locFanElecPower + elecCoolingPower + elecHeatingPower + suppHeatingPower + this->m_TotalAuxElecPower;
        this->m_ElecPowerConsumption = this->m_ElecPower * ReportingConstant;

        if (state.dataAirflowNetwork->SimulateAirflowNetwork == AirflowNetwork::AirflowNetworkControlMultiADS ||
            state.dataAirflowNetwork->SimulateAirflowNetwork == AirflowNetwork::AirflowNetworkControlSimpleADS) {
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).LoopSystemOnMassFlowrate = state.dataUnitarySystems->CompOnMassFlow;
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).LoopSystemOffMassFlowrate = state.dataUnitarySystems->CompOffMassFlow;
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).LoopFanOperationMode = this->m_FanOpMode;
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).LoopOnOffFanPartLoadRatio = this->FanPartLoadRatio;
            state.dataAirLoop->AirLoopAFNInfo(AirLoopNum).LoopCompCycRatio = this->m_CycRatio;
        }
        if (this->m_FirstPass) {
            if (AirLoopNum > -1) {
                if (!state.dataGlobal->SysSizingCalc) {

                    if (CurOASysNum > 0) {
                        OASysEqSizing(CurOASysNum).AirFlow = false;
                        OASysEqSizing(CurOASysNum).CoolingAirFlow = false;
                        OASysEqSizing(CurOASysNum).HeatingAirFlow = false;
                        OASysEqSizing(CurOASysNum).Capacity = false;
                        OASysEqSizing(CurOASysNum).CoolingCapacity = false;
                        OASysEqSizing(CurOASysNum).HeatingCapacity = false;
                        this->m_FirstPass = false;
                    } else if (state.dataSize->CurSysNum > 0) {
                        state.dataAirLoop->AirLoopControlInfo(state.dataSize->CurSysNum).UnitarySysSimulating = false;
                        DataSizing::resetHVACSizingGlobals(state, state.dataSize->CurZoneEqNum, state.dataSize->CurSysNum, this->m_FirstPass);
                    } else if (state.dataSize->CurZoneEqNum > 0) {
                        DataSizing::resetHVACSizingGlobals(state, state.dataSize->CurZoneEqNum, state.dataSize->CurSysNum, this->m_FirstPass);
                    } else {
                        this->m_FirstPass = false;
                    }
                }
            } else {
                this->m_FirstPass = false;
            }
        }

        // reset to 1 in case blow through fan configuration (fan resets to 1, but for blow thru fans coil sets back down < 1)
        state.dataHVACGlobal->OnOffFanPartLoadFraction = 1.0;
        state.dataSize->ZoneEqUnitarySys = false;
    }

    void UnitarySys::unitarySystemHeatRecovery(EnergyPlusData &state)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR:          Chandan Sharma
        //       DATE WRITTEN:    May 2013

        // PURPOSE OF THIS SUBROUTINE:
        //  Calculate the heat recovered from UnitarySystem

        // SUBROUTINE PARAMETER DEFINITIONS:
        static constexpr std::string_view routineName("UnitarySystemHeatRecovery");

        Real64 ReportingConstant = state.dataHVACGlobal->TimeStepSys * DataGlobalConstants::SecInHour;

        int HeatRecInNode = this->m_HeatRecoveryInletNodeNum;
        int HeatRecOutNode = this->m_HeatRecoveryOutletNodeNum;

        Real64 HeatRecInletTemp = state.dataLoopNodes->Node(HeatRecInNode).Temp;
        Real64 HeatRecOutletTemp = 0.0;

        // Set heat recovery mass flow rates
        Real64 HeatRecMassFlowRate = state.dataLoopNodes->Node(HeatRecInNode).MassFlowRate;

        Real64 QHeatRec = state.dataHVACGlobal->MSHPWasteHeat;

        if (HeatRecMassFlowRate > 0.0) {

            Real64 CpHeatRec = FluidProperties::GetSpecificHeatGlycol(state,
                                                                      state.dataPlnt->PlantLoop(this->m_HRLoopNum).FluidName,
                                                                      HeatRecInletTemp,
                                                                      state.dataPlnt->PlantLoop(this->m_HRLoopNum).FluidIndex,
                                                                      routineName);

            HeatRecOutletTemp = QHeatRec / (HeatRecMassFlowRate * CpHeatRec) + HeatRecInletTemp;
            // coil model should be handling max outlet water temp (via limit to heat transfer) since heat rejection needs to be accounted for by the
            // coil
            if (HeatRecOutletTemp > this->m_MaxHROutletWaterTemp) {
                HeatRecOutletTemp = max(HeatRecInletTemp, this->m_MaxHROutletWaterTemp);
                QHeatRec = HeatRecMassFlowRate * CpHeatRec * (HeatRecOutletTemp - HeatRecInletTemp);
            }
        } else {
            HeatRecOutletTemp = HeatRecInletTemp;
            QHeatRec = 0.0;
        }

        PlantUtilities::SafeCopyPlantNode(state, HeatRecInNode, HeatRecOutNode);

        state.dataLoopNodes->Node(HeatRecOutNode).Temp = HeatRecOutletTemp;

        this->m_HeatRecoveryRate = QHeatRec;
        this->m_HeatRecoveryEnergy = this->m_HeatRecoveryRate * ReportingConstant;
        this->m_HeatRecoveryInletTemp = HeatRecInletTemp;
        this->m_HeatRecoveryOutletTemp = HeatRecOutletTemp;
        this->m_HeatRecoveryMassFlowRate = HeatRecMassFlowRate;
    }

    void UnitarySys::heatPumpRunFrac(Real64 const PLR,   // part load ratio
                                     bool &errFlag,      // part load factor out of range flag
                                     Real64 &RuntimeFrac // the required run time fraction to meet part load
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Kenneth Tang
        //       DATE WRITTEN   Apr 2004

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine calculates the PLF based on the PLR. Parameters required are
        // thermostat cycling rate (Nmax), heat pump time constant (tau), and the fraction
        // of on-cycle power use (pr)

        // METHODOLOGY EMPLOYED:
        // NA

        // REFERENCES:
        // (1) Henderson, H. I., K. Rengarajan.1996. A Model to predict the latent capacity
        // of air conditioners and heat pumps at part-load conditions with constant fan
        // operation. ASHRAE Transactions 102 (1): 266-274

        // (2) Henderson, H.I. Jr., Y.J. Huang and Danny Parker. 1999. Residential Equipment
        // Part Load Curves for Use in DOE-2.  Environmental Energy Technologies Division,
        // Ernest OrlanDO Lawrence Berkeley National Laboratory.

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        Real64 PartLoadFactor; // Part load factor
        Real64 Nmax;           // Maximum cycling rate [cycles/hr]
        Real64 tau;            // Heat pump time constant [s]
        Real64 pr;             // On-cycle power use fraction [~]
        Real64 error;          // Calculation error
        Real64 PLF1;           // ith term of part load factor
        Real64 PLF2;           // (i+1)th term of part load factor
        Real64 A;              // Variable for simplIFy equation
        int NumIteration;      // Iteration Counter

        Nmax = this->m_MaxONOFFCyclesperHour;
        tau = this->m_HPTimeConstant;
        pr = this->m_OnCyclePowerFraction;

        // Initialize
        errFlag = false;
        error = 1;
        NumIteration = 0;

        // Initial guess for part load fraction
        PLF1 = 1;

        // Calculate PLF using successive substitution until convergence
        // is achieved
        while (true) {
            ++NumIteration;

            if (PLR == 1) {
                // Set part load fraction, PLF1=1.0 IF PLR=1.0 and EXIT loop
                PLF1 = 1;
                break;
            }

            if (NumIteration > 100) {
                // EXIT loop IF interation exceed 100
                errFlag = true;
                PLF1 = 1;
                break;
            }

            if (error < 0.00001) {
                // EXIT loop IF convergence is achieved
                break;

            } else {
                // Calculate PLF
                A = 4.0 * tau * (Nmax / 3600.0) * (1 - PLR / PLF1);
                if (A < 1.5e-3) {
                    // A safety check to prevent PLF2 = 1 - A * (1 - Exp(-1 / A))
                    // from "float underflow error". Occurs when PLR is very close to 1.0,
                    // small A value, thus Exp(-1/A) = 0
                    PLF2 = 1.0 - A;
                } else {
                    PLF2 = 1.0 - A * (1.0 - std::exp(-1.0 / A));
                }
                error = std::abs((PLF2 - PLF1) / PLF1);
                PLF1 = PLF2;
            }
        }

        // Adjust PLF for the off cycle power consumption IF
        // on-cycle power use is specified by the user
        if (pr > 0.0) {
            PartLoadFactor = PLR / ((PLR / PLF1) + (1.0 - PLR / PLF1) * pr);
        } else {
            PartLoadFactor = PLF1;
        }

        if (PartLoadFactor <= 0.0) {
            PartLoadFactor = 0;
            RuntimeFrac = 0;
            errFlag = true;
        } else {
            RuntimeFrac = PLR / PartLoadFactor;
        }

        if (RuntimeFrac > 1.0) {
            RuntimeFrac = 1.0;
        }
    }

    Real64 UnitarySys::hotWaterHeatingCoilResidual(EnergyPlusData &state,
                                                   Real64 const PartLoadFrac,     // Compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                   std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Chandan Sharma, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // hot water Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimulateWaterCoilComponents to get outlet temperature at the given part load ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // Residual to be minimized to zero

        // Argument array dimensioning
        // Par(2) = desired air outlet temperature [C]

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirTemp; // Outlet air temperature [C]

        int UnitarySysNum = int(Par[1]);
        bool FirstHVACIteration = (Par[2] > 0.0);
        bool SuppHeatingCoilFlag = (Par[4] > 0.0);
        bool LoadBased = (Par[5] > 0.0);
        Real64 QActual = 0.0;
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        if (!SuppHeatingCoilFlag) {
            Real64 mdot =
                min(state.dataLoopNodes->Node(thisSys.HeatCoilFluidOutletNodeNum).MassFlowRateMaxAvail, thisSys.MaxHeatCoilFluidFlow * PartLoadFrac);
            state.dataLoopNodes->Node(thisSys.HeatCoilFluidInletNode).MassFlowRate = mdot;
            WaterCoils::SimulateWaterCoilComponents(
                state, thisSys.m_HeatingCoilName, FirstHVACIteration, thisSys.m_HeatingCoilIndex, QActual, thisSys.m_FanOpMode, PartLoadFrac);
            OutletAirTemp = state.dataLoopNodes->Node(thisSys.HeatCoilOutletNodeNum).Temp;
        } else {
            Real64 mdot = min(state.dataLoopNodes->Node(thisSys.m_SuppCoilFluidOutletNodeNum).MassFlowRateMaxAvail,
                              thisSys.m_MaxSuppCoilFluidFlow * PartLoadFrac);
            state.dataLoopNodes->Node(thisSys.m_SuppCoilFluidInletNode).MassFlowRate = mdot;
            WaterCoils::SimulateWaterCoilComponents(
                state, thisSys.m_SuppHeatCoilName, FirstHVACIteration, thisSys.m_SuppHeatCoilIndex, QActual, thisSys.m_FanOpMode, PartLoadFrac);
            OutletAirTemp = state.dataLoopNodes->Node(thisSys.m_SuppCoilAirOutletNode).Temp;
        }
        if (LoadBased) {
            Residuum = Par[3] - QActual;
        } else {
            Residuum = Par[3] - OutletAirTemp;
        }

        return Residuum;
    }

    Real64 UnitarySys::DOE2DXCoilResidual(EnergyPlusData &state,
                                          Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                          std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   November 2003

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // DX Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls CalcDOe2DXCoil to get outlet temperature at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet temperature [C]
        // par(5) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        int CoilIndex = int(Par[1]);
        int FanOpMode = int(Par[5]);
        DXCoils::CalcDoe2DXCoil(state, CoilIndex, state.dataUnitarySystems->On, true, PartLoadRatio, FanOpMode);
        Real64 OutletAirTemp = state.dataDXCoils->DXCoilOutletTemp(CoilIndex);
        Residuum = Par[2] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::genericDXCoilResidual(EnergyPlusData &state,
                                             Real64 const PartLoadRatio,      // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                             std::array<Real64, 8> const &Par // par(1) = DX coil number
    )
    {

        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2020

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        int CoilIndex = int(Par[0]);
        bool useDehumMode = int(Par[2]) > 0;
        int FanOpMode = int(Par[3]);
        int CoolingSpeedNum = int(Par[4]);
        Real64 CoolingSpeedRatio = Par[5];
        bool RunOnSensible = (Par[6] == 0.0);
        bool const singleMode = (Par[7] == 1.0);
        if (CoolingSpeedNum == 1) {
            state.dataCoilCooingDX->coilCoolingDXs[CoilIndex].simulate(
                state, useDehumMode, PartLoadRatio, CoolingSpeedNum, CoolingSpeedRatio, FanOpMode, singleMode);
        } else {
            state.dataCoilCooingDX->coilCoolingDXs[CoilIndex].simulate(
                state, useDehumMode, CoolingSpeedRatio, CoolingSpeedNum, PartLoadRatio, FanOpMode, singleMode);
        }
        Real64 outletCondition = 0.0;
        if (RunOnSensible) {
            outletCondition = state.dataLoopNodes->Node(state.dataCoilCooingDX->coilCoolingDXs[CoilIndex].evapOutletNodeIndex).Temp;
        } else {
            outletCondition = state.dataLoopNodes->Node(state.dataCoilCooingDX->coilCoolingDXs[CoilIndex].evapOutletNodeIndex).HumRat;
        }
        Residuum = Par[1] - outletCondition;

        return Residuum;
    }

    Real64 UnitarySys::DOE2DXCoilHumRatResidual(EnergyPlusData &state,
                                                Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   January 2008

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet humrat - actual outlet humrat)
        // DX Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls CalcDOe2DXCoil to get outlet humidity ratio at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet humidity ratio [kg/kg]
        // par(5) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        int CoilIndex = int(Par[1]);
        int FanOpMode = int(Par[5]);
        DXCoils::CalcDoe2DXCoil(state, CoilIndex, state.dataUnitarySystems->On, true, PartLoadRatio, FanOpMode);
        Real64 OutletAirHumRat = state.dataDXCoils->DXCoilOutletHumRat(CoilIndex);
        Residuum = Par[2] - OutletAirHumRat;

        return Residuum;
    }

    Real64 UnitarySys::calcUnitarySystemLoadResidual(EnergyPlusData &state,
                                                     Real64 const PartLoadRatio,    // DX cooling coil part load ratio
                                                     std::vector<Real64> const &Par // Function parameters
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // To calculate the part-load ratio for the unitary system

        // METHODOLOGY EMPLOYED:
        // Use SolveRoot to CALL this Function to converge on a solution

        // Return value
        Real64 Residuum; // Result (force to 0)

        // Argument array dimensioning
        //   Parameter description example:
        //       Par(1)  = REAL(UnitarySysNum,r64) ! Index to Unitary System
        //       Par(2)  = 0.0                  ! FirstHVACIteration FLAG, IF 1.0 then TRUE, if 0.0 then FALSE
        //       Par(3)  = REAL(OpMode,r64)     ! Fan control, IF 1.0 then cycling fan, if 0.0 then continuous fan
        //       Par(4)  = REAL(CompOp,r64)     ! Compressor control, IF 1.0 then compressor ON, if 0.0 then compressor OFF
        //       Par(5)  = SensLoad or MoistureLoad   ! Sensible or Latent load to be met by unitary system
        //       Par(6)  = HeatingLoad or CoolingLoad ! Type of load FLAG, 0.0 IF heating load, 1.0 IF cooling or moisture load
        //       Par(7)  = 1.0                  ! Output calculation FLAG, 0.0 for latent capacity, 1.0 for sensible capacity
        //       Par(8)  = OnOffAirFlowRatio    ! Ratio of compressor ON air mass flow to AVERAGE air mass flow over time step
        //       Par(9)  = HXUnitOn             ! flag to enable HX, 1=ON and 2=OFF
        //       Par(10) = HeatingCoilPLR       ! used to calculate latent degradation for cycling fan RH control

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        Real64 HeatPLR;    // heating coil part load ratio
        Real64 CoolPLR;    // cooling coil part load ratio
        Real64 SensOutput; // sensible output of system
        Real64 LatOutput;  // latent output of system
        Real64 HeatCoilLoad = 0.0;
        Real64 SupHeaterLoad = 0.0;

        // Convert parameters to usable variables
        int UnitarySysNum = int(Par[1]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        bool FirstHVACIteration = (Par[2] > 0.0);
        // int FanOpMode = int(Par[3]);
        int CompOp = int(Par[4]);
        Real64 LoadToBeMet = Par[5];
        Real64 OnOffAirFlowRatio = Par[8];

        if (Par[6] == 1.0) {
            CoolPLR = PartLoadRatio;
            HeatPLR = 0.0;
        } else {
            CoolPLR = 0.0;
            HeatPLR = PartLoadRatio;
        }
        bool SensibleLoad = (Par[7] > 0.0);
        bool HXUnitOn = (Par[9] > 0.0);
        int AirLoopNum = int(Par[11]);

        thisSys.setSpeedVariables(state, SensibleLoad, PartLoadRatio);

        thisSys.calcUnitarySystemToLoad(state,
                                        AirLoopNum,
                                        FirstHVACIteration,
                                        CoolPLR,
                                        HeatPLR,
                                        OnOffAirFlowRatio,
                                        SensOutput,
                                        LatOutput,
                                        HXUnitOn,
                                        HeatCoilLoad,
                                        SupHeaterLoad,
                                        CompOp);

        // Calculate residual based on output calculation flag
        if (SensibleLoad) {
            if (std::abs(LoadToBeMet) == 0.0) {
                Residuum = (SensOutput - LoadToBeMet) / 100.0;
            } else {
                Residuum = (SensOutput - LoadToBeMet) / LoadToBeMet;
            }
        } else {
            if (std::abs(LoadToBeMet) == 0.0) {
                Residuum = (LatOutput - LoadToBeMet) / 100.0;
            } else {
                Residuum = (LatOutput - LoadToBeMet) / LoadToBeMet;
            }
        }

        return Residuum;
    }

    Real64 UnitarySys::HXAssistedCoolCoilTempResidual(EnergyPlusData &state,
                                                      Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                      std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   November 2003

        // PURPOSE OF THIS FUNCTION:
        //  Calculates residual function (desired outlet temp - actual outlet temp)
        //  DX Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        //  Calls CalcHXAssistedCoolingCoil to get outlet temperature at the given part load ratio
        //  and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet temperature [C]
        // par(3) = FirstHVACIteration logical converted to numeric (1=TRUE,0=FALSE)
        // par(4) = HX control (On/Off)
        // par(5) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        int CoilIndex = int(Par[1]);
        // FirstHVACIteration is a logical, Par is REAL(r64), so make 1=TRUE and 0=FALSE
        bool FirstHVACIteration = (Par[3] > 0.0);
        bool HXUnitOn = (Par[4] == 1.0);
        int FanOpMode = int(Par[5]);
        int UnitarySysNum = int(Par[6]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        if (thisSys.CoolCoilFluidInletNode > 0) {
            state.dataLoopNodes->Node(thisSys.CoolCoilFluidInletNode).MassFlowRate = thisSys.MaxCoolCoilFluidFlow * PartLoadRatio;
        }
        HVACHXAssistedCoolingCoil::CalcHXAssistedCoolingCoil(
            state, CoilIndex, FirstHVACIteration, state.dataUnitarySystems->On, PartLoadRatio, HXUnitOn, FanOpMode);
        Real64 OutletAirTemp = state.dataHVACAssistedCC->HXAssistedCoilOutletTemp(CoilIndex);
        Residuum = Par[2] - OutletAirTemp;
        return Residuum;
    }

    Real64 UnitarySys::HXAssistedCoolCoilHRResidual(EnergyPlusData &state,
                                                    Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                    std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   January 2008

        // PURPOSE OF THIS FUNCTION:
        //  Calculates residual function (desired outlet humrat - actual outlet humrat)
        //  DX Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        //  Calls CalcHXAssistedCoolingCoil to get outlet humidity ratio at the given part load ratio
        //  and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet humidity ratio [kg/kg]
        // par(3) = FirstHVACIteration logical converted to numeric (1=TRUE,0=FALSE)
        // par(4) = HX control (On/Off)
        // par(5) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        int CoilIndex = int(Par[1]);
        // FirstHVACIteration is a logical, Par is REAL(r64), so make 1=TRUE and 0=FALSE
        bool FirstHVACIteration = (Par[3] > 0.0);
        bool HXUnitOn = (Par[4] == 1.0);
        int FanOpMode = int(Par[5]);
        HVACHXAssistedCoolingCoil::CalcHXAssistedCoolingCoil(state,
                                                             CoilIndex,
                                                             FirstHVACIteration,
                                                             state.dataUnitarySystems->On,
                                                             PartLoadRatio,
                                                             HXUnitOn,
                                                             FanOpMode,
                                                             _,
                                                             state.dataUnitarySystems->economizerFlag);
        Real64 OutletAirHumRat = state.dataHVACAssistedCC->HXAssistedCoilOutletHumRat(CoilIndex);
        Residuum = Par[2] - OutletAirHumRat;
        return Residuum;
    }

    Real64 UnitarySys::DXCoilVarSpeedResidual(EnergyPlusData &state,
                                              Real64 const SpeedRatio,       // compressor speed ratio (1.0 is max, 0.0 is min)
                                              std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {
        // FUNCTION INFORMATION:
        //       AUTHOR         Fred Buhl
        //       DATE WRITTEN   September 2002

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp).
        // DX Coil output depends on the compressor speed which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls CalcMultiSpeedDXCoil to get outlet temperature at the given compressor speed
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirTemp(0.0); // outlet air temperature [C]
        Real64 CycRatio;
        int SpeedNum;
        int FanOpMode;
        int CompOp;
        Real64 ReqOutput;
        Real64 dummy;
        Real64 RuntimeFrac;
        Real64 OnOffAirFlowRatio;
        Real64 SensLoad;

        int CoilIndex = int(Par[1]);
        int UnitarySysNum = int(Par[3]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        {
            auto const SELECT_CASE_var(thisSys.m_CoolingCoilType_Num);

            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {

                DXCoils::CalcMultiSpeedDXCoil(state, CoilIndex, SpeedRatio, 1.0);
                OutletAirTemp = state.dataDXCoils->DXCoilOutletTemp(CoilIndex);

            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedCooling) {

                CycRatio = Par[4];
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                OnOffAirFlowRatio = 1.0;

                thisSys.setAverageAirFlow(state, SpeedRatio, OnOffAirFlowRatio);
                DXCoils::CalcMultiSpeedDXCoilCooling(state, CoilIndex, SpeedRatio, CycRatio, SpeedNum, FanOpMode, CompOp, 0);
                OutletAirTemp = state.dataDXCoils->DXCoilOutletTemp(CoilIndex);

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {

                CycRatio = Par[4];
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                ReqOutput = Par[8];
                dummy = 0.0;
                SensLoad = -1.0;
                RuntimeFrac = 1.0;
                OnOffAirFlowRatio = 1.0;

                VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                          "",
                                                          CoilIndex,
                                                          FanOpMode,
                                                          thisSys.m_MaxONOFFCyclesperHour,
                                                          thisSys.m_HPTimeConstant,
                                                          thisSys.m_FanDelayTime,
                                                          CompOp,
                                                          CycRatio,
                                                          SpeedNum,
                                                          SpeedRatio,
                                                          SensLoad,
                                                          dummy,
                                                          OnOffAirFlowRatio);

                OutletAirTemp = state.dataLoopNodes->Node(thisSys.CoolCoilOutletNodeNum).Temp;

            } else {
                assert(false);
            }
        }

        Residuum = Par[2] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::heatingCoilVarSpeedResidual(EnergyPlusData &state,
                                                   Real64 const SpeedRatio,       // compressor speed ratio (1.0 is max, 0.0 is min)
                                                   std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {
        // FUNCTION INFORMATION:
        //       AUTHOR         Fred Buhl
        //       DATE WRITTEN   September 2002

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp).
        // DX Coil output depends on the compressor speed which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls calc routines of  multi Speed or variable Coil to get outlet temperature at the given compressor speed
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirTemp(0.0); // outlet air temperature [C]
        Real64 CycRatio;
        int SpeedNum;
        int FanOpMode;
        int CompOp;
        Real64 ReqOutput;
        Real64 OnOffAirFlowRatio;
        Real64 SensLoad;
        Real64 LatLoad;

        int CoilIndex = int(Par[1]);
        int UnitarySysNum = int(Par[3]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        {
            auto const SELECT_CASE_var(thisSys.m_HeatingCoilType_Num);

            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedHeating) {

                CycRatio = Par[4];
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                OnOffAirFlowRatio = 1.0;

                thisSys.setAverageAirFlow(state, SpeedRatio, OnOffAirFlowRatio);

                DXCoils::CalcMultiSpeedDXCoilHeating(state, CoilIndex, SpeedRatio, CycRatio, SpeedNum, FanOpMode, 0);

                OutletAirTemp = state.dataDXCoils->DXCoilOutletTemp(CoilIndex);

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit)) {

                CycRatio = Par[4];
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                ReqOutput = Par[8];
                OnOffAirFlowRatio = 1.0;
                SensLoad = 1.0;
                LatLoad = -1.0;

                // can't call only the calc routine with these coil types since Init sets air flow rate based on speed num and cycling ratio
                VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                          "",
                                                          CoilIndex,
                                                          FanOpMode,
                                                          thisSys.m_MaxONOFFCyclesperHour,
                                                          thisSys.m_HPTimeConstant,
                                                          thisSys.m_FanDelayTime,
                                                          CompOp,
                                                          CycRatio,
                                                          SpeedNum,
                                                          SpeedRatio,
                                                          SensLoad,
                                                          LatLoad,
                                                          OnOffAirFlowRatio);

                OutletAirTemp = state.dataLoopNodes->Node(thisSys.HeatCoilOutletNodeNum).Temp;

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric_MultiStage) {

                CycRatio = Par[4];
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);

                HeatingCoils::CalcMultiStageElectricHeatingCoil(state, CoilIndex, SpeedRatio, CycRatio, SpeedNum, FanOpMode);

                OutletAirTemp = state.dataLoopNodes->Node(thisSys.HeatCoilOutletNodeNum).Temp;

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGas_MultiStage) {

                CycRatio = Par[4];
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);

                HeatingCoils::CalcMultiStageElectricHeatingCoil(state, CoilIndex, SpeedRatio, CycRatio, SpeedNum, FanOpMode);

                OutletAirTemp = state.dataLoopNodes->Node(thisSys.HeatCoilOutletNodeNum).Temp;

            } else {
                assert(false);
            }
        }

        Residuum = Par[2] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::DXCoilVarSpeedHumRatResidual(EnergyPlusData &state,
                                                    Real64 const SpeedRatio,       // compressor speed ratio (1.0 is max, 0.0 is min)
                                                    std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {
        // FUNCTION INFORMATION:
        //       AUTHOR         Richard Raustad
        //       DATE WRITTEN   January 2008

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet humrat - actual outlet humrat).
        // DX Coil output depends on the compressor speed which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls calc routine sof multi speed or variable speed coils to get outlet humidity ratio at the given compressor speed
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirHumRat(0.0); // outlet air humidity ratio
        Real64 CycRatio;
        int SpeedNum;
        int FanOpMode;
        int CompOp;
        Real64 ReqOutput;
        Real64 SensLoad;
        Real64 LatLoad;
        Real64 RuntimeFrac;
        Real64 OnOffAirFlowRatio;

        int CoilIndex = int(Par[1]);
        int UnitarySysNum = int(Par[3]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        {
            auto const SELECT_CASE_var(thisSys.m_CoolingCoilType_Num);

            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {

                DXCoils::CalcMultiSpeedDXCoil(state, CoilIndex, SpeedRatio, 1.0);
                OutletAirHumRat = state.dataDXCoils->DXCoilOutletHumRat(CoilIndex);

            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedCooling) {

                CycRatio = Par[4];
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                OnOffAirFlowRatio = 1.0;

                thisSys.setAverageAirFlow(state, SpeedRatio, OnOffAirFlowRatio);
                DXCoils::CalcMultiSpeedDXCoilCooling(state, CoilIndex, SpeedRatio, CycRatio, SpeedNum, FanOpMode, CompOp, 0);
                OutletAirHumRat = state.dataDXCoils->DXCoilOutletHumRat(CoilIndex);

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {

                CycRatio = Par[4];
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                ReqOutput = Par[8];
                SensLoad = -1.0;
                LatLoad = 0.0;
                RuntimeFrac = 1.0;
                OnOffAirFlowRatio = 1.0;

                VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                          "",
                                                          CoilIndex,
                                                          FanOpMode,
                                                          thisSys.m_MaxONOFFCyclesperHour,
                                                          thisSys.m_HPTimeConstant,
                                                          thisSys.m_FanDelayTime,
                                                          CompOp,
                                                          CycRatio,
                                                          SpeedNum,
                                                          SpeedRatio,
                                                          SensLoad,
                                                          LatLoad,
                                                          OnOffAirFlowRatio);

                OutletAirHumRat = state.dataLoopNodes->Node(thisSys.CoolCoilOutletNodeNum).HumRat;

            } else {
                assert(false);
            }
        }

        Residuum = Par[2] - OutletAirHumRat;

        return Residuum;
    }

    Real64 UnitarySys::DXCoilCyclingResidual(EnergyPlusData &state,
                                             Real64 const CycRatio,         // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                             std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {
        // FUNCTION INFORMATION:
        //       AUTHOR         Fred Buhl
        //       DATE WRITTEN   September 2002

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // DX Coil output depends on the cycling ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls multi or variable speed coil to get outlet temperature at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirTemp(0.0); // outlet air temperature [C]
        Real64 SpeedRatio;
        int SpeedNum;
        int FanOpMode;
        int CompOp;
        Real64 ReqOutput;
        Real64 dummy;
        Real64 SensLoad;
        Real64 OnOffAirFlowRatio;

        //            Par(1) = REAL(UnitarySystem(UnitarySysNum)%CoolingCoilIndex,r64)
        //            Par(2) = DesOutTemp
        //            Par(3) = UnitarySysNum
        //            Par(4) = SpeedRatio
        //            Par(5) = UnitarySystem(UnitarySysNum)%CoolingSpeedNum
        //            Par(6) = UnitarySystem(UnitarySysNum)%FanOpMode
        //            Par(7) = 1.0d0 ! CompOp

        int CoilIndex = int(Par[1]);
        int UnitarySysNum = int(Par[3]);
        int AirloopNum = int(Par[9]);
        bool FirstHVACIteration = (Par[10] > 0.0);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];
        {
            auto const SELECT_CASE_var(thisSys.m_CoolingCoilType_Num);

            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {

                if (thisSys.m_FanPlace == FanPlace::BlowThru) { // must simulate fan if blow through since OnOffFanPartLoadFrac affects fan heat
                    thisSys.m_CoolingCycRatio = CycRatio;
                    thisSys.m_CoolingPartLoadFrac = CycRatio;
                    thisSys.calcPassiveSystem(state, AirloopNum, FirstHVACIteration);
                } else {
                    DXCoils::CalcMultiSpeedDXCoil(state, CoilIndex, 0.0, CycRatio);
                }

                OutletAirTemp = state.dataDXCoils->DXCoilOutletTemp(CoilIndex);

            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedCooling) {

                SpeedRatio = int(Par[4]);
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                OnOffAirFlowRatio = 1.0;

                thisSys.setAverageAirFlow(state, CycRatio, OnOffAirFlowRatio);
                if (thisSys.m_FanPlace == FanPlace::BlowThru) { // must simulate fan if blow through since OnOffFanPartLoadFrac affects fan heat
                    thisSys.m_CoolingCycRatio = CycRatio;
                    thisSys.m_CoolingPartLoadFrac = CycRatio;
                    thisSys.calcPassiveSystem(state, AirloopNum, FirstHVACIteration);
                } else {
                    DXCoils::CalcMultiSpeedDXCoilCooling(state, CoilIndex, SpeedRatio, CycRatio, SpeedNum, FanOpMode, CompOp, 0);
                }
                OutletAirTemp = state.dataDXCoils->DXCoilOutletTemp(CoilIndex);

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {

                SpeedRatio = Par[4]; // Autodesk:Init Added line to elim use uninitialized
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                if (CycRatio == 0.0) CompOp = 0;
                ReqOutput = Par[8];
                dummy = 0.0;
                OnOffAirFlowRatio = 1.0;

                SensLoad = -1.0;
                VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                          "",
                                                          CoilIndex,
                                                          FanOpMode,
                                                          thisSys.m_MaxONOFFCyclesperHour,
                                                          thisSys.m_HPTimeConstant,
                                                          thisSys.m_FanDelayTime,
                                                          CompOp,
                                                          CycRatio,
                                                          SpeedNum,
                                                          SpeedRatio,
                                                          SensLoad,
                                                          dummy,
                                                          OnOffAirFlowRatio);

                OutletAirTemp = state.dataLoopNodes->Node(thisSys.CoolCoilOutletNodeNum).Temp;

            } else {
                assert(false);
            }
        }

        Residuum = Par[2] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::DXCoilCyclingHumRatResidual(EnergyPlusData &state,
                                                   Real64 const CycRatio,         // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                   std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Fred Buhl
        //       DATE WRITTEN   September 2002

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // DX Coil output depends on the cycling ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls CalcMultiSpeedDXCoil to get outlet temperature at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirHumRat(0.0); // outlet air humidity ratio [kg/kg]
        Real64 SpeedRatio;
        int SpeedNum;
        int FanOpMode;
        int CompOp;
        Real64 ReqOutput;
        Real64 SensLoad;
        Real64 LatLoad;
        Real64 OnOffAirFlowRatio;

        int CoilIndex = int(Par[1]);
        int UnitarySysNum = int(Par[3]);
        auto &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        {
            auto const SELECT_CASE_var(thisSys.m_CoolingCoilType_Num);

            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {

                DXCoils::CalcMultiSpeedDXCoil(state, CoilIndex, 0.0, CycRatio);

                OutletAirHumRat = state.dataDXCoils->DXCoilOutletHumRat(CoilIndex);
            } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedCooling) {

                SpeedRatio = int(Par[4]);
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                OnOffAirFlowRatio = 1.0;

                thisSys.setAverageAirFlow(state, CycRatio, OnOffAirFlowRatio);
                DXCoils::CalcMultiSpeedDXCoilCooling(state, CoilIndex, SpeedRatio, CycRatio, SpeedNum, FanOpMode, CompOp, 0);
                OutletAirHumRat = state.dataDXCoils->DXCoilOutletHumRat(CoilIndex);

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {

                SpeedRatio = int(Par[4]); // Autodesk:Init Added line to elim use uninitialized
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                ReqOutput = Par[8];
                SensLoad = -1.0;
                LatLoad = 0.0;
                OnOffAirFlowRatio = 1.0;

                VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                          "",
                                                          CoilIndex,
                                                          FanOpMode,
                                                          thisSys.m_MaxONOFFCyclesperHour,
                                                          thisSys.m_HPTimeConstant,
                                                          thisSys.m_FanDelayTime,
                                                          CompOp,
                                                          CycRatio,
                                                          SpeedNum,
                                                          SpeedRatio,
                                                          SensLoad,
                                                          LatLoad,
                                                          OnOffAirFlowRatio);

                OutletAirHumRat = state.dataLoopNodes->Node(thisSys.CoolCoilOutletNodeNum).HumRat;

            } else {
                assert(false);
            }
        }

        Residuum = Par[2] - OutletAirHumRat;

        return Residuum;
    }

    Real64 UnitarySys::heatingCoilVarSpeedCycResidual(EnergyPlusData &state,
                                                      Real64 const CycRatio,         // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                      std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Fred Buhl
        //       DATE WRITTEN   September 2002

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // DX Coil output depends on the cycling ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls multi or variable speed coil to get outlet temperature at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirTemp(0.0); // outlet air temperature [C]
        Real64 SpeedRatio;
        int SpeedNum;
        int FanOpMode;
        int CompOp;
        Real64 ReqOutput;
        Real64 SensLoad;
        Real64 LatLoad;
        Real64 OnOffAirFlowRatio;

        //            Par(1) = REAL(UnitarySystem(UnitarySysNum)%CoolingCoilIndex,r64)
        //            Par(2) = DesOutTemp
        //            Par(3) = UnitarySysNum
        //            Par(4) = SpeedRatio
        //            Par(5) = UnitarySystem(UnitarySysNum)%CoolingSpeedNum
        //            Par(6) = UnitarySystem(UnitarySysNum)%FanOpMode
        //            Par(7) = 1.0d0 ! CompOp

        int CoilIndex = int(Par[1]);
        int UnitarySysNum = int(Par[3]);
        auto &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        {
            auto const SELECT_CASE_var(thisSys.m_HeatingCoilType_Num);

            if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedHeating) {

                SpeedRatio = int(Par[4]);
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                OnOffAirFlowRatio = 1.0;

                thisSys.setAverageAirFlow(state, CycRatio, OnOffAirFlowRatio);
                DXCoils::CalcMultiSpeedDXCoilHeating(state, CoilIndex, SpeedRatio, CycRatio, SpeedNum, FanOpMode, 0);
                OutletAirTemp = state.dataDXCoils->DXCoilOutletTemp(CoilIndex);

            } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) ||
                       (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit)) {

                SpeedRatio = int(Par[4]); // Autodesk:Init Added line to elim use uninitialized
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);
                CompOp = int(Par[7]);
                if (CycRatio == 0.0) CompOp = 0;
                ReqOutput = Par[8];
                SensLoad = -1.0;
                LatLoad = 0.0;
                OnOffAirFlowRatio = 1.0;

                VariableSpeedCoils::SimVariableSpeedCoils(state,
                                                          "",
                                                          CoilIndex,
                                                          FanOpMode,
                                                          thisSys.m_MaxONOFFCyclesperHour,
                                                          thisSys.m_HPTimeConstant,
                                                          thisSys.m_FanDelayTime,
                                                          CompOp,
                                                          CycRatio,
                                                          SpeedNum,
                                                          SpeedRatio,
                                                          SensLoad,
                                                          LatLoad,
                                                          OnOffAirFlowRatio);

                OutletAirTemp = state.dataLoopNodes->Node(thisSys.HeatCoilOutletNodeNum).Temp;

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingElectric_MultiStage) {

                SpeedRatio = int(Par[4]);
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);

                HeatingCoils::CalcMultiStageElectricHeatingCoil(state, CoilIndex, SpeedRatio, CycRatio, SpeedNum, FanOpMode);

                OutletAirTemp = state.dataLoopNodes->Node(thisSys.HeatCoilOutletNodeNum).Temp;

            } else if (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingGas_MultiStage) {

                SpeedRatio = int(Par[4]);
                SpeedNum = int(Par[5]);
                FanOpMode = int(Par[6]);

                HeatingCoils::CalcMultiStageGasHeatingCoil(state, CoilIndex, SpeedRatio, CycRatio, SpeedNum, FanOpMode);

                OutletAirTemp = state.dataLoopNodes->Node(thisSys.HeatCoilOutletNodeNum).Temp;

            } else {
                assert(false);
            }
        }

        Residuum = Par[2] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::TESIceStorageCoilOutletResidual(EnergyPlusData &state,
                                                       Real64 PartLoadRatio,          // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                       std::vector<Real64> const &Par // data array
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR        Richard Raustad, FSEC
        //       DATE WRITTEN   August 2015

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimWatertoAirHP or SimWatertoAirHPSimple to get outlet humidity ratio at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // Par( 1 ) = double( UnitarySysNum );
        // Par( 2 ) = DesOutTemp;
        // Par( 3 ) = 0.0; // DesOutHumRat; set to 0 if temp controlled

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirTemp;   // outlet air temperature [C]
        Real64 OutletAirHumRat; // outlet air humidity ratio [kg/kg]

        int UnitarySysNum = int(Par[1]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        Real64 DesiredOutletTemp = Par[2];
        Real64 DesiredOutletHumRat = Par[3];

        PackagedThermalStorageCoil::SimTESCoil(
            state, thisSys.m_CoolingCoilName, thisSys.m_CoolingCoilIndex, thisSys.m_FanOpMode, thisSys.m_TESOpMode, PartLoadRatio);

        if (DesiredOutletHumRat > 0.0) {
            OutletAirHumRat = state.dataLoopNodes->Node(thisSys.CoolCoilOutletNodeNum).HumRat;
            Residuum = OutletAirHumRat - DesiredOutletHumRat;
        } else {
            OutletAirTemp = state.dataLoopNodes->Node(thisSys.CoolCoilOutletNodeNum).Temp;
            Residuum = OutletAirTemp - DesiredOutletTemp;
        }

        return Residuum;
    }

    Real64 UnitarySys::multiModeDXCoilResidual(EnergyPlusData &state,
                                               Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                               std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         M. J. Witte, GARD Analytics, Inc.
        //       DATE WRITTEN   February 2005
        //                      (based on DOE2DXCoilResidual by Richard Raustad, FSEC)

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // DX Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimDXCoilMultiMode to get outlet temperature at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet temperature [C]
        // par(3) = dehumidification mode (0=normal, 1=enhanced)
        // par(4) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        int CoilIndex;        // index of this coil
        Real64 OutletAirTemp; // outlet air temperature [C]
        int DehumidMode;      // dehumidification mode (par3)
        int FanOpMode;        // supply air fan operating mode

        CoilIndex = int(Par[1]);
        DehumidMode = int(Par[3]);
        FanOpMode = int(Par[4]);
        DXCoils::SimDXCoilMultiMode(state, "", state.dataUnitarySystems->On, false, PartLoadRatio, DehumidMode, CoilIndex, FanOpMode);
        OutletAirTemp = state.dataDXCoils->DXCoilOutletTemp(CoilIndex);
        Residuum = Par[2] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::multiModeDXCoilHumRatResidual(EnergyPlusData &state,
                                                     Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                     std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   January 2008

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet humrat - actual outlet humrat)
        // DX Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimDXCoilMultiMode to get outlet humidity ratio at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet humidity ratio [kg/kg]
        // par(3) = dehumidification mode (0=normal, 1=enhanced)
        // par(4) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        int CoilIndex = int(Par[1]);
        int DehumidMode = int(Par[3]);
        int FanOpMode = int(Par[4]);
        DXCoils::SimDXCoilMultiMode(state, "", state.dataUnitarySystems->On, false, PartLoadRatio, DehumidMode, CoilIndex, FanOpMode);
        Real64 OutletAirHumRat = state.dataDXCoils->DXCoilOutletHumRat(CoilIndex);
        Residuum = Par[2] - OutletAirHumRat;

        return Residuum;
    }

    Real64 UnitarySys::coolWaterHumRatResidual(EnergyPlusData &state,
                                               Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                               std::vector<Real64> const &Par // par(1) = CoolWater coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Chandan Sharma, FSEC
        //       DATE WRITTEN   January 2013

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet humrat - actual outlet humrat)
        // Cool water coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimulateWaterCoilComponents to get outlet temp at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet humidity ratio [kg/kg]
        // par(5) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        int UnitarySysNum = int(Par[1]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];
        bool FirstHVACIteration = (Par[2] > 0.0);

        Real64 mdot =
            min(state.dataLoopNodes->Node(thisSys.CoolCoilFluidOutletNodeNum).MassFlowRateMaxAvail, thisSys.MaxCoolCoilFluidFlow * PartLoadRatio);
        state.dataLoopNodes->Node(thisSys.CoolCoilFluidInletNode).MassFlowRate = mdot;
        WaterCoils::SimulateWaterCoilComponents(
            state, thisSys.m_CoolingCoilName, FirstHVACIteration, thisSys.m_CoolingCoilIndex, _, _, PartLoadRatio);

        Real64 OutletAirHumRat = state.dataLoopNodes->Node(thisSys.CoolCoilOutletNodeNum).HumRat;
        Residuum = Par[3] - OutletAirHumRat;

        return Residuum;
    }

    Real64 UnitarySys::coolWaterTempResidual(EnergyPlusData &state,
                                             Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                             std::vector<Real64> const &Par // par(1) = CoolWater coil number
    )
    {
        // FUNCTION INFORMATION:
        //       AUTHOR         Chandan Sharma, FSEC
        //       DATE WRITTEN   January 2013

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // Cool water coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimulateWaterCoilComponents to get outlet temp at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet humidity ratio [kg/kg]
        // par(5) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirTemp; // outlet air humidity ratio [kg/kg]

        int UnitarySysNum = int(Par[1]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];
        bool FirstHVACIteration = (Par[2] > 0.0);

        Real64 mdot =
            min(state.dataLoopNodes->Node(thisSys.CoolCoilFluidOutletNodeNum).MassFlowRateMaxAvail, thisSys.MaxCoolCoilFluidFlow * PartLoadRatio);
        state.dataLoopNodes->Node(thisSys.CoolCoilFluidInletNode).MassFlowRate = mdot;
        WaterCoils::SimulateWaterCoilComponents(
            state, thisSys.m_CoolingCoilName, FirstHVACIteration, thisSys.m_CoolingCoilIndex, _, _, PartLoadRatio);

        OutletAirTemp = state.dataLoopNodes->Node(thisSys.CoolCoilOutletNodeNum).Temp;
        Residuum = Par[3] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::gasElecHeatingCoilResidual(EnergyPlusData &state,
                                                  Real64 const PartLoadFrac,     // Compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                  std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Chandan Sharma, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // hot water Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimulateHeatingCoilComponents to get outlet temperature at the given part load ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // Residual to be minimized to zero

        // Argument array dimensioning
        // Par(2) = desired air outlet temperature [C]

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirTemp; // Outlet air temperature [C]

        int UnitarySysNum = int(Par[1]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        bool FirstHVACIteration = (Par[2] > 0.0);
        bool SuppHeatingCoilFlag = (Par[4] > 0.0);
        bool FanOpMode = Par[5]; // RR this was a 4
        Real64 HeatingLoad = Par[6] * PartLoadFrac;
        // heating coils using set point control pass DataLoopNode::SensedLoadFlagValue as QCoilReq to indicate temperature control
        if (!SuppHeatingCoilFlag) {
            HeatingCoils::SimulateHeatingCoilComponents(
                state, thisSys.m_HeatingCoilName, FirstHVACIteration, HeatingLoad, thisSys.m_HeatingCoilIndex, _, _, FanOpMode, PartLoadFrac);
            OutletAirTemp = state.dataLoopNodes->Node(thisSys.HeatCoilOutletNodeNum).Temp;
        } else {
            HeatingCoils::SimulateHeatingCoilComponents(
                state, thisSys.m_SuppHeatCoilName, FirstHVACIteration, HeatingLoad, thisSys.m_SuppHeatCoilIndex, _, true, FanOpMode, PartLoadFrac);
            OutletAirTemp = state.dataLoopNodes->Node(thisSys.m_SuppCoilAirOutletNode).Temp;
        }
        Residuum = Par[3] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::steamHeatingCoilResidual(EnergyPlusData &state,
                                                Real64 const PartLoadFrac,     // Compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Chandan Sharma, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // hot Steam Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimulateSteamCoilComponents to get outlet temperature at the given part load ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // Residual to be minimized to zero

        // Argument array dimensioning
        // Par(2) = desired air outlet temperature [C]

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirTemp; // Outlet air temperature [C]
        Real64 mdot;

        int UnitarySysNum = int(Par[1]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        bool FirstHVACIteration = (Par[2] > 0.0);
        bool SuppHeatingCoilFlag = (Par[4] > 0.0);

        if (!SuppHeatingCoilFlag) {
            mdot =
                min(state.dataLoopNodes->Node(thisSys.HeatCoilFluidOutletNodeNum).MassFlowRateMaxAvail, thisSys.MaxHeatCoilFluidFlow * PartLoadFrac);
            state.dataLoopNodes->Node(thisSys.HeatCoilFluidInletNode).MassFlowRate = mdot;
            SteamCoils::SimulateSteamCoilComponents(
                state, thisSys.m_HeatingCoilName, FirstHVACIteration, thisSys.m_HeatingCoilIndex, 1.0, _, thisSys.m_FanOpMode, PartLoadFrac);
        } else {
            mdot = min(state.dataLoopNodes->Node(thisSys.m_SuppCoilFluidOutletNodeNum).MassFlowRateMaxAvail,
                       thisSys.m_MaxSuppCoilFluidFlow * PartLoadFrac);
            state.dataLoopNodes->Node(thisSys.m_SuppCoilFluidInletNode).MassFlowRate = mdot;
            SteamCoils::SimulateSteamCoilComponents(
                state, thisSys.m_SuppHeatCoilName, FirstHVACIteration, thisSys.m_SuppHeatCoilIndex, 1.0, _, thisSys.m_FanOpMode, PartLoadFrac);
        }
        OutletAirTemp = state.dataLoopNodes->Node(thisSys.HeatCoilOutletNodeNum).Temp; // RR this should be supp coil
        Residuum = Par[3] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::heatWatertoAirHPTempResidual(EnergyPlusData &state,
                                                    Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                    std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Chandan Sharma, FSEC
        //       DATE WRITTEN   January 2013

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // Heat water coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimWatertoAirHP or SimWatertoAirHPSimple to get outlet humidity ratio at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet humidity ratio [kg/kg]
        // par(5) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        Real64 OutletAirTemp; // outlet air humidity ratio [kg/kg]
        bool errFlag;
        Real64 RuntimeFrac;
        Real64 dummy;

        int UnitarySysNum = int(Par[1]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        bool FirstHVACIteration = (Par[2] > 0.0);
        Real64 ReqOutput = Par[4]; // RR this was a 1

        thisSys.heatPumpRunFrac(PartLoadRatio, errFlag, RuntimeFrac);

        if (RuntimeFrac > 0.0 && thisSys.m_FanOpMode == DataHVACGlobals::CycFanCycCoil) {
            state.dataHVACGlobal->OnOffFanPartLoadFraction = PartLoadRatio / RuntimeFrac;
        } else {
            state.dataHVACGlobal->OnOffFanPartLoadFraction = 1.0;
        }

        thisSys.m_CompPartLoadRatio = PartLoadRatio;
        thisSys.m_WSHPRuntimeFrac = RuntimeFrac;

        dummy = 0.0;
        if (thisSys.m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple) {
            WaterToAirHeatPumpSimple::SimWatertoAirHPSimple(state,
                                                            blankString,
                                                            thisSys.m_HeatingCoilIndex,
                                                            ReqOutput,
                                                            dummy,
                                                            thisSys.m_FanOpMode,
                                                            RuntimeFrac,
                                                            thisSys.m_MaxONOFFCyclesperHour,
                                                            thisSys.m_HPTimeConstant,
                                                            thisSys.m_FanDelayTime,
                                                            1,
                                                            PartLoadRatio,
                                                            FirstHVACIteration);
        } else {
            WaterToAirHeatPump::SimWatertoAirHP(state,
                                                blankString,
                                                thisSys.m_HeatingCoilIndex,
                                                thisSys.MaxHeatAirMassFlow,
                                                thisSys.m_FanOpMode,
                                                FirstHVACIteration,
                                                RuntimeFrac,
                                                thisSys.m_MaxONOFFCyclesperHour,
                                                thisSys.m_HPTimeConstant,
                                                thisSys.m_FanDelayTime,
                                                thisSys.m_InitHeatPump,
                                                ReqOutput,
                                                dummy,
                                                0,
                                                PartLoadRatio);
        }

        OutletAirTemp = state.dataLoopNodes->Node(thisSys.HeatCoilOutletNodeNum).Temp;
        Residuum = Par[3] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::coolWatertoAirHPHumRatResidual(EnergyPlusData &state,
                                                      Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                      std::vector<Real64> const &Par // par(1) = CoolWatertoAirHP coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Chandan Sharma, FSEC
        //       DATE WRITTEN   January 2013

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet humrat - actual outlet humrat)
        // Cool water coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimWatertoAirHP or SimWatertoAirHPSimple to get outlet humidity ratio at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet humidity ratio [kg/kg]
        // par(5) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        int UnitarySysNum = int(Par[1]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        bool FirstHVACIteration = (Par[2] > 0.0);
        Real64 ReqOutput = Par[4];
        bool errFlag = false;
        Real64 RuntimeFrac = 0.0; // heat pump runtime fraction

        thisSys.heatPumpRunFrac(PartLoadRatio, errFlag, RuntimeFrac);

        thisSys.m_CompPartLoadRatio = PartLoadRatio;
        thisSys.m_WSHPRuntimeFrac = RuntimeFrac;

        Real64 dummy = 0.0;
        if (thisSys.m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) {
            WaterToAirHeatPumpSimple::SimWatertoAirHPSimple(state,
                                                            blankString,
                                                            thisSys.m_CoolingCoilIndex,
                                                            ReqOutput,
                                                            dummy,
                                                            thisSys.m_FanOpMode,
                                                            RuntimeFrac,
                                                            thisSys.m_MaxONOFFCyclesperHour,
                                                            thisSys.m_HPTimeConstant,
                                                            thisSys.m_FanDelayTime,
                                                            0,
                                                            PartLoadRatio,
                                                            FirstHVACIteration);
        } else {
            WaterToAirHeatPump::SimWatertoAirHP(state,
                                                blankString,
                                                thisSys.m_CoolingCoilIndex,
                                                thisSys.MaxCoolAirMassFlow,
                                                thisSys.m_FanOpMode,
                                                FirstHVACIteration,
                                                RuntimeFrac,
                                                thisSys.m_MaxONOFFCyclesperHour,
                                                thisSys.m_HPTimeConstant,
                                                thisSys.m_FanDelayTime,
                                                thisSys.m_InitHeatPump,
                                                ReqOutput,
                                                dummy,
                                                0,
                                                PartLoadRatio);
        }

        Real64 OutletAirHumRat = state.dataLoopNodes->Node(thisSys.CoolCoilOutletNodeNum).HumRat;
        Residuum = Par[3] - OutletAirHumRat;

        return Residuum;
    }

    Real64 UnitarySys::coolWatertoAirHPTempResidual(EnergyPlusData &state,
                                                    Real64 const PartLoadRatio,    // compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                                    std::vector<Real64> const &Par // par(1) = CoolWatertoAirHP coil number
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR        Chandan Sharma, FSEC
        //       DATE WRITTEN   January 2013

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // Cool water coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls SimWatertoAirHP or SimWatertoAirHPSimple to get outlet humidity ratio at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // residual to be minimized to zero

        // Argument array dimensioning
        // par(2) = desired air outlet humidity ratio [kg/kg]
        // par(5) = supply air fan operating mode (DataHVACGlobals::ContFanCycCoil)

        // FUNCTION LOCAL VARIABLE DECLARATIONS:
        bool errFlag = false;
        Real64 RuntimeFrac = 0.0;

        int UnitarySysNum = int(Par[1]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        bool FirstHVACIteration = (Par[2] > 0.0);
        Real64 ReqOutput = Par[4];

        thisSys.heatPumpRunFrac(PartLoadRatio, errFlag, RuntimeFrac);

        if (RuntimeFrac > 0.0 && thisSys.m_FanOpMode == DataHVACGlobals::CycFanCycCoil) {
            state.dataHVACGlobal->OnOffFanPartLoadFraction = PartLoadRatio / RuntimeFrac;
        } else {
            state.dataHVACGlobal->OnOffFanPartLoadFraction = 1;
        }

        thisSys.m_CompPartLoadRatio = PartLoadRatio;
        thisSys.m_WSHPRuntimeFrac = RuntimeFrac;

        Real64 dummy = 0.0;
        if (thisSys.m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) {
            WaterToAirHeatPumpSimple::SimWatertoAirHPSimple(state,
                                                            blankString,
                                                            thisSys.m_CoolingCoilIndex,
                                                            ReqOutput,
                                                            dummy,
                                                            thisSys.m_FanOpMode,
                                                            RuntimeFrac,
                                                            thisSys.m_MaxONOFFCyclesperHour,
                                                            thisSys.m_HPTimeConstant,
                                                            thisSys.m_FanDelayTime,
                                                            1,
                                                            PartLoadRatio,
                                                            FirstHVACIteration);
        } else {
            WaterToAirHeatPump::SimWatertoAirHP(state,
                                                blankString,
                                                thisSys.m_CoolingCoilIndex,
                                                thisSys.MaxCoolAirMassFlow,
                                                thisSys.m_FanOpMode,
                                                FirstHVACIteration,
                                                RuntimeFrac,
                                                thisSys.m_MaxONOFFCyclesperHour,
                                                thisSys.m_HPTimeConstant,
                                                thisSys.m_FanDelayTime,
                                                thisSys.m_InitHeatPump,
                                                ReqOutput,
                                                dummy,
                                                0,
                                                PartLoadRatio);
        }

        Real64 OutletAirTemp = state.dataLoopNodes->Node(thisSys.CoolCoilOutletNodeNum).Temp;
        Residuum = Par[3] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::DXHeatingCoilResidual(EnergyPlusData &state,
                                             Real64 const PartLoadFrac,     // Compressor cycling ratio (1.0 is continuous, 0.0 is off)
                                             std::vector<Real64> const &Par // par(1) = DX coil number
    )
    {
        // FUNCTION INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   June 2006

        // PURPOSE OF THIS FUNCTION:
        // Calculates residual function (desired outlet temp - actual outlet temp)
        // DX Coil output depends on the part load ratio which is being varied to zero the residual.

        // METHODOLOGY EMPLOYED:
        // Calls CalcDOe2DXCoil to get outlet temperature at the given cycling ratio
        // and calculates the residual as defined above

        // Return value
        Real64 Residuum; // Residual to be minimized to zero

        int CoilIndex = int(Par[1]);
        Real64 OnOffAirFlowFrac = Par[3];

        DXCoils::CalcDXHeatingCoil(state, CoilIndex, PartLoadFrac, DataHVACGlobals::ContFanCycCoil, OnOffAirFlowFrac);

        Real64 OutletAirTemp = state.dataDXCoils->DXCoilOutletTemp(CoilIndex);
        Residuum = Par[2] - OutletAirTemp;

        return Residuum;
    }

    Real64 UnitarySys::calcUnitarySystemWaterFlowResidual(EnergyPlusData &state,
                                                          Real64 const PartLoadRatio,    // coil part load ratio
                                                          std::vector<Real64> const &Par // Function parameters
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   January 2017

        // PURPOSE OF THIS SUBROUTINE:
        // To calculate the part-load ratio for the UnitarySystem coil with varying part load ratio

        // METHODOLOGY EMPLOYED:
        // Use SolveRoot to CALL this Function to converge on a solution

        // Return value
        Real64 Residuum; // Result (forces solution to be within tolerance)
        Real64 HeatCoilLoad = 0.0;
        Real64 SupHeaterLoad = 0.0;

        // Argument array dimensioning
        //   Parameter description example:
        //       Par(1)  = double(UnitarySysNum)    ! Index to unitary system
        //       Par(2)  = 0.0                      ! FirstHVACIteration FLAG, IF 1.0 then TRUE, if 0.0 then FALSE
        //       Par(3)  = double(ControlledZoneNum) ! zone index
        //       Par(4)  = QZnReq                   ! zone load [W]
        //       Par(5)  = double(AirControlNode)   ! UnitarySystem air inlet node number
        //       Par(6)  = OnOffAirFlowRatio        ! ratio of coil on air flow rate to coil off air flow rate
        //       Par(7)  = double(AirLoopNum)       ! index to air loop
        //       Par(8)  = double(WaterControlNode) ! CW or HW control node number
        //       Par(9)  = lowWaterMdot             ! water flow rate at low speed fan that meets outlet air set point temperature
        //       Par(10) = highWaterMdot            ! water flow rate at high speed fan that meets outlet air set point temperature
        //       Par(11) = lowSpeedRatio            ! ratio of low speed fan flow rate to high speed fan flow rate
        //       Par(12) = airMdot                  ! air flow rate used for function calculations
        //       Par(13) = SATempTarget             ! SA temperature target [C], 0 if target is load [W]
        //       Par(14) = systemMaxAirFlowRate     ! UnitarySystem maximum air flow rate [kg/s]
        //       Par(15) = LoadType                 ! 1.0 for CoolingLoad otherwise don't care
        //       Par(16) = iteration method         ! 1 = iteration on coil capacity, 2 = iterate on air flow rate at constant coil capacity

        // Convert parameters to usable variables
        int UnitarySysNum = int(Par[1]);
        UnitarySys &thisSys = state.dataUnitarySystems->unitarySys[UnitarySysNum];

        bool FirstHVACIteration = (Par[2] > 0.0);
        // int ControlledZoneNum = int(Par[3]);
        Real64 QZnReq = Par[4];
        int AirControlNode = int(Par[5]);
        Real64 OnOffAirFlowRat = Par[6];
        int AirLoopNum = int(Par[7]);
        int WaterControlNode = int(Par[8]);
        // Real64 lowWaterMdot = Par[9];
        Real64 highWaterMdot = Par[10];
        Real64 lowSpeedRatio = Par[11];
        Real64 airMdot = Par[12];
        Real64 SATempTarget = 0.0;
        bool LoadIsTarget = false;
        if (Par[13] == 0.0) {
            LoadIsTarget = true;
        } else {
            SATempTarget = Par[13];
        }
        Real64 systemMaxAirFlowRate = Par[14];
        bool coolingLoad = (Par[15] > 0.0);
        bool iterateOnAirOnly = (Par[16] > 1.0);
        bool HXUnitOn = true;

        if (iterateOnAirOnly) {

            // set air flow rate bounded by low speed and high speed air flow rates
            state.dataLoopNodes->Node(AirControlNode).MassFlowRate = airMdot * (lowSpeedRatio + (PartLoadRatio * (1.0 - lowSpeedRatio)));
            // FanPartLoadRatio is used to pass info over to function SetAverageAirFlow since air and coil PLR are disassociated in the model
            // FanPartLoadRatio is a report variable that is updated (overwritten) in ReportUnitarySystem
            thisSys.FanPartLoadRatio = PartLoadRatio;
            //            if( WaterControlNode > 0 ) Node( WaterControlNode ).MassFlowRate = highWaterMdot;

        } else {

            state.dataLoopNodes->Node(AirControlNode).MassFlowRate = airMdot;
            if (lowSpeedRatio != 1.0) {
                // division by zero when lowSpeedRatio == 1.0
                thisSys.FanPartLoadRatio =
                    max(0.0, ((airMdot - (systemMaxAirFlowRate * lowSpeedRatio)) / ((1.0 - lowSpeedRatio) * systemMaxAirFlowRate)));
            } else {
                thisSys.FanPartLoadRatio = 1.0;
            }
            if (WaterControlNode > 0) {
                Real64 waterMdot = highWaterMdot * PartLoadRatio;
                state.dataLoopNodes->Node(WaterControlNode).MassFlowRate = waterMdot;
            }
        }

        Real64 coolingPLR = 0.0;
        Real64 heatingPLR = 0.0;

        if (WaterControlNode > 0 && WaterControlNode == thisSys.CoolCoilFluidInletNode) {
            // cooling load using water cooling coil
            coolingPLR = PartLoadRatio;
            thisSys.m_CoolingPartLoadFrac = PartLoadRatio;
            if (thisSys.MaxCoolCoilFluidFlow > 0.0)
                thisSys.CoolCoilWaterFlowRatio = state.dataLoopNodes->Node(WaterControlNode).MassFlowRate / thisSys.MaxCoolCoilFluidFlow;
        } else if (WaterControlNode > 0 && WaterControlNode == thisSys.HeatCoilFluidInletNode) {
            // heating load using water heating coil
            heatingPLR = PartLoadRatio;
            thisSys.m_HeatingPartLoadFrac = PartLoadRatio;
            if (thisSys.MaxHeatCoilFluidFlow > 0.0)
                thisSys.HeatCoilWaterFlowRatio = state.dataLoopNodes->Node(WaterControlNode).MassFlowRate / thisSys.MaxHeatCoilFluidFlow;
        } else if (coolingLoad) { // non-water coil with cooling load
            coolingPLR = PartLoadRatio;
            thisSys.m_CoolingPartLoadFrac = coolingPLR;
        } else { // must be non-water coil with heating load
            heatingPLR = PartLoadRatio;
            thisSys.m_HeatingPartLoadFrac = heatingPLR;
        }

        Real64 SensOutput = 0.0;
        Real64 LatOutput = 0.0;
        thisSys.calcUnitarySystemToLoad(state,
                                        AirLoopNum,
                                        FirstHVACIteration,
                                        coolingPLR,
                                        heatingPLR,
                                        OnOffAirFlowRat,
                                        SensOutput,
                                        LatOutput,
                                        HXUnitOn,
                                        HeatCoilLoad,
                                        SupHeaterLoad,
                                        1.0);

        if (LoadIsTarget) {
            // Calculate residual based on output magnitude
            if (std::abs(QZnReq) <= 100.0) {
                Residuum = (SensOutput - QZnReq) / 100.0;
            } else {
                Residuum = (SensOutput - QZnReq) / QZnReq;
            }
        } else {
            // Calculate residual based on outlet temperature
            Residuum = (state.dataLoopNodes->Node(thisSys.AirOutNode).Temp - SATempTarget) * 10.0;
        }

        return Residuum;
    }

    void UnitarySys::setSpeedVariables(EnergyPlusData &state,
                                       bool const SensibleLoad,   // True when meeting a sensible load (not a moisture load)
                                       Real64 const PartLoadRatio // operating PLR
    )
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Richard Raustad, FSEC
        //       DATE WRITTEN   February 2013

        // PURPOSE OF THIS SUBROUTINE:
        // This subroutine determines operating PLR and calculates the load based system output.

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        bool errFlag = false;           // error flag returned from subroutine
        Real64 RuntimeFrac = 0.0;       // heat pump runtime fraction
        Real64 OnOffAirFlowRatio = 0.0; // compressor on to average flow rate

        if (state.dataUnitarySystems->HeatingLoad && SensibleLoad) {
            this->m_CoolingSpeedRatio = 0.0;
            this->m_CoolingCycRatio = 0.0;
            if (this->m_MultiSpeedHeatingCoil || this->m_VarSpeedHeatingCoil) {
                if (this->m_HeatingSpeedNum <= 1) {
                    this->m_HeatingSpeedRatio = 0.0;
                    this->m_HeatingCycRatio = PartLoadRatio;
                    state.dataHVACGlobal->MSHPMassFlowRateLow = state.dataUnitarySystems->CompOnMassFlow;
                } else {
                    if (this->m_SingleMode == 0) {
                        this->m_HeatingSpeedRatio = PartLoadRatio;
                        this->m_HeatingCycRatio = 1.0;
                    } else {
                        this->m_HeatingSpeedRatio = 1.0;
                        this->m_HeatingCycRatio = PartLoadRatio;
                    }
                }
            } else if (this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple ||
                       this->m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWaterToAirHP) {
                this->heatPumpRunFrac(PartLoadRatio, errFlag, RuntimeFrac);
                if (RuntimeFrac > 0.0 && this->m_FanOpMode == DataHVACGlobals::CycFanCycCoil) { // was DataHVACGlobals::ContFanCycCoil
                    state.dataHVACGlobal->OnOffFanPartLoadFraction = PartLoadRatio / RuntimeFrac;
                } else {
                    state.dataHVACGlobal->OnOffFanPartLoadFraction = 1;
                }
                this->m_CompPartLoadRatio = PartLoadRatio;
                this->m_WSHPRuntimeFrac = RuntimeFrac;
                this->m_HeatingSpeedNum = 0;
            }
        } else {
            this->m_HeatingSpeedRatio = 0.0;
            this->m_HeatingCycRatio = 0.0;
            if (this->m_DiscreteSpeedCoolingCoil || this->m_ContSpeedCoolingCoil) {
                if (this->m_CoolingSpeedNum <= 1) {
                    this->m_CoolingSpeedRatio = 0.0;
                    this->m_CoolingCycRatio = PartLoadRatio;
                    state.dataHVACGlobal->MSHPMassFlowRateLow = state.dataUnitarySystems->CompOnMassFlow;
                } else {
                    if (this->m_SingleMode == 0) {
                        this->m_CoolingSpeedRatio = PartLoadRatio;
                        this->m_CoolingCycRatio = 1.0;
                    } else {
                        this->m_CoolingSpeedRatio = 1.0;
                        this->m_CoolingCycRatio = PartLoadRatio;
                    }
                }
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple ||
                       this->m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterToAirHP) {
                this->heatPumpRunFrac(PartLoadRatio, errFlag, RuntimeFrac);
                if (RuntimeFrac > 0.0 &&
                    this->m_FanOpMode ==
                        DataHVACGlobals::CycFanCycCoil) { // was DataHVACGlobals::ContFanCycCoil, maybe file an issue or see if it fixes some
                    state.dataHVACGlobal->OnOffFanPartLoadFraction = PartLoadRatio / RuntimeFrac;
                } else {
                    state.dataHVACGlobal->OnOffFanPartLoadFraction = 1.0;
                }
                this->m_CompPartLoadRatio = PartLoadRatio;
                this->m_WSHPRuntimeFrac = RuntimeFrac;
                this->m_CoolingSpeedNum = 0;
            } else if (this->m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {
                if (this->m_CoolingSpeedNum == 1) {
                    this->m_CoolingSpeedRatio = 0.0;
                    this->m_CoolingCycRatio = PartLoadRatio;
                } else {
                    this->m_CoolingSpeedRatio = PartLoadRatio;
                    this->m_CoolingCycRatio = 1.0;
                }
            } else {
                this->m_CoolingSpeedNum = 0;
            }
        }
        OnOffAirFlowRatio = 1.0;
        this->setAverageAirFlow(state, PartLoadRatio, OnOffAirFlowRatio);
    }

    void UnitarySys::checkUnitarySysCoilInOASysExists(EnergyPlusData &state, std::string_view UnitarySysName, int const ZoneOAUnitNum)
    {

        // SUBROUTINE INFORMATION:
        //       AUTHOR         Chandan Sharma
        //       DATE WRITTEN   April 2013

        // PURPOSE OF THIS SUBROUTINE:
        // After making sure get input is done, checks if the Coil System DX coil is in the
        // OA System.  IF exists then the DX cooling coil is 100% DOAS DX coil.
        // METHODOLOGY EMPLOYED:
        // Based on CheckDXCoolingCoilInOASysExists by Bereket Nigusse

        // Locals
        // SUBROUTINE PARAMETER DEFINITIONS:
        static constexpr std::string_view RoutineName("CheckUnitarySysCoilInOASysExists: "); // include trailing blank space

        // SUBROUTINE LOCAL VARIABLE DECLARATIONS:
        if (state.dataUnitarySystems->getInputOnceFlag) {
            getUnitarySystemInput(state, UnitarySysName, false, ZoneOAUnitNum);
            state.dataUnitarySystems->getInputOnceFlag = false;
        }

        bool UnitarySysFound = false;
        if (state.dataUnitarySystems->numUnitarySystems > 0) {
            for (int UnitarySysNum = 0; UnitarySysNum < state.dataUnitarySystems->numUnitarySystems; ++UnitarySysNum) {
                if (UtilityRoutines::SameString(UnitarySysName, state.dataUnitarySystems->unitarySys[UnitarySysNum].Name)) {
                    if (state.dataUnitarySystems->unitarySys[UnitarySysNum].m_ThisSysInputShouldBeGotten)
                        getUnitarySystemInput(state, UnitarySysName, false, ZoneOAUnitNum);
                    if (state.dataUnitarySystems->unitarySys[UnitarySysNum].m_ISHundredPercentDOASDXCoil) {
                        if (!(state.dataUnitarySystems->unitarySys[UnitarySysNum].m_CoolingCoilType_Num ==
                                  DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed ||
                              state.dataUnitarySystems->unitarySys[UnitarySysNum].m_CoolingCoilType_Num ==
                                  DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit)) {
                            DXCoils::SetDXCoilTypeData(state, state.dataUnitarySystems->unitarySys[UnitarySysNum].m_CoolingCoilName);
                        }
                    }
                    UnitarySysFound = true;
                    break;
                }
            }
            if (!UnitarySysFound) {
                ShowSevereError(state, std::string{RoutineName} + "System not found = UnitarySystem \"" + std::string{UnitarySysName} + "\"");
            }
        } else {
            ShowSevereError(state, std::string{RoutineName} + "System not found = UnitarySystem \"" + std::string{UnitarySysName} + "\"");
        }
    }

    void UnitarySys::getUnitarySysHeatCoolCoil(EnergyPlusData &state,
                                               std::string_view UnitarySysName, // Name of Unitary System object
                                               bool &CoolingCoil,               // Cooling coil exists
                                               bool &HeatingCoil,               // Heating coil exists
                                               int const ZoneOAUnitNum          // index to zone OA unit
    )
    {

        // FUNCTION INFORMATION:
        //       AUTHOR         Chandan Sharma
        //       DATE WRITTEN   April 2013

        // PURPOSE OF THIS FUNCTION:
        // Determined weather Unitary system has heating or cooling coils

        if (state.dataUnitarySystems->getInputOnceFlag) {
            getUnitarySystemInput(state, UnitarySysName, false, ZoneOAUnitNum);
            state.dataUnitarySystems->getInputOnceFlag = false;
        }

        for (int UnitarySysNum = 0; UnitarySysNum < state.dataUnitarySystems->numUnitarySystems; ++UnitarySysNum) {
            if (UtilityRoutines::SameString(UnitarySysName, state.dataUnitarySystems->unitarySys[UnitarySysNum].Name)) {
                if (state.dataUnitarySystems->unitarySys[UnitarySysNum].m_ThisSysInputShouldBeGotten)
                    getUnitarySystemInput(state, UnitarySysName, false, ZoneOAUnitNum);
                if (state.dataUnitarySystems->unitarySys[UnitarySysNum].m_CoolCoilExists &&
                    !state.dataUnitarySystems->unitarySys[UnitarySysNum].m_WaterHRPlantLoopModel) {
                    CoolingCoil = true;
                }
                if (state.dataUnitarySystems->unitarySys[UnitarySysNum].m_HeatCoilExists ||
                    state.dataUnitarySystems->unitarySys[UnitarySysNum].m_SuppCoilExists) {
                    HeatingCoil = true;
                }
                break;
            }
        }
    }

    int UnitarySys::getAirInNode(EnergyPlusData &state, std::string_view UnitarySysName, int const ZoneOAUnitNum, bool &errFlag)
    {
        if (state.dataUnitarySystems->getInputOnceFlag) {
            getUnitarySystemInput(state, UnitarySysName, false, ZoneOAUnitNum);
            state.dataUnitarySystems->getInputOnceFlag = false;
        }
        int airNode = 0;
        for (int UnitarySysNum = 0; UnitarySysNum < state.dataUnitarySystems->numUnitarySystems; ++UnitarySysNum) {
            if (UtilityRoutines::SameString(UnitarySysName, state.dataUnitarySystems->unitarySys[UnitarySysNum].Name)) {
                airNode = this->AirInNode;
                break;
            }
        }
        if (airNode == 0) errFlag = true;
        return airNode;
    }

    int UnitarySys::getAirOutNode(EnergyPlusData &state, std::string_view UnitarySysName, int const ZoneOAUnitNum, bool &errFlag)
    {
        if (state.dataUnitarySystems->getInputOnceFlag) {
            getUnitarySystemInput(state, UnitarySysName, false, ZoneOAUnitNum);
            state.dataUnitarySystems->getInputOnceFlag = false;
        }
        int airNode = 0;
        for (int UnitarySysNum = 0; UnitarySysNum < state.dataUnitarySystems->numUnitarySystems; ++UnitarySysNum) {
            if (UtilityRoutines::SameString(UnitarySysName, state.dataUnitarySystems->unitarySys[UnitarySysNum].Name)) {
                airNode = this->AirOutNode;
                break;
            }
        }
        if (airNode == 0) errFlag = true;
        return airNode;
    }

    bool searchZoneInletNodes(EnergyPlusData &state, int nodeToFind, int &ZoneEquipConfigIndex, int &InletNodeIndex)
    {
        for (int ControlledZoneNum = 1; ControlledZoneNum <= state.dataGlobal->NumOfZones; ++ControlledZoneNum) {
            for (int ZoneInletNum = 1; ZoneInletNum <= state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).NumInletNodes; ++ZoneInletNum) {
                if (state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).InletNode(ZoneInletNum) == nodeToFind) {
                    ZoneEquipConfigIndex = ControlledZoneNum;
                    InletNodeIndex = ZoneInletNum;
                    return true;
                }
            }
        }
        return false;
    }

    bool searchZoneInletNodesByEquipmentIndex(EnergyPlusData &state, int nodeToFind, int zoneEquipmentIndex)
    {
        for (int ZoneInletNum = 1; ZoneInletNum <= state.dataZoneEquip->ZoneEquipConfig(zoneEquipmentIndex).NumInletNodes; ++ZoneInletNum) {
            if (state.dataZoneEquip->ZoneEquipConfig(zoneEquipmentIndex).InletNode(ZoneInletNum) == nodeToFind) {
                return true;
            }
        }
        return false;
    }

    bool searchZoneInletNodeAirLoopNum(EnergyPlusData &state, int airLoopNumToFind, int ZoneEquipConfigIndex, int &InletNodeIndex)
    {
        for (int ZoneInletNum = 1; ZoneInletNum <= state.dataZoneEquip->ZoneEquipConfig(ZoneEquipConfigIndex).NumInletNodes; ++ZoneInletNum) {
            if (state.dataZoneEquip->ZoneEquipConfig(ZoneEquipConfigIndex).InletNodeAirLoopNum(ZoneInletNum) == airLoopNumToFind) {
                InletNodeIndex = ZoneInletNum;
                return true;
            }
        }
        return false;
    }

    bool searchExhaustNodes(EnergyPlusData &state, const int nodeToFind, int &ZoneEquipConfigIndex, int &ExhaustNodeIndex)
    {
        for (int ControlledZoneNum = 1; ControlledZoneNum <= state.dataGlobal->NumOfZones; ++ControlledZoneNum) {
            for (int ZoneExhNum = 1; ZoneExhNum <= state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).NumExhaustNodes; ++ZoneExhNum) {
                if (state.dataZoneEquip->ZoneEquipConfig(ControlledZoneNum).ExhaustNode(ZoneExhNum) == nodeToFind) {
                    ZoneEquipConfigIndex = ControlledZoneNum;
                    ExhaustNodeIndex = ZoneExhNum;
                    return true;
                }
            }
        }
        return false;
    }

    void UnitarySys::setSystemParams(EnergyPlusData &state, Real64 &TotalFloorAreaOnAirLoop, const std::string thisObjectName)
    {
        this->NodeNumOfControlledZone = state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).ZoneNode;
        TotalFloorAreaOnAirLoop = state.dataHeatBal->Zone(state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).ActualZoneNum).FloorArea;
        this->m_AirLoopEquipment = false;
        if (state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).EquipListIndex > 0) {
            for (int EquipNum = 1;
                 EquipNum <=
                 state.dataZoneEquip->ZoneEquipList(state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).EquipListIndex).NumOfEquipTypes;
                 ++EquipNum) {
                if ((state.dataZoneEquip->ZoneEquipList(state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).EquipListIndex)
                         .EquipType_Num(EquipNum) != DataZoneEquipment::ZoneUnitarySys_Num) ||
                    state.dataZoneEquip->ZoneEquipList(state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).EquipListIndex)
                            .EquipName(EquipNum) != thisObjectName)
                    continue;
                this->m_ZoneSequenceCoolingNum =
                    state.dataZoneEquip->ZoneEquipList(state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).EquipListIndex)
                        .CoolingPriority(EquipNum);
                this->m_ZoneSequenceHeatingNum =
                    state.dataZoneEquip->ZoneEquipList(state.dataZoneEquip->ZoneEquipConfig(this->ControlZoneNum).EquipListIndex)
                        .HeatingPriority(EquipNum);
                break;
            }
        }
    }

    bool searchTotalComponents(EnergyPlusData &state, std::string_view objectNameToFind, int &compIndex, int &branchIndex, int &airLoopIndex)
    {
        for (int AirLoopNum = 1; AirLoopNum <= state.dataHVACGlobal->NumPrimaryAirSys; ++AirLoopNum) {
            for (int BranchNum = 1; BranchNum <= state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).NumBranches; ++BranchNum) {
                for (int CompNum = 1; CompNum <= state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).Branch(BranchNum).TotalComponents;
                     ++CompNum) {
                    if (UtilityRoutines::SameString(state.dataAirSystemsData->PrimaryAirSystems(AirLoopNum).Branch(BranchNum).Comp(CompNum).Name,
                                                    objectNameToFind)) {
                        compIndex = CompNum;
                        branchIndex = BranchNum;
                        airLoopIndex = AirLoopNum;
                        return true;
                    }
                }
            }
        }
        return false;
    }

    void setupAllOutputVars(EnergyPlusData &state, int const numAllSystemTypes)
    {
        // setup reports only once
        if (state.dataUnitarySystems->reportVariablesAreSetup) return;
        // all report variable are set up here after all UnitarySystem controlled types are read in.
        // UnitarySystem now models CoilSystem, any new reports may be setup in the order of call in SimAirServingZones.
        // if (UnitarySystem), else (CoilSystem), else (otherSystems), etc., else FATAL.
        if (numAllSystemTypes == state.dataUnitarySystems->numUnitarySystems) {
            for (int sysNum = 0; sysNum < state.dataUnitarySystems->numUnitarySystems; ++sysNum) {
                if (state.dataUnitarySystems->unitarySys[sysNum].m_sysType == UnitarySys::SysType::Unitary) {
                    // Setup Report variables for the Unitary System that are not reported in the components themselves
                    SetupOutputVariable(state,
                                        "Unitary System Part Load Ratio",
                                        OutputProcessor::Unit::None,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_PartLoadFrac,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Unitary System Total Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_TotCoolEnergyRate,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Unitary System Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_SensCoolEnergyRate,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Unitary System Latent Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_LatCoolEnergyRate,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Unitary System Total Heating Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_TotHeatEnergyRate,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Unitary System Sensible Heating Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_SensHeatEnergyRate,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Unitary System Latent Heating Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_LatHeatEnergyRate,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Unitary System Ancillary Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_TotalAuxElecPower,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    if (state.dataUnitarySystems->unitarySys[sysNum].m_CoolCoilExists) {
                        SetupOutputVariable(state,
                                            "Unitary System Cooling Ancillary Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_CoolingAuxElecConsumption,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Summed,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name,
                                            _,
                                            "Electricity",
                                            "Cooling",
                                            _,
                                            "System");
                    }
                    if (state.dataUnitarySystems->unitarySys[sysNum].m_HeatCoilExists ||
                        state.dataUnitarySystems->unitarySys[sysNum].m_SuppCoilExists) {
                        SetupOutputVariable(state,
                                            "Unitary System Heating Ancillary Electricity Energy",
                                            OutputProcessor::Unit::J,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_HeatingAuxElecConsumption,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Summed,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name,
                                            _,
                                            "Electricity",
                                            "Heating",
                                            _,
                                            "System");
                    }

                    SetupOutputVariable(state,
                                        "Unitary System Electricity Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_ElecPower,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Unitary System Electricity Energy",
                                        OutputProcessor::Unit::J,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_ElecPowerConsumption,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Summed,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);

                    // report predicted load as determined by Unitary System for load control only
                    if (state.dataUnitarySystems->unitarySys[sysNum].m_ControlType != UnitarySys::ControlType::Setpoint) {
                        SetupOutputVariable(state,
                                            "Unitary System Predicted Sensible Load to Setpoint Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_SensibleLoadPredicted,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                        SetupOutputVariable(state,
                                            "Unitary System Predicted Moisture Load to Setpoint Heat Transfer Rate",
                                            OutputProcessor::Unit::W,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_MoistureLoadPredicted,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                    }

                    //        IF(UnitarySystem(UnitarySysNum)%m_DehumidControlType_Num .EQ. dehumidm_ControlType::CoolReheat)THEN
                    SetupOutputVariable(state,
                                        "Unitary System Dehumidification Induced Heating Demand Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_DehumidInducedHeatingDemandRate,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    //        END IF

                    if (state.dataUnitarySystems->unitarySys[sysNum].m_FanExists) {
                        SetupOutputVariable(state,
                                            "Unitary System Fan Part Load Ratio",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].FanPartLoadRatio,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                    }

                    SetupOutputVariable(state,
                                        "Unitary System Compressor Part Load Ratio",
                                        OutputProcessor::Unit::None,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_CompPartLoadRatio,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);

                    SetupOutputVariable(state,
                                        "Unitary System Frost Control Status",
                                        OutputProcessor::Unit::None,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_FrostControlStatus,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);

                    {
                        auto const SELECT_CASE_var(state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilType_Num);
                        if (SELECT_CASE_var == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {
                        } else if (SELECT_CASE_var == DataHVACGlobals::CoilDX_MultiSpeedCooling ||
                                   (SELECT_CASE_var == DataHVACGlobals::CoilDX_Cooling)) {
                            if (state.dataUnitarySystems->unitarySys[sysNum].m_HeatRecActive) {
                                SetupOutputVariable(state,
                                                    "Unitary System Heat Recovery Rate",
                                                    OutputProcessor::Unit::W,
                                                    state.dataUnitarySystems->unitarySys[sysNum].m_HeatRecoveryRate,
                                                    OutputProcessor::SOVTimeStepType::System,
                                                    OutputProcessor::SOVStoreType::Average,
                                                    state.dataUnitarySystems->unitarySys[sysNum].Name);
                                SetupOutputVariable(state,
                                                    "Unitary System Heat Recovery Inlet Temperature",
                                                    OutputProcessor::Unit::C,
                                                    state.dataUnitarySystems->unitarySys[sysNum].m_HeatRecoveryInletTemp,
                                                    OutputProcessor::SOVTimeStepType::System,
                                                    OutputProcessor::SOVStoreType::Average,
                                                    state.dataUnitarySystems->unitarySys[sysNum].Name);
                                SetupOutputVariable(state,
                                                    "Unitary System Heat Recovery Outlet Temperature",
                                                    OutputProcessor::Unit::C,
                                                    state.dataUnitarySystems->unitarySys[sysNum].m_HeatRecoveryOutletTemp,
                                                    OutputProcessor::SOVTimeStepType::System,
                                                    OutputProcessor::SOVStoreType::Average,
                                                    state.dataUnitarySystems->unitarySys[sysNum].Name);
                                SetupOutputVariable(state,
                                                    "Unitary System Heat Recovery Fluid Mass Flow Rate",
                                                    OutputProcessor::Unit::kg_s,
                                                    state.dataUnitarySystems->unitarySys[sysNum].m_HeatRecoveryMassFlowRate,
                                                    OutputProcessor::SOVTimeStepType::System,
                                                    OutputProcessor::SOVStoreType::Average,
                                                    state.dataUnitarySystems->unitarySys[sysNum].Name);
                                SetupOutputVariable(state,
                                                    "Unitary System Heat Recovery Energy",
                                                    OutputProcessor::Unit::J,
                                                    state.dataUnitarySystems->unitarySys[sysNum].m_HeatRecoveryEnergy,
                                                    OutputProcessor::SOVTimeStepType::System,
                                                    OutputProcessor::SOVStoreType::Summed,
                                                    state.dataUnitarySystems->unitarySys[sysNum].Name);
                            }
                        } else if ((SELECT_CASE_var == DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) ||
                                   (SELECT_CASE_var == DataHVACGlobals::CoilDX_Cooling) ||
                                   (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterToAirHPVSEquationFit) ||
                                   (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterToAirHPSimple) ||
                                   (SELECT_CASE_var == DataHVACGlobals::Coil_CoolingWaterToAirHP)) {
                            SetupOutputVariable(state,
                                                "Unitary System Requested Sensible Cooling Rate",
                                                OutputProcessor::Unit::W,
                                                state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilSensDemand,
                                                OutputProcessor::SOVTimeStepType::System,
                                                OutputProcessor::SOVStoreType::Average,
                                                state.dataUnitarySystems->unitarySys[sysNum].Name);
                            SetupOutputVariable(state,
                                                "Unitary System Requested Latent Cooling Rate",
                                                OutputProcessor::Unit::W,
                                                state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilLatentDemand,
                                                OutputProcessor::SOVTimeStepType::System,
                                                OutputProcessor::SOVStoreType::Average,
                                                state.dataUnitarySystems->unitarySys[sysNum].Name);
                        } else {
                        }
                    }

                    if (state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilIndex >= 0) {
                        if (state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling &&
                            state.dataCoilCooingDX->coilCoolingDXs[state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilIndex]
                                .SubcoolReheatFlag) {
                            SetupOutputVariable(state,
                                                "Unitary System Zone Load Sensible Heat Ratio",
                                                OutputProcessor::Unit::None,
                                                state.dataUnitarySystems->unitarySys[sysNum].LoadSHR,
                                                OutputProcessor::SOVTimeStepType::System,
                                                OutputProcessor::SOVStoreType::Average,
                                                state.dataUnitarySystems->unitarySys[sysNum].Name);
                            SetupOutputVariable(state,
                                                "Unitary System Cooling Coil Load Sensible Heat Ratio",
                                                OutputProcessor::Unit::None,
                                                state.dataUnitarySystems->unitarySys[sysNum].CoilSHR,
                                                OutputProcessor::SOVTimeStepType::System,
                                                OutputProcessor::SOVStoreType::Average,
                                                state.dataUnitarySystems->unitarySys[sysNum].Name);
                        }
                    }

                    {
                        auto const SELECT_CASE_var(state.dataUnitarySystems->unitarySys[sysNum].m_HeatingCoilType_Num);
                        if ((SELECT_CASE_var == DataHVACGlobals::Coil_HeatingAirToAirVariableSpeed) ||
                            (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPVSEquationFit) ||
                            (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHPSimple) ||
                            (SELECT_CASE_var == DataHVACGlobals::Coil_HeatingWaterToAirHP)) {
                            SetupOutputVariable(state,
                                                "Unitary System Requested Heating Rate",
                                                OutputProcessor::Unit::W,
                                                state.dataUnitarySystems->unitarySys[sysNum].m_HeatingCoilSensDemand,
                                                OutputProcessor::SOVTimeStepType::System,
                                                OutputProcessor::SOVStoreType::Average,
                                                state.dataUnitarySystems->unitarySys[sysNum].Name);
                        }
                    }

                    if (state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling ||
                        state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed ||
                        state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_Cooling ||
                        state.dataUnitarySystems->unitarySys[sysNum].m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating ||
                        state.dataUnitarySystems->unitarySys[sysNum].m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingElectric_MultiStage ||
                        state.dataUnitarySystems->unitarySys[sysNum].m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingGas_MultiStage) {
                        SetupOutputVariable(state,
                                            "Unitary System DX Coil Cycling Ratio",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_CycRatio,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                        SetupOutputVariable(state,
                                            "Unitary System DX Coil Speed Ratio",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_SpeedRatio,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                        SetupOutputVariable(state,
                                            "Unitary System DX Coil Speed Level",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_SpeedNum,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                    }

                    if (((state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWater ||
                          state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilType_Num == DataHVACGlobals::Coil_CoolingWaterDetailed) &&
                         state.dataUnitarySystems->unitarySys[sysNum].m_DiscreteSpeedCoolingCoil) ||
                        (state.dataUnitarySystems->unitarySys[sysNum].m_HeatingCoilType_Num == DataHVACGlobals::Coil_HeatingWater &&
                         state.dataUnitarySystems->unitarySys[sysNum].m_MultiSpeedHeatingCoil)) {
                        SetupOutputVariable(state,
                                            "Unitary System Water Coil Cycling Ratio",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_CycRatio,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                        SetupOutputVariable(state,
                                            "Unitary System Water Coil Speed Ratio",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_SpeedRatio,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                        SetupOutputVariable(state,
                                            "Unitary System Water Coil Speed Level",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_SpeedNum,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                    }

                    if (state.dataGlobal->AnyEnergyManagementSystemInModel) {
                        SetupEMSActuator(state,
                                         "UnitarySystem",
                                         state.dataUnitarySystems->unitarySys[sysNum].Name,
                                         "Autosized Supply Air Flow Rate",
                                         "[m3/s]",
                                         state.dataUnitarySystems->unitarySys[sysNum].m_DesignFanVolFlowRateEMSOverrideOn,
                                         state.dataUnitarySystems->unitarySys[sysNum].m_DesignFanVolFlowRateEMSOverrideValue);
                        SetupEMSActuator(state,
                                         "UnitarySystem",
                                         state.dataUnitarySystems->unitarySys[sysNum].Name,
                                         "Autosized Supply Air Flow Rate During Cooling Operation",
                                         "[m3/s]",
                                         state.dataUnitarySystems->unitarySys[sysNum].m_MaxCoolAirVolFlowEMSOverrideOn,
                                         state.dataUnitarySystems->unitarySys[sysNum].m_MaxCoolAirVolFlowEMSOverrideValue);
                        SetupEMSActuator(state,
                                         "UnitarySystem",
                                         state.dataUnitarySystems->unitarySys[sysNum].Name,
                                         "Autosized Supply Air Flow Rate During Heating Operation",
                                         "[m3/s]",
                                         state.dataUnitarySystems->unitarySys[sysNum].m_MaxHeatAirVolFlowEMSOverrideOn,
                                         state.dataUnitarySystems->unitarySys[sysNum].m_MaxHeatAirVolFlowEMSOverrideValue);
                        SetupEMSActuator(state,
                                         "UnitarySystem",
                                         state.dataUnitarySystems->unitarySys[sysNum].Name,
                                         "Autosized Supply Air Flow Rate During No Heating or Cooling Operation",
                                         "[m3/s]",
                                         state.dataUnitarySystems->unitarySys[sysNum].m_MaxNoCoolHeatAirVolFlowEMSOverrideOn,
                                         state.dataUnitarySystems->unitarySys[sysNum].m_MaxNoCoolHeatAirVolFlowEMSOverrideValue);
                        SetupEMSInternalVariable(state,
                                                 "Unitary System Control Zone Mass Flow Fraction",
                                                 state.dataUnitarySystems->unitarySys[sysNum].Name,
                                                 "[]",
                                                 state.dataUnitarySystems->unitarySys[sysNum].ControlZoneMassFlowFrac);
                        SetupEMSInternalVariable(state,
                                                 "Unitary HVAC Design Heating Capacity",
                                                 state.dataUnitarySystems->unitarySys[sysNum].Name,
                                                 "[W]",
                                                 state.dataUnitarySystems->unitarySys[sysNum].m_DesignHeatingCapacity);
                        SetupEMSInternalVariable(state,
                                                 "Unitary HVAC Design Cooling Capacity",
                                                 state.dataUnitarySystems->unitarySys[sysNum].Name,
                                                 "[W]",
                                                 state.dataUnitarySystems->unitarySys[sysNum].m_DesignCoolingCapacity);
                        SetupEMSActuator(state,
                                         "Unitary HVAC",
                                         state.dataUnitarySystems->unitarySys[sysNum].Name,
                                         "Sensible Load Request",
                                         "[W]",
                                         state.dataUnitarySystems->unitarySys[sysNum].m_EMSOverrideSensZoneLoadRequest,
                                         state.dataUnitarySystems->unitarySys[sysNum].m_EMSSensibleZoneLoadValue);
                        SetupEMSActuator(state,
                                         "Unitary HVAC",
                                         state.dataUnitarySystems->unitarySys[sysNum].Name,
                                         "Moisture Load Request",
                                         "[W]",
                                         state.dataUnitarySystems->unitarySys[sysNum].m_EMSOverrideMoistZoneLoadRequest,
                                         state.dataUnitarySystems->unitarySys[sysNum].m_EMSMoistureZoneLoadValue);
                        if (state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedCooling ||
                            state.dataUnitarySystems->unitarySys[sysNum].m_HeatingCoilType_Num == DataHVACGlobals::CoilDX_MultiSpeedHeating) {
                            SetupEMSActuator(state,
                                             "Coil Speed Control",
                                             state.dataUnitarySystems->unitarySys[sysNum].Name,
                                             "Unitary System DX Coil Speed Value",
                                             "[]",
                                             state.dataUnitarySystems->unitarySys[sysNum].m_EMSOverrideCoilSpeedNumOn,
                                             state.dataUnitarySystems->unitarySys[sysNum].m_EMSOverrideCoilSpeedNumValue);
                        }
                    }
                    bool anyEMSRan;
                    EMSManager::ManageEMS(state, EMSManager::EMSCallFrom::ComponentGetInput, anyEMSRan, ObjexxFCL::Optional_int_const());
                } else if (state.dataUnitarySystems->unitarySys[sysNum].m_sysType == UnitarySys::SysType::CoilCoolingDX) {
                    // Setup Report variables for the DXCoolingSystem that is not reported in the components themselves
                    if (state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilType_Num == DataHVACGlobals::CoilDX_CoolingTwoSpeed) {
                        SetupOutputVariable(state,
                                            "Coil System Cycling Ratio",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCycRatio,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                        SetupOutputVariable(state,
                                            "Coil System Compressor Speed Ratio",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_CoolingSpeedRatio,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                    } else if (state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCoilType_Num ==
                               DataHVACGlobals::Coil_CoolingAirToAirVariableSpeed) {
                        SetupOutputVariable(state,
                                            "Coil System Cycling Ratio",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_CoolingCycRatio,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                        SetupOutputVariable(state,
                                            "Coil System Compressor Speed Ratio",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_CoolingSpeedRatio,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                        SetupOutputVariable(state,
                                            "Coil System Compressor Speed Number",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_CoolingSpeedNum,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                    } else {
                        SetupOutputVariable(state,
                                            "Coil System Part Load Ratio",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].m_CoolingPartLoadFrac,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                    }
                    SetupOutputVariable(state,
                                        "Coil System Frost Control Status",
                                        OutputProcessor::Unit::None,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_FrostControlStatus,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                } else if (state.dataUnitarySystems->unitarySys[sysNum].m_sysType == UnitarySys::SysType::CoilCoolingWater) {
                    // Setup Report variables for the CoilSystemWater
                    SetupOutputVariable(state,
                                        "Coil System Water Part Load Ratio",
                                        OutputProcessor::Unit::None,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_PartLoadFrac,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Coil System Water Total Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_TotCoolEnergyRate,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Coil System Water Sensible Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_SensCoolEnergyRate,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);
                    SetupOutputVariable(state,
                                        "Coil System Water Latent Cooling Rate",
                                        OutputProcessor::Unit::W,
                                        state.dataUnitarySystems->unitarySys[sysNum].m_LatCoolEnergyRate,
                                        OutputProcessor::SOVTimeStepType::System,
                                        OutputProcessor::SOVStoreType::Average,
                                        state.dataUnitarySystems->unitarySys[sysNum].Name);

                    if (state.dataUnitarySystems->unitarySys[sysNum].m_TemperatureOffsetControlActive) {
                        SetupOutputVariable(state,
                                            "Coil System Water Control Status",
                                            OutputProcessor::Unit::None,
                                            state.dataUnitarySystems->unitarySys[sysNum].temperatureOffsetControlStatus,
                                            OutputProcessor::SOVTimeStepType::System,
                                            OutputProcessor::SOVStoreType::Average,
                                            state.dataUnitarySystems->unitarySys[sysNum].Name);
                    }
                } else {
                    ShowFatalError(state,
                                   "setupAllOutputVar: Developer error. All report variables must be set up here after all systems are read in.");
                }
            }
        }
        state.dataUnitarySystems->reportVariablesAreSetup = true;
    }

    void isWaterCoilHeatRecoveryType(EnergyPlusData &state, int const waterCoilNodeNum, bool &nodeNotFound)
    {
        for (int sysNum = 0; sysNum < state.dataUnitarySystems->numUnitarySystems; ++sysNum) {
            if (state.dataUnitarySystems->unitarySys[sysNum].m_HRcoolCoilFluidInletNode == waterCoilNodeNum &&
                state.dataUnitarySystems->unitarySys[sysNum].m_WaterHRPlantLoopModel) {
                nodeNotFound = false;
                break;
            }
        }
    }

} // namespace UnitarySystems
} // namespace EnergyPlus
