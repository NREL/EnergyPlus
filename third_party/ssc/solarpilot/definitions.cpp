//File automatically generated by variable_map_makefile.py 2018/7/9


/*******************************************************************************************************
*  Copyright 2017 Alliance for Sustainable Energy, LLC
*
*  NOTICE: This software was developed at least in part by Alliance for Sustainable Energy, LLC
*  ("Alliance") under Contract No. DE-AC36-08GO28308 with the U.S. Department of Energy and the U.S.
*  The Government retains for itself and others acting on its behalf a nonexclusive, paid-up,
*  irrevocable worldwide license in the software to reproduce, prepare derivative works, distribute
*  copies to the public, perform publicly and display publicly, and to permit others to do so.
*
*  Redistribution and use in source and binary forms, with or without modification, are permitted
*  provided that the following conditions are met:
*
*  1. Redistributions of source code must retain the above copyright notice, the above government
*  rights notice, this list of conditions and the following disclaimer.
*
*  2. Redistributions in binary form must reproduce the above copyright notice, the above government
*  rights notice, this list of conditions and the following disclaimer in the documentation and/or
*  other materials provided with the distribution.
*
*  3. The entire corresponding source code of any redistribution, with or without modification, by a
*  research entity, including but not limited to any contracting manager/operator of a United States
*  National Laboratory, any institution of higher learning, and any non-profit organization, must be
*  made publicly available under this license for as long as the redistribution is made available by
*  the research entity.
*
*  4. Redistribution of this software, without modification, must refer to the software by the same
*  designation. Redistribution of a modified version of this software (i) may not refer to the modified
*  version by the same designation, or by any confusingly similar designation, and (ii) must refer to
*  the underlying software originally provided by Alliance as "System Advisor Model" or "SAM". Except
*  to comply with the foregoing, the terms "System Advisor Model", "SAM", or any confusingly similar
*  designation may not be used to refer to any modified version of this software or any modified
*  version of the underlying software originally provided by Alliance without the prior written consent
*  of Alliance.
*
*  5. The name of the copyright holder, contributors, the United States Government, the United States
*  Department of Energy, or any of their employees may not be used to endorse or promote products
*  derived from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
*  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
*  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER,
*  CONTRIBUTORS, UNITED STATES GOVERNMENT OR UNITED STATES DEPARTMENT OF ENERGY, NOR ANY OF THEIR
*  EMPLOYEES, BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
*  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
*  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
*  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************************************/


#include "definitions.h"
#include "mod_base.h"
#include "string_util.h"

var_map::var_map()
{
    reset();
}

var_map::var_map( var_map &vc )
{
    reset();
    copy( vc );
}

void var_map::copy( var_map &vc )
{
    //to copy, we need to make sure the template structures for heliostats and receivers are
    //parallel between both varmaps first. Then copy by iterating over the list of strings in
    //the varmap and set the corresponding object values in each map.

    //receiver templates
    for( size_t i=0; i<recs.size(); i++ )
        drop_receiver((int)i);
    for( size_t i=0; i<vc.recs.size(); i++ )
        add_receiver( vc.recs.at(i).id.val );

    //heliostat templates
    for( size_t i=0; i<hels.size(); i++ )
        drop_heliostat((int)i);
    for( size_t i=0; i<vc.hels.size(); i++ )
        add_heliostat( vc.hels.at(i).id.val );

    //now add by string->obj
    for( unordered_map< std::string, spbase* >::iterator var=_varptrs.begin(); var!=_varptrs.end(); var++ )
        var->second->set_from_string( vc._varptrs.at( var->first )->as_string().c_str() );
    
    return;
}

void var_map::reset()
{
    //first clear the receiver and heliostat objects
    hels.clear();
    recs.clear();
    //clear out pointer map
    _varptrs.clear();
    
    //reserve size for the templates. otherwise, the pointer addresses get confused. This is the max limit of templates.
    hels.reserve(100);
    recs.reserve(100);
    
	amb.atm_coefs                    .set("ambient.0.atm_coefs"              , SP_DATTYPE::SP_MATRIX_T  , "0.006789,0.1046,-0.0170,0.002845;0.01293,0.2748,-.03394,0;0.006789,0.1046,-0.0170,0.002845",       "none",    false,         "", "0.006789,0.1046,-0.0170,0.002845;0.01293,0.2748,-.03394,0;0.006789,0.1046,-0.0170,0.002845",    false,               "User-defined attenuation", "Atmospheric attenuation coefficients for user-defined analysis");
	amb.atm_model                    .set("ambient.0.atm_model"              , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "DELSOL3 clear day=0;DELSOL3 hazy day=1;User-defined=2",    false,          "Atmospheric attenuation model", "Atmospheric attenuation model {0=25km Barstow, 1 = 5km Barstow, 2 = user defined}");
	amb.class_name                   .set("ambient.0.class_name"             , SP_DATTYPE::SP_STRING    ,            "Climate",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	amb.del_h2o                      .set("ambient.0.del_h2o"                , SP_DATTYPE::SP_DOUBLE    ,                 "20",     "mm H2O",    false,         "",    "",    false,         "Atmospheric precipitable water", "Atmospheric precipitable water depth for use in the Allen insolation model");
	amb.dni_layout                   .set("ambient.0.dni_layout"             , SP_DATTYPE::SP_DOUBLE    ,                "950",       "W/m2",     true,         "",    "",    false,   "Constant DNI for layout calculations", "DNI to use during all layout calculations. CONSTANT model only.");
	amb.dpres                        .set("ambient.0.dpres"                  , SP_DATTYPE::SP_DOUBLE    ,                  "1",        "atm",     true,         "",    "",    false,                       "Ambient pressure", "Local ambient pressure relative to sea-level pressure");
	amb.elevation                    .set("ambient.0.elevation"              , SP_DATTYPE::SP_DOUBLE    ,                "588",          "m",    false,         "",    "",    false,                        "Plant elevation", "Plant mean elevation");
	amb.insol_type                   .set("ambient.0.insol_type"             , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "Weather file data=-1;Meinel model=0;Hottel model=1;Constant value=2;Allen model=3;Moon model=4",    false,                       "Insolation model", "Model used to determine insolation as a function of time");
	amb.latitude                     .set("ambient.0.latitude"               , SP_DATTYPE::SP_DOUBLE    ,             "34.867",        "deg",    false,         "",    "",    false,                         "Plant latitude", "Plant latitude");
	amb.loc_city                     .set("ambient.0.loc_city"               , SP_DATTYPE::SP_STRING    ,          "city name",       "none",    false,         "",    "",    false,             "Weather file location name", "City or place name for weather station (informational only)");
	amb.loc_state                    .set("ambient.0.loc_state"              , SP_DATTYPE::SP_STRING    ,         "state name",       "none",    false,         "",    "",    false,                "Weather file state name", "State name for weather station (informational only)");
	amb.longitude                    .set("ambient.0.longitude"              , SP_DATTYPE::SP_DOUBLE    ,           "-116.783",        "deg",    false,         "",    "",    false,                        "Plant longitude", "Plant longitude");
	amb.sun_csr                      .set("ambient.0.sun_csr"                , SP_DATTYPE::SP_DOUBLE    ,                "0.1",       "none",     true,         "",    "",    false,                      "Circumsolar ratio", "Ratio of solar flux contained in the circumsolar ring over the solar disc flux");
	amb.sun_pos_map                  .set("ambient.0.sun_pos_map"            , SP_DATTYPE::SP_MATRIX_T  ,                   "",  "[deg,deg]",    false,         "",    "",    false,                            "sun_pos_map", "Map of sun positions to use for calculations");
	amb.sun_rad_limit                .set("ambient.0.sun_rad_limit"          , SP_DATTYPE::SP_DOUBLE    ,               "4.65",       "mrad",     true,         "",    "",    false,                "Sunshape angular extent", "Half-angle of sunshape size (4.65mrad for Pillbox, 2.73mrad for Gaussian)");
	amb.sun_type                     .set("ambient.0.sun_type"               , SP_DATTYPE::SP_STRING    ,                  "2",       "none",     true,    "combo", "Pillbox sun=2;Gaussian sun=4;Limb-darkened sun=1;Point sun=0;Buie CSR=5;User sun=3;",    false,                         "Sunshape model", "Sunshape model - {0=point sun, 1=limb darkened sun, 2=square wave sun, 3=user sun}");
	amb.time_zone                    .set("ambient.0.time_zone"              , SP_DATTYPE::SP_DOUBLE    ,                 "-8",         "hr",    false,         "",    "",    false,                              "Time zone", "Time zone");
	amb.user_sun                     .set("ambient.0.user_sun"               , SP_DATTYPE::SP_MATRIX_T  ,                   "",  "[deg,deg]",    false,         "",    "",    false,                               "user_sun", "Array of intensity at various angles from the centroid of the sun");
	amb.weather_file                 .set("ambient.0.weather_file"           , SP_DATTYPE::SP_STRING    , "USA CA Daggett (TMY2).csv",       "none",     true,         "",    "",    false,                           "Weather file", "Weather file to use for analysis");
	amb.wf_data                      .set("ambient.0.wf_data"                , SP_DATTYPE::SP_WEATHERDATA,                   "",       "none",    false,         "",    "",    false,                                "wf_data", "Data entries in the weather file");
	amb.atm_atten_est                .setup("ambient.0.atm_atten_est"          , SP_DATTYPE::SP_DOUBLE    ,                                "%",    false,         "",    "",    false,                    "Average attenuation", "Average solar field attenuation due to atmospheric scattering");
	amb.sim_time_step                .setup("ambient.0.sim_time_step"          , SP_DATTYPE::SP_DOUBLE    ,                              "sec",    false,         "",    "",    false,      "Simulation weather data time step", "Simulation weather data time step");

	fin.class_name                   .set("financial.0.class_name"           , SP_DATTYPE::SP_STRING    ,          "Financial",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	fin.contingency_rate             .set("financial.0.contingency_rate"     , SP_DATTYPE::SP_DOUBLE    ,                  "7",          "%",     true,         "",    "",    false,                            "Contingency", "Fraction of the direct capital costs added to account for contingency");
	fin.fixed_cost                   .set("financial.0.fixed_cost"           , SP_DATTYPE::SP_DOUBLE    ,                  "0",          "$",    false,         "",    "",    false,                             "Fixed cost", "Cost that does not scale with any plant parameter");
	fin.heliostat_spec_cost          .set("financial.0.heliostat_spec_cost"  , SP_DATTYPE::SP_DOUBLE    ,                "145",       "$/m2",     true,         "",    "",    false,                        "Heliostat field", "Cost per square meter of heliostat aperture area of the heliostat field");
	fin.is_pmt_factors               .set("financial.0.is_pmt_factors"       , SP_DATTYPE::SP_BOOL      ,              "FALSE",           "",    false, "checkbox",    "",    false,       "Enable payment weighting factors", "Enable or disable the use of weighting factors in determining field layout");
	fin.land_spec_cost               .set("financial.0.land_spec_cost"       , SP_DATTYPE::SP_DOUBLE    ,              "10000",     "$/acre",     true,         "",    "",    false,                     "Land cost per acre", "Cost of land per acre including the footprint of the land occupied by the entire plant.");
	fin.pmt_factors                  .set("financial.0.pmt_factors"          , SP_DATTYPE::SP_VEC_DOUBLE, "2.064,1.2,1,1.1,0.8,0.7,1,1,1",       "none",    false,         "",    "",    false,             "Payment allocation factors", "Relative value of electricity produced during this period compared to the average");
	fin.rec_cost_exp                 .set("financial.0.rec_cost_exp"         , SP_DATTYPE::SP_DOUBLE    ,                "0.7",       "none",     true,         "",    "",    false,         "Receiver cost scaling exponent", "Exponent in the equation (total cost) = (ref. cost) * ( (area) / (ref. area) ) ^ X");
	fin.rec_ref_area                 .set("financial.0.rec_ref_area"         , SP_DATTYPE::SP_DOUBLE    ,               "1571",         "m2",     true,         "",    "",    false,                "Receiver reference area", "Receiver surface area corresponding to the receiver reference cost");
	fin.rec_ref_cost                 .set("financial.0.rec_ref_cost"         , SP_DATTYPE::SP_DOUBLE    ,          "103000000",          "$",     true,         "",    "",    false,                "Receiver reference cost", "Cost of the receiver at the sizing indicated by the reference receiver area");
	fin.sales_tax_frac               .set("financial.0.sales_tax_frac"       , SP_DATTYPE::SP_DOUBLE    ,                 "80",          "%",     true,         "",    "",    false,                 "Sales tax rate portion", "Fraction of the direct capital costs for which sales tax applies");
	fin.sales_tax_rate               .set("financial.0.sales_tax_rate"       , SP_DATTYPE::SP_DOUBLE    ,                  "5",          "%",     true,         "",    "",    false,                         "Sales tax rate", "Sales tax rate applid to the total direct capital cost");
	fin.site_spec_cost               .set("financial.0.site_spec_cost"       , SP_DATTYPE::SP_DOUBLE    ,                 "16",       "$/m2",     true,         "",    "",    false,                      "Site improvements", "Cost per square meter of heliostat aperture area of site improvements");
	fin.tower_exp                    .set("financial.0.tower_exp"            , SP_DATTYPE::SP_DOUBLE    ,             "0.0113",       "none",     true,         "",    "",    false,            "Tower cost scaling exponent", "Exponent in the equation (total cost) = (fixed cost) * exp( X * (tower height) )");
	fin.tower_fixed_cost             .set("financial.0.tower_fixed_cost"     , SP_DATTYPE::SP_DOUBLE    ,           "3.00E+06",          "$",     true,         "",    "",    false,                       "Fixed tower cost", "Fixed tower cost - used as the basis for scaling tower cost as a function of height");
	fin.weekday_sched                .set("financial.0.weekday_sched"        , SP_DATTYPE::SP_STRING    , "666666554444444444444555666666554444444444444555666666554444444444444555666666554444444444444555666666554444444444444555333333332222111111222333333333332222111111222333333333332222111111222333333333332222111111222333666666554444444444444555666666554444444444444555666666554444444444444555",           "",    false,         "",    "",    false,       "Weekday dispatch period schedule", "Weekday dispatch period schedule");
	fin.weekend_sched                .set("financial.0.weekend_sched"        , SP_DATTYPE::SP_STRING    , "666666555555555555555555666666555555555555555555666666555555555555555555666666555555555555555555666666555555555555555555333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333666666555555555555555555666666555555555555555555666666555555555555555555",           "",    false,         "",    "",    false,       "Weekend dispatch period schedule", "Weekend dispatch period schedule");
	fin.wiring_user_spec             .set("financial.0.wiring_user_spec"     , SP_DATTYPE::SP_DOUBLE    ,                  "0",       "$/m2",     true,         "",    "",    false,                   "Wiring specific cost", "Cost of wiring per square meter of heliostat aperture area");
	fin.contingency_cost             .setup("financial.0.contingency_cost"     , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                       "Contingency cost", "Contingency cost");
	fin.heliostat_cost               .setup("financial.0.heliostat_cost"       , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                   "Heliostat field cost", "Heliostat field cost");
	fin.land_cost                    .setup("financial.0.land_cost"            , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                              "Land cost", "Land cost");
	fin.pricing_array                .setup("financial.0.pricing_array"        , SP_DATTYPE::SP_VEC_DOUBLE,                             "none",    false,         "",    "",    false, "Time series schedule of price multipliers", "Yearly time series schedule of price multipliers to incentivize electricity sales at particular times");
	fin.rec_cost                     .setup("financial.0.rec_cost"             , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                          "Receiver cost", "Receiver cost");
	fin.sales_tax_cost               .setup("financial.0.sales_tax_cost"       , SP_DATTYPE::SP_DOUBLE    ,                                "$",     true,         "",    "",    false,                         "Sales tax cost", "Sales tax cost");
	fin.schedule_array               .setup("financial.0.schedule_array"       , SP_DATTYPE::SP_VEC_INTEGER,                             "none",    false,         "",    "",    false,    "Time series schedule of TOU periods", "Yearly time series schedule of TOU periods");
	fin.site_cost                    .setup("financial.0.site_cost"            , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                 "Site improvements cost", "Site improvements cost");
	fin.total_direct_cost            .setup("financial.0.total_direct_cost"    , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                      "Total direct cost", "Sum of all direct costs");
	fin.total_indirect_cost          .setup("financial.0.total_indirect_cost"  , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                    "Total indirect cost", "Sum of all indirect costs");
	fin.total_installed_cost         .setup("financial.0.total_installed_cost" , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                   "Total installed cost", "Sum of direct and indirect costs");
	fin.tower_cost                   .setup("financial.0.tower_cost"           , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                             "Tower cost", "Tower cost");
	fin.wiring_cost                  .setup("financial.0.wiring_cost"          , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                            "Wiring cost", "Wiring cost");

	flux.aim_method                  .set("fluxsim.0.aim_method"             , SP_DATTYPE::SP_STRING    ,                  "3",           "",     true,    "combo", "Simple aim points=0;Sigma aiming=1;Probability shift=2;Image size priority=3;Keep existing=4;Freeze tracking=5",    false,             "Heliostat aim point method", "Method for determining the aim point for each heliostat");
	flux.class_name                  .set("fluxsim.0.class_name"             , SP_DATTYPE::SP_STRING    , "Performance Simulation",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	flux.cloud_depth                 .set("fluxsim.0.cloud_depth"            , SP_DATTYPE::SP_DOUBLE    ,                "250",          "m",     true,         "",    "",    false,                            "Cloud depth", "Depth of the cloud shape");
	flux.cloud_loc_x                 .set("fluxsim.0.cloud_loc_x"            , SP_DATTYPE::SP_DOUBLE    ,                "200",          "m",     true,         "",    "",    false,                     "Cloud location (X)", "Base location of the cloud(s) relative to the tower position - X dimension");
	flux.cloud_loc_y                 .set("fluxsim.0.cloud_loc_y"            , SP_DATTYPE::SP_DOUBLE    ,                "200",          "m",     true,         "",    "",    false,                     "Cloud location (Y)", "Base location of the cloud(s) relative to the tower position - Y dimension");
	flux.cloud_opacity               .set("fluxsim.0.cloud_opacity"          , SP_DATTYPE::SP_DOUBLE    ,                "0.8",       "none",     true,         "",    "",    false,                          "Cloud opacity", "Fraction of DNI obfuscated by a cloud shadow");
	flux.cloud_sep_depth             .set("fluxsim.0.cloud_sep_depth"        , SP_DATTYPE::SP_DOUBLE    ,                  "1",           "",     true,         "",    "",    false,      "Cloud pattern depth spacing mult.", "Cloud pattern depth spacing");
	flux.cloud_sep_width             .set("fluxsim.0.cloud_sep_width"        , SP_DATTYPE::SP_DOUBLE    ,                  "2",           "",     true,         "",    "",    false,      "Cloud pattern width spacing mult.", "Cloud pattern width spacing");
	flux.cloud_shape                 .set("fluxsim.0.cloud_shape"            , SP_DATTYPE::SP_STRING    ,                  "0",           "",     true,    "combo", "Elliptical=0;Rectangular=1;Front=2",    false,                            "Cloud shape", "Shape used to model the cloud shadow");
	flux.cloud_skew                  .set("fluxsim.0.cloud_skew"             , SP_DATTYPE::SP_DOUBLE    ,                 "35",        "deg",     true,         "",    "",    false,                "Cloud orientation angle", "Angle between North and the depth direction (-180 to +180 with clockwise positive)");
	flux.cloud_width                 .set("fluxsim.0.cloud_width"            , SP_DATTYPE::SP_DOUBLE    ,                "500",          "m",     true,         "",    "",    false,                            "Cloud width", "Width of the cloud shape");
	flux.flux_data                   .set("fluxsim.0.flux_data"              , SP_DATTYPE::SP_STRING    ,                   "",           "",    false,         "",    "",    false,            "Flux profile in string form", "2D matrix of flux data");
	flux.flux_day                    .set("fluxsim.0.flux_day"               , SP_DATTYPE::SP_INT       ,                 "20",           "",     true,         "",    "",    false,                       "Day of the month", "Day of the month for the flux simulation");
	flux.flux_dist                   .set("fluxsim.0.flux_dist"              , SP_DATTYPE::SP_STRING    ,                  "0",           "",     true,    "combo", "Triangular=0;Normal=1;Uniform=2",    false,        "Aim point distribution sampling", "Sampling basis for random positioning. Non-uniform distributions are weighted away from the center.");
	flux.flux_dni                    .set("fluxsim.0.flux_dni"               , SP_DATTYPE::SP_DOUBLE    ,                "950",       "W/m2",     true,         "",    "",    false,              "Direct Normal Irradiation", "Direct Normal Irradiation at the specified simulation point");
	flux.flux_hour                   .set("fluxsim.0.flux_hour"              , SP_DATTYPE::SP_DOUBLE    ,                 "12",         "hr",     true,         "",    "",    false,                        "Hour of the day", "Hour of the day for the flux simulation");
	flux.flux_model                  .set("fluxsim.0.flux_model"             , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Hermite (analytical)=0;SolTrace=1",    false,                  "Flux simulation model", "Desired flux simulation tool. Not all geometries can be simulated using the Hermite approximation.");
	flux.flux_month                  .set("fluxsim.0.flux_month"             , SP_DATTYPE::SP_INT       ,                  "3",           "",     true,         "",    "",    false,                      "Month of the year", "Month of the year for the flux simulation");
	flux.flux_solar_az_in            .set("fluxsim.0.flux_solar_az_in"       , SP_DATTYPE::SP_DOUBLE    ,                "180",           "",     true,         "",    "",    false,              "Solar azimuth angle (0=N)", "Solar azimuth angle to use for the flux simulation");
	flux.flux_solar_el_in            .set("fluxsim.0.flux_solar_el_in"       , SP_DATTYPE::SP_DOUBLE    ,                 "85",           "",     true,         "",    "",    false,                  "Solar elevation angle", "Solar elevation angle to use for the flux simulation");
	flux.flux_time_type              .set("fluxsim.0.flux_time_type"         , SP_DATTYPE::SP_STRING    ,                  "1",       "none",    false,    "combo", "Sun position=0;Hour/Day=1",    false,           "Simulation time spec. method", "Method for specifying the desired flux simulation time.");
	flux.is_autoscale                .set("fluxsim.0.is_autoscale"           , SP_DATTYPE::SP_BOOL      ,               "TRUE",       "none",    false, "checkbox",    "",    false,                              "Autoscale", "Autoscale the Z-axis of the contour plot");
	flux.is_cloud_pattern            .set("fluxsim.0.is_cloud_pattern"       , SP_DATTYPE::SP_BOOL      ,               "TRUE",           "",     true, "checkbox",    "",    false,                   "Enable cloud pattern", "Create a pattern based on the specified cloud");
	flux.is_cloud_symd               .set("fluxsim.0.is_cloud_symd"          , SP_DATTYPE::SP_BOOL      ,               "TRUE",           "",     true, "checkbox",    "",    false,   "Pattern symmetric in depth direction", "Mirror the cloud pattern below the width axis");
	flux.is_cloud_symw               .set("fluxsim.0.is_cloud_symw"          , SP_DATTYPE::SP_BOOL      ,               "TRUE",           "",     true, "checkbox",    "",    false,   "Pattern symmetric in width direction", "Mirror the cloud pattern to the left of the depth axis");
	flux.is_cloudy                   .set("fluxsim.0.is_cloudy"              , SP_DATTYPE::SP_BOOL      ,              "FALSE",           "",     true, "checkbox",    "",    false,               "Simulate cloud transient", "Enable simulation for a cloud transient");
	flux.is_load_raydata             .set("fluxsim.0.is_load_raydata"        , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",     true, "checkbox",    "",     true,       "Load existing heliostat ray data", "Load heliostat field raytrace data from an existing file");
	flux.is_optical_err              .set("fluxsim.0.is_optical_err"         , SP_DATTYPE::SP_BOOL      ,               "TRUE",           "",    false, "checkbox",    "",    false,                 "Include optical errors", "Include the reflector optical error sources in the SolTrace simulation");
	flux.is_save_raydata             .set("fluxsim.0.is_save_raydata"        , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",     true, "checkbox",    "",     true,          "Save heliostat stage ray data", "Save heliostat field raytrace data to a file for future re-use");
	flux.is_sunshape_err             .set("fluxsim.0.is_sunshape_err"        , SP_DATTYPE::SP_BOOL      ,               "TRUE",           "",    false, "checkbox",    "",    false,                      "Include sun shape", "Include the sun shape error in the SolTrace simulation");
	flux.max_rays                    .set("fluxsim.0.max_rays"               , SP_DATTYPE::SP_INT       ,            "1000000",       "none",    false,         "",    "",    false,       "Maximum number of generated rays", "The maximum number of generated rays allowed before terminating the simulation. Overrides the desired rays setting.");
	flux.min_rays                    .set("fluxsim.0.min_rays"               , SP_DATTYPE::SP_INT       ,              "10000",       "none",    false,         "",    "",    false,    "Desired number of ray intersections", "The minimum number of ray hits on the receiver before terminating the simulation.");
	flux.norm_dist_sigma             .set("fluxsim.0.norm_dist_sigma"        , SP_DATTYPE::SP_DOUBLE    ,               "0.25",           "",     true,         "",    "",    false,      "Aiming distribution standard dev.", "Size of the standard distribution relative to half of the height of the receiver.");
	flux.plot_zmax                   .set("fluxsim.0.plot_zmax"              , SP_DATTYPE::SP_DOUBLE    ,               "1000",       "none",    false,         "",    "",    false,                                    "Max", "Z-axis maximum value");
	flux.plot_zmin                   .set("fluxsim.0.plot_zmin"              , SP_DATTYPE::SP_DOUBLE    ,                  "0",       "none",    false,         "",    "",    false,                                    "Min", "Z-axis minimum value");
	flux.raydata_file                .set("fluxsim.0.raydata_file"           , SP_DATTYPE::SP_STRING    ,        "raydata.dat",       "none",     true,     "path",    "",     true,                          "Ray data file", "Location and file of the ray data");
	flux.save_data                   .set("fluxsim.0.save_data"              , SP_DATTYPE::SP_BOOL      ,              "FALSE",           "",    false, "checkbox",    "",    false,                 "Save all raytrace data", "Save the results for each ray");
	flux.save_data_loc               .set("fluxsim.0.save_data_loc"          , SP_DATTYPE::SP_STRING    , "soltrace_ray_data.csv",           "",    false,         "",    "",    false,                               "ray data", "Choose a location to save the ray data");
	flux.seed                        .set("fluxsim.0.seed"                   , SP_DATTYPE::SP_INT       ,                 "-1",       "none",    false,         "",    "",    false, "Seed value (-1 for automatic selection)", "The seed for the random number generator");
	flux.sigma_limit_x               .set("fluxsim.0.sigma_limit_x"          , SP_DATTYPE::SP_DOUBLE    ,                  "2",           "",     true,         "",    "",    false, "Min. image offset from receiver edge - X", "Minimum distance (std. dev.) between optical center of heliostat image and the receiver edge in the receiver-X direction");
	flux.sigma_limit_y               .set("fluxsim.0.sigma_limit_y"          , SP_DATTYPE::SP_DOUBLE    ,                  "2",       "none",     true,         "",    "",    false, "Min. image offset from receiver edge - Y", "Minimum distance (std. dev.) between optical center of heliostat image and the receiver edge in the receiver-Y direction");
	flux.x_res                       .set("fluxsim.0.x_res"                  , SP_DATTYPE::SP_INT       ,                 "25",       "none",    false,         "",    "",    false,      "Flux grid resolution - Horizontal", "Number of flux test points per panel (maximum) in the vertical direction for the flux simulation");
	flux.y_res                       .set("fluxsim.0.y_res"                  , SP_DATTYPE::SP_INT       ,                 "25",       "none",    false,         "",    "",    false,        "Flux grid resolution - Vertical", "Number of flux test points per panel (maximum) in the horizontal direction for the flux simulation");
	flux.flux_solar_az               .setup("fluxsim.0.flux_solar_az"          , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false,         "Calculated solar azimuth angle", "Solar azimuth angle to use for the flux simulation");
	flux.flux_solar_el               .setup("fluxsim.0.flux_solar_el"          , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false,       "Calculated solar elevation angle", "Solar elevation angle to use for the flux simulation");

	land.class_name                  .set("land.0.class_name"                , SP_DATTYPE::SP_STRING    ,               "Land",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	land.exclusions                  .set("land.0.exclusions"                , SP_DATTYPE::SP_DVEC_POINT,                   "",           "",    false,         "",    "",    false,                             "exclusions", "Vector of arrays that specify the regions of land to exclude in the heliostat layout");
	land.import_tower_lat            .set("land.0.import_tower_lat"          , SP_DATTYPE::SP_DOUBLE    ,                  "0",        "deg",    false,         "",    "",    false,  "Imported land boundary tower latitude", "Imported land boundary tower latitude");
	land.import_tower_lon            .set("land.0.import_tower_lon"          , SP_DATTYPE::SP_DOUBLE    ,                  "0",        "deg",    false,         "",    "",    false, "Imported land boundary tower longitude", "Imported land boundary tower longitude");
	land.import_tower_set            .set("land.0.import_tower_set"          , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false,         "",    "",    false,      "Imported land boundary tower flag", "Has the tower location been set for imported land geometries?");
	land.inclusions                  .set("land.0.inclusions"                , SP_DATTYPE::SP_DVEC_POINT,                   "",           "",    false,         "",    "",    false,                             "inclusions", "Vector of arrays that specify the regions of land to include in the heliostat layout");
	land.is_bounds_array             .set("land.0.is_bounds_array"           , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,                "Use land boundary array", "Land boundary is specified by points array");
	land.is_bounds_fixed             .set("land.0.is_bounds_fixed"           , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,                  "Use fixed land bounds", "Land boundary has fixed limits (not more than | not less than)");
	land.is_bounds_scaled            .set("land.0.is_bounds_scaled"          , SP_DATTYPE::SP_BOOL      ,               "TRUE",       "none",    false, "checkbox",    "",    false,         "Bounds scale with tower height", "Land boundary scales with tower hight value");
	land.is_exclusions_relative      .set("land.0.is_exclusions_relative"    , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",     true, "checkbox",    "",    false,  "Exclusions relative to tower position", "Shift the exclusion regions along with the tower offset values");
	land.land_const                  .set("land.0.land_const"                , SP_DATTYPE::SP_DOUBLE    ,                 "45",       "acre",     true,         "",    "",    false,              "Non-solar field land area", "Fixed land area that is added to the area occupied by heliostats");
	land.land_mult                   .set("land.0.land_mult"                 , SP_DATTYPE::SP_DOUBLE    ,                "1.3",       "none",     true,         "",    "",    false,       "Solar field land area multiplier", "Factor multiplying the land area occupied by heliostats");
	land.max_fixed_rad               .set("land.0.max_fixed_rad"             , SP_DATTYPE::SP_DOUBLE    ,               "2000",          "m",     true,         "",    "",    false,            "Maximum land radius (fixed)", "Outer land boundary for circular land plot");
	land.max_scaled_rad              .set("land.0.max_scaled_rad"            , SP_DATTYPE::SP_DOUBLE    ,                "9.5",       "none",     true,         "",    "",    false,                   "Maximum field radius", "Maximum radius (in units of tower height) for positioning of the heliostats");
	land.min_fixed_rad               .set("land.0.min_fixed_rad"             , SP_DATTYPE::SP_DOUBLE    ,                "100",          "m",     true,         "",    "",    false,            "Minimum land radius (fixed)", "Inner land boundary for circular land plot");
	land.min_scaled_rad              .set("land.0.min_scaled_rad"            , SP_DATTYPE::SP_DOUBLE    ,               "0.75",       "none",     true,         "",    "",    false,                   "Minimum field radius", "Minimum radius (in units of tower height) for positioning of the heliostats");
	land.tower_offset_x              .set("land.0.tower_offset_x"            , SP_DATTYPE::SP_DOUBLE    ,                  "0",          "m",     true,         "",    "",    false,              "Tower location offset - X", "Displacement of the tower in X relative to the X-positions specified in the land table");
	land.tower_offset_y              .set("land.0.tower_offset_y"            , SP_DATTYPE::SP_DOUBLE    ,                  "0",          "m",     true,         "",    "",    false,              "Tower location offset - Y", "Displacement of the tower in Y relative to the Y-positions specified in the land table");
	land.bound_area                  .setup("land.0.bound_area"                , SP_DATTYPE::SP_DOUBLE    ,                             "acre",    false,         "",    "",    false,                  "Solar field land area", "Land area occupied by heliostats. This value is the area of a convex hull surrounding the heliostat positions.");
	land.land_area                   .setup("land.0.land_area"                 , SP_DATTYPE::SP_DOUBLE    ,                             "acre",    false,         "",    "",    false,                        "Total land area", "Land area, including solar field and multiplying factor");
	land.radmax_m                    .setup("land.0.radmax_m"                  , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,             "Maximum heliostat distance", "Calculated maximum distance between tower and last row of heliostats");
	land.radmin_m                    .setup("land.0.radmin_m"                  , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,             "Minimum heliostat distance", "Calculated minimum distance between tower and first row of heliostats");

	opt.algorithm                    .set("optimize.0.algorithm"             , SP_DATTYPE::SP_STRING    ,                  "1",           "",     true,    "combo", "BOBYQA=0;COBYLA=1;NEWOUA=2;Nelder-Mead=3;Subplex=4;RSGS=5",     true,                 "Optimization algorithm", "Optimization algorithm");
	opt.class_name                   .set("optimize.0.class_name"            , SP_DATTYPE::SP_STRING    ,       "Optimization",           "",    false,         "",    "",    false,                                       "", "");
	opt.converge_tol                 .set("optimize.0.converge_tol"          , SP_DATTYPE::SP_DOUBLE    ,             "0.0001",       "none",     true,         "",    "",    false,                  "Convergence tolerance", "Relative change in the objective function below which convergence is achieved");
	opt.flux_penalty                 .set("optimize.0.flux_penalty"          , SP_DATTYPE::SP_DOUBLE    ,               "0.35",       "none",     true,         "",    "",     true,                   "Flux overage penalty", "Relative weight in the objective function given to flux intensity over the allowable limit");
	opt.max_desc_iter                .set("optimize.0.max_desc_iter"         , SP_DATTYPE::SP_INT       ,                 "20",       "none",    false,         "",    "",     true,      "Max. no. continuous descent steps", "Maximum number of steps along the direction of steepest descent before recalculating the response surface");
	opt.max_gs_iter                  .set("optimize.0.max_gs_iter"           , SP_DATTYPE::SP_INT       ,                  "5",       "none",    false,         "",    "",     true,             "Max. refinement iterations", "Maximum number of golden section iterations to refine the position of a local minimum");
	opt.max_iter                     .set("optimize.0.max_iter"              , SP_DATTYPE::SP_INT       ,                "200",       "none",     true,         "",    "",    false,                     "Maximum iterations", "Maximum number of times the optimization can iterate");
	opt.max_step                     .set("optimize.0.max_step"              , SP_DATTYPE::SP_DOUBLE    ,               "0.06",       "none",     true,         "",    "",    false,                      "Initial step size", "Maximum total relative step size during optimization");
	opt.power_penalty                .set("optimize.0.power_penalty"         , SP_DATTYPE::SP_DOUBLE    ,                  "2",       "none",     true,         "",    "",    false,                 "Power shortage penalty", "Relative weight in the objective function given to power to the receiver below the required minimum");
	opt.aspect_display               .setup("optimize.0.aspect_display"        , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,    "Current receiver aspect ratio (H/W)", "Current receiver aspect ratio (H/W)");
	opt.gs_refine_ratio              .setup("optimize.0.gs_refine_ratio"       , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",     true,       "Refinement relative bounding box", "The relative step size of the refined area during refinement simulations. More iterations will allow greater refinement");

	par.class_name                   .set("parametric.0.class_name"          , SP_DATTYPE::SP_STRING    , "Parametric Simulation",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	par.eff_file_name                .set("parametric.0.eff_file_name"       , SP_DATTYPE::SP_STRING    ,      "eff_array.csv",           "",    false,         "",    "",    false,                   "Efficiency file name", "Name of the output file containing the efficiency matrix");
	par.flux_file_name               .set("parametric.0.flux_file_name"      , SP_DATTYPE::SP_STRING    ,        "fluxmap.csv",           "",    false,         "",    "",    false,                      "Fluxmap file name", "Name of the output file containing the fluxmap data");
	par.fluxmap_format               .set("parametric.0.fluxmap_format"      , SP_DATTYPE::SP_STRING    ,                  "0",           "",    false,    "combo", "SAM format=0;12x10 array=1;Specified dimensions=2",    false,                "Fluxmap data dimensions", "Dimensions of the fluxmap data (rows,cols)");
	par.is_fluxmap_norm              .set("parametric.0.is_fluxmap_norm"     , SP_DATTYPE::SP_BOOL      ,               "TRUE",           "",    false, "checkbox",    "",    false,                    "Normalize flux data", "Flux data is reported as normalized");
	par.par_save_field_img           .set("parametric.0.par_save_field_img"  , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,            "Save field efficiency image", "Save field efficiency image");
	par.par_save_flux_dat            .set("parametric.0.par_save_flux_dat"   , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,                "Save receiver flux data", "Save receiver flux data");
	par.par_save_flux_img            .set("parametric.0.par_save_flux_img"   , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,               "Save receiver flux image", "Save receiver flux image");
	par.par_save_helio               .set("parametric.0.par_save_helio"      , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,        "Save heliostat performance data", "Save detailed heliostat performance data for each run");
	par.par_save_summary             .set("parametric.0.par_save_summary"    , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,   "Save performance summary information", "Save detailed system performance data to a file for each run");
	par.sam_grid_format              .set("parametric.0.sam_grid_format"     , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "Auto spacing=0;Even grid=1",    false,                   "SAM data grid format", "SAM data grid format");
	par.sam_out_dir                  .set("parametric.0.sam_out_dir"         , SP_DATTYPE::SP_STRING    ,                   "",           "",    false,         "",    "",    false,                       "Output directory", "Output directory");
	par.upar_save_field_img          .set("parametric.0.upar_save_field_img" , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,     "Save field efficiency image (User)", "Save field efficiency image");
	par.upar_save_flux_dat           .set("parametric.0.upar_save_flux_dat"  , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,         "Save receiver flux data (User)", "Save receiver flux data");
	par.upar_save_flux_img           .set("parametric.0.upar_save_flux_img"  , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,        "Save receiver flux image (User)", "Save receiver flux image");
	par.upar_save_helio              .set("parametric.0.upar_save_helio"     , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false, "Save heliostat performance data (User)", "Save detailed heliostat performance data for each run");
	par.upar_save_summary            .set("parametric.0.upar_save_summary"   , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,   "Save performance summary info (User)", "Save detailed system performance data to a file for each run");
	par.user_par_values              .set("parametric.0.user_par_values"     , SP_DATTYPE::SP_STRING    ,                   "",       "none",    false,         "",    "",    false,                 "User parametric values", "User parametric values");

	sf.accept_max                    .set("solarfield.0.accept_max"          , SP_DATTYPE::SP_DOUBLE    ,                "180",        "deg",     true,         "",    "",    false,       "Maximum solar field extent angle", "Upper bound of the angular range containing the heliostat field");
	sf.accept_min                    .set("solarfield.0.accept_min"          , SP_DATTYPE::SP_DOUBLE    ,               "-180",        "deg",     true,         "",    "",    false,       "Minimum solar field extent angle", "Lower bound of the angular range containing the heliostat field");
	sf.az_spacing                    .set("solarfield.0.az_spacing"          , SP_DATTYPE::SP_DOUBLE    ,                  "2",       "none",     true,         "",    "",    false,               "Azimuthal spacing factor", "Azimuthal spacing factor for the first row of heliostats after a reset. Heliostats separated by heliostat width times this factor.");
	sf.class_name                    .set("solarfield.0.class_name"          , SP_DATTYPE::SP_STRING    ,        "Solar Field",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	sf.des_sim_detail                .set("solarfield.0.des_sim_detail"      , SP_DATTYPE::SP_STRING    ,                  "5",       "none",     true,    "combo", "Subset of days/hours=2;Single simulation point=1;Do not filter heliostats=0;Annual simulation=3;Limited annual simulation=4;Representative profiles=5;Efficiency map + annual=6",    false,               "Optimization simulations", "Simulation detail for placing heliostats (see definitions in options spreadsheet)");
	sf.des_sim_ndays                 .set("solarfield.0.des_sim_ndays"       , SP_DATTYPE::SP_INT       ,                  "4",       "none",     true,         "",    "",    false,             "Number of days to simulate", "For limited annual simulation, the number of evenly spaced days to simulate");
	sf.des_sim_nhours                .set("solarfield.0.des_sim_nhours"      , SP_DATTYPE::SP_INT       ,                  "2",       "none",     true,         "",    "",    false,              "Simulation hour frequency", "Simulation will run with the specified hourly frequency (1=every hour, 2=every other hour...)");
	sf.dni_des                       .set("solarfield.0.dni_des"             , SP_DATTYPE::SP_DOUBLE    ,                "950",       "W/m2",     true,         "",    "",    false,                 "Design-point DNI value", "DNI value at which the design-point receiver thermal power is achieved");
	sf.hsort_method                  .set("solarfield.0.hsort_method"        , SP_DATTYPE::SP_STRING    ,                  "7",       "none",     true,    "combo", "Power to receiver=0;Total efficiency=1;Cosine efficiency=2;Attenuation efficiency=3;Intercept efficiency=4;Blocking efficiency=5;Shadowing efficiency=6;TOU-weighted power=7",    false,           "Heliostat selection criteria", "Select the criteria by which heliostats will be included in the solar field layout.");
	sf.interaction_limit             .set("solarfield.0.interaction_limit"   , SP_DATTYPE::SP_DOUBLE    ,                "100",   "helio-ht",     true,         "",    "",    false,    "Heliostat shading interaction limit", "Multiply the heliostat height to determine the radius of possible interaction with other heliostats");
	sf.is_opt_zoning                 .set("solarfield.0.is_opt_zoning"       , SP_DATTYPE::SP_BOOL      ,               "TRUE",       "none",    false, "checkbox",    "",    false,      "Enable optical layout zone method", "Enables grouping of heliostats into zones for intercept factor calculation during layout only");
	sf.is_prox_filter                .set("solarfield.0.is_prox_filter"      , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",     true, "checkbox",    "",    false,                 "Apply proximity filter", "Post-process the layout to select heliostats that are closer to the tower.");
	sf.is_sliprow_skipped            .set("solarfield.0.is_sliprow_skipped"  , SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",     true, "checkbox",    "",    false,         "Offset slip plane for blocking", "Radial gap before first row after slip plane is sufficient to eliminate blocking");
	sf.is_tht_opt                    .set("solarfield.0.is_tht_opt"          , SP_DATTYPE::SP_BOOL      ,               "TRUE",       "none",    false, "checkbox",    "",    false,                  "Optimize tower height", "Vary the tower height during optimization to identify optimal level?");
	sf.layout_data                   .set("solarfield.0.layout_data"         , SP_DATTYPE::SP_STRING    ,                   "",           "",    false,         "",    "",    false,             "Layout data in string form", "Layout data in string form");
	sf.layout_method                 .set("solarfield.0.layout_method"       , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "Radial Stagger=1;Cornfield=2;User-defined=3",    false,                          "Layout method", "Field layout method");
	sf.max_zone_size_az              .set("solarfield.0.max_zone_size_az"    , SP_DATTYPE::SP_DOUBLE    ,                  "1",   "tower-ht",     true,         "",    "",    false, "Max. optical layout zone size - azimuthal", "Maximum zone size (azimuthal direction) for grouping optical intercept factor calculations");
	sf.max_zone_size_rad             .set("solarfield.0.max_zone_size_rad"   , SP_DATTYPE::SP_DOUBLE    ,                  "1",   "tower-ht",     true,         "",    "",    false, "Max. optical layout zone size - radial", "Maximum zone size (radial direction) for grouping optical intercept factor calculations");
	sf.min_zone_size_az              .set("solarfield.0.min_zone_size_az"    , SP_DATTYPE::SP_DOUBLE    ,                "0.1",   "tower-ht",     true,         "",    "",    false, "Min. optical layout zone size - azimuthal", "Minimum zone size (azimuthal direction) for grouping optical intercept factor calculations");
	sf.min_zone_size_rad             .set("solarfield.0.min_zone_size_rad"   , SP_DATTYPE::SP_DOUBLE    ,                "0.1",   "tower-ht",     true,         "",    "",    false, "Min. optical layout zone size - radial", "Minimum zone size (radial direction) for grouping optical intercept factor calculations");
	sf.prox_filter_frac              .set("solarfield.0.prox_filter_frac"    , SP_DATTYPE::SP_DOUBLE    ,               "0.03",       "none",     true,         "",    "",    false,              "Proximity filter fraction", "Fraction of heliostats to subject to proximity filter.");
	sf.q_des                         .set("solarfield.0.q_des"               , SP_DATTYPE::SP_DOUBLE    ,                "670",        "MWt",     true,         "",    "",    false,               "Solar field design power", "Design thermal power delivered from the solar field");
	sf.rad_spacing_method            .set("solarfield.0.rad_spacing_method"  , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "No blocking-dense=3;Eliminate blocking=2;DELSOL Empirical Fit=1",    false,                  "Radial spacing method", "Method for determining radial spacing during field layout for radial-stagger");
	sf.row_spacing_x                 .set("solarfield.0.row_spacing_x"       , SP_DATTYPE::SP_DOUBLE    ,                "1.1",       "none",     true,         "",    "",    false, "Heliostat spacing factor - X direction", "Separation between adjacent heliostats in the X-direction, multiplies heliostat radius");
	sf.row_spacing_y                 .set("solarfield.0.row_spacing_y"       , SP_DATTYPE::SP_DOUBLE    ,                "1.1",       "none",     true,         "",    "",    false, "Heliostat spacing factor - Y direction", "Separation between adjacent heliostats in the Y-direction, multiplies heliostat radius");
	sf.shadow_height                 .set("solarfield.0.shadow_height"       , SP_DATTYPE::SP_DOUBLE    ,                "195",          "m",    false,         "",    "",    false,                    "Tower shadow height", "Effective tower height for shadowing calculations");
	sf.shadow_width                  .set("solarfield.0.shadow_width"        , SP_DATTYPE::SP_DOUBLE    ,                 "16",          "m",    false,         "",    "",    false,                     "Tower shadow width", "Effective tower diameter for shadowing calculations");
	sf.slip_plane_blocking           .set("solarfield.0.slip_plane_blocking" , SP_DATTYPE::SP_DOUBLE    ,                "0.5",       "none",     true,         "",    "",    false,       "Allowable blocking in slip plane", "Allowable blocking in slip plane");
	sf.spacing_reset                 .set("solarfield.0.spacing_reset"       , SP_DATTYPE::SP_DOUBLE    ,               "1.33",       "none",     true,         "",    "",    false,          "Azimuthal spacing reset limit", "For heliostat layout - ratio of maximum to initial azimuthal spacing before starting new compressed row");
	sf.sun_az_des_user               .set("solarfield.0.sun_az_des_user"     , SP_DATTYPE::SP_DOUBLE    ,                "180",        "deg",     true,         "",    "",    false,   "Specified design-point solar azimuth", "Solar azimuth angle at the design point");
	sf.sun_el_des_user               .set("solarfield.0.sun_el_des_user"     , SP_DATTYPE::SP_DOUBLE    ,                 "85",        "deg",     true,         "",    "",    false, "Specified design-point solar elevation", "Solar elevation angle at the design point");
	sf.sun_loc_des                   .set("solarfield.0.sun_loc_des"         , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Summer solstice=0;Equinox=1;Winter solstice=2;Zenith=3;Other..=4",    false,           "Sun location at design point", "Sun location when thermal power rating is achieved");
	sf.temp_which                    .set("solarfield.0.temp_which"          , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo",    "",    false,              "Select heliostat geometry", "Select the heliostat geometry template that will be used in the layout");
	sf.template_rule                 .set("solarfield.0.template_rule"       , SP_DATTYPE::SP_STRING    ,                  "0",           "",     true,    "combo", "Use single template=0;Specified range=1;Even radial distribution=2",    false,        "Heliostat geometry distribution", "Method for distributing heliostat geometry templates in the field");
	sf.tht                           .set("solarfield.0.tht"                 , SP_DATTYPE::SP_DOUBLE    ,                "195",          "m",     true,         "",    "",    false,                   "Tower optical height", "Average height of the tower receiver centerline above the base heliostat pivot point elevation");
	sf.trans_limit_fact              .set("solarfield.0.trans_limit_fact"    , SP_DATTYPE::SP_DOUBLE    ,                  "1",       "none",     true,         "",    "",    false,        "Packing transition limit factor", "Determines the point at which close-packing switches to standard layout. =1 at no-blocking transition limit.");
	sf.xy_field_shape                .set("solarfield.0.xy_field_shape"      , SP_DATTYPE::SP_STRING    ,                  "0",           "",     true,    "combo", "Hexagon=0;Rectangle=1;Undefined=2",    false,           "Heliostat field layout shape", "Enforced shape of the heliostat field");
	sf.xy_rect_aspect                .set("solarfield.0.xy_rect_aspect"      , SP_DATTYPE::SP_DOUBLE    ,                  "1",       "none",     true,         "",    "",    false,              "Layout aspect ratio (Y/X)", "Aspect ratio of the rectangular field layout (height in Y / width in X)");
	sf.zone_div_tol                  .set("solarfield.0.zone_div_tol"        , SP_DATTYPE::SP_DOUBLE    ,              "0.001",       "none",     true,         "",    "",    false,     "Optical layout zone mesh tolerance", "Allowable variation in optical intercept factor within a layout zone");
	sf.rec_area                      .setup("solarfield.0.rec_area"            , SP_DATTYPE::SP_DOUBLE    ,                               "m2",    false,         "",    "",    false,            "Total receiver surface area", "Surface area from all receivers included in the solar field");
	sf.sf_area                       .setup("solarfield.0.sf_area"             , SP_DATTYPE::SP_DOUBLE    ,                               "m2",    false,         "",    "",    false,                 "Total solar field area", "The sum of all heliostat reflector area in the current layout");
	sf.sim_step_data                 .setup("solarfield.0.sim_step_data"       , SP_DATTYPE::SP_WEATHERDATA,                             "none",    false,         "",    "",    false,       "Data used for design simulations", "Data used for design simulations");
	sf.sun_az_des                    .setup("solarfield.0.sun_az_des"          , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false,  "Calculated design-point solar azimuth", "Calculated design-point solar azimuth");
	sf.sun_el_des                    .setup("solarfield.0.sun_el_des"          , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false, "Calculated design-point solar elevation", "Calculated design-point solar elevation");

	amb.addptrs( _varptrs );
	fin.addptrs( _varptrs );
	flux.addptrs( _varptrs );
	land.addptrs( _varptrs );
	opt.addptrs( _varptrs );
	par.addptrs( _varptrs );
	sf.addptrs( _varptrs );

    add_heliostat(0);
    add_receiver(0);
    
}

void var_map::add_heliostat(int id)
{
	std::string sid=my_to_string(id);
	hels.push_back(var_heliostat());

	hels.back().cant_day             .set("heliostat."+sid+".cant_day"       , SP_DATTYPE::SP_INT       ,                 "82",        "day",     true,         "",    "",    false,                "Canting day of the year", "Day of the year used for canting the heliostats (1-365)");
	hels.back().cant_hour            .set("heliostat."+sid+".cant_hour"      , SP_DATTYPE::SP_DOUBLE    ,                  "0",         "hr",     true,         "",    "",    false,               "Canting hour (past noon)", "Hours past noon at which the mirror panels are canted (-12 to 12)");
	hels.back().cant_method          .set("heliostat."+sid+".cant_method"    , SP_DATTYPE::SP_STRING    ,                  "1",       "none",     true,    "combo", "No canting=0;On-axis at slant=-1;On-axis, user-defined=1;Off-axis, day and hour=3;User-defined vector=4",    false,               "Heliostat canting method", "Integer to specify the canting method {0=none, -1=Cant on-axis equal to slant range, 1=user-defined on-axis, 3=user-defined off-axis at hour + day}");
	hels.back().cant_rad_scaled      .set("heliostat."+sid+".cant_rad_scaled", SP_DATTYPE::SP_DOUBLE    ,                  "6",       "none",     true,         "",    "",    false,                  "Canting radius factor", "Canting radius value (absolute value if radius is not scaled, multiplied by tower height if scaled)");
	hels.back().cant_vect_i          .set("heliostat."+sid+".cant_vect_i"    , SP_DATTYPE::SP_DOUBLE    ,                  "0",       "none",     true,         "",    "",    false,             "Canting vector x-component", "Canting vector - x-component");
	hels.back().cant_vect_j          .set("heliostat."+sid+".cant_vect_j"    , SP_DATTYPE::SP_DOUBLE    ,                  "0",       "none",     true,         "",    "",    false,             "Canting vector y-component", "Canting vector y-component");
	hels.back().cant_vect_k          .set("heliostat."+sid+".cant_vect_k"    , SP_DATTYPE::SP_DOUBLE    ,                  "1",       "none",     true,         "",    "",    false,             "Canting vector z-component", "Canting vector z-component");
	hels.back().cant_vect_scale      .set("heliostat."+sid+".cant_vect_scale", SP_DATTYPE::SP_DOUBLE    ,                "400",          "m",     true,         "",    "",    false,               "Canting vector magnitude", "Value to scale the canting unit vector to determine actual canting magnitude");
	hels.back().cbdata               .set("heliostat."+sid+".cbdata"         , SP_DATTYPE::SP_VOIDPTR   ,                  "0",       "none",    false,         "",    "",    false,               "Data pointer for UI page", "Data pointer for UI page");
	hels.back().class_name           .set("heliostat."+sid+".class_name"     , SP_DATTYPE::SP_STRING    ,          "Heliostat",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	hels.back().diameter             .set("heliostat."+sid+".diameter"       , SP_DATTYPE::SP_DOUBLE    ,              "13.77",          "m",     true,         "",    "",    false,                     "Heliostat diameter", "Diameter of the heliostat structure (round heliostats only)");
	hels.back().err_azimuth          .set("heliostat."+sid+".err_azimuth"    , SP_DATTYPE::SP_DOUBLE    ,                  "0",        "rad",     true,         "",    "",    false,                 "Azimuth pointing error", "Standard deviation of the normal error dist. of the azimuth angle");
	hels.back().err_elevation        .set("heliostat."+sid+".err_elevation"  , SP_DATTYPE::SP_DOUBLE    ,                  "0",        "rad",     true,         "",    "",    false,               "Elevation pointing error", "Standard deviation of the normal error dist. of the elevation angle");
	hels.back().err_reflect_x        .set("heliostat."+sid+".err_reflect_x"  , SP_DATTYPE::SP_DOUBLE    ,             "0.0002",        "rad",     true,         "",    "",    false,              "Reflected beam error in X", "error in reflected vector (horiz.) caused by atmospheric refraction, tower sway, etc.");
	hels.back().err_reflect_y        .set("heliostat."+sid+".err_reflect_y"  , SP_DATTYPE::SP_DOUBLE    ,             "0.0002",        "rad",     true,         "",    "",    false,              "Reflected beam error in Y", "error in reflected vector (vert.) caused by atmospheric refraction, tower sway, etc.");
	hels.back().err_surface_x        .set("heliostat."+sid+".err_surface_x"  , SP_DATTYPE::SP_DOUBLE    ,            "0.00153",        "rad",     true,         "",    "",    false,               "Surface slope error in X", "Std.dev. of the normal error dist. of the reflective surface normal in the X (horizontal)");
	hels.back().err_surface_y        .set("heliostat."+sid+".err_surface_y"  , SP_DATTYPE::SP_DOUBLE    ,            "0.00153",        "rad",     true,         "",    "",    false,               "Surface slope error in Y", "Same as above, but in the vertical direction");
	hels.back().focus_method         .set("heliostat."+sid+".focus_method"   , SP_DATTYPE::SP_STRING    ,                  "1",       "none",     true,    "combo", "Flat=0;At slant=1;Group average=2;User-defined=3",    false,                "Heliostat focusing type", "The focusing method {0=Flat, 1=Each at slant, 2=Average of group, 3=User defined}");
	hels.back().height               .set("heliostat."+sid+".height"         , SP_DATTYPE::SP_DOUBLE    ,               "12.2",          "m",     true,         "",    "",    false,                       "Structure height", "Height of the heliostat structure");
	hels.back().helio_name           .set("heliostat."+sid+".helio_name"     , SP_DATTYPE::SP_STRING    ,         "Template 1",           "",    false,         "",    "",    false,                "Heliostat template name", "Heliostat template name");
	hels.back().id                   .set("heliostat."+sid+".id"             , SP_DATTYPE::SP_INT       ,                 "-1",       "none",    false,         "",    "",    false,                                     "id", "Unique ID number for the heliostat template");
	hels.back().is_cant_rad_scaled   .set("heliostat."+sid+".is_cant_rad_scaled", SP_DATTYPE::SP_BOOL      ,               "TRUE",           "",    false, "checkbox",    "",    false,    "Scale cant radius with tower height", "The cant radius scales with tower height");
	hels.back().is_cant_vect_slant   .set("heliostat."+sid+".is_cant_vect_slant", SP_DATTYPE::SP_BOOL      ,              "FALSE",       "none",    false, "checkbox",    "",    false,          "Scale vector with slant range", "Multiply the canting vector by the slant range");
	hels.back().is_enabled           .set("heliostat."+sid+".is_enabled"     , SP_DATTYPE::SP_BOOL      ,               "TRUE",           "",    false,         "",    "",    false,                   "Is template enabled?", "Is template enabled?");
	hels.back().is_faceted           .set("heliostat."+sid+".is_faceted"     , SP_DATTYPE::SP_BOOL      ,               "TRUE",       "none",    false, "checkbox",    "",    false,                    "Use multiple panels", "The number of reflective panels per heliostat is greater than 1");
	hels.back().is_focal_equal       .set("heliostat."+sid+".is_focal_equal" , SP_DATTYPE::SP_BOOL      ,               "TRUE",       "none",    false, "checkbox",    "",    false,                "Use single focal length", "Both the X and Y focal lengths will use a single value as indicated by the X focal length");
	hels.back().is_round             .set("heliostat."+sid+".is_round"       , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "Rectangular=0;Round=1",    false,                        "Heliostat shape", "Is the heliostat round (true) or rectangular (false)");
	hels.back().is_xfocus            .set("heliostat."+sid+".is_xfocus"      , SP_DATTYPE::SP_BOOL      ,               "TRUE",       "none",    false, "checkbox",    "",    false,                             "Focus in X", "Reflector is focused in with respect to the heliostat X axis");
	hels.back().is_yfocus            .set("heliostat."+sid+".is_yfocus"      , SP_DATTYPE::SP_BOOL      ,               "TRUE",       "none",    false, "checkbox",    "",    false,                             "Focus in Y", "Reflector is focused in with respect to the heliostat Y axis");
	hels.back().n_cant_x             .set("heliostat."+sid+".n_cant_x"       , SP_DATTYPE::SP_INT       ,                  "2",           "",     true,         "",    "",    false,                  "No. horizontal panels", "Number of cant panels in the X direction");
	hels.back().n_cant_y             .set("heliostat."+sid+".n_cant_y"       , SP_DATTYPE::SP_INT       ,                  "8",           "",     true,         "",    "",    false,                    "No. vertical panels", "Number of cant panels in the Y direction");
	hels.back().reflect_ratio        .set("heliostat."+sid+".reflect_ratio"  , SP_DATTYPE::SP_DOUBLE    ,               "0.97",       "none",     true,         "",    "",    false,               "Reflective surface ratio", "Ratio of mirror area to total area of the heliostat defined by wm x hm");
	hels.back().reflectivity         .set("heliostat."+sid+".reflectivity"   , SP_DATTYPE::SP_DOUBLE    ,               "0.95",       "none",     true,         "",    "",    false,                    "Mirror reflectivity", "Average reflectivity (clean) of the mirrored surface");
	hels.back().rvel_max_x           .set("heliostat."+sid+".rvel_max_x"     , SP_DATTYPE::SP_DOUBLE    ,               "1000",      "rad/s",    false,         "",    "",    false,                             "rvel_max_x", "maximum rotational velocity about the x axis");
	hels.back().rvel_max_y           .set("heliostat."+sid+".rvel_max_y"     , SP_DATTYPE::SP_DOUBLE    ,               "1000",      "rad/s",    false,         "",    "",    false,                             "rvel_max_y", "maximum rotational velocity about the z axis");
	hels.back().soiling              .set("heliostat."+sid+".soiling"        , SP_DATTYPE::SP_DOUBLE    ,               "0.95",       "none",     true,         "",    "",    false,                         "Soiling factor", "Average soiling factor");
	hels.back().st_err_type          .set("heliostat."+sid+".st_err_type"    , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Gaussian=0;Pillbox=1",    false,     "Optical error type (SolTrace only)", "Error distribution of the reflected rays from the heliostat optical surface");
	hels.back().temp_az_max          .set("heliostat."+sid+".temp_az_max"    , SP_DATTYPE::SP_DOUBLE    ,                "180",        "deg",    false,         "",    "",    false, "Max. angular boundary for heliostat type", "Angular boundary for heliostat geometry - on the clockwise side of the region");
	hels.back().temp_az_min          .set("heliostat."+sid+".temp_az_min"    , SP_DATTYPE::SP_DOUBLE    ,               "-180",        "deg",    false,         "",    "",    false, "Min. angular boundary for heliostat type", "Angular boundary for heliostat geometry - on the counter-clockwise side of the region");
	hels.back().temp_rad_max         .set("heliostat."+sid+".temp_rad_max"   , SP_DATTYPE::SP_DOUBLE    ,                 "10",       "none",    false,         "",    "",    false,      "Maximum radius for heliostat type", "Maximum radius at which this heliostat geometry can be used");
	hels.back().temp_rad_min         .set("heliostat."+sid+".temp_rad_min"   , SP_DATTYPE::SP_DOUBLE    ,               "0.75",       "none",    false,         "",    "",    false,      "Minimum radius for heliostat type", "Minimum radius at which this heliostat geometry can be used");
	hels.back().template_order       .set("heliostat."+sid+".template_order" , SP_DATTYPE::SP_INT       ,                 "-1",       "none",    false,         "",    "",    false,                         "template_order", "template_order");
	hels.back().track_method         .set("heliostat."+sid+".track_method"   , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Continuous=0;Periodic=1",     true,       "Heliostat tracking update method", "Specify how often heliostats update their tracking position ");
	hels.back().track_period         .set("heliostat."+sid+".track_period"   , SP_DATTYPE::SP_DOUBLE    ,                 "10",        "sec",     true,         "",    "",     true,       "Heliostat tracking update period", "The amount of time between tracking updates for each heliostat");
	hels.back().type                 .set("heliostat."+sid+".type"           , SP_DATTYPE::SP_INT       ,                  "0",           "",    false,         "",    "",    false,                                   "type", "Integer used to group heliostats into geometries within a field, (e.g. 5 different focal length designs)");
	hels.back().width                .set("heliostat."+sid+".width"          , SP_DATTYPE::SP_DOUBLE    ,               "12.2",          "m",     true,         "",    "",    false,                        "Structure width", "Width of the heliostat structure");
	hels.back().x_focal_length       .set("heliostat."+sid+".x_focal_length" , SP_DATTYPE::SP_DOUBLE    ,               "1000",          "m",     true,         "",    "",    false,                      "Focal length in X", "Reflector focal length with respect to the heliostat X (horizontal) axis");
	hels.back().x_gap                .set("heliostat."+sid+".x_gap"          , SP_DATTYPE::SP_DOUBLE    ,                  "0",          "m",     true,         "",    "",    false,                  "Cant panel horiz. gap", "Separation between panels in the horizontal direction");
	hels.back().y_focal_length       .set("heliostat."+sid+".y_focal_length" , SP_DATTYPE::SP_DOUBLE    ,               "1000",          "m",     true,         "",    "",    false,                      "Focal length in Y", "Reflector focal length with respect to the heliostat Y (vertical) axis");
	hels.back().y_gap                .set("heliostat."+sid+".y_gap"          , SP_DATTYPE::SP_DOUBLE    ,                  "0",          "m",     true,         "",    "",    false,                   "Cant panel vert. gap", "Separation between panels in the vertical direction");
	hels.back().area                 .setup("heliostat."+sid+".area"           , SP_DATTYPE::SP_DOUBLE    ,                               "m2",    false,         "",    "",    false,         "Total reflective aperture area", "Aperture area including geometry penalties and gaps in the structure");
	hels.back().cant_mag_i           .setup("heliostat."+sid+".cant_mag_i"     , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,               "Total canting vector - i", "Total canting vector - i");
	hels.back().cant_mag_j           .setup("heliostat."+sid+".cant_mag_j"     , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,               "Total canting vector - j", "Total canting vector - j");
	hels.back().cant_mag_k           .setup("heliostat."+sid+".cant_mag_k"     , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,               "Total canting vector - k", "Total canting vector - k");
	hels.back().cant_norm_i          .setup("heliostat."+sid+".cant_norm_i"    , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,          "Normalized canting vector - i", "Normalized canting vector - i");
	hels.back().cant_norm_j          .setup("heliostat."+sid+".cant_norm_j"    , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,          "Normalized canting vector - j", "Normalized canting vector - j");
	hels.back().cant_norm_k          .setup("heliostat."+sid+".cant_norm_k"    , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,          "Normalized canting vector - k", "Normalized canting vector - k");
	hels.back().cant_radius          .setup("heliostat."+sid+".cant_radius"    , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,                         "Canting radius", "Radius for canting focal point assuming on-axis canting");
	hels.back().cant_sun_az          .setup("heliostat."+sid+".cant_sun_az"    , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false,                 "Sun azimuth at canting", "Sun azimuth angle at the moment the cant panels are focused on the receiver");
	hels.back().cant_sun_el          .setup("heliostat."+sid+".cant_sun_el"    , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false,               "Sun elevation at canting", "Sun elevation angle at the moment the cant panels are focused on the receiver");
	hels.back().err_total            .setup("heliostat."+sid+".err_total"      , SP_DATTYPE::SP_DOUBLE    ,                              "rad",    false,         "",    "",    false,            "Total reflected image error", "Total convolved optical error in the reflected beam from the above sources");
	hels.back().r_collision          .setup("heliostat."+sid+".r_collision"    , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,             "Heliostat collision radius", "Distance between heliostat center and maximum radial extent of structure");
	hels.back().ref_total            .setup("heliostat."+sid+".ref_total"      , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,              "Total optical reflectance", "Effective reflectance - product of the mirror reflectance and soiling");

	hels.back().id.val = id;
	hels.back().addptrs( _varptrs );
}

void var_map::add_receiver(int id)
{
	std::string sid=my_to_string(id);
	recs.push_back(var_receiver());

	recs.back().absorptance          .set("receiver."+sid+".absorptance"     , SP_DATTYPE::SP_DOUBLE    ,               "0.94",       "none",     true,         "",    "",    false,           "Receiver thermal absorptance", "Energy absorbed by the receiver surface before accounting for radiation/convection losses");
	recs.back().accept_ang_type      .set("receiver."+sid+".accept_ang_type" , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Rectangular=0;Elliptical=1",    false,       "Receiver acceptance angles shape", "Receiver angular acceptance window defines angles about the aperture normal, can be rectangular or elliptical shape");
	recs.back().accept_ang_x         .set("receiver."+sid+".accept_ang_x"    , SP_DATTYPE::SP_DOUBLE    ,                "180",        "deg",     true,         "",    "",    false,   "Receiver horizontal acceptance angle", "Acceptance angle of the receiver in the horizontal direction (in aperture coordinates)");
	recs.back().accept_ang_y         .set("receiver."+sid+".accept_ang_y"    , SP_DATTYPE::SP_DOUBLE    ,                "180",        "deg",     true,         "",    "",    false,     "Receiver vertical acceptance angle", "Acceptance angle of the receiver in the vertical direction (in aperture coordinates)");
	recs.back().aperture_type        .set("receiver."+sid+".aperture_type"   , SP_DATTYPE::SP_STRING    ,                  "0",           "",     true,    "combo", "Rectangular=0",    false,                "Aperture geometry shape", "The shape of the receiver aperture");
	recs.back().cbdata               .set("receiver."+sid+".cbdata"          , SP_DATTYPE::SP_VOIDPTR   ,                  "0",       "none",    false,         "",    "",    false,               "Data pointer for UI page", "Data pointer for UI page");
	recs.back().class_name           .set("receiver."+sid+".class_name"      , SP_DATTYPE::SP_STRING    ,           "Receiver",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	recs.back().id                   .set("receiver."+sid+".id"              , SP_DATTYPE::SP_INT       ,                 "-1",           "",    false,         "",    "",    false,                            "Template ID", "Template ID");
	recs.back().is_aspect_opt        .set("receiver."+sid+".is_aspect_opt"   , SP_DATTYPE::SP_BOOL      ,               "TRUE",           "",    false, "checkbox",    "",    false,         "Optimize receiver aspect ratio", "Optimize receiver aspect ratio (height / width)");
	recs.back().is_enabled           .set("receiver."+sid+".is_enabled"      , SP_DATTYPE::SP_BOOL      ,               "TRUE",           "",    false,         "",    "",    false,                   "Is template enabled?", "Is template enabled?");
	recs.back().is_open_geom         .set("receiver."+sid+".is_open_geom"    , SP_DATTYPE::SP_BOOL      ,              "FALSE",           "",    false, "checkbox",    "",     true,        "Limit receiver panel span angle", "If true, the receiver is represented by an arc rather than a closed circle/polygon");
	recs.back().is_polygon           .set("receiver."+sid+".is_polygon"      , SP_DATTYPE::SP_BOOL      ,              "FALSE",           "",     true, "checkbox",    "",     true,          "Represent receiver as polygon", "Receiver geometry is represented as discrete polygon of N panels rather than continuous arc");
	recs.back().n_panels             .set("receiver."+sid+".n_panels"        , SP_DATTYPE::SP_INT       ,                 "12",       "none",     true,         "",    "",     true,              "Number of receiver panels", "Number of receiver panels (polygon facets) for a polygonal receiver geometry");
	recs.back().panel_rotation       .set("receiver."+sid+".panel_rotation"  , SP_DATTYPE::SP_DOUBLE    ,                  "0",        "deg",     true,         "",    "",     true,   "Receiver panel azimuthal orientation", "Azimuth angle between the normal vector to the primary 'north' panel and North");
	recs.back().peak_flux            .set("receiver."+sid+".peak_flux"       , SP_DATTYPE::SP_DOUBLE    ,               "1000",      "kW/m2",     true,         "",    "",    false,                    "Allowable peak flux", "Maximum allowable flux intensity on any portion of the receiver surface");
	recs.back().piping_loss_coef     .set("receiver."+sid+".piping_loss_coef", SP_DATTYPE::SP_DOUBLE    ,               "10.2",       "kW/m",     true,         "",    "",    false,       "Receiver piping loss coefficient", "Loss per meter of tower height");
	recs.back().piping_loss_const    .set("receiver."+sid+".piping_loss_const", SP_DATTYPE::SP_DOUBLE    ,                  "0",         "kW",     true,         "",    "",    false,          "Receiver piping loss constant", "Constant thermal loss due to piping - doesn't scale with tower height");
	recs.back().rec_azimuth          .set("receiver."+sid+".rec_azimuth"     , SP_DATTYPE::SP_DOUBLE    ,                  "0",        "deg",     true,         "",    "",    false,           "Receiver orientation azimuth", "Receiver azimuth orientation: 0 deg is north, positive clockwise");
	recs.back().rec_cav_cdepth       .set("receiver."+sid+".rec_cav_cdepth"  , SP_DATTYPE::SP_DOUBLE    ,                  "0",          "m",     true,         "",    "",     true,       "Cavity curvature centroid offset", "Offset of centroid of cavity absorber surface from the aperture plane. (Positive->Increased depth)");
	recs.back().rec_cav_rad          .set("receiver."+sid+".rec_cav_rad"     , SP_DATTYPE::SP_DOUBLE    ,               "7.75",          "m",     true,         "",    "",     true,       "Receiver cavity curvature radius", "Radius of the receiver cavity absorbing surface");
	recs.back().rec_diameter         .set("receiver."+sid+".rec_diameter"    , SP_DATTYPE::SP_DOUBLE    ,              "17.65",          "m",     true,         "",    "",    false,                      "Receiver diameter", "Receiver diameter for cylindrical receivers");
	recs.back().rec_elevation        .set("receiver."+sid+".rec_elevation"   , SP_DATTYPE::SP_DOUBLE    ,                  "0",        "deg",     true,         "",    "",    false,         "Receiver orientation elevation", "Receiver elevation orientation: 0 deg to the horizon, negative rotating downward");
	recs.back().rec_height           .set("receiver."+sid+".rec_height"      , SP_DATTYPE::SP_DOUBLE    ,               "21.6",          "m",     true,         "",    "",    false,                        "Receiver height", "Height of the absorbing component");
	recs.back().rec_name             .set("receiver."+sid+".rec_name"        , SP_DATTYPE::SP_STRING    ,         "Receiver 1",           "",    false,         "",    "",    false,                 "Receiver template name", "Receiver template name");
	recs.back().rec_offset_x         .set("receiver."+sid+".rec_offset_x"    , SP_DATTYPE::SP_DOUBLE    ,                  "0",          "m",     true,         "",    "",    false,   "Receiver positioning offset - X axis", "Offset of receiver center in the East(+)/West(-) direction from the tower");
	recs.back().rec_offset_y         .set("receiver."+sid+".rec_offset_y"    , SP_DATTYPE::SP_DOUBLE    ,                  "0",          "m",     true,         "",    "",    false,   "Receiver positioning offset - Y axis", "Offset of receiver center in the North(+)/South(-) direction from the tower");
	recs.back().rec_offset_z         .set("receiver."+sid+".rec_offset_z"    , SP_DATTYPE::SP_DOUBLE    ,                  "0",          "m",     true,         "",    "",    false,   "Receiver positioning offset - Z axis", "Offset of the receiver center in the vertical direction, positive upwards");
	recs.back().rec_type             .set("receiver."+sid+".rec_type"        , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "External cylindrical=0;Flat plate=2",    false,                          "Receiver type", "Receiver geometrical configuration");
	recs.back().rec_width            .set("receiver."+sid+".rec_width"       , SP_DATTYPE::SP_DOUBLE    ,                 "17",          "m",     true,         "",    "",    false,                         "Receiver width", "Receiver width for cavity or flat receivers");
	recs.back().span_max             .set("receiver."+sid+".span_max"        , SP_DATTYPE::SP_DOUBLE    ,                "180",        "deg",     true,         "",    "",     true,         "Max. receiver panel span angle", "Maximum (CW) bound of the arc defining the receiver surface");
	recs.back().span_min             .set("receiver."+sid+".span_min"        , SP_DATTYPE::SP_DOUBLE    ,               "-180",        "deg",     true,         "",    "",     true,         "Min. receiver panel span angle", "Minimum (CCW) bound of the arc defining the receiver surface");
	recs.back().therm_loss_base      .set("receiver."+sid+".therm_loss_base" , SP_DATTYPE::SP_DOUBLE    ,                 "30",      "kW/m2",     true,         "",    "",    false,     "Design point receiver thermal loss", "Thermal loss from the receiver at design-point conditions");
	recs.back().therm_loss_load      .set("receiver."+sid+".therm_loss_load" , SP_DATTYPE::SP_MATRIX_T  ,            "1,0,0,0",       "none",    false,         "",    "",    false,     "Load-based thermal loss adjustment", "Temperature-dependant thermal loss");
	recs.back().therm_loss_wind      .set("receiver."+sid+".therm_loss_wind" , SP_DATTYPE::SP_MATRIX_T  ,            "1,0,0,0",       "none",    false,         "",    "",    false,     "Wind-based thermal loss adjustment", "Wind speed-dependant thermal loss");
	recs.back().absorber_area        .setup("receiver."+sid+".absorber_area"   , SP_DATTYPE::SP_DOUBLE    ,                               "m2",    false,         "",    "",    false,                 "Receiver absorber area", "Effective area of the receiver absorber panels");
	recs.back().optical_height       .setup("receiver."+sid+".optical_height"  , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,                "Receiver optical height", "Calculated height of the centerline of the receiver above the plane of the heliostats");
	recs.back().piping_loss          .setup("receiver."+sid+".piping_loss"     , SP_DATTYPE::SP_DOUBLE    ,                               "MW",    false,         "",    "",    false,                   "Receiver piping loss", "Thermal loss from non-absorber receiver piping");
	recs.back().rec_aspect           .setup("receiver."+sid+".rec_aspect"      , SP_DATTYPE::SP_DOUBLE    ,                             "none",     true,         "",    "",    false,            "Receiver aspect ratio (H/W)", "Ratio of receiver height to width");
	recs.back().therm_eff            .setup("receiver."+sid+".therm_eff"       , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false, "Receiver calculated thermal efficiency", "Receiver calculated thermal efficiency");
	recs.back().therm_loss           .setup("receiver."+sid+".therm_loss"      , SP_DATTYPE::SP_DOUBLE    ,                               "MW",    false,         "",    "",    false,              "Design-point thermal loss", "Receiver thermal loss at design");

	recs.back().id.val = id;
	recs.back().addptrs( _varptrs );
}

void var_ambient::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	pmap["ambient.0.atm_coefs"] = &atm_coefs;
	pmap["ambient.0.atm_model"] = &atm_model;
	pmap["ambient.0.class_name"] = &class_name;
	pmap["ambient.0.del_h2o"] = &del_h2o;
	pmap["ambient.0.dni_layout"] = &dni_layout;
	pmap["ambient.0.dpres"] = &dpres;
	pmap["ambient.0.elevation"] = &elevation;
	pmap["ambient.0.insol_type"] = &insol_type;
	pmap["ambient.0.latitude"] = &latitude;
	pmap["ambient.0.loc_city"] = &loc_city;
	pmap["ambient.0.loc_state"] = &loc_state;
	pmap["ambient.0.longitude"] = &longitude;
	pmap["ambient.0.sun_csr"] = &sun_csr;
	pmap["ambient.0.sun_pos_map"] = &sun_pos_map;
	pmap["ambient.0.sun_rad_limit"] = &sun_rad_limit;
	pmap["ambient.0.sun_type"] = &sun_type;
	pmap["ambient.0.time_zone"] = &time_zone;
	pmap["ambient.0.user_sun"] = &user_sun;
	pmap["ambient.0.weather_file"] = &weather_file;
	pmap["ambient.0.wf_data"] = &wf_data;
	pmap["ambient.0.atm_atten_est"] = &atm_atten_est;
	pmap["ambient.0.sim_time_step"] = &sim_time_step;
}

void var_financial::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	pmap["financial.0.class_name"] = &class_name;
	pmap["financial.0.contingency_rate"] = &contingency_rate;
	pmap["financial.0.fixed_cost"] = &fixed_cost;
	pmap["financial.0.heliostat_spec_cost"] = &heliostat_spec_cost;
	pmap["financial.0.is_pmt_factors"] = &is_pmt_factors;
	pmap["financial.0.land_spec_cost"] = &land_spec_cost;
	pmap["financial.0.pmt_factors"] = &pmt_factors;
	pmap["financial.0.rec_cost_exp"] = &rec_cost_exp;
	pmap["financial.0.rec_ref_area"] = &rec_ref_area;
	pmap["financial.0.rec_ref_cost"] = &rec_ref_cost;
	pmap["financial.0.sales_tax_frac"] = &sales_tax_frac;
	pmap["financial.0.sales_tax_rate"] = &sales_tax_rate;
	pmap["financial.0.site_spec_cost"] = &site_spec_cost;
	pmap["financial.0.tower_exp"] = &tower_exp;
	pmap["financial.0.tower_fixed_cost"] = &tower_fixed_cost;
	pmap["financial.0.weekday_sched"] = &weekday_sched;
	pmap["financial.0.weekend_sched"] = &weekend_sched;
	pmap["financial.0.wiring_user_spec"] = &wiring_user_spec;
	pmap["financial.0.contingency_cost"] = &contingency_cost;
	pmap["financial.0.heliostat_cost"] = &heliostat_cost;
	pmap["financial.0.land_cost"] = &land_cost;
	pmap["financial.0.pricing_array"] = &pricing_array;
	pmap["financial.0.rec_cost"] = &rec_cost;
	pmap["financial.0.sales_tax_cost"] = &sales_tax_cost;
	pmap["financial.0.schedule_array"] = &schedule_array;
	pmap["financial.0.site_cost"] = &site_cost;
	pmap["financial.0.total_direct_cost"] = &total_direct_cost;
	pmap["financial.0.total_indirect_cost"] = &total_indirect_cost;
	pmap["financial.0.total_installed_cost"] = &total_installed_cost;
	pmap["financial.0.tower_cost"] = &tower_cost;
	pmap["financial.0.wiring_cost"] = &wiring_cost;
}

void var_fluxsim::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	pmap["fluxsim.0.aim_method"] = &aim_method;
	pmap["fluxsim.0.class_name"] = &class_name;
	pmap["fluxsim.0.cloud_depth"] = &cloud_depth;
	pmap["fluxsim.0.cloud_loc_x"] = &cloud_loc_x;
	pmap["fluxsim.0.cloud_loc_y"] = &cloud_loc_y;
	pmap["fluxsim.0.cloud_opacity"] = &cloud_opacity;
	pmap["fluxsim.0.cloud_sep_depth"] = &cloud_sep_depth;
	pmap["fluxsim.0.cloud_sep_width"] = &cloud_sep_width;
	pmap["fluxsim.0.cloud_shape"] = &cloud_shape;
	pmap["fluxsim.0.cloud_skew"] = &cloud_skew;
	pmap["fluxsim.0.cloud_width"] = &cloud_width;
	pmap["fluxsim.0.flux_data"] = &flux_data;
	pmap["fluxsim.0.flux_day"] = &flux_day;
	pmap["fluxsim.0.flux_dist"] = &flux_dist;
	pmap["fluxsim.0.flux_dni"] = &flux_dni;
	pmap["fluxsim.0.flux_hour"] = &flux_hour;
	pmap["fluxsim.0.flux_model"] = &flux_model;
	pmap["fluxsim.0.flux_month"] = &flux_month;
	pmap["fluxsim.0.flux_solar_az_in"] = &flux_solar_az_in;
	pmap["fluxsim.0.flux_solar_el_in"] = &flux_solar_el_in;
	pmap["fluxsim.0.flux_time_type"] = &flux_time_type;
	pmap["fluxsim.0.is_autoscale"] = &is_autoscale;
	pmap["fluxsim.0.is_cloud_pattern"] = &is_cloud_pattern;
	pmap["fluxsim.0.is_cloud_symd"] = &is_cloud_symd;
	pmap["fluxsim.0.is_cloud_symw"] = &is_cloud_symw;
	pmap["fluxsim.0.is_cloudy"] = &is_cloudy;
	pmap["fluxsim.0.is_load_raydata"] = &is_load_raydata;
	pmap["fluxsim.0.is_optical_err"] = &is_optical_err;
	pmap["fluxsim.0.is_save_raydata"] = &is_save_raydata;
	pmap["fluxsim.0.is_sunshape_err"] = &is_sunshape_err;
	pmap["fluxsim.0.max_rays"] = &max_rays;
	pmap["fluxsim.0.min_rays"] = &min_rays;
	pmap["fluxsim.0.norm_dist_sigma"] = &norm_dist_sigma;
	pmap["fluxsim.0.plot_zmax"] = &plot_zmax;
	pmap["fluxsim.0.plot_zmin"] = &plot_zmin;
	pmap["fluxsim.0.raydata_file"] = &raydata_file;
	pmap["fluxsim.0.save_data"] = &save_data;
	pmap["fluxsim.0.save_data_loc"] = &save_data_loc;
	pmap["fluxsim.0.seed"] = &seed;
	pmap["fluxsim.0.sigma_limit_x"] = &sigma_limit_x;
	pmap["fluxsim.0.sigma_limit_y"] = &sigma_limit_y;
	pmap["fluxsim.0.x_res"] = &x_res;
	pmap["fluxsim.0.y_res"] = &y_res;
	pmap["fluxsim.0.flux_solar_az"] = &flux_solar_az;
	pmap["fluxsim.0.flux_solar_el"] = &flux_solar_el;
}

void var_heliostat::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	std::string sid = my_to_string(id.val);
	pmap["heliostat."+sid+".cant_day"] = &cant_day;
	pmap["heliostat."+sid+".cant_hour"] = &cant_hour;
	pmap["heliostat."+sid+".cant_method"] = &cant_method;
	pmap["heliostat."+sid+".cant_rad_scaled"] = &cant_rad_scaled;
	pmap["heliostat."+sid+".cant_vect_i"] = &cant_vect_i;
	pmap["heliostat."+sid+".cant_vect_j"] = &cant_vect_j;
	pmap["heliostat."+sid+".cant_vect_k"] = &cant_vect_k;
	pmap["heliostat."+sid+".cant_vect_scale"] = &cant_vect_scale;
	pmap["heliostat."+sid+".cbdata"] = &cbdata;
	pmap["heliostat."+sid+".class_name"] = &class_name;
	pmap["heliostat."+sid+".diameter"] = &diameter;
	pmap["heliostat."+sid+".err_azimuth"] = &err_azimuth;
	pmap["heliostat."+sid+".err_elevation"] = &err_elevation;
	pmap["heliostat."+sid+".err_reflect_x"] = &err_reflect_x;
	pmap["heliostat."+sid+".err_reflect_y"] = &err_reflect_y;
	pmap["heliostat."+sid+".err_surface_x"] = &err_surface_x;
	pmap["heliostat."+sid+".err_surface_y"] = &err_surface_y;
	pmap["heliostat."+sid+".focus_method"] = &focus_method;
	pmap["heliostat."+sid+".height"] = &height;
	pmap["heliostat."+sid+".helio_name"] = &helio_name;
	pmap["heliostat."+sid+".id"] = &id;
	pmap["heliostat."+sid+".is_cant_rad_scaled"] = &is_cant_rad_scaled;
	pmap["heliostat."+sid+".is_cant_vect_slant"] = &is_cant_vect_slant;
	pmap["heliostat."+sid+".is_enabled"] = &is_enabled;
	pmap["heliostat."+sid+".is_faceted"] = &is_faceted;
	pmap["heliostat."+sid+".is_focal_equal"] = &is_focal_equal;
	pmap["heliostat."+sid+".is_round"] = &is_round;
	pmap["heliostat."+sid+".is_xfocus"] = &is_xfocus;
	pmap["heliostat."+sid+".is_yfocus"] = &is_yfocus;
	pmap["heliostat."+sid+".n_cant_x"] = &n_cant_x;
	pmap["heliostat."+sid+".n_cant_y"] = &n_cant_y;
	pmap["heliostat."+sid+".reflect_ratio"] = &reflect_ratio;
	pmap["heliostat."+sid+".reflectivity"] = &reflectivity;
	pmap["heliostat."+sid+".rvel_max_x"] = &rvel_max_x;
	pmap["heliostat."+sid+".rvel_max_y"] = &rvel_max_y;
	pmap["heliostat."+sid+".soiling"] = &soiling;
	pmap["heliostat."+sid+".st_err_type"] = &st_err_type;
	pmap["heliostat."+sid+".temp_az_max"] = &temp_az_max;
	pmap["heliostat."+sid+".temp_az_min"] = &temp_az_min;
	pmap["heliostat."+sid+".temp_rad_max"] = &temp_rad_max;
	pmap["heliostat."+sid+".temp_rad_min"] = &temp_rad_min;
	pmap["heliostat."+sid+".template_order"] = &template_order;
	pmap["heliostat."+sid+".track_method"] = &track_method;
	pmap["heliostat."+sid+".track_period"] = &track_period;
	pmap["heliostat."+sid+".type"] = &type;
	pmap["heliostat."+sid+".width"] = &width;
	pmap["heliostat."+sid+".x_focal_length"] = &x_focal_length;
	pmap["heliostat."+sid+".x_gap"] = &x_gap;
	pmap["heliostat."+sid+".y_focal_length"] = &y_focal_length;
	pmap["heliostat."+sid+".y_gap"] = &y_gap;
	pmap["heliostat."+sid+".area"] = &area;
	pmap["heliostat."+sid+".cant_mag_i"] = &cant_mag_i;
	pmap["heliostat."+sid+".cant_mag_j"] = &cant_mag_j;
	pmap["heliostat."+sid+".cant_mag_k"] = &cant_mag_k;
	pmap["heliostat."+sid+".cant_norm_i"] = &cant_norm_i;
	pmap["heliostat."+sid+".cant_norm_j"] = &cant_norm_j;
	pmap["heliostat."+sid+".cant_norm_k"] = &cant_norm_k;
	pmap["heliostat."+sid+".cant_radius"] = &cant_radius;
	pmap["heliostat."+sid+".cant_sun_az"] = &cant_sun_az;
	pmap["heliostat."+sid+".cant_sun_el"] = &cant_sun_el;
	pmap["heliostat."+sid+".err_total"] = &err_total;
	pmap["heliostat."+sid+".r_collision"] = &r_collision;
	pmap["heliostat."+sid+".ref_total"] = &ref_total;
}

void var_land::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	pmap["land.0.class_name"] = &class_name;
	pmap["land.0.exclusions"] = &exclusions;
	pmap["land.0.import_tower_lat"] = &import_tower_lat;
	pmap["land.0.import_tower_lon"] = &import_tower_lon;
	pmap["land.0.import_tower_set"] = &import_tower_set;
	pmap["land.0.inclusions"] = &inclusions;
	pmap["land.0.is_bounds_array"] = &is_bounds_array;
	pmap["land.0.is_bounds_fixed"] = &is_bounds_fixed;
	pmap["land.0.is_bounds_scaled"] = &is_bounds_scaled;
	pmap["land.0.is_exclusions_relative"] = &is_exclusions_relative;
	pmap["land.0.land_const"] = &land_const;
	pmap["land.0.land_mult"] = &land_mult;
	pmap["land.0.max_fixed_rad"] = &max_fixed_rad;
	pmap["land.0.max_scaled_rad"] = &max_scaled_rad;
	pmap["land.0.min_fixed_rad"] = &min_fixed_rad;
	pmap["land.0.min_scaled_rad"] = &min_scaled_rad;
	pmap["land.0.tower_offset_x"] = &tower_offset_x;
	pmap["land.0.tower_offset_y"] = &tower_offset_y;
	pmap["land.0.bound_area"] = &bound_area;
	pmap["land.0.land_area"] = &land_area;
	pmap["land.0.radmax_m"] = &radmax_m;
	pmap["land.0.radmin_m"] = &radmin_m;
}

void var_optimize::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	pmap["optimize.0.algorithm"] = &algorithm;
	pmap["optimize.0.class_name"] = &class_name;
	pmap["optimize.0.converge_tol"] = &converge_tol;
	pmap["optimize.0.flux_penalty"] = &flux_penalty;
	pmap["optimize.0.max_desc_iter"] = &max_desc_iter;
	pmap["optimize.0.max_gs_iter"] = &max_gs_iter;
	pmap["optimize.0.max_iter"] = &max_iter;
	pmap["optimize.0.max_step"] = &max_step;
	pmap["optimize.0.power_penalty"] = &power_penalty;
	pmap["optimize.0.aspect_display"] = &aspect_display;
	pmap["optimize.0.gs_refine_ratio"] = &gs_refine_ratio;
}

void var_parametric::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	pmap["parametric.0.class_name"] = &class_name;
	pmap["parametric.0.eff_file_name"] = &eff_file_name;
	pmap["parametric.0.flux_file_name"] = &flux_file_name;
	pmap["parametric.0.fluxmap_format"] = &fluxmap_format;
	pmap["parametric.0.is_fluxmap_norm"] = &is_fluxmap_norm;
	pmap["parametric.0.par_save_field_img"] = &par_save_field_img;
	pmap["parametric.0.par_save_flux_dat"] = &par_save_flux_dat;
	pmap["parametric.0.par_save_flux_img"] = &par_save_flux_img;
	pmap["parametric.0.par_save_helio"] = &par_save_helio;
	pmap["parametric.0.par_save_summary"] = &par_save_summary;
	pmap["parametric.0.sam_grid_format"] = &sam_grid_format;
	pmap["parametric.0.sam_out_dir"] = &sam_out_dir;
	pmap["parametric.0.upar_save_field_img"] = &upar_save_field_img;
	pmap["parametric.0.upar_save_flux_dat"] = &upar_save_flux_dat;
	pmap["parametric.0.upar_save_flux_img"] = &upar_save_flux_img;
	pmap["parametric.0.upar_save_helio"] = &upar_save_helio;
	pmap["parametric.0.upar_save_summary"] = &upar_save_summary;
	pmap["parametric.0.user_par_values"] = &user_par_values;
}

void var_receiver::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	std::string sid = my_to_string(id.val);
	pmap["receiver."+sid+".absorptance"] = &absorptance;
	pmap["receiver."+sid+".accept_ang_type"] = &accept_ang_type;
	pmap["receiver."+sid+".accept_ang_x"] = &accept_ang_x;
	pmap["receiver."+sid+".accept_ang_y"] = &accept_ang_y;
	pmap["receiver."+sid+".aperture_type"] = &aperture_type;
	pmap["receiver."+sid+".cbdata"] = &cbdata;
	pmap["receiver."+sid+".class_name"] = &class_name;
	pmap["receiver."+sid+".id"] = &id;
	pmap["receiver."+sid+".is_aspect_opt"] = &is_aspect_opt;
	pmap["receiver."+sid+".is_enabled"] = &is_enabled;
	pmap["receiver."+sid+".is_open_geom"] = &is_open_geom;
	pmap["receiver."+sid+".is_polygon"] = &is_polygon;
	pmap["receiver."+sid+".n_panels"] = &n_panels;
	pmap["receiver."+sid+".panel_rotation"] = &panel_rotation;
	pmap["receiver."+sid+".peak_flux"] = &peak_flux;
	pmap["receiver."+sid+".piping_loss_coef"] = &piping_loss_coef;
	pmap["receiver."+sid+".piping_loss_const"] = &piping_loss_const;
	pmap["receiver."+sid+".rec_azimuth"] = &rec_azimuth;
	pmap["receiver."+sid+".rec_cav_cdepth"] = &rec_cav_cdepth;
	pmap["receiver."+sid+".rec_cav_rad"] = &rec_cav_rad;
	pmap["receiver."+sid+".rec_diameter"] = &rec_diameter;
	pmap["receiver."+sid+".rec_elevation"] = &rec_elevation;
	pmap["receiver."+sid+".rec_height"] = &rec_height;
	pmap["receiver."+sid+".rec_name"] = &rec_name;
	pmap["receiver."+sid+".rec_offset_x"] = &rec_offset_x;
	pmap["receiver."+sid+".rec_offset_y"] = &rec_offset_y;
	pmap["receiver."+sid+".rec_offset_z"] = &rec_offset_z;
	pmap["receiver."+sid+".rec_type"] = &rec_type;
	pmap["receiver."+sid+".rec_width"] = &rec_width;
	pmap["receiver."+sid+".span_max"] = &span_max;
	pmap["receiver."+sid+".span_min"] = &span_min;
	pmap["receiver."+sid+".therm_loss_base"] = &therm_loss_base;
	pmap["receiver."+sid+".therm_loss_load"] = &therm_loss_load;
	pmap["receiver."+sid+".therm_loss_wind"] = &therm_loss_wind;
	pmap["receiver."+sid+".absorber_area"] = &absorber_area;
	pmap["receiver."+sid+".optical_height"] = &optical_height;
	pmap["receiver."+sid+".piping_loss"] = &piping_loss;
	pmap["receiver."+sid+".rec_aspect"] = &rec_aspect;
	pmap["receiver."+sid+".therm_eff"] = &therm_eff;
	pmap["receiver."+sid+".therm_loss"] = &therm_loss;
}

void var_solarfield::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	pmap["solarfield.0.accept_max"] = &accept_max;
	pmap["solarfield.0.accept_min"] = &accept_min;
	pmap["solarfield.0.az_spacing"] = &az_spacing;
	pmap["solarfield.0.class_name"] = &class_name;
	pmap["solarfield.0.des_sim_detail"] = &des_sim_detail;
	pmap["solarfield.0.des_sim_ndays"] = &des_sim_ndays;
	pmap["solarfield.0.des_sim_nhours"] = &des_sim_nhours;
	pmap["solarfield.0.dni_des"] = &dni_des;
	pmap["solarfield.0.hsort_method"] = &hsort_method;
	pmap["solarfield.0.interaction_limit"] = &interaction_limit;
	pmap["solarfield.0.is_opt_zoning"] = &is_opt_zoning;
	pmap["solarfield.0.is_prox_filter"] = &is_prox_filter;
	pmap["solarfield.0.is_sliprow_skipped"] = &is_sliprow_skipped;
	pmap["solarfield.0.is_tht_opt"] = &is_tht_opt;
	pmap["solarfield.0.layout_data"] = &layout_data;
	pmap["solarfield.0.layout_method"] = &layout_method;
	pmap["solarfield.0.max_zone_size_az"] = &max_zone_size_az;
	pmap["solarfield.0.max_zone_size_rad"] = &max_zone_size_rad;
	pmap["solarfield.0.min_zone_size_az"] = &min_zone_size_az;
	pmap["solarfield.0.min_zone_size_rad"] = &min_zone_size_rad;
	pmap["solarfield.0.prox_filter_frac"] = &prox_filter_frac;
	pmap["solarfield.0.q_des"] = &q_des;
	pmap["solarfield.0.rad_spacing_method"] = &rad_spacing_method;
	pmap["solarfield.0.row_spacing_x"] = &row_spacing_x;
	pmap["solarfield.0.row_spacing_y"] = &row_spacing_y;
	pmap["solarfield.0.shadow_height"] = &shadow_height;
	pmap["solarfield.0.shadow_width"] = &shadow_width;
	pmap["solarfield.0.slip_plane_blocking"] = &slip_plane_blocking;
	pmap["solarfield.0.spacing_reset"] = &spacing_reset;
	pmap["solarfield.0.sun_az_des_user"] = &sun_az_des_user;
	pmap["solarfield.0.sun_el_des_user"] = &sun_el_des_user;
	pmap["solarfield.0.sun_loc_des"] = &sun_loc_des;
	pmap["solarfield.0.temp_which"] = &temp_which;
	pmap["solarfield.0.template_rule"] = &template_rule;
	pmap["solarfield.0.tht"] = &tht;
	pmap["solarfield.0.trans_limit_fact"] = &trans_limit_fact;
	pmap["solarfield.0.xy_field_shape"] = &xy_field_shape;
	pmap["solarfield.0.xy_rect_aspect"] = &xy_rect_aspect;
	pmap["solarfield.0.zone_div_tol"] = &zone_div_tol;
	pmap["solarfield.0.rec_area"] = &rec_area;
	pmap["solarfield.0.sf_area"] = &sf_area;
	pmap["solarfield.0.sim_step_data"] = &sim_step_data;
	pmap["solarfield.0.sun_az_des"] = &sun_az_des;
	pmap["solarfield.0.sun_el_des"] = &sun_el_des;
}


void var_map::drop_receiver(int id)
{
    //find the receiver in the list
    int id_ind=-1;
    for( int i=0; i<(int)recs.size(); i++)
    {
        if( recs.at(i).id.val == id )
        {
            id_ind = i;
            break;
        }
    }
    if( id_ind < 0 )
        throw spexception("Attempting to remove a receiver ID that doesn't exist!");

    //remove var ptrs
    std::string pat = "receiver.";

    unordered_map<std::string, spbase*>::iterator it = _varptrs.begin();
    while( it != _varptrs.end() )
    {
        if( it->first.find( pat ) != std::string::npos )
        {
            it = _varptrs.erase( it );
        }
        else
        {
            it++;
        }
    }
    
    //remove the variable structure
    recs.erase( recs.begin() + id_ind );

    //add back all receiver pointers
    for(int i=0; i<(int)recs.size(); i++)
    {
        recs.at(i).addptrs(_varptrs);
    }    
}

void var_map::drop_heliostat(int id)
{
    //find the heliostat in the list
    int id_ind=-1;
    for( int i=0; i<(int)hels.size(); i++)
    {
        if( hels.at(i).id.val == id )
        {
            id_ind = i;
            break;
        }
    }
    if( id_ind < 0 )
        throw spexception("Attempting to remove a heliostat ID that doesn't exist!");

    //remove var ptrs
    std::string pat = "heliostat.";

    unordered_map<std::string, spbase*>::iterator it = _varptrs.begin();
    while( it != _varptrs.end() )
    {
        if( it->first.find( pat ) != std::string::npos )
        {
            it = _varptrs.erase( it );
        }
        else
        {
            it++;
        }
    }
    
    //remove the variable structure
    hels.erase( hels.begin() + id_ind );

    //add back all heliostat pointers
    for(int i=0; i<(int)hels.size(); i++)
    {
        hels.at(i).addptrs(_varptrs);
    }
}
