@c ------------------------------------------------------------------
@chapter Ядро MathGL
@nav{}
@cindex mglGraph

@ifset UDAV
Эта глава посвящена описанию множества команд построения графиков для 1D, 2D и 3D массивов данных. Сюда включены также команды настройки графика, вывода текста и примитивов, рисования осей координат и др. Дополнительную информацию о цвете, шрифтах, стилях линий и формулах можно найти в @ref{General concepts}.
@end ifset

@ifclear UDAV
Основным классом MathGL является класс @strong{mglGraph}, определённый в @code{#include <mgl2/mgl.h>}. Он включает в себя множество функций для построения графиков от 1D, 2D и 3D массивов. Он также содержит функции вывода текста и построения осей координат. Есть возможность построения в произвольной системе координат, которая  задается строковыми формулами. Все графические функции используют класс mglData (см. @ref{Data processing}) для хранения массивов данных. Это позволяет легко контролировать размеры, работу с памятью и производить обработку данных. Дополнительная информация о цветах, шрифтах, вычисления формул может быть найдена в @ref{General concepts} и @ref{Other classes}.
@end ifclear

Некоторые возможности MathGL доступны только в новых версиях библиотеки. Для проверки текущей версии MathGL можно использовать следующую функцию.
@anchor{version}
@deftypefn {Команда MGL} {} version 'ver'
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{bool} CheckVersion (@code{const char *}ver) static
@deftypefnx {Функция С} @code{int} mgl_check_version (@code{const char *}ver)
@end ifclear
Возвращает нулевое значение если версия MathGL подходит для требуемой в @var{ver}, т.е. если номер основной версии совпадает и "подверсия" больше или равна указанной в @var{ver}.
@end deftypefn

@menu
* Constructor::
* Graphics setup::
* Axis settings::
* Subplots and rotation::
* Export picture::
* Background::
* Primitives::
* Text printing::
* Axis and Colorbar::
* Legend::
* 1D plotting::
* 2D plotting::
* 3D plotting::
* Dual plotting::
* Vector fields::
* Other plotting::
* Nonlinear fitting::
* Data manipulation::
@c * IDTF functions::
@end menu

@c ##################################################################
@external{}
@node Constructor, Graphics setup, , MathGL core
@section Создание и удаление графического объекта
@nav{}

@ifclear UDAV
@deftypefn {Конструктор класса @code{mglGraph}} {} mglGraph (@code{int} kind=@code{0}, @code{int} width=@code{600}, @code{int} height=@code{400})
@deftypefnx {Конструктор класса @code{mglGraph}} {} mglGraph (@code{const mglGraph &}gr)
@deftypefnx {Конструктор класса @code{mglGraph}} {} mglGraph (@code{HMGL} gr)
@deftypefnx {Функция С} @code{HMGL} mgl_create_graph (@code{int} width, @code{int} height)
@deftypefnx {Функция С} @code{HMGL} mgl_create_graph_gl ()
Создает (или использует созданный) экземпляр класса, производного от @code{mglGraph} (тип @code{HMGL}) с указанными размерами @var{width} и @var{height}. Параметр @var{kind} может иметь следующие значения: @samp{0} -- использовать рисование по умолчанию, @samp{1} -- использовать рисование в OpenGL.
@end deftypefn

@deftypefn {Destructor on @code{mglGraph}} {} ~mglGraph ()
@deftypefnx {Функция С} @code{HMGL} mgl_delete_graph (@code{HMGL} gr)
Удаляет экземпляр класса mglGraph.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{HMGL} Self ()
Возвращает указатель на используемый объект типа @code{HMGL}.
@end deftypefn
@end ifclear

@ifset UDAV
MGL не требует создания данного типа объектов.
@end ifset

@c ##################################################################
@external{}
@node Graphics setup, Axis settings, Constructor, MathGL core
@section Настройка графика
@nav{}
@cindex Настройка MathGL

Функции и переменные в этой группе влияют на вид всего рисунка. Соответственно они должны располагаться @emph{перед} вызовом функций непосредственно рисующих графики.

@anchor{reset}
@deftypefn {Команда MGL} {} reset
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} DefaultPlotParam ()
@deftypefnx {Функция С} @code{void} mgl_set_def_param (@code{HMGL} gr)
@end ifclear
Устанавливает все настройки по умолчанию и очищает рисунок.
@end deftypefn

@anchor{setup}
@deftypefn {Команда MGL} {} setup @code{val flag}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetFlagAdv (@code{int} val, @code{uint32_t} flag)
@deftypefnx {Функция С} @code{void} mgl_set_flag (@code{HMGL} gr, @code{int} val, @code{uint32_t} flag)
@end ifclear
Устанавливает значение бинарного флага @var{flag} в @var{val}. Список флагов можно найти в @url{https://sourceforge.net/p/mathgl/code/HEAD/tree/mathgl-2x/include/mgl2/define.h#l267, define.h}. Текущий список флагов: 
@verbatim
#define MGL_ENABLE_CUT		0x00000004 	///< Определяет способ рисования точек вне диапазона осей координат
#define MGL_ENABLE_RTEXT 	0x00000008 	///< Использовать вращение текста
#define MGL_AUTO_FACTOR		0x00000010 	///< Разрешить автоматическое масштабирование графика
#define MGL_ENABLE_ALPHA 	0x00000020 	///< Использовать прозрачность
#define MGL_ENABLE_LIGHT 	0x00000040 	///< Использовать освещение
#define MGL_TICKS_ROTATE 	0x00000080 	///< Разрешить вращение меток осей
#define MGL_TICKS_SKIP		0x00000100 	///< Разрешить пропуск меток осей
#define MGL_DISABLE_SCALE	0x00000200 	///< Временный флаг, запрещающий изменение размеров
#define MGL_FINISHED 		0x00000400 	///< Флаг готовности окончательной картинки (т.е. mglCanvas::G)
#define MGL_USE_GMTIME		0x00000800 	///< Использовать gmtime вместо localtime
#define MGL_SHOW_POS		0x00001000 	///< Включить показ координат щелчка мыши
#define MGL_CLF_ON_UPD		0x00002000 	///< Очищать график перед Update()
#define MGL_NOSUBTICKS		0x00004000 	///< Запретить рисование subticks для bounding box
#define MGL_LOCAL_LIGHT		0x00008000 	///< Сохранять источники освещения в каждом inplot
#define MGL_VECT_FRAME		0x00010000 	///< Использовать DrwDat для сохранения всех данных в кадрах
#define MGL_REDUCEACC		0x00020000 	///< Сокращать точность вывода точек (для уменьшения размера выходных файлов)
#define MGL_PREFERVC 		0x00040000 	///< Предпочитать цвета вершин вместо текстур если выходной формат поддерживает
#define MGL_ONESIDED 		0x00080000 	///< Выводить только переднюю сторону поверхностей если выходной формат поддерживает
#define MGL_NO_ORIGIN 		0x00100000 	///< Не рисовать метки в точке пересечения осей
#define MGL_GRAY_MODE 		0x00200000 	///< Преобразовать все цвета в оттенки серого
#define MGL_FULL_CURV 		0x00400000 	///< Запретить пропуск точек на прямолинейных участках
#define MGL_NO_SCALE_REL 	0x00800000 	///< Запретить изменение размера текста в относительных inplots
@end verbatim
@end deftypefn

@ifclear UDAV
@deftypefn {Функция С} @code{void} mgl_bsize (@code{unsigned} bsize)
Задает размер буфера под примитивы как (1<<bsize)^2. Т.е. как 10^12 для bsize=20 или 4*10^9 для bsize=16 (по умолчанию). ВАЖНО: можно устанавливать только один раз вначале, до построения графиков. Возвращает текущее значение.
@end deftypefn
@end ifclear

@menu
* Transparency::
* Lighting::
* Fog::
* Default sizes::
* Cutting::
* Font settings::
* Palette and colors::
* Masks::
* Error handling::
* Stop drawing::
@end menu

@c ==================================================================
@external{}
@node Transparency, Lighting, , Graphics setup
@subsection Прозрачность
@nav{}
@cindex Alpha
@ifclear UDAV
@cindex SetAlphaDef
@cindex SetTranspType
@end ifclear
@cindex AlphaDef
@cindex TranspType

Эти функции и переменные настраивают тип и степень прозрачности поверхностей. Главной является функция @ref{alpha}, которая включает/выключает прозрачность для всего графика. Функция @ref{alphadef} устанавливает величину alpha-канала по умолчанию. Наконец, функция @ref{transptype} задает тип прозрачности. @sref{Transparency and lighting}

@anchor{alpha}
@deftypefn {Команда MGL} {} alpha @code{[val=on]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Alpha (@code{bool} enable)
@deftypefnx {Функция С} @code{void} mgl_set_alpha (@code{HMGL} gr, @code{int} enable)
@end ifclear
Включает/выключает прозрачность и возвращает свое предыдущее состояние. По умолчанию прозрачность выключена. Функция включает прозрачность для @emph{всего} рисунка.
@end deftypefn

@anchor{alphadef}
@deftypefn {Команда MGL} {} alphadef @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetAlphaDef (@code{mreal} val)
@deftypefnx {Функция С} @code{void} mgl_set_alpha_default (@code{HMGL} gr, @code{mreal} alpha)
@end ifclear
Задает значение прозрачности по умолчанию для всех графиков. Значение по умолчанию 0.5.
@end deftypefn

@anchor{transptype}
@deftypefn {Команда MGL} {} transptype @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTranspType (@code{int} type)
@deftypefnx {Функция С} @code{void} mgl_set_transp_type (@code{HMGL} gr, @code{int} type)
@end ifclear
Задает тип прозрачности. Допустимые значения:
@itemize @bullet
@item
Обычная прозрачность (@samp{0}) -- "закрытые" объекты видны меньше чем закрывающие. Этот режим некорректно отображается в OpenGL (mglGraphGL) для нескольких перекрывающихся поверхностей.
@item
"Стеклянная" прозрачность (@samp{1}) -- закрытые и закрывающие объекты единообразно ослабляют интенсивность света (по RGB каналам).
@item
"Ламповая" прозрачность (@samp{2}) -- закрытые и закрывающие объекты являются источниками дополнительного освещения (рекомендую установить @code{SetAlphaDef(0.3)} или меньше в этом случае).
@end itemize
@sref{Types of transparency}
@end deftypefn

@c ==================================================================
@external{}
@node Lighting, Fog, Transparency, Graphics setup
@subsection Освещение
@nav{}
@ifclear UDAV
@cindex SetAmbient
@cindex AddLight
@end ifclear
@cindex Light
@cindex Ambient

Эти функции настраивают освещение графика. Главная функция @ref{light} включает/выключает освещение графиков построенных после ее вызова (в OpenGL работает сразу для всего рисунка). MathGL  поддерживает до 10 независимых источников света. Но в режиме OpenGL можно использовать только первые 8 из них. Положение, цвет, яркость каждого источника света можно задавать по отдельности. По умолчанию включен только первый (с порядковым номером @code{0}) источник света белого цвета, расположенный сверху. @sref{Lighting sample}

@anchor{light}
@deftypefn {Команда MGL} {} light @code{[val=on]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{bool} Light (@code{bool} enable)
@deftypefnx {Функция С} @code{void} mgl_set_light (@code{HMGL} gr, @code{int} enable)
@end ifclear
Включает/выключает освещение графика и возвращает предыдущее состояние. По умолчанию освещение выключено.
@end deftypefn

@deftypefn {Команда MGL} {} light @code{num} @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Light (@code{int} n, @code{bool} enable)
@deftypefnx {Функция С} @code{void} mgl_set_light_n (@code{HMGL} gr, @code{int} n, @code{int} enable)
@end ifclear
Включает/выключает @var{n}-ый источник света.
@end deftypefn

@deftypefn {Команда MGL} {} light @code{num xdir ydir zdir} ['col'='w' @code{br=0.5 ap=0}]
@deftypefnx {Команда MGL} {} light @code{num xdir ydir zdir xpos ypos zpos} ['col'='w' @code{br=0.5}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} AddLight (@code{int} n, @code{mglPoint} d, @code{char} c=@code{'w'}, @code{mreal} bright=@code{0.5}, @code{mreal} ap=@code{0})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} AddLight (@code{int} n, @code{mglPoint} r, @code{mglPoint} d, @code{char} c=@code{'w'}, @code{mreal} bright=@code{0.5}, @code{mreal} ap=@code{0})
@deftypefnx {Функция С} @code{void} mgl_add_light (@code{HMGL} gr, @code{int} n, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz)
@deftypefnx {Функция С} @code{void} mgl_add_light_ext (@code{HMGL} gr, @code{int} n, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{char} c, @code{mreal} bright, @code{mreal} ap)
@deftypefnx {Функция С} @code{void} mgl_add_light_loc (@code{HMGL} gr, @code{int} n, @code{mreal} rx, @code{mreal} ry, @code{mreal} rz, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{char} c, @code{mreal} bright, @code{mreal} ap)
@end ifclear
Добавляет источник света с номером @var{n} в положение @var{p} с цветом @var{c} и яркостью @var{bright}, которая должна быть в диапазоне [0,1]. Если указано положение источника @var{r} и оно не NAN, то источник считается локальным, иначе источник полагается бесконечно удалённым (для более быстрого рисования).
@end deftypefn

@anchor{diffuse}
@deftypefn {Команда MGL} {} diffuse @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetDifLight (@code{mreal} bright)
@deftypefnx {Функция С} @code{void} mgl_set_difbr (@code{HMGL} gr, @code{mreal} bright)
@end ifclear
Задает яркость диффузного освещения (только для локальных источников света).
@end deftypefn

@anchor{ambient}
@deftypefn {Команда MGL} {} ambient @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetAmbient (@code{mreal} bright=@code{0.5})
@deftypefnx {Функция С} @code{void} mgl_set_ambbr (@code{HMGL} gr, @code{mreal} bright)
@end ifclear
Задает яркость рассеянного освещения. Значение должно быть в диапазоне [0,1].
@end deftypefn

@anchor{attachlight}
@deftypefn {Команда MGL} {} attachlight @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} AttachLight (@code{bool} val)
@deftypefnx {Функция С} @code{void} mgl_set_attach_light (@code{HMGL} gr, @code{int} val)
@end ifclear
Задает привязку настроек освещения к @ref{inplot}/@ref{subplot}. Отмечу, что OpenGL и некоторые выходные форматы не поддерживают эту возможность.
@end deftypefn


@c ==================================================================
@external{}
@node Fog, Default sizes, Lighting, Graphics setup
@subsection Туман
@nav{}
@cindex Fog

@anchor{fog}
@deftypefn {Команда MGL} {} fog @code{val [dz=0.25]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Fog (@code{mreal} d, @code{mreal} dz=@code{0.25})
@deftypefnx {Функция С} @code{void} mgl_set_fog (@code{HMGL} gr, @code{mreal} d, @code{mreal} dz)
@end ifclear
Имитирует туман на графике. Туман начинается на относительном расстоянии @var{dz} от точки обзора и его плотность растет экспоненциально вглубь по закону ~ 1-exp(-@emph{d*z}). Здесь @emph{z} -- нормализованная на 1 глубина графика. Если @var{d}=@code{0} то туман отсутствует. @sref{Adding fog}
@end deftypefn

@c ==================================================================
@external{}
@node Default sizes, Cutting, Fog, Graphics setup
@subsection Базовые размеры
@nav{}
@ifclear UDAV
@cindex SetBarWidth
@cindex SetMarkSize
@cindex SetArrowSize
@cindex SetMeshNum
@cindex SetPlotId
@end ifclear
@cindex BarWidth
@cindex MarkSize
@cindex ArrowSize
@cindex MeshNum

Эти функции задают величины большинства параметров графика, включая размеры маркеров, стрелок, толщину линий и т.д. Как и любые другие настройки, они подействуют только на графики созданные после изменения настроек.

@anchor{barwidth}
@deftypefn {Команда MGL} {} barwidth @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetBarWidth ( @code{mreal} val)
@deftypefnx {Функция С} @code{void} mgl_set_bar_width (@code{HMGL} gr, @code{mreal} val)
@end ifclear
Задает относительный размер прямоугольников в @ref{bars}, @ref{barh}, @ref{boxplot}, @ref{candle}. Значение по умолчанию @code{0.7}.
@end deftypefn

@anchor{marksize}
@deftypefn {Команда MGL} {} marksize @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetMarkSize (@code{mreal} val)
@deftypefnx {Функция С} @code{void} mgl_set_mark_size (@code{HMGL} gr, @code{mreal} val)
@end ifclear
Задает размер маркеров для @ref{1D plotting}. Значение по умолчанию @code{1}.
@end deftypefn

@anchor{arrowsize}
@deftypefn {Команда MGL} {} arrowsize @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetArrowSize (@code{mreal} val)
@deftypefnx {Функция С} @code{void} mgl_set_arrow_size (@code{HMGL} gr, @code{mreal} val)
@end ifclear
Задает размер стрелок для @ref{1D plotting}, линий и кривых (см. @ref{Primitives}). Значение по умолчанию @code{1}.
@end deftypefn

@anchor{meshnum}
@anchor{MeshNum}
@deftypefn {Команда MGL} {} meshnum @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetMeshNum (@code{int} val)
@deftypefnx {Функция С} @code{void} mgl_set_meshnum (@code{HMGL} gr, @code{int} num)
@end ifclear
Задает ориентировочное число линий в @ref{mesh}, @ref{fall}, и число стрелок (штрихов) в @ref{vect}, @ref{dew}, и число ячеек в @ref{cloud}, и число маркеров в @ref{plot}, @ref{tens}, @ref{step}, @ref{mark}, @ref{textmark}. По умолчанию (=0) рисуются все линии, стрелки, ячейки и т.д.
@end deftypefn

@anchor{facenum}
@deftypefn {Команда MGL} {} facenum @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetFaceNum (@code{int} val)
@deftypefnx {Функция С} @code{void} mgl_set_facenum (@code{HMGL} gr, @code{int} num)
@end ifclear
Задает ориентировочное число видимых граней. Может быть использована для ускорения рисования за счет более грубого рисунка. По умолчанию (=0) рисуются все грани.
@end deftypefn

@anchor{plotid}
@deftypefn {Команда MGL} {} plotid 'id'
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetPlotId (@code{const char *}id)
@deftypefnx {Функция С} @code{void} mgl_set_plotid (@code{HMGL} gr, @code{const char *}id)
@end ifclear
Задает имя графика для сохранения в файл (например, в окне FLTK).
@end deftypefn

@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{const char *} GetPlotId ()
@deftypefnx {Функция С} @code{const char *} mgl_get_plotid (@code{HMGL} gr)
@deftypefnx {Fortran процедура} @code{} mgl_get_plotid (@code{long} gr, @code{char *}out, @code{int} len)
Возвращает имя графика для сохранения в файл (например, в окне FLTK).
@end deftypefn
@end ifclear

@anchor{pendelta}
@deftypefn {Команда MGL} {} pendelta @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetPenDelta (@code{double} val)
@deftypefnx {Функция С} @code{void} mgl_pen_delta (@code{HMGL} gr, @code{double} val)
@end ifclear
Изменяет размытие около линий и текста (по умолчанию 1). Для @var{val}>1 текст и линии более резкие. Для @var{val}<1 текст и линии более размытые.
@end deftypefn

@c ==================================================================
@external{}
@node Cutting, Font settings, Default sizes, Graphics setup
@subsection Обрезание
@nav{}
@ifclear UDAV
@cindex SetCut
@cindex SetCutBox
@cindex CutOff
@end ifclear
@cindex Cut

Эти функции задают условия когда точка будет исключена (вырезана) из рисования. Замечу, что все точки со значением(-ями) NAN по одной из координат или амплитуде автоматически исключаются из рисования. @sref{Cutting sample}

@anchor{cut}
@deftypefn {Команда MGL} {} cut @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetCut (@code{bool} val)
@deftypefnx {Функция С} @code{void} mgl_set_cut (@code{HMGL} gr, @code{int} val)
@end ifclear
Задает обрезание точек за пределами осей координат. Если @code{true} то такие точки исключаются из рисования (это по умолчанию) иначе они проецируются на ограничивающий прямоугольник.
@end deftypefn

@deftypefn {Команда MGL} {} cut @code{x1 y1 z1 x2 y2 z2}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetCutBox (@code{mglPoint} p1, @code{mglPoint} p1)
@deftypefnx {Функция С} @code{void} mgl_set_cut_box (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2)
@end ifclear
Задает границы параллелепипеда внутри которого точки не рисуются. Если границы одинаковы (переменные равны), то параллелепипеда считается пустым.
@end deftypefn

@deftypefn {Команда MGL} {} cut 'cond'
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} CutOff (@code{const char *}cond)
@deftypefnx {Функция С} @code{void} mgl_set_cutoff (@code{HMGL} gr, @code{const char *}cond)
@end ifclear
Задает условие обрезания по формуле @var{cond}. Это условие исключает точки из рисования если результат вычисления формулы не равен нулю. Установите аргумент @code{""} для выключения условия обрезания.
@end deftypefn

@c ==================================================================
@external{}
@node Font settings, Palette and colors, Cutting, Graphics setup
@subsection Шрифты
@nav{}
@ifclear UDAV
@cindex SetFontSize
@cindex SetFontDef
@cindex SetRotatedText
@cindex SetFontSizePT
@cindex SetFontSizeCM
@cindex SetFontSizeIN
@cindex LoadFont
@cindex CopyFont
@cindex RestoreFont
@end ifclear
@cindex Font
@cindex RotateText

@anchor{font}
@deftypefn {Команда MGL} {} font 'fnt' [@code{val=6}]
Задает стиль и размер шрифта. Вначале используется @samp{:rC} -- прямой шрифт с выравниванием по центру. По умолчанию размер подписей оси координат в 1.4 раза больше. См. также см. @ref{Font styles}.
@end deftypefn

@anchor{rotatetext}
@deftypefn {Команда MGL} {} rotatetext @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetRotatedText (@code{bool} val)
@deftypefnx {Функция С} @code{void} mgl_set_rotated_text (@code{HMGL} gr, @code{int} val)
@end ifclear
Включает/выключает вращение меток и подписей осей координат вдоль оси.
@end deftypefn

@anchor{scaletext}
@deftypefn {Команда MGL} {} scaletext @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetScaleText (@code{bool} val)
@deftypefnx {Функция С} @code{void} mgl_set_scale_text (@code{HMGL} gr, @code{int} val)
@end ifclear
Включает/выключает масштабирование текста в относительных @ref{inplot}-ах (в том числе @ref{columnplot}, @ref{gridplot}, @ref{stickplot}, @ref{shearplot}).
@end deftypefn

@anchor{loadfont}
@deftypefn {Команда MGL} {} loadfont ['name'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} LoadFont (@code{const char *}name, @code{const char *}path=@code{""})
@deftypefnx {Функция С} @code{void} mgl_load_font (@code{HMGL} gr, @code{const char *}name, @code{const char *}path)
@end ifclear
Загружает начертание шрифта из файла @var{path}/@var{name}. Пустая строка загрузит шрифт по умолчанию.
@end deftypefn

@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{void} SetFontDef (@code{const char *}fnt)
@deftypefnx {Функция С} @code{void} mgl_set_font_def (@code{HMGL} gr, @code{const char *} val)
Задает стиль шрифта (см. @ref{Text printing}). По умолчанию используется @samp{rC} -- прямой шрифт с выравниванием по центру.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetFontSize (@code{mreal} val)
@deftypefnx {Функция С} @code{void} mgl_set_font_size (@code{HMGL} gr, @code{mreal} val)
Задает базовый размер шрифта. По умолчанию размер подписей оси координат в 1.4 раза больше.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetFontSizePT (@code{mreal} cm, @code{int} dpi=@code{72})
Задает размер шрифта в пунктах для заданного DPI (по умолчанию 16 pt для dpi=72).
@end deftypefn
@deftypefn {Метод класса @code{mglGraph}} @code{inline void} SetFontSizeCM (@code{mreal} cm, @code{int} dpi=@code{72})
Задает размер шрифта в сантиметрах для заданного DPI (по умолчанию 0.56 см = 16 pt).
@end deftypefn
@deftypefn {Метод класса @code{mglGraph}} @code{inline void} SetFontSizeIN (@code{mreal} cm, @code{int} dpi=@code{72})
Задает размер шрифта в дюймах для заданного DPI (по умолчанию 0.22 in = 16 pt).
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} CopyFont (@code{mglGraph *} from)
@deftypefnx {Функция С} @code{void} mgl_copy_font (@code{HMGL} gr, @code{HMGL} gr_from)
Копирует начертание шрифта из другого объекта @code{mglGraph}.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} RestoreFont ()
@deftypefnx {Функция С} @code{void} mgl_restore_font (@code{HMGL} gr)
Восстанавливает начертание шрифта по умолчанию.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetDefFont (@code{const char *}name, @code{const char *}path=@code{""}) static
@deftypefnx {Функция С} @code{void} mgl_def_font (@code{const char *}name, @code{const char *}path)
Загружает начертание шрифта по умолчанию (для всех вновь создаваемых HMGL/mglGraph объектов) из файла @var{path}/@var{name}.
@end deftypefn

@end ifclear

@c ==================================================================
@external{}
@node Palette and colors, Masks, Font settings, Graphics setup
@subsection Палитра и цвета
@nav{}
@ifclear UDAV
@cindex SetPalette
@end ifclear
@cindex Palette

@anchor{palette}
@deftypefn {Команда MGL} {} palette 'colors'
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetPalette (@code{const char *}colors)
@deftypefnx {Функция С} @code{void} mgl_set_palette (@code{HMGL} gr, @code{const char *}colors)
@end ifclear
Задает палитру как последовательность цветов. Значение по умолчанию @code{"Hbgrcmyhlnqeup"}, что соответствует цветам: темно серый @samp{H}, синий @samp{b}, зелёный @samp{g}, красный @samp{r}, голубой @samp{c}, малиновый @samp{m}, жёлтый @samp{y}, серый @samp{h}, сине-зелёный  @samp{l}, небесно-голубой @samp{n}, оранжевый @samp{q}, желто-зелёный @samp{e}, сине-фиолетовый @samp{u}, фиолетовый @samp{p}. Палитра в основном используется в 1D графиках (см. @ref{1D plotting}) для кривых с неопределённым стилем линии. Внутренний счетчик цвета будет сброшен при любом изменении палитры, включая скрытые (например, функциями @ref{box} или @ref{axis}).
@end deftypefn

@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{void} SetDefScheme (@code{const char *}sch)
@deftypefnx {Функция С} @code{void} mgl_set_def_sch (@code{HMGL} gr, @code{const char *}sch)
Устанавливает @var{sch} в качестве цветовой схемы по умолчанию. Начальное значение @code{"BbcyrR"}.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetColor (@code{char} id, @code{mreal} r, @code{mreal} g, @code{mreal} b) static
@deftypefnx {Функция С} @code{void} mgl_set_color (@code{char} id, @code{mreal} r, @code{mreal} g, @code{mreal} b)
Задает RGB значения для цвета с заданным @var{id}. Изменения действуют глобально для всех последующих использований данного @var{id}.
@end deftypefn
@end ifclear

@anchor{gray}
@deftypefn {Команда MGL} {} gray [@code{val=on}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Gray (@code{bool} enable)
@deftypefnx {Функция С} @code{void} mgl_set_gray (@code{HMGL} gr, @code{int} enable)
@end ifclear
Включает/выключает вывод графика в оттенках серого.
@end deftypefn

@c ==================================================================
@external{}
@node Masks, Error handling, Palette and colors, Graphics setup
@subsection Маски
@nav{}
@cindex SetMask
@cindex SetMaskAngle

@anchor{mask}
@deftypefn {Команда MGL} {} mask 'id' 'hex' [angle]
@deftypefnx {Команда MGL} {} mask 'id' hex [angle]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetMask (@code{char} id, @code{const char *}hex)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetMask (@code{char} id, @code{uint64_t} hex)
@deftypefnx {Функция С} @code{void} mgl_set_mask (@code{HMGL} gr, @code{const char *}hex)
@deftypefnx {Функция С} @code{void} mgl_set_mask_val (@code{HMGL} gr, @code{uint64_t} hex)
@end ifclear
Задает новую матрицу @var{hex} размером 8*8 для маски с заданным @var{id}. Изменения действуют глобально для всех последующих использований данного @var{id}. Значения по умолчанию (см. @ref{Color scheme}): @samp{-} -- 000000FF00000000, @samp{+} -- 080808FF08080808,	@samp{=} -- 0000FF00FF000000,	@samp{;} -- 0000007700000000, @samp{o} -- 0000182424180000,	@samp{O} -- 0000183C3C180000,	@samp{s} -- 00003C24243C0000,	@samp{S} -- 00003C3C3C3C0000, @samp{~} -- 0000060990600000,	@samp{<} -- 0060584658600000,	@samp{>} -- 00061A621A060000,	@samp{j} -- 0000005F00000000, @samp{d} -- 0008142214080000,	@samp{D} -- 00081C3E1C080000,	@samp{*} -- 8142241818244281,	@samp{^} -- 0000001824420000. Параметр @var{angle} позволяет сразу задать и угол поворота маски. ВАЖНО: при экспорте в EPS угол поворота будет приведен к ближайшему кратному 45 градусам.

Задает новую матрицу @var{hex} размером 8*8 для маски с заданным @var{id}. Изменения действуют глобально для всех последующих использований данного @var{id}. Значения по умолчанию (см. @ref{Color scheme}): @samp{-} -- линии (@code{0x000000FF00000000}), @samp{+} -- клетки (@code{080808FF08080808}),	@samp{=} -- двойные линии (@code{0000FF00FF000000}),	@samp{;} -- пунктир (@code{0x0000000F00000000}), @samp{o} -- окружкости (@code{0000182424180000}),	@samp{O} -- круги (@code{0000183C3C180000}),	@samp{s} -- квадраты (@code{00003C24243C0000}),	@samp{S} -- закрашенные квадраты (@code{00003C3C3C3C0000}), @samp{~} -- волны (@code{0000060990600000}),	@samp{<} -- треугольники влево (@code{0060584658600000}),	@samp{>} -- треугольники вправо (@code{00061A621A060000}),	@samp{j} пунктир с точками (@code{0000002700000000}), @samp{d} плюсы (@code{0x0008083E08080000}),	@samp{D} -- стежки (@code{0x0139010010931000}),	@samp{*} -- точки (@code{0x0000001818000000}),	@samp{^} -- кирпичи (@code{0x101010FF010101FF}). Параметр @var{angle} позволяет сразу задать и угол поворота маски. ВАЖНО: при экспорте в EPS угол поворота будет приведен к ближайшему кратному 45 градусам.
@end deftypefn

@deftypefn {Команда MGL} {} mask angle
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetMaskAngle (@code{int} angle)
@deftypefnx {Функция С} @code{void} mgl_set_mask_angle (@code{HMGL} gr, @code{int} angle)
@end ifclear
Задает угол поворота маски в градусах. Отмечу, что символы @samp{\}, @samp{/}, @samp{I} в цветовой схеме задают угол поворота в 45, -45 и 90 градусов соответственно. ВАЖНО: при экспорте в EPS угол поворота будет приведен к ближайшему кратному 45 градусам.
@end deftypefn

@c ==================================================================
@external{}
@node Error handling, Stop drawing , Masks, Graphics setup
@subsection Обработка ошибок
@nav{}
@ifset UDAV
Все сообщения будут выведены автоматически в специальном окне или в консоли.
@end ifset
@ifclear UDAV
@cindex Message
@cindex SetWarn
@cindex GetWarn

Обычно вы должны сбросить признак ошибки с помощью @code{SetWarn(0);} перед построением и проверить @code{GetWarnCode()} или @code{Message()} на наличие ошибок после построения. Только последнее предупреждение сохраняется. Замечу, что все предупреждения/ошибки в MathGL не являются критичными -- в худшем из вариантов соответствующий график просто не будет построен. По умолчанию, все предупреждения выводятся в @code{stderr}. Этот вывод можно выключить вызовом @code{mgl_suppress_warn(true);}.

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetWarn (@code{int} code, @code{const char *}info=@code{""})
@deftypefnx {Функция С} @code{void} mgl_set_warn (@code{HMGL} gr, @code{int} code, @code{const char *}info)
Задает код предупреждения. Обычно вызывается только для очистки предупреждений (@code{SetWarn(0);}) или внутри библиотеки. Текст @var{info} будет добавлен к предупреждениям как есть при @var{code}<0.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{const char *}Message ()
@deftypefnx {Функция С} @code{const char *}mgl_get_mess (@code{HMGL} gr)
@deftypefnx {Fortran процедура} @code{} mgl_get_mess (@code{long} gr, @code{char *}out, @code{int} len)
Возвращает текст предупреждений о причине отсутствия графика. Если возвращаемая строка пустая, то сообщений нет.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{int} GetWarn ()
@deftypefnx {Функция С} @code{int} mgl_get_warn (@code{HMGL} gr)
Возвращает код сообщения о причине отсутствия графика. Возможные значения:
@table @code
@item mglWarnNone=0
Предупреждений нет
@item mglWarnDim
Неправильные или несовместимые размеры данных
@item mglWarnLow
Размеры данных слишком малы
@item mglWarnNeg
Минимальное значение отрицательно
@item mglWarnFile
Файл не найден или указаны неправильные размерности
@item mglWarnMem
Не достаточно памяти
@item mglWarnZero
Значение данных равно нулю
@item mglWarnLeg
Нет записей в легенде
@item mglWarnSlc
Индекс среза вне данных
@item mglWarnCnt
Число линий уровня меньше или равно нулю
@item mglWarnOpen
Не могу открыть файл
@item mglWarnLId
Light: ID вне допустимых значений
@item mglWarnSize
Setsize: размер(ы) равны нулю или отрицательны
@item mglWarnFmt
Формат не поддерживается
@item mglWarnTern
Диапазоны осей несовместимые
@item mglWarnNull
Указатель равен NULL
@item mglWarnSpc
Не хватает места для графика
@item mglScrArg
Неправильные аргументы команды скрипта MGL
@item mglScrCmd
Неправильная команда в скрипте MGL
@item mglScrLong
Слишком длинная строка в скрипте MGL
@item mglScrStr
Одиночная ' в скрипте MGL
@item mglScrTemp
Изменяется временная переменная в MGL скрипте
@end table
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} SuppressWarn (@code{bool} state) static
@deftypefnx {Функция С} @code{void} mgl_suppress_warn (@code{int} state)
Выключает вывод предупреждений в @code{stderr} если @var{state} не ноль.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetGlobalWarn (@code{const char *}info) static
@deftypefnx {Функция С} @code{void} mgl_set_global_warn (@code{const char *}info)
Задает предупреждение @var{info}, не привязанное к конкретному объекту рисования.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{const char *} GlobalWarn () static
@deftypefnx {Функция С} @code{const char *} mgl_get_global_warn ()
Возвращает предупреждения, не привязанные к конкретному объекту рисования.
@end deftypefn


@end ifclear

@c ==================================================================
@external{}
@node Stop drawing, , Error handling, Graphics setup
@subsection Остановка рисования
@nav{}
@ifset UDAV
Вы можете использовать команду @ref{stop} или соответствующую кнопку панели инструментов для остановки рисования и выполнения скрипта.
@end ifset
@ifclear UDAV
@cindex Stop
@cindex NeedStop
@cindex SetEventFunc

@deftypefn {Метод класса @code{mglGraph}} @code{void} Stop (@code{bool} stop=@code{true})
@deftypefnx {Функция С only} @code{void} mgl_ask_stop (@code{HMGL} gr, @code{int} stop)
Просит остановить рисование если @var{stop} не ноль, иначе сбрасывает флаг остановки.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{bool} NeedStop ()
@deftypefnx {Функция С only} @code{void} mgl_need_stop (@code{HMGL} gr)
Возвращает @code{true} если рисование должно быть остановлено. Также запускает обработку всех отложенных событий в GUI. Пользователь должен вызывать эту функцию время от времени внутри долгих вычислений для плавности отклика GUI.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{bool} SetEventFunc (@code{void (*}func@code{)(void *)}, @code{void *}par=@code{NULL})
@deftypefnx {Функция С only} @code{void} mgl_set_event_func (@code{HMGL} gr, @code{void (*}func@code{)(void *)}, @code{void *}par)
Задает функцию, которая будет вызвана для обработки событий в GUI библиотеке.
@end deftypefn

@end ifclear


@c ==================================================================
@external{}
@node Axis settings, Subplots and rotation, Graphics setup, MathGL core
@section Настройки осей координат
@nav{}

Эти функции управляет видом и масштабом осей координат. Перед построением для каждой точки выполняются 3 преобразования: сначала определяется возможность рисования точки (см. @ref{Cutting}), далее применяются формулы перехода к криволинейным координатам и наконец точка отображается. Отмечу, что MathGL выдает предупреждение если масштабы осей координат лежат вне области определения формул преобразования координат.

@menu
* Ranges (bounding box)::
* Curved coordinates::
* Ticks::
@end menu

@c ------------------------------------------------------------------
@external{}
@node Ranges (bounding box), Curved coordinates, , Axis settings
@subsection Масштаб осей координат
@nav{}
@cindex CRange
@cindex XRange
@cindex YRange
@cindex ZRange
@cindex Ranges
@cindex Origin
@ifclear UDAV
@cindex SetRange
@cindex SetRanges
@cindex SetOrigin
@end ifclear

@anchor{xrange}
@anchor{yrange}
@anchor{zrange}
@anchor{crange}
@deftypefn {Команда MGL} {} xrange @code{v1 v2} [@code{add=off}]
@deftypefnx {Команда MGL} {} yrange @code{v1 v2} [@code{add=off}]
@deftypefnx {Команда MGL} {} zrange @code{v1 v2} [@code{add=off}]
@deftypefnx {Команда MGL} {} crange @code{v1 v2} [@code{add=off}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetRange (@code{char} dir, @code{mreal} v1, @code{mreal} v2)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} AddRange (@code{char} dir, @code{mreal} v1, @code{mreal} v2)
@deftypefnx {Функция С} @code{void} mgl_set_range_val (@code{HMGL} gr, @code{char} dir, @code{mreal} v1, @code{mreal} v2)
@deftypefnx {Функция С} @code{void} mgl_add_range_val (@code{HMGL} gr, @code{char} dir, @code{mreal} v1, @code{mreal} v2)
@end ifclear
Задает диапазон изменения @samp{x}-,@samp{y}-,@samp{z}-,@samp{c}-координат. Если одно из значений равно @code{NAN}, то оно игнорируется. Параметр @code{add=on} указывает добавлять новый диапазон к существующему (не заменять его). См. также @ref{ranges}.
@end deftypefn

@deftypefn {Команда MGL} {} xrange dat [@code{add=off}]
@deftypefnx {Команда MGL} {} yrange dat [@code{add=off}]
@deftypefnx {Команда MGL} {} zrange dat [@code{add=off}]
@deftypefnx {Команда MGL} {} crange dat [@code{add=off}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetRange (@code{char} dir, @code{const mglDataA &}dat, @code{bool} add=@code{false})
@deftypefnx {Функция С} @code{void} mgl_set_range_dat (@code{HMGL} gr, @code{char} dir, @code{const HCDT} a, @code{int} add)
@end ifclear
Задает диапазон изменения @samp{x}-,@samp{y}-,@samp{z}-,@samp{c}-координат как минимальное и максимальное значение массива @var{dat}. Параметр @code{add=on} указывает добавлять новый диапазон к существующему (не заменять его).
@end deftypefn

@anchor{ranges}
@deftypefn {Команда MGL} {} ranges @code{x1 x2 y1 y2 [z1=0 z2=0]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetRanges (@code{mglPoint} p1, @code{mglPoint} p2)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetRanges (@code{mreal} x1, @code{mreal} x2, @code{mreal} y1, @code{mreal} y2, @code{mreal} z1=@code{0}, @code{mreal} z2=@code{0})
@deftypefnx {Функция С} @code{void} mgl_set_ranges (@code{HMGL} gr, @code{mreal} x1, @code{mreal} x2, @code{mreal} y1, @code{mreal} y2, @code{mreal} z1, @code{mreal} z2)
@end ifclear
Задает диапазон изменения координат. Если минимальное и максимальное значение координаты равны, то они игнорируются по данному направлению. Также устанавливает размер цветовой шкалы, аналогично команде  @code{crange z1 z2}. Начальные диапазоны равны [-1, 1].
@end deftypefn

@deftypefn {Команда MGL} {} ranges @code{xx yy [zz cc=zz]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetRanges (@code{const mglDataA &}xx, @code{const mglDataA &}yy)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetRanges (@code{const mglDataA &}xx, @code{const mglDataA &}yy, @code{const mglDataA &}zz)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetRanges (@code{const mglDataA &}xx, @code{const mglDataA &}yy, @code{const mglDataA &}zz, @code{const mglDataA &}cc)
@end ifclear
Задает диапазон изменения @samp{x}-,@samp{y}-,@samp{z}-,@samp{c}-координат как минимальное и максимальное значение массивов @var{xx}, @var{yy}, @var{zz}, @var{cc} соответственно.
@end deftypefn

@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{void} SetAutoRanges (@code{mglPoint} p1, @code{mglPoint} p2)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetAutoRanges (@code{double} x1, @code{double} x2, @code{double} y1, @code{double} y2, @code{double} z1=@code{0}, @code{double} z2=@code{0}, @code{double} c1=@code{0}, @code{double} c2=@code{0})
@deftypefnx {Функция С} @code{void} mgl_set_auto_ranges (@code{HMGL} gr, @code{double} x1, @code{double} x2, @code{double} y1, @code{double} y2, @code{double} z1, @code{double} z2, @code{double} z1, @code{double} z2)
Задает диапазон изменения координат для автоматических переменных. Если минимальное и максимальное значение координаты равны, то они игнорируются по данному направлению.
@end deftypefn
@end ifclear

@anchor{origin}
@deftypefn {Команда MGL} {} origin @code{x0 y0 [z0=nan]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetOrigin (@code{mglPoint} p0)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetOrigin (@code{mreal} x0, @code{mreal} y0, @code{mreal} z0=@code{NAN})
@deftypefnx {Функция С} @code{void} mgl_set_origin (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0)
@end ifclear
Задает центр пересечения осей координат. Если одно из значений равно NAN, то MathGL попытается выбрать оптимальное положение осей координат по этому направлению.
@end deftypefn

@anchor{zoomaxis}
@deftypefn {Команда MGL} {} zoomaxis @code{x1 x2}
@deftypefnx {Команда MGL} {} zoomaxis @code{x1 y1 x2 y2}
@deftypefnx {Команда MGL} {} zoomaxis @code{x1 y1 z1 x2 y2 z2}
@deftypefnx {Команда MGL} {} zoomaxis @code{x1 y1 z1 c1 x2 y2 z2 c2}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ZoomAxis (@code{mglPoint} p1, @code{mglPoint} p2)
@deftypefnx {Функция С} @code{void} mgl_zoom_axis (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} c1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} c2)
@end ifclear
Дополнительно расширяет диапазон осей координат, задаваемый функциями @code{SetRange} или @code{SetRanges}, в соответствии с формулами @math{min += (max-min)*p1} и @math{max += (max-min)*p1} (или @math{min *= (max/min)^p1} и @math{max *= (max/min)^p1} для "логарифмических" диапазонов, когда @math{inf>max/min>100} или @math{0<max/min<0.01}). Начальные значения [0, 1]. Внимание! эти настройки не могут быть переписаны никакими другими функциями, включая  @code{DefaultPlotParam()}.
@end deftypefn


@c ------------------------------------------------------------------
@external{}
@node Curved coordinates, Ticks, Ranges (bounding box), Axis settings
@subsection Криволинейные координаты
@nav{}
@cindex Axis
@ifclear UDAV
@cindex SetFunc
@cindex SetCoor
@cindex Ternary
@end ifclear

@deftypefn {Команда MGL} {} axis 'fx' 'fy' 'fz' ['fa'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetFunc (@code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ=@code{""}, @code{const char *}EqA=@code{""})
@deftypefnx {Функция С} @code{void} mgl_set_func (@code{HMGL} gr, @code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ, @code{const char *}EqA)
@end ifclear
Задает формулы перехода к криволинейным координатам. Каждая строка является математическим выражением, зависящим от старых координат @samp{x}, @samp{y}, @samp{z} и @samp{a} или @samp{c} для цветовой шкалы. Например, для цилиндрических координат будет @code{SetFunc("x*cos(y)", "x*sin(y)", "z");}. Для удаления формул соответствующий параметр должен быть пустым или @code{NULL}. Использование формул преобразования слегка замедляет программу. Параметр @var{EqA} задает аналогичную формулу для цветовой шкалы. @xref{Textual formulas}.
@end deftypefn

@deftypefn {Команда MGL} {} axis @code{how}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetCoor (@code{int} how)
@deftypefnx {Функция С} @code{void} mgl_set_coor (@code{HMGL} gr, @code{int} how)
@end ifclear
Устанавливает одну из предопределенных систем криволинейных координат в зависимости от параметра @var{how}:
@table @code
@item mglCartesian=0
декартова система (нет преобразования координат, @{x,y,z@});
@item mglPolar=1
полярные координаты: @{x*cos(y),x*sin(y), z@};
@item mglSpherical=2
сферические координаты: @{x*sin(y)*cos(z), x*sin(y)*sin(z), x*cos(y)@};
@item mglParabolic=3
параболические координаты: @{x*y, (x*x-y*y)/2, z@};
@item mglParaboloidal=4
Paraboloidal coordinates: @{(x*x-y*y)*cos(z)/2, (x*x-y*y)*sin(z)/2, x*y@};
@item mglOblate=5
Oblate coordinates: @{cosh(x)*cos(y)*cos(z), cosh(x)*cos(y)*sin(z), sinh(x)*sin(y)@};
@item mglProlate=6
Prolate coordinates: @{sinh(x)*sin(y)*cos(z), sinh(x)*sin(y)*sin(z), cosh(x)*cos(y)@};
@item mglElliptic=7
эллиптические координаты: @{cosh(x)*cos(y), sinh(x)*sin(y), z@};
@item mglToroidal=8
тороидальные координаты: @{sinh(x)*cos(z)/(cosh(x)-cos(y)), sinh(x)*sin(z)/(cosh(x)-cos(y)), sin(y)/(cosh(x)-cos(y))@};
@item mglBispherical=9
бисферические координаты: @{sin(y)*cos(z)/(cosh(x)-cos(y)), sin(y)*sin(z)/(cosh(x)-cos(y)), sinh(x)/(cosh(x)-cos(y))@};
@item mglBipolar=10
биполярные координаты: @{sinh(x)/(cosh(x)-cos(y)), sin(y)/(cosh(x)-cos(y)), z@};
@item mglLogLog=11
Log-log координаты: @{lg(x), lg(y), lg(z)@};
@item mglLogX=12
Log-x координаты: @{lg(x), y, z@};
@item mglLogY=13
Log-y координаты: @{x, lg(y), z@}.
@end table
@end deftypefn

@anchor{ternary}
@deftypefn {Команда MGL} {} ternary @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Ternary (@code{int} tern)
@deftypefnx {Функция С} @code{void} mgl_set_ternary (@code{HMGL} gr, @code{int} tern)
@end ifclear
Задает рисование треугольных (Ternary, @var{tern}=@code{1}), пирамидальных (Quaternary, @var{tern}=@code{2}) осей координат и проекций осей координат (@var{tern}=@code{4,5,6}).

Ternary -- специальный тип графика для 3 зависимых координат (компонент) @var{a}, @var{b}, @var{c} таких, что @var{a}+@var{b}+@var{c}=1. MathGL использует только 2 независимые координаты @var{a}=x и @var{b}=y поскольку их достаточно для построения всех графиков. При этом третья координата z является независимым параметром для построения линий уровня, поверхностей и т.д.

Соответственно Quaternary координаты -- 4 зависимые координаты @var{a}, @var{b}, @var{c} и @var{d}, такие что @var{a}+@var{b}+@var{c}+@var{d}=1. MathGL использует только 2 независимые координаты @var{a}=x, @var{b}=y и @var{d}=z поскольку их достаточно для построения всех графиков.

Проекции строятся если к переменной @var{tern} добавить число @code{4}. Так что @var{tern}=@code{4} нарисует проекции в декартовых координатах, @var{tern}=@code{5} нарисует проекции в треугольных координатах, @var{tern}=@code{6} нарисует проекции в пирамидальных координатах. Если добавить @code{8} вместо @code{4}, то текст не будет выводиться на проекциях.

Используйте @code{Ternary(0)} для возвращения к привычным координатам. @sref{Ternary axis} @sref{Axis projection}
@end deftypefn

@c ------------------------------------------------------------------
@external{}
@node Ticks, , Curved coordinates, Axis settings
@subsection Метки осей
@nav{}
@cindex AxisStl
@cindex TickLen
@cindex Adjust
@cindex XTick
@cindex YTick
@cindex ZTick
@cindex CTick
@ifclear UDAV
@cindex SetAxisStl
@cindex SetTickLen
@cindex SetTicks
@cindex SetTicksVal
@cindex SetTuneTicks
@cindex SetTickTime
@cindex SetTickTempl
@cindex SetTickRotate
@cindex SetTickSkip
@cindex SetOriginTick
@cindex AddTick
@end ifclear

@anchor{adjust}
@deftypefn {Команда MGL} {} adjust ['dir'='xyzc']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Adjust (@code{const char *}dir=@code{"xyzc"})
@deftypefnx {Функция С} @code{void} mgl_adjust_ticks (@code{HMGL} gr, @code{const char *}dir)
@end ifclear
Автоматически задает шаг меток осей, число подметок и начальное положение меток для осей координат @var{dir} в виде наиболее удобном для человека. Также задает @code{SetTuneTicks(true)}. Обычно не требуется вызывать эту функцию кроме случая возвращения настроек по умолчанию.
@end deftypefn

@anchor{xtick}
@anchor{ytick}
@anchor{ztick}
@anchor{ctick}
@deftypefn {Команда MGL} {} xtick @code{val [sub=0 org=nan 'fact'='']}
@deftypefnx {Команда MGL} {} ytick @code{val [sub=0 org=nan 'fact'='']}
@deftypefnx {Команда MGL} {} ztick @code{val [sub=0 org=nan 'fact'='']}
@deftypefnx {Команда MGL} {} xtick @code{val sub ['fact'='']}
@deftypefnx {Команда MGL} {} ytick @code{val sub ['fact'='']}
@deftypefnx {Команда MGL} {} ztick @code{val sub ['fact'='']}
@deftypefnx {Команда MGL} {} ctick @code{val ['fact'='']}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTicks (@code{char} dir, @code{mreal} d=@code{0}, @code{int} ns=@code{0}, @code{mreal} org=@code{NAN}, @code{const char *}fact=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTicks (@code{char} dir, @code{mreal} d=@code{0}, @code{int} ns=@code{0}, @code{mreal} org=@code{NAN}, @code{const wchar_t *}fact)
@deftypefnx {Функция С} @code{void} mgl_set_ticks (@code{HMGL} gr, @code{char} dir, @code{mreal} d, @code{int} ns, @code{mreal} org)
@deftypefnx {Функция С} @code{void} mgl_set_ticks_fact (@code{HMGL} gr, @code{char} dir, @code{mreal} d, @code{int} ns, @code{mreal} org, @code{const char *}fact)
@deftypefnx {Функция С} @code{void} mgl_set_ticks_factw (@code{HMGL} gr, @code{char} dir, @code{mreal} d, @code{int} ns, @code{mreal} org, @code{const wchar_t *} fact)
@end ifclear
Задает шаг меток осей @var{d}, число подметок @var{ns} и начальное положение меток @var{org} для оси вдоль направления @var{dir} (используйте 'c' для меток colorbar). Переменная @var{d} задает шаг меток (если положительна) или их число на оси (если отрицательна). Нулевое значение задает автоматическую расстановку меток. Если @var{org}=@code{NAN}, то используется значение из переменной @var{Org}. Параметр @var{fact} задает текст, которые будет напечатан после метки оси (например, "\pi" для @var{d}=M_PI).
@end deftypefn

@deftypefn {Команда MGL} {} xtick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deftypefnx {Команда MGL} {} ytick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deftypefnx {Команда MGL} {} ztick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deftypefnx {Команда MGL} {} ctick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deftypefnx {Команда MGL} {} xtick vdat 'lbls' [@code{add=off}]
@deftypefnx {Команда MGL} {} ytick vdat 'lbls' [@code{add=off}]
@deftypefnx {Команда MGL} {} ztick vdat 'lbls' [@code{add=off}]
@deftypefnx {Команда MGL} {} ctick vdat 'lbls' [@code{add=off}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const char *}lbl, @code{bool} add=@code{false})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const wchar_t *}lbl, @code{bool} add=@code{false})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const mglDataA &}val, @code{const char *}lbl, @code{bool} add=@code{false})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const mglDataA &}val, @code{const wchar_t *}lbl, @code{bool} add=@code{false})
@deftypefnx {Функция С} @code{void} mgl_set_ticks_str (@code{HMGL} gr, @code{char} dir, @code{const char *}lbl, @code{bool} add)
@deftypefnx {Функция С} @code{void} mgl_set_ticks_wcs (@code{HMGL} gr, @code{char} dir, @code{const wchar_t *}lbl, @code{bool} add)
@deftypefnx {Функция С} @code{void} mgl_set_ticks_val (@code{HMGL} gr, @code{char} dir, @code{HCDT} val, @code{const char *}lbl, @code{bool} add)
@deftypefnx {Функция С} @code{void} mgl_set_ticks_valw (@code{HMGL} gr, @code{char} dir, @code{HCDT} val, @code{const wchar_t *}lbl, @code{bool} add)
@end ifclear
Задает явное положение @var{val} и подписи @var{lbl} для меток вдоль оси @var{dir}. Если массив @var{val} не указан, то используются значения равно распределённые в диапазоне осей координат. Метки разделяются символом @samp{\n}. Если в команде MGL задано только одно значение, то метка будет @emph{добавлена} к существующим меткам. Используйте @code{SetTicks()} для восстановления автоматических меток.
@end deftypefn

@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{void} AddTick (@code{char} dir, @code{double} val, @code{const char *}lbl)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} AddTick (@code{char} dir, @code{double} val, @code{const wchar_t *}lbl)
@deftypefnx {Функция С} @code{void} mgl_add_tick (@code{HMGL} gr, @code{char} dir, @code{double} val, @code{const char *}lbl)
@deftypefnx {Функция С} @code{void} mgl_set_tickw (@code{HMGL} gr, @code{char} dir, @code{double} val, @code{const wchar_t *}lbl)
Аналогично предыдущему, но добавляет одну метку оси к списку существующих меток.
@end deftypefn
@end ifclear

@deftypefn {Команда MGL} {} xtick 'templ'
@deftypefnx {Команда MGL} {} ytick 'templ'
@deftypefnx {Команда MGL} {} ztick 'templ'
@deftypefnx {Команда MGL} {} ctick 'templ'
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTickTempl (@code{char} dir, @code{const char *}templ)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTickTempl (@code{char} dir, @code{const wchar_t *}templ)
@deftypefnx {Функция С} @code{void} mgl_set_tick_templ (@code{HMGL} gr, @code{const char *}templ)
@deftypefnx {Функция С} @code{void} mgl_set_tick_templw (@code{HMGL} gr, @code{const wchar_t *}templ)
@end ifclear
Задает шаблон @var{templ} для меток вдоль x-,y-,z-оси или colorbar. Шаблон может содержать и символы TeX. Если @var{templ}=@code{""}, то используется шаблон по умолчанию (в простейшем случае @samp{%.2g}). Если шаблон начинается с символа @samp{&}, то будет использовано целое @code{long} вместо типа @code{double}. Установка шаблона выключает автоматическое улучшение вида меток.
@end deftypefn

@anchor{ticktime}
@deftypefn {Команда MGL} {} ticktime 'dir' [@code{dv=0} 'tmpl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTicksTime (@code{char} dir, @code{mreal} val, @code{const char *}templ)
@deftypefnx {Функция С} @code{void} mgl_set_ticks_time (@code{HMGL} gr, @code{mreal} val, @code{const char *}templ)
@end ifclear
Задает метки времени с шагом @var{val} и шаблоном @var{templ} для меток вдоль x-,y-,z-оси или colorbar. Шаблон может содержать и символы TeX. Формат шаблона @var{templ} такой же как @url{http://www.manpagez.com/man/3/strftime/}. Наиболее употребительные варианты: @samp{%X} для национального представления времени, @samp{%x} для национального представления даты, @samp{%Y} для года с цифрами столетия. Если @var{val}=0 и/или @var{templ}="", то используется автоматическая расстановка меток и/или выбор шаблона. Вы можете использовать функцию @code{mgl_get_time}() для получения числа секунд с 1970 года до указанной даты/времени. Отмечу, что MS Visual Studio не может обрабатывать даты до 1970.
@end deftypefn

@ifclear UDAV
@deftypefn {Функция С} @code{double} mgl_get_time (@code{const char*}str, @code{const char *}templ)
Возвращает число секунд с 1970 года до даты/времени, указанной в строке @var{str}. Формат строки задается @var{templ}, такой же как @url{http://www.manpagez.com/man/3/strftime/}. Наиболее употребительные варианты: @samp{%X} для национального представления времени, @samp{%x} для национального представления даты, @samp{%Y} для года с цифрами столетия. Отмечу, что MS Visual Studio не может обрабатывать даты до 1970.
@end deftypefn
@end ifclear

@anchor{tuneticks}
@deftypefn {Команда MGL} {} tuneticks @code{val} [@code{pos=1.15}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTuneTicks (@code{int} tune, @code{mreal} pos=@code{1.15})
@deftypefnx {Функция С} @code{void} mgl_tune_ticks (@code{HMGL} gr, @code{int} tune, @code{mreal} pos)
@end ifclear
Включает/выключает улучшение вида меток осей путем вынесения общего множителя (для маленьких, типа 0.001...0.002, или больших, типа 1000...2000, значений координат) или общей компоненты (для узкого диапазона, типа 0.999...1.000). Также задает положение @var{pos} общего множителя на оси: =0 около минимального значения, =1 около максимального значения.
@end deftypefn

@anchor{tickshift}
@deftypefn {Команда MGL} {} tickshift @code{dx [dy=0 dz=0 dc=0]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTickShift (@code{mglPoint} d)
@deftypefnx {Функция С} @code{void} mgl_set_tick_shift (@code{HMGL} gr, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{mreal} dc)
@end ifclear
Задает значение дополнительного сдвига меток осей координат.
@end deftypefn

@ifclear UDAV

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetTickRotate (@code{bool} val)
@deftypefnx {Функция С} @code{void} mgl_set_tick_rotate (@code{HMGL} gr, @code{bool} val)
Включает/выключает поворот меток если их число или длина меток слишком велики.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetTickSkip (@code{bool} val)
@deftypefnx {Функция С} @code{void} mgl_set_tick_skip (@code{HMGL} gr, @code{bool} val)
Включает/выключает пропуск меток если их число или длина меток слишком велики.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetTimeUTC (@code{bool} val)
Разрешает/запрещает использование UTC времени в метках осей координат. В C/Fortran следует использовать @code{mgl_set_flag(gr,val, MGL_USE_GMTIME);}.
@end deftypefn

@end ifclear

@anchor{origintick}
@deftypefn {Команда MGL} {} origintick @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetOriginTick (@code{bool} val=@code{true})
@end ifclear
Разрешает/запрещает рисование меток в точке пересечения осей координат. В C/Fortran следует использовать @code{mgl_set_flag(gr,val, MGL_NO_ORIGIN);}.
@end deftypefn

@anchor{ticklen}
@deftypefn {Команда MGL} {} ticklen @code{val} [@code{stt=1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetTickLen (@code{mreal} val, @code{mreal} stt=@code{1})
@deftypefnx {Функция С} @code{void} mgl_set_tick_len (@code{HMGL} gr, @code{mreal} val, @code{mreal} stt)
@end ifclear
Задает относительную длину меток осей координат. Значение по умолчанию @code{0.1}. Параметр @var{stt}>0 задает относительную длину подметок, которые в @code{sqrt(1+stt)} раз меньше.
@end deftypefn

@deftypefn {Команда MGL} {} axisstl 'stl' ['tck'='' 'sub'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetAxisStl (@code{const char *}stl=@code{"k"}, @code{const char *}tck=@code{0}, @code{const char *}sub=@code{0})
@deftypefnx {Функция С} @code{void} mgl_set_axis_stl (@code{HMGL} gr, @code{const char *}stl, @code{const char *}tck, @code{const char *}sub)
@end ifclear
Задает стиль осей (@var{stl}), меток (@var{tck}) и подметок (@var{sub}) осей координат. Если @var{stl} пустая или ноль, то используется стиль по умолчанию (@samp{k} или @samp{w} в зависимости от типа прозрачности). Если  @var{tck}, @var{sub} пустая или ноль, то используется стиль осей (т.е. @var{stl}).
@end deftypefn

@c ##################################################################
@external{}
@node Subplots and rotation, Export picture, Axis settings, MathGL core
@section Матрица преобразования
@nav{}
@cindex Aspect
@cindex Rotate
@cindex RotateN
@cindex SubPlot
@cindex MultiPlot
@cindex StickPlot
@cindex ColumnPlot
@cindex InPlot
@cindex Title
@cindex Perspective
@cindex View
@cindex Push
@cindex Pop

Эти функции контролируют где и как график будет расположен. Существует определенный порядок вызова этих функций для лучшего вида графика. Вначале должны вызываться функции @ref{subplot}, @ref{multiplot} или @ref{inplot} для указания местоположения вывода. После них -- функции вращения @ref{rotate}, @ref{shear} и @ref{aspect}. И наконец любые другие функции для рисования графика. Вместо вращения графика можно вызвать функцию @ref{columnplot}, @ref{gridplot}, @ref{stickplot}, @ref{shearplot} или относительную @ref{inplot} для расположения графиков в столбец одного над другим без зазора между осями. @sref{Subplots}

@anchor{subplot}
@deftypefn {Команда MGL} {} subplot @code{nx ny m} ['stl'='<>_^' @code{dx=0 dy=0}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SubPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{const char *}stl=@code{"<>_^"}, @code{mreal} dx=@code{0}, @code{mreal} dy=@code{0})
@deftypefnx {Функция С} @code{void} mgl_subplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{const char *}stl)
@deftypefnx {Функция С} @code{void} mgl_subplot_d (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{const char *}stl, @code{mreal} dx, @code{mreal} dy)
@end ifclear
Помещает последующий вывод в @var{m}-ую ячейку сетки размером @var{nx}*@var{ny} от всего рисунка. Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться первой для создания "подграфика". С эстетической точки зрения не рекомендуется вызывать эту функцию с различными (или не кратными) размерами сетки. Дополнительное место для осей/colorbar резервируется только если строка @var{stl} содержит: 
@itemize @bullet
@item
@samp{L} или @samp{<} -- с левого края,
@item
@samp{R} или @samp{>} -- с правого края,
@item
@samp{A} или @samp{^} -- с верхнего края,
@item
@samp{U} или @samp{_} -- с нижнего края,
@item
@samp{#} -- место резервироваться не будет -- оси координат будут занимать все доступное пространство.
@end itemize
Ячейка может быть дополнительно сдвинута относительно своего обычного положения на относительный размер @var{dx}, @var{dy}. Отмечу, что colorbar может находиться за пределами рисунка если выбран пустой стиль @samp{}.
@end deftypefn

@anchor{multiplot}
@deftypefn {Команда MGL} {} multiplot @code{nx ny m dx dy} ['style'='<>_^' sx sy]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} MultiPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{int} dx, @code{int} dy, @code{const char *}stl=@code{"<>_^"})
@deftypefnx {Функция С} @code{void} mgl_multiplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{int} dx, @code{int} dy, @code{const char *}stl)
@end ifclear
Помещает последующий вывод в прямоугольник из @var{dx}*@var{dy} ячеек, начиная с @var{m}-ой ячейки, сетки размером @var{nx}*@var{ny} от всего рисунка. Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться первой для создания "подграфика". Дополнительное место для осей/colorbar резервируется если строка @var{stl} содержит:
@itemize @bullet
@item
@samp{L} или @samp{<} -- с левого края,
@item
@samp{R} или @samp{>} -- с правого края,
@item
@samp{A} или @samp{^} -- с верхнего края,
@item
@samp{U} или @samp{_} -- с нижнего края,
@item
@samp{#} -- место резервироваться не будет -- оси координат будут занимать все доступное пространство.
@end itemize
Область вывода может быть дополнительно сдвинута относительно своего обычного положения на относительный размер @var{sx}, @var{sy}.
@end deftypefn

@anchor{inplot}
@deftypefn {Команда MGL} {} inplot @code{x1 x2 y1 y2 [rel=on]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} InPlot (@code{mreal} x1, @code{mreal} x2, @code{mreal} y1, @code{mreal} y2, @code{bool} rel=@code{true})
@deftypefnx {Функция С} @code{void} mgl_inplot (@code{HMGL} gr, @code{mreal} x1, @code{mreal} x2, @code{mreal} y1, @code{mreal} y2)
@deftypefnx {Функция С} @code{void} mgl_relplot (@code{HMGL} gr, @code{mreal} x1, @code{mreal} x2, @code{mreal} y1, @code{mreal} y2)
@end ifclear
Помещает последующий вывод в прямоугольную область [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}] (исходный размер [0,1]*[0,1]). Эта функция позволяет поместить график в произвольную область рисунка. Если параметр @var{rel}=@code{true}, то используется позиция относительно текущего @ref{subplot} (или @ref{inplot} с @var{rel}=@code{false}). Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться первой для создания "подграфика".
@end deftypefn

@anchor{columnplot}
@deftypefn {Команда MGL} {} columnplot @code{num ind [d=0]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ColumnPlot (@code{int} num, @code{int} ind, @code{mreal} d=@code{0})
@deftypefnx {Функция С} @code{void} mgl_columnplot (@code{HMGL} gr, @code{int} num, @code{int} ind)
@deftypefnx {Функция С} @code{void} mgl_columnplot_d (@code{HMGL} gr, @code{int} num, @code{int} ind, @code{mreal} d)
@end ifclear
Помещает последующий вывод в @var{ind}-ую строку столбца из @var{num} строк. Положение столбца выбирается относительно последнего вызова @ref{subplot} (или @ref{inplot} с @var{rel}=@code{false}). Параметр @var{d} задает дополнительный зазор между строк.
@end deftypefn

@anchor{gridplot}
@deftypefn {Команда MGL} {} gridplot @code{nx ny ind [d=0]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} GridPlot (@code{int} nx, @code{int} ny, @code{int} ind, @code{mreal} d=@code{0})
@deftypefnx {Функция С} @code{void} mgl_gridplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} ind)
@deftypefnx {Функция С} @code{void} mgl_gridplot_d (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} ind, @code{mreal} d)
@end ifclear
Помещает последующий вывод в @var{ind}-ую ячейку таблицы @var{nx}*@var{ny}. Положение ячейки выбирается относительно последнего вызова @ref{subplot} (или @ref{inplot} с @var{rel}=@code{false}). Параметр @var{d} задает дополнительный зазор между ячеек.
@end deftypefn

@anchor{stickplot}
@deftypefn {Команда MGL} {} stickplot @code{num ind tet phi}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} StickPlot (@code{int} num, @code{int} ind, @code{mreal} tet, @code{mreal} phi)
@deftypefnx {Функция С} @code{void} mgl_stickplot (@code{HMGL} gr, @code{int} num, @code{int} ind, @code{mreal} tet, @code{mreal} phi)
@end ifclear
Помещает последующий вывод в @var{ind}-ую ячейку "бруска" из @var{num} ячеек. При этом сам брусок повернут на углы @var{tet}, @var{phi}. Положение выбирается относительно последнего вызова  @ref{subplot} (или @ref{inplot} с @var{rel}=@code{false}).
@end deftypefn

@anchor{shearplot}
@deftypefn {Команда MGL} {} shearplot @code{num ind sx sy [xd yd]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ShearPlot (@code{int} num, @code{int} ind, @code{mreal} sx, @code{mreal} sy, @code{mreal} xd=@code{1}, @code{mreal} yd=@code{0})
@deftypefnx {Функция С} @code{void} mgl_shearplot (@code{HMGL} gr, @code{int} num, @code{int} ind, @code{mreal} sx, @code{mreal} sy, @code{mreal} xd, @code{mreal} yd)
@end ifclear
Помещает последующий вывод в @var{ind}-ую ячейку "бруска" из @var{num} ячеек. При этом сама ячейка скошена на @var{sx}, @var{sy}. Направление бруска задается переменными @var{xd} и @var{yd}. Положение выбирается относительно последнего вызова  @ref{subplot} (или @ref{inplot} с @var{rel}=@code{false}).
@end deftypefn

@anchor{title}
@deftypefn {Команда MGL} {} title 'title' ['stl'='' @code{size=-2}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Title (@code{const char *}txt, @code{const char *}stl=@code{""}, @code{mreal} size=@code{-2})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Title (@code{const wchar_t *}txt, @code{const char *}stl=@code{""}, @code{mreal} size=@code{-2})
@deftypefnx {Функция С} @code{void} mgl_title (@code{HMGL} gr, @code{const char *}txt, @code{const char *}stl, @code{mreal} size)
@deftypefnx {Функция С} @code{void} mgl_titlew (@code{HMGL} gr, @code{const wchar_t *}txt, @code{const char *}stl, @code{mreal} size)
@end ifclear
Выводит заголовок @var{title} для текущего "подграфика" шрифтом @var{stl} с размером @var{size}. Если строка @var{stl} содержит @samp{#}, то рисуется обрамляющий прямоугольник. Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться сразу после создания "подграфика".
@end deftypefn

@anchor{rotate}
@deftypefn {Команда MGL} {} rotate @code{tetx tetz [tety=0]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Rotate (@code{mreal} TetX, @code{mreal} TetZ, @code{mreal} TetY=@code{0})
@deftypefnx {Функция С} @code{void} mgl_rotate (@code{HMGL} gr, @code{mreal} TetX, @code{mreal} TetZ, @code{mreal} TetY)
@end ifclear
Вращает систему координат относительно осей @{x, z, y@} последовательно на углы @var{TetX}, @var{TetZ}, @var{TetY}.
@end deftypefn

@deftypefn {Команда MGL} {} rotate @code{tet x y z}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} RotateN (@code{mreal} Tet, @code{mreal} x, @code{mreal} y, @code{mreal} z)
@deftypefnx {Функция С} @code{void} mgl_rotate_vector (@code{HMGL} gr, @code{mreal Tet}, @code{mreal x}, @code{mreal y}, @code{mreal z})
@end ifclear
Вращает систему координат относительно вектора @{@var{x}, @var{y}, @var{z}@} на угол @var{Tet}.
@end deftypefn


@anchor{shear}
@deftypefn {Команда MGL} {} shear @code{sx sy}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Shear (@code{mreal} sx, @code{mreal} sy)
@deftypefnx {Функция С} @code{void} mgl_shear (@code{HMGL} gr, @code{mreal} sx, @code{mreal} sy)
@end ifclear
Сдвигает (скашивает) систему координат на значения @var{sx}, @var{sy}.
@end deftypefn


@anchor{aspect}
@deftypefn {Команда MGL} {} aspect @code{ax ay [az=1]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Aspect (@code{mreal} Ax, @code{mreal} Ay, @code{mreal} Az=@code{1})
@deftypefnx {Функция С} @code{void} mgl_aspect (@code{HMGL} gr, @code{mreal} Ax, @code{mreal} Ay, @code{mreal} Az)
@end ifclear
Устанавливает соотношение размеров осей в отношении @var{Ax:Ay:Az}. Для лучшего вида следует вызывать после функции @ref{rotate}. Если @var{Ax}=@code{NAN}, то функция выберет оптимальное соотношение размеров, чтобы шаг по осям x-y был одинаков. При этом, @var{Ay} задает фактор пропорциональности шага (обычно 1), или указывает на его автоматический выбор при @var{Ay}=@code{NAN}.
@end deftypefn

@ifclear UDAV

@deftypefn {Метод класса @code{mglGraph}} @code{void} Push ()
@deftypefnx {Функция С} @code{void} mgl_mat_push (@code{HMGL} gr)
Помещает матрицу преобразования в стек. Позднее вы можете восстановить текущее состояние с помощью функции Pop().
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} Pop ()
@deftypefnx {Функция С} @code{void} mgl_mat_pop (@code{HMGL} gr)
Заменяет (восстанавливает) матрицу преобразования на последнюю помещенную в стек матрицу.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetPlotFactor (@code{mreal} val)
@deftypefnx {Функция С} @code{void} mgl_set_plotfactor (@code{HMGL} gr, @code{mreal} val)
Задает масштаб картинки. Не рекомендуется устанавливать значения меньше 1.5. Это аналог функции Zoom(), но применяется только к конкретному подграфику. Используйте ноль для включения автоматического масштабирования.
@end deftypefn

@end ifclear


Также есть 3 функции, которые управляют перспективой @code{Perspective()}, масштабированием @code{Zoom()} и вращением @code{View()} всего рисунка. Т.е. они действуют как ещё одна матрица трансформации. Они были введены для вращения/приближения графика с помощью мыши. Не рекомендуется вызывать их при рисовании графика.

@anchor{perspective}
@deftypefn {Команда MGL} {} perspective @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Perspective (@code{mreal} a)
@deftypefnx {Функция С} @code{void} mgl_perspective (@code{HMGL} gr, @code{mreal} a)
@end ifclear
Добавляет (включает) перспективу для графика. Параметр @math{a = Depth/(Depth+dz) \in [0,1)}. По умолчанию (@code{a=0}) перспектива отключена.
@end deftypefn

@anchor{view}
@deftypefn {Команда MGL} {} view @code{tetx tetz [tety=0]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} View (@code{mreal} TetX, @code{mreal} TetZ, @code{mreal} TetY=@code{0})
@deftypefnx {Функция С} @code{void} mgl_view (@code{HMGL} gr, @code{mreal} TetX, @code{mreal} TetZ, @code{mreal} TetY)
@end ifclear
Вращает систему координат относительно осей @{x, z, y@} последовательно на углы @var{TetX}, @var{TetZ}, @var{TetY}. Вращение происходит независимо от @ref{rotate}. Внимание! эти настройки не могут быть переписаны функцией  @code{DefaultPlotParam()}. Используйте @code{Zoom(0,0,1,1)} для возвращения к виду по умолчанию.
@end deftypefn

@anchor{zoom}
@deftypefn {Команда MGL} {} zoom @code{x1 y1 x2 y2}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Zoom (@code{mreal} x1, @code{mreal} y1, @code{mreal} x2, @code{mreal} y2)
@deftypefnx {Функция С} @code{void} mgl_set_zoom (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} x2, @code{mreal} y2)
@end ifclear
Масштабирует весь рисунок. После вызова функции текущий график будет очищен и в дальнейшем рисунок будет содержать только область [x1,x2]*[y1,y2] от исходного рисунка. Координаты @var{x1}, @var{x2}, @var{y1}, @var{y2} меняются в диапазоне от 0 до 1. Внимание! эти настройки не могут быть переписаны никакими другими функциями, включая  @code{DefaultPlotParam()}. Используйте @code{Zoom(0,0,1,1)} для возвращения к виду по умолчанию.
@end deftypefn

@c ##################################################################
@external{}
@node Export picture, Background, Subplots and rotation, MathGL core
@section Экспорт рисунка
@nav{}
@cindex SetSize

Функции в этой группе сохраняют или дают доступ к полученному рисунку. Поэтом обычно они должны вызываться в конце рисования.

@anchor{setsize}
@deftypefn {Команда MGL} {} setsize @code{w h}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetSize (@code{int} width, @code{int} height, @code{bool} clear=@code{true})
@deftypefnx {Функция С} @code{void} mgl_set_size (@code{HMGL} gr, @code{int} width, @code{int} height)
@deftypefnx {Функция С} @code{void} mgl_scale_size (@code{HMGL} gr, @code{int} width, @code{int} height)
@end ifclear
Изменяет размер картинки в пикселях. Функция должна вызываться @strong{перед} любыми функциями построения потому что полностью очищает содержимое рисунка при @var{clear}=@code{true}. Функция только очищает растровый рисунок и масштабирует примитивы при @var{clear}=@code{false}.
@end deftypefn


@anchor{setsizescl}
@deftypefn {Команда MGL} {} setsizescl @code{factor}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetSizeScl (@code{double} factor)
@deftypefnx {Функция С} @code{void} mgl_set_size_scl (@code{HMGL} gr, @code{double} factor)
@end ifclear
Задает множитель для высоты и ширины во всех последующих вызовах @ref{setsize}.
@end deftypefn


@anchor{quality}
@deftypefn {Команда MGL} {} quality [@code{val}=2]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetQuality (@code{int} val=@code{MGL_DRAW_NORM})
@deftypefnx {Функция С} @code{void} mgl_set_quality (@code{HMGL} gr, @code{int} val)
@end ifclear
Задает качество графика в зависимости от значения @var{val}: @code{MGL_DRAW_WIRE=0} -- нет рисования граней (наиболее быстрый), @code{MGL_DRAW_FAST=1} -- нет интерполяции цвета (быстрый), @code{MGL_DRAW_NORM=2} -- высокое качество (нормальный), @code{MGL_DRAW_HIGH=3} -- высокое качество с рисованием 3d примитивов (стрелок и маркеров). Если установлен бит @code{MGL_DRAW_LMEM=0x4}, то происходит прямое рисование в растровое изображение (меньше затраты памяти). Если установлен бит @code{MGL_DRAW_DOTS=0x8}, то рисуются точки вместо примитивов (очень быстро).
@end deftypefn

@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{int} GetQuality ()
@deftypefnx {Функция С} @code{void} mgl_get_quality (@code{HMGL} gr)
Возвращает качество графика: @code{MGL_DRAW_WIRE=0} -- нет рисования граней (наиболее быстрый), @code{MGL_DRAW_FAST=1} -- нет интерполяции цвета (быстрый), @code{MGL_DRAW_NORM=2} -- высокое качество (нормальный), @code{MGL_DRAW_HIGH=3} -- высокое качество с рисованием 3d примитивов (стрелок и маркеров). Если установлен бит @code{MGL_DRAW_LMEM=0x4}, то происходит прямое рисование в растровое изображение (меньше затраты памяти). Если установлен бит @code{MGL_DRAW_DOTS=0x8}, то рисуются точки вместо примитивов (очень быстро).
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} StartGroup (const char *name)
@deftypefnx {Функция С} @code{void} mgl_start_group (@code{HMGL} gr, @code{const char *}name)
Начинает определение группы. Группа может содержать объекты и другие группы. Они используются для выбора части модели при приближении, изменении прозрачности и т.д.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} EndGroup ()
@deftypefnx {Функция С} @code{void} mgl_end_group (@code{HMGL} gr)
Завершает определение группы.
@end deftypefn
@end ifclear

@menu
* Export to file::
* Frames/Animation::
* Bitmap in memory::
* Parallelization::
@end menu

@c ==================================================================
@external{}
@node Export to file, Frames/Animation, , Export picture
@subsection Экспорт в файл
@nav{}
@cindex Write
@ifclear UDAV
@cindex WriteFrame
@cindex WritePNG
@cindex WriteGIF
@c @cindex WriteIDTF
@cindex WriteSVG
@cindex WriteBMP
@cindex WriteEPS
@cindex WriteBPS
@cindex WriteTGA
@cindex WriteTEX
@cindex WritePRC
@cindex WriteOBJ
@cindex WriteWGL
@cindex WriteJPEG
@cindex ShowImage
@end ifclear

Эти функции экспортируют текущую картинку (кадр) в файл. Имя файла @var{fname} должно иметь соответствующее расширение. Параметр @var{descr} дает краткое описание картинки. Пока прозрачность поддерживается только для форматов PNG, SVG, OBJ и PRC.

@anchor{write}
@deftypefn {Команда MGL} {} write ['fname'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} WriteFrame (@code{const char *}fname=@code{""}, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_frame (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@end ifclear
Экспортирует текущий кадр в файл @var{fname} с типом, определяемым по расширению. Параметр @var{descr} добавляет описание (может быть пустым). Если @var{fname} пустой, то используется имя @samp{frame####.jpg}, где @samp{####} -- текущий номер кадра и имя @samp{frame} определяется переменной @ref{plotid}.
@end deftypefn

@anchor{bbox}
@deftypefn {Команда MGL} {} bbox x1 y1 [x2=@code{-1} y2=@code{-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetBBox (@code{int} x1=@code{0}, @code{int} y1=@code{0}, @code{int} x2=@code{-1}, @code{int} y2=@code{-1})
@deftypefnx {Функция С} @code{void} mgl_set_bbox (@code{HMGL} gr, @code{int} x1, @code{int} y1, @code{int} x2, @code{int} y2)
@end ifclear
Задает область изображения, которая будет сохранена в файл 2D формата. Если @var{x2}<0 (@var{y2}<0), то исходная ширина (высота) рисунка будет использована. Если @var{x1}<0 или @var{y1}<0 или @var{x1}>=@var{x2}|Width или @var{y1}>=@var{y2}|Height, то обрезания рисунка не будет.
@end deftypefn

@ifclear UDAV

@deftypefn {Метод класса @code{mglGraph}} @code{void} WritePNG (@code{const char *}fname, @code{const char *}descr=@code{""}, @code{int} compr=@code{""}, @code{bool} alpha=@code{true})
@deftypefnx {Функция С} @code{void} mgl_write_png (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@deftypefnx {Функция С} @code{void} mgl_write_png_solid (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в PNG файл. Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла, @var{alpha} -- прозрачность фона. Если при компиляции MathGL не был определен флаг HAVE_PNG, то экспорт в файл не производится.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteJPEG (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_jpg (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в JPEG файл. Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла. Если при компиляции MathGL не был определен флаг HAVE_JPEG, то экспорт в файл не производится.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteGIF (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_gif (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в GIF файл. Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла. Если при компиляции MathGL не был определен флаг HAVE_GIF, то экспорт в файл не производится.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteBMP (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_bmp (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в BMP файл. Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteTGA (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_tga (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в TGA файл. Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteEPS (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_eps (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в EPS файл, используя векторное представление графика. Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла. Если имя файла оканчивается на @samp{z} (например, @samp{fname.eps.gz}), то файл автоматически архивируется в формате gzip. Отмечу, что формат EPS не поддерживает интерполяцию цвета, и картинка будет выглядеть как при использовании @ref{quality}=1.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteBPS (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_eps (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в EPS файл, используя растровое представление графика. Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла. Если имя файла оканчивается на @samp{z} (например, @samp{fname.eps.gz}), то файл автоматически архивируется в формате gzip.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteSVG (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_svg (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в SVG файл, используя векторное представление графика. Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла. Если имя файла оканчивается на @samp{z} (например, @samp{fname.svgz}), то файл автоматически архивируется в формате gzip. Отмечу, что формат SVG не поддерживает интерполяцию цвета, и картинка будет выглядеть как при использовании @ref{quality}=1.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteTEX (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_tex (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в LaTeX файл (пакет Tikz/PGF), используя векторное представление графика. Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла. Отмечу, что сейчас отсутствует изменение размера текста (например, в subplot), что может приводить к неправильному положению надписей.
@end deftypefn


@deftypefn {Метод класса @code{mglGraph}} @code{void} WritePRC (@code{const char *}fname, @code{const char *}descr=@code{""}, @code{bool} make_pdf=@code{true})
@deftypefnx {Функция С} @code{void} mgl_write_prc (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr, @code{int} make_pdf)
Экспортирует текущий кадр в PRC файл, используя векторное представление графика (см. @url{http://en.wikipedia.org/wiki/PRC_%28file_format%29}). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла. Если параметр @var{make_pdf}=@code{true} и PDF был выбран при конфигурировании MathGL, то также создается соответствующий PDF файл с 3D изображением.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteOBJ (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_obj (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в OBJ/MTL файл, используя векторное представление графика (см. @url{http://en.wikipedia.org/wiki/Wavefront_.obj_file, OBJ формат}). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла.
@end deftypefn


@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteXYZ (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_xyz (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в XYZ/XYZL/XYZF файлы, используя векторное представление графика (см. @url{http://people.sc.fsu.edu/~jburkardt/data/xyz/xyz.html, XYZ формат}). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteSTL (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_stl (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует текущий кадр в STL файл, используя векторное представление графика (см. @url{http://en.wikipedia.org/wiki/STL_(file_format), STL формат}). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteOFF (@code{const char *}fname, @code{const char *}descr=@code{""}, @code{bool} colored=@code{false})
@deftypefnx {Функция С} @code{void} mgl_write_off (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr, @code{bool} colored)
Экспортирует текущий кадр в OFF файл, используя векторное представление графика (см. @url{http://people.sc.fsu.edu/~jburkardt/data/off/off.html, OFF формат}). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла.
@end deftypefn

@c @deftypefn {Метод класса @code{mglGraph}} @code{void} WriteX3D (@code{const char *}fname, @code{const char *}descr=@code{""})
@c @deftypefnx {Функция С} @code{void} mgl_write_x3d (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@c Экспортирует текущий кадр в X3D файл, используя векторное представление графика (см. @url{http://en.wikipedia.org/wiki/X3d, X3D формат}). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла.
@c @end deftypefn


@c @deftypefn {Метод класса @code{mglGraph}} @code{void} WriteIDTF (@code{const char *}fname, @code{const char *}descr=@code{""})
@c @deftypefnx {Функция С} @code{void} mgl_write_idtf (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@c Экспортирует текущий кадр в IDTF файл, используя векторное представление графика (класс mglGraphIDTF). Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла.
@c @end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} ShowImage (@code{const char *}viewer, @code{bool} nowait=@code{false})
@deftypefnx {Функция С} @code{void} mgl_show_image (@code{const char *}viewer, @code{int} nowait)
Отображает текущий кадр используя внешнюю программу просмотра @var{viewer}. Функция сохраняет картинку во временный файл и вызывает @var{viewer} для его отображения. Если @var{nowait}=@code{true}, то функция возвращает управление немедленно -- не ждет пока окно просмотра будет закрыто.
@end deftypefn


@deftypefn {Метод класса @code{mglGraph}} @code{void} WriteJSON (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_write_json (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует точки и примитивы в текстовый файл используя @ref{JSON format}. В дальнейшем этот файл можно загрузить и просмотреть в JavaScript скрипте. Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} ExportMGLD (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {Функция С} @code{void} mgl_export_mgld (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Экспортирует точки и примитивы в файл @ref{MGLD format}. В дальнейшем этот файл можно загрузить и просмотреть с помощью @code{mglview}. Параметры функции следующие: @var{fname} -- имя файла, @var{descr} -- описание файла.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} ImportMGLD (@code{const char *}fname, @code{bool} add=@code{false})
@deftypefnx {Функция С} @code{void} mgl_import_mgld (@code{HMGL} gr, @code{const char *}fname, @code{int} add)
Импортирует точки и примитивы из файла в @ref{MGLD format}. Параметры функции следующие: @var{fname} -- имя файла, @var{add} -- флаг добавления или замены существующих точек и примитивов.
@end deftypefn

@end ifclear


@c ##################################################################
@external{}
@node Frames/Animation, Bitmap in memory, Export to file, Export picture
@subsection Кадры/Анимация
@nav{}

@ifset UDAV
В MGL нет специальных команд для создания анимации. Однако можно воспользоваться возможностями утилит @code{mglconv} и @code{mglview}. Например, используя комментарии спеиального вида @samp{##a } или @samp{##c }.
@end ifset

@ifclear UDAV
@cindex NewFrame
@cindex EndFrame
@cindex GetNumFrame
@cindex ResetFrames
@cindex StartGIF
@cindex CloseGIF

Эти функции позволяют создавать несколько картинок одновременно. В большинстве случаев это бесполезно, но для органов управления (см. @ref{Widget classes}) это позволяет показывать анимацию. Также можно записать несколько кадров в анимированный GIF файл.

@deftypefn {Метод класса @code{mglGraph}} @code{void} NewFrame ()
@deftypefnx {Функция С} @code{void} mgl_new_frame (@code{HMGL} gr)
Создает новый кадр. Функция возвращает номер текущего кадра. В режиме OpenGL функция не должны вызываться в параллельных потоках! -- используйте прямое создание списка. Функция @code{EndFrame()} @strong{должна} быть вызвана после рисования кадра для каждого вызова этой функции.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} EndFrame ()
@deftypefnx {Функция С} @code{void} mgl_end_frame (@code{HMGL} gr)
Завершает рисование кадра.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{int} GetNumFrame ()
@deftypefnx {Функция С} @code{int} mgl_get_num_frame (@code{HMGL} gr)
Возвращает число созданных кадров.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} GetFrame (@code{int} i)
@deftypefnx {Функция С} @code{void} mgl_get_frame (@code{HMGL} gr, @code{int} i)
Завершает рисование кадра и сохраняет объекты рисования в кадр с номером @var{i}, который должен быть в диапазоне [0, @code{GetNumFrame()}-1]. Функция аналогична @code{EndFrame()}, но не добавляет кадр в GIF изображение.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} GetFrame (@code{int} i)
@deftypefnx {Функция С} @code{void} mgl_get_frame (@code{HMGL} gr, @code{int} i)
Заменяет объекты рисования на объекты из кадра с номером @var{i}. Функция работает если установлен флаг @code{MGL_VECT_FRAME} (по умолчанию).
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} ShowFrame (@code{int} i)
@deftypefnx {Функция С} @code{void} mgl_show_frame (@code{HMGL} gr, @code{int} i)
Добавляет объекты рисования из кадра с номером @var{i} к уже существующим. Функция работает если установлен флаг @code{MGL_VECT_FRAME} (по умолчанию).
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} DelFrame (@code{int} i)
@deftypefnx {Функция С} @code{void} mgl_del_frame (@code{HMGL} gr, @code{int} i)
Удаляет объекты рисования для кадра с номером @var{i} и сдвигает нумерацию всех последующих кадров. Функция работает если установлен флаг @code{MGL_VECT_FRAME} (по умолчанию).
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} ResetFrames ()
@deftypefnx {Функция С} @code{void} mgl_reset_frames (@code{HMGL} gr)
Сбрасывает счетчик кадров в 0.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} ClearFrame (@code{int} i)
@deftypefnx {Функция С} @code{void} mgl_clear_frame (@code{HMGL} gr, @code{int} i)
Очищает текущий список объектов.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} StartGIF (@code{const char *}fname, @code{int} ms=@code{100})
@deftypefnx {Функция С} @code{void} mgl_start_gif (@code{HMGL} gr, @code{const char *}fname, @code{int} ms)
Начинает запись кадров в анимированный GIF файл @var{fname}. Параметр @var{ms} задает задержку между кадрами в миллисекундах. Вы @strong{не должны} менять размер рисунка во время создания кино. Используйте CloseGIF() для завершения записи. Эта функция не работает в режиме OpenGL.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} CloseGIF ()
@deftypefnx {Функция С} @code{void} mgl_close_gif (@code{HMGL} gr)
Завершает запись анимированного GIF файла.
@end deftypefn
@end ifclear

@c ------------------------------------------------------------------
@external{}
@node Bitmap in memory, Parallelization, Frames/Animation, Export picture
@subsection Рисование в памяти
@nav{}

@ifclear UDAV
Эти функции возвращают созданный растровый рисунок, его ширину и высоту. В дальнейшем его можно использовать в любой графической библиотеке (см. также, @ref{Widget classes}) или сохранить в файл (см. также, @ref{Export to file}).

@deftypefn {Метод класса @code{mglGraph}} @code{const unsigned char *} GetRGB ()
@deftypefnx {Метод класса @code{mglGraph}} @code{void} GetRGB (@code{char *}buf, @code{int} size)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} GetBGRN (@code{char *}buf, @code{int} size)
@deftypefnx {Функция С} @code{const unsigned char *} mgl_get_rgb (@code{HMGL} gr)
Возвращает растровое изображение в формате RGB для текущего кадра. Формат каждого элемента (пикселя): @{red, green, blue@}. Число элементов Width*Height. Положение элемента @{i,j@} есть [3*i + 3*Width*j] (или [4*i + 4*Width*j] для @code{GetBGRN()}). В Python вы должны предоставить буфер @var{buf} достаточного размера @var{size}, т.е. код должен выглядеть следующим образом (для Python)
@verbatim
from mathgl import *
gr = mglGraph();
bits='\t';
bits=bits.expandtabs(4*gr.GetWidth()*gr.GetHeight());
gr.GetBGRN(bits, len(bits));
@end verbatim
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{const unsigned char *} GetRGBA ()
@deftypefnx {Метод класса @code{mglGraph}} @code{void} GetRGBA (@code{char *}buf, @code{int} size)
@deftypefnx {Функция С} @code{const unsigned char *} mgl_get_rgba (@code{HMGL} gr)
Возвращает растровое изображение в формате RGBA для текущего кадра. Формат каждого элемента (пикселя): @{red, green, blue, alpha@}. Число элементов Width*Height. Положение элемента @{i,j@} есть [4*i + 4*Width*j].
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{int} GetWidth ()
@deftypefnx {Метод класса @code{mglGraph}} @code{int} GetHeight ()
@deftypefnx {Функция С} @code{int} mgl_get_width (@code{HMGL} gr)
@deftypefnx {Функция С} @code{int} mgl_get_height (@code{HMGL} gr)
Возвращает ширину и высоту изображения.
@end deftypefn


@deftypefn {Метод класса @code{mglGraph}} @code{mglPoint} CalcXYZ (@code{int} xs, @code{int} ys)
@deftypefnx {Функция С} @code{void} mgl_calc_xyz (@code{HMGL} gr, @code{int} xs, @code{int} ys, @code{mreal *}x, @code{mreal *}y, @code{mreal *}z)
Вычисляет 3D координаты @{x,y,z@} для экранной точки @{xs,ys@}. В данный момент игнорируется перспектива графика и формулы перехода в криволинейные координаты. Вычисления производятся для последнего использованного InPlot (см. @ref{Subplots and rotation}).
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{mglPoint} CalcScr (@code{mglPoint} p)
@deftypefnx {Функция С} @code{void} mgl_calc_scr (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{int *}xs, @code{int *}ys)
Вычисляет экранные координаты @{xs,ys@} для 3D координат @{x,y,z@}. Вычисления производятся для последнего использованного InPlot (см. @ref{Subplots and rotation}).
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} SetObjId (@code{int} id)
@deftypefnx {Функция С} @code{void} mgl_set_obj_id (@code{HMGL} gr, @code{int} id)
Задает числовой идентификатор для объектов или subplot/inplot.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{int} GetObjId (@code{int} xs, @code{int} ys)
@deftypefnx {Функция С} @code{int} mgl_get_obj_id (@code{HMGL} gr, @code{int} xs, @code{int} ys)
Возвращает числовой идентификатор верхнего объекта в точке @{xs, ys@} рисунка.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{int} GetSplId (@code{int} xs, @code{int} ys)
@deftypefnx {Функция С} @code{int} mgl_get_spl_id (@code{HMGL} gr, @code{int} xs, @code{int} ys)
Возвращает числовой идентификатор верхнего "подграфика" в точке @{xs, ys@} рисунка.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{void} Highlight (@code{int} id)
@deftypefnx {Функция С} @code{void} mgl_highlight (@code{HMGL} gr, @code{int} id)
Выделяет объект с заданным @var{id}.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{long} IsActive (@code{int} xs, @code{int} ys, @code{int} d=@code{1})
@deftypefnx {Функция С} @code{long} mgl_is_active (@code{HMGL} gr, @code{int} xs, @code{int} ys, @code{int} d)
Проверяет близка ли точка @{@var{xs}, @var{ys}@} к активной точке (т.е. mglBase::Act) с точностью @var{d} и возвращает индекс активной точки или @code{-1} если не найдено. Активные точки -- специальные точки, которые характеризуют примитивы (например, вершины). Это функция только для опытных пользователей.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{long} SetDrawReg (@code{int} nx=@code{1}, @code{int} ny=@code{1}, @code{int} m=@code{0})
@deftypefnx {Функция С} @code{long} mgl_set_draw_reg (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m)
Ограничивает рисование прямоугольной областью @var{m}-ой клетки матрицы размером @var{nx}*@var{ny} (аналогично @ref{subplot}). Функция может бытб использована для ускорения вывода путем уменьшения выводимых примитивов. Это функция только для опытных пользователей.
@end deftypefn

@end ifclear

@c ------------------------------------------------------------------
@external{}
@node Parallelization, , Bitmap in memory, Export picture
@subsection Распараллеливание
@nav{}

@ifclear UDAV
@cindex Combine
@cindex MPI_Send
@cindex MPI_Recv

Многие функции MathGL используют несколько потоков для ускорения работы (если MathGL была собрана с поддержкой pthread). При этом можно настраивать число используемых потоков.

@deftypefn {Функция С} @code{int} mgl_set_num_thr (@code{int} n)
Задает число потоков, которое будет использовано в MathGL. При @var{n}<1 число потоков задается как максимальное число процессоров (ядер) в системе. При @var{n}=1 не используется распараллеливание.
@end deftypefn

Другая возможность -- комбинирование изображений из разных объектов @code{mglGraph}. Эти методы наиболее подходят для компьютерных кластеров, когда данные настолько велики, что не могут поместиться в памяти отдельного компьютера.

@deftypefn {Метод класса @code{mglGraph}} @code{int} Combine (@code{const mglGraph *}g)
@deftypefnx {Функция С} @code{int} mgl_combine_gr (@code{HMGL} gr, @code{HMGL} g)
Комбинирует (добавляет) рисунок из @var{g} с @var{gr}, принимая во внимание ``высоту'' пикселей. Ширина и высота обоих рисунков должна быть одинаковы.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{int} MPI_Send (@code{int} id)
@deftypefnx {Функция С} @code{int} mgl_mpi_send (@code{HMGL} gr, @code{int} id)
Посылает рисунок из компьютера (ноды) @var{id}, используя MPI. Ширина и высота обоих рисунков должна быть одинаковы.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{int} MPI_Recv (@code{int} id)
@deftypefnx {Функция С} @code{int} mgl_mpi_send (@code{HMGL} gr, @code{int} id)
Принимает рисунок из компьютера (ноды) @var{id}, используя MPI. Ширина и высота обоих рисунков должна быть одинаковы.
@end deftypefn
@end ifclear


@c ##################################################################
@external{}
@node Background, Primitives, Export picture, MathGL core
@section Фоновое изображение
@nav{}
@cindex LoadBackground
@cindex Clf
@cindex Rasterize

These functions change background image.

@anchor{clf}
@deftypefn {Команда MGL} {} clf ['col']
@deftypefnx {Команда MGL} {} clf r g b
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Clf ()
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Clf (@code{const char *} col)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Clf (@code{char} col)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Clf (@code{mreal} r, @code{mreal} g, @code{mreal} b)
@deftypefnx {Функция С} @code{void} mgl_clf (@code{HMGL} gr)
@deftypefnx {Функция С} @code{void} mgl_clf_str (@code{HMGL} gr, @code{const char *} col)
@deftypefnx {Функция С} @code{void} mgl_clf_chr (@code{HMGL} gr, @code{char} col)
@deftypefnx {Функция С} @code{void} mgl_clf_rgb (@code{HMGL} gr, @code{mreal} r, @code{mreal} g, @code{mreal} b)
@end ifclear
Очищает рисунок и заполняет фон заданным цветом.
@end deftypefn

@anchor{rasterize}
@deftypefn {Команда MGL} {} rasterize
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Rasterize ()
@deftypefnx {Функция С} @code{void} mgl_rasterize (@code{HMGL} gr)
@end ifclear
Завершает рисование графика и помещает результат в качестве фона. После этого, очищает список примитивов (как @ref{clf}). Функция полезна для сохранения части графика (например, поверхностей или векторных полей) в растровом виде, а другой части (кривых, осей и пр.) в векторном.
@end deftypefn

@anchor{background}
@deftypefn {Команда MGL} {} background 'fname' [@code{alpha=1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} LoadBackground (@code{const char *} fname, @code{double} alpha=@code{1})
@deftypefnx {Функция С} @code{void} mgl_load_background (@code{HMGL} gr, @code{const char *} fname, @code{double} alpha)
@end ifclear
Загружает PNG или JPEG файл @var{fname} в качестве фона для графика. Параметр @var{alpha} задает прозрачность фона вручную.
@end deftypefn


@c ##################################################################
@external{}
@node Primitives, Text printing, Export picture, MathGL core
@section Рисование примитивов
@nav{}
@cindex Ball
@cindex Line
@cindex Curve
@cindex Glyph
@cindex Face
@cindex FaceX
@cindex FaceY
@cindex FaceZ
@cindex Cone
@cindex Drop
@cindex Sphere

@ifclear UDAV
@cindex Mark
@cindex Error
@end ifclear

Эти функции рисуют рисуют простые объекты типа линий, точек, сфер, капель, конусов, и т.д.

@anchor{ball}
@deftypefn {Команда MGL} {} ball @code{x y} ['col'='r.']
@deftypefnx {Команда MGL} {} ball @code{x y z} ['col'='r.']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Ball (@code{mglPoint} p, @code{char} col=@code{'r'})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Mark (@code{mglPoint} p, @code{const char *}mark)
@deftypefnx {Функция С} @code{void} mgl_mark (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{const char *}mark)
@end ifclear
Рисует маркер (точку по умолчанию) с координатами @var{p}=@{@var{x}, @var{y}, @var{z}@} и цветом @var{col}.
@end deftypefn

@anchor{errbox}
@deftypefn {Команда MGL} {} errbox @code{x y ex ey} ['stl'='']
@deftypefnx {Команда MGL} {} errbox @code{x y z ex ey ez} ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Error (@code{mglPoint} p, @code{mglPoint} e, @code{char} *stl=@code{""})
@deftypefnx {Функция С} @code{void} mgl_error_box (@code{HMGL} gr, @code{mreal} px, @code{mreal} py, @code{mreal} pz, @code{mreal} ex, @code{mreal} ey, @code{mreal} ez, @code{char *}stl)
@end ifclear
Рисует 3d error box в точке @var{p}=@{@var{x}, @var{y}, @var{z}@} размером @var{e}=@{@var{ex}, @var{ey}, @var{ez}@} и стилем @var{stl}. Используйте NAN в компонентах @var{e} для уменьшения рисуемых элементов.
@end deftypefn

@anchor{line}
@deftypefn {Команда MGL} {} line @code{x1 y1 x2 y2} ['stl'='']
@deftypefnx {Команда MGL} {} line @code{x1 y1 z1 x2 y2 z2} ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Line (@code{mglPoint} p1, @code{mglPoint} p2, @code{char *}stl=@code{"B"}, @code{int}num=@code{2})
@deftypefnx {Функция С} @code{void} mgl_line (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{char *}stl, @code{int}num)
@end ifclear
Рисует геодезическую линию (декартовых координатах -- прямую) из точки @var{p1} в @var{p2} использую стиль линии @var{stl}. Параметр @var{num} определяет гладкость линии (число точек на линии). Если @var{num}=@code{2}, то рисуется прямая даже в криволинейных координатах (см. @ref{Curved coordinates}). Наоборот, для больших значений (например, =@code{100}) рисуется геодезическая линия (окружность в полярных координатах, парабола в параболических и т.д.). Линия рисуется даже если часть ее лежит вне диапазона осей координат.
@end deftypefn

@anchor{curve}
@deftypefn {Команда MGL} {} curve @code{x1 y1 dx1 dy1 x2 y2 dx2 dy2} ['stl'='']
@deftypefnx {Команда MGL} {} curve @code{x1 y1 z1 dx1 dy1 dz1 x2 y2 z2 dx2 dy2 dz2} ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Curve (@code{mglPoint} p1, @code{mglPoint} d1, @code{mglPoint} p2, @code{mglPoint} d2, @code{const char *}stl=@code{"B"}, @code{int} num=@code{100})
@deftypefnx {Функция С} @code{void} mgl_curve (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} dx1, @code{mreal} dy1, @code{mreal} dz1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} dx2, @code{mreal} dy2, @code{mreal} dz2, @code{const char *}stl, @code{int} num)
@end ifclear
Рисует кривую Безье из точки @var{p1} в @var{p2} используя стиль линии @var{stl}. Касательные в точках пропорциональны @var{d1}, @var{d2}. Параметр @var{num} определяет гладкость линии (число точек на линии). Если @var{num}=@code{2}, то рисуется прямая даже в криволинейных координатах (см. @ref{Curved coordinates}). Наоборот, для больших значений (например, =@code{100}) рисуется геодезическая линия (окружность в полярных координатах, парабола в параболических и т.д.). Кривая рисуется даже если часть ее лежит вне диапазона осей координат.
@end deftypefn

@anchor{face}
@deftypefn {Команда MGL} {} face @code{x1 y1 x2 y2 x3 y3 x4 y4} ['stl'='']
@deftypefnx {Команда MGL} {} face @code{x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4} ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Face (@code{mglPoint} p1, @code{mglPoint} p2, @code{mglPoint} p3, @code{mglPoint} p4, @code{const char *}stl=@code{"w"})
@deftypefnx {Функция С} @code{void} mgl_face (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} x3, @code{mreal} y3, @code{mreal} z3, @code{mreal} x4, @code{mreal} y4, @code{mreal} z4, @code{const char *}stl)
@end ifclear
Рисует заполненный четырехугольник (грань) с углами в точках @var{p1}, @var{p2}, @var{p3}, @var{p4} и цветом(-ами) @var{stl}. При этом цвет может быть один для всей грани, или различным если указаны все 4 цвета. Грань будет нарисована даже если часть ее лежит вне диапазона осей координат.
@end deftypefn

@anchor{rect}
@deftypefn {Команда MGL} {} rect @code{x1 y1 x2 y2} ['stl'='']
@deftypefnx {Команда MGL} {} rect @code{x1 y1 z1 x2 y2 z2} ['stl'='']
Рисует закрашенный прямоугольник (грань) с вершинами @{@var{x1}, @var{y1}, @var{z1}@} и @{@var{x2}, @var{y2}, @var{z2}@} цветом @var{stl}. При этом цвет может быть один для всей грани, или различным для разных вершин если указаны все 4 цвета. Грань будет нарисована даже если часть ее лежит вне диапазона осей координат.
@end deftypefn

@anchor{facex}
@anchor{facey}
@anchor{facez}
@deftypefn {Команда MGL} {} facex @code{x0 y0 z0 wy wz} ['stl'='' @code{d1=0 d2=0}]
@deftypefnx {Команда MGL} {} facey @code{x0 y0 z0 wx wz} ['stl'='' @code{d1=0 d2=0}]
@deftypefnx {Команда MGL} {} facez @code{x0 y0 z0 wx wy} ['stl'='' @code{d1=0 d2=0}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FaceX (@code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wy, @code{mreal} wz, @code{const char *}stl=@code{"w"}, @code{mreal} d1=@code{0}, @code{mreal} d2=@code{0})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FaceY (@code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wx, @code{mreal} wz, @code{const char *}stl=@code{"w"}, @code{mreal} d1=@code{0}, @code{mreal} d2=@code{0})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FaceZ (@code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wx, @code{mreal} wy, @code{const char *}stl=@code{"w"}, @code{mreal} d1=@code{0}, @code{mreal} d2=@code{0})
@deftypefnx {Функция С} @code{void} mgl_facex (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wy, @code{mreal} wz, @code{const char *}stl, @code{mreal} d1, @code{mreal} d2)
@deftypefnx {Функция С} @code{void} mgl_facey (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wx, @code{mreal} wz, @code{const char *}stl, @code{mreal} d1, @code{mreal} d2)
@deftypefnx {Функция С} @code{void} mgl_facez (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} wx, @code{mreal} wy, @code{const char *}stl, @code{mreal} d1, @code{mreal} d2)
@end ifclear
Рисует закрашенный прямоугольник (грань) перпендикулярно оси [x,y,z] в точке @{@var{x0}, @var{y0}, @var{z0}@} цветом @var{stl} и шириной @var{wx}, @var{wy}, @var{wz} вдоль соответствующего направления. При этом цвет может быть один для всей грани, или различным для разных вершин если указаны все 4 цвета. Параметры @var{d1}!=0, @var{d2}!=0 задают дополнительный сдвиг последней точки (т.е. рисуют четырехугольник). Грань будет нарисована даже если часть ее лежит вне диапазона осей координат.
@end deftypefn

@anchor{sphere}
@deftypefn {Команда MGL} {} sphere @code{x0 y0 r} ['col'='r']
@deftypefnx {Команда MGL} {} sphere @code{x0 y0 z0 r} ['col'='r']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Sphere (@code{mglPoint} p, @code{mreal} r, @code{const char *}stl=@code{"r"})
@deftypefnx {Функция С} @code{void} mgl_sphere (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} r, @code{const char *}stl)
@end ifclear
Рисует сферу радиуса @var{r} с центром в точке @var{p}=@{@var{x0}, @var{y0}, @var{z0}@} цветом @var{stl}.
@end deftypefn

@anchor{drop}
@deftypefn {Команда MGL} {} drop @code{x0 y0 dx dy r} ['col'='r' @code{sh=1 asp=1}]
@deftypefnx {Команда MGL} {} drop @code{x0 y0 z0 dx dy dz r} ['col'='r' @code{sh=1 asp=1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Drop (@code{mglPoint} p, @code{mglPoint} d, @code{mreal} r, @code{const char *}col=@code{"r"}, @code{mreal} shift=@code{1}, @code{mreal} ap=@code{1})
@deftypefnx {Функция С} @code{void} mgl_drop (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{mreal} r, @code{const char *}col, @code{mreal} shift, @code{mreal} ap)
@end ifclear
Рисует каплю радиуса @var{r} в точке @var{p} вытянутую вдоль направления @var{d} цветом @var{col}. Параметр @var{shift} определяет степень вытянутости: @samp{0} -- сфера, @samp{1} -- классическая капля. Параметр @var{ap} определяет относительную ширину капли (аналог "эллиптичности" для сферы).
@end deftypefn

@anchor{cone}
@deftypefn {Команда MGL} {} cone @code{x1 y1 z1 x2 y2 z2 r1} [@code{r2=-1} 'stl'='' @code{edge=off}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cone (@code{mglPoint} p1, @code{mglPoint} p2, @code{mreal} r1, @code{mreal} r2=@code{-1}, @code{const char *}stl=@code{"B"}, @code{bool} edge=@code{false})
@deftypefnx {Функция С} @code{void} mgl_cone (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} r1, @code{mreal} r2, @code{const char *}stl, @code{int} draw_edge)
@end ifclear
Рисует трубу (или усеченный конус если @var{edge}=@code{false}) между точками @var{p1}, @var{p2} с радиусами на концах @var{r1}, @var{r2}. Если @var{r2}<0, то полагается @var{r2}=@var{r1}. Цвет конуса задается строкой @var{stl}. Параметр @var{stl} может содержать:
@itemize @bullet
@item
@samp{@@} для рисования торцов;
@item
@samp{#} для сетчатой фигуры;
@item
@samp{t} для рисования цилиндра вместо конуса/призмы;
@item
@samp{4}, @samp{6}, @samp{8} для рисования квадратной, шестиугольной или восьмиугольной призмы вместо конуса.
@end itemize

@end deftypefn

@anchor{circle}
@deftypefn {Команда MGL} {} circle @code{x0 y0 r} ['col'='r']
@deftypefnx {Команда MGL} {} circle @code{x0 y0 z0 r} ['col'='r']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Circle (@code{mglPoint} p, @code{mreal} r, @code{const char *}stl=@code{"r"})
@end ifclear
Рисует круг радиуса @var{r} с центром в точке @var{p}=@{@var{x0}, @var{y0}, @var{z0}@} цветом @var{stl}. Если @var{col} содержит: @samp{#} то рисуется только граница, @samp{@@} то рисуется граница (вторым цветом из @var{col} или черными).
@end deftypefn

@anchor{ellipse}
@deftypefn {Команда MGL} {} ellipse @code{x1 y1 x2 y2 r} ['col'='r']
@deftypefnx {Команда MGL} {} ellipse @code{x1 y1 z1 x2 y2 z2 r} ['col'='r']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Ellipse (@code{mglPoint} p1, @code{mglPoint} p2, @code{mreal} r, @code{const char *}col=@code{"r"})
@deftypefnx {Функция С} @code{void} mgl_ellipse (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} r, @code{const char *}col)
@end ifclear
Рисует эллипс радиуса @var{r} с фокусами в точках @var{p1}, @var{p2} цветом @var{stl}. Если @var{col} содержит: @samp{#} то рисуется только граница, @samp{@@} то рисуется граница (вторым цветом из @var{col} или черными).
@end deftypefn

@anchor{rhomb}
@deftypefn {Команда MGL} {} rhomb @code{x1 y1 x2 y2 r} ['col'='r']
@deftypefnx {Команда MGL} {} rhomb @code{x1 y1 z1 x2 y2 z2 r} ['col'='r']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Rhomb (@code{mglPoint} p1, @code{mglPoint} p2, @code{mreal} r, @code{const char *}col=@code{"r"})
@deftypefnx {Функция С} @code{void} mgl_rhomb (@code{HMGL} gr, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} x2, @code{mreal} y2, @code{mreal} z2, @code{mreal} r, @code{const char *}col)
@end ifclear
Рисует ромб ширины @var{r} с вершинами в точках @var{p1}, @var{p2} цветом @var{stl}. Если @var{col} содержит: @samp{#} то рисуется только граница, @samp{@@} то рисуется граница (вторым цветом из @var{col} или черными). Если @var{col} содержит 3 цвета, то используется градиентная заливка.
@end deftypefn

@anchor{arc}
@deftypefn {Команда MGL} {} arc @code{x0 y0 x1 y1 a} ['col'='r']
@deftypefnx {Команда MGL} {} arc @code{x0 y0 z0 x1 y1 a} ['col'='r']
@deftypefnx {Команда MGL} {} arc @code{x0 y0 z0 xa ya za x1 y1 z1 a} ['col'='r']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Arc (@code{mglPoint} p0, @code{mglPoint} p1, @code{mreal} a, @code{const char *}col=@code{"r"})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Arc (@code{mglPoint} p0, @code{mglPoint} pa, @code{mglPoint} p1, @code{mreal} a, @code{const char *}col=@code{"r"})
@deftypefnx {Функция С} @code{void} mgl_arc (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} x1, @code{mreal} y1, @code{mreal} a, @code{const char *}col)
@deftypefnx {Функция С} @code{void} mgl_arc_ext (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} xa, @code{mreal} ya, @code{mreal} za, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{mreal} a, @code{const char *}col)
@end ifclear
Рисует дугу вокруг оси @var{pa} (по умолчанию вокруг оси z @var{pa}=@{0,0,1@}) с центром в @var{p0}, начиная с точки @var{p1}. Параметр @var{a} задает угол дуги в градусах. Строка @var{col} задает цвет дуги и тип стрелок на краях.
@end deftypefn

@anchor{polygon}
@deftypefn {Команда MGL} {} polygon @code{x0 y0 x1 y1 num} ['col'='r']
@deftypefnx {Команда MGL} {} polygon @code{x0 y0 z0 x1 y1 z1 num} ['col'='r']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Polygon (@code{mglPoint} p0, @code{mglPoint} p1, @code{int} num, @code{const char *}col=@code{"r"})
@deftypefnx {Функция С} @code{void} mgl_polygon (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{mreal} x1, @code{mreal} y1, @code{mreal} z1, @code{int} num, @code{const char *}col)
@end ifclear
Рисует правильный @var{num}-угольник с центром в @var{p0} с первой вершиной в @var{p1} цветом @var{col}. Если @var{col} содержит: @samp{#} то рисуется только граница, @samp{@@} то рисуется граница (вторым цветом из @var{col} или черными).
@c Если @var{col} содержит 3 цвета, то используется градиентная заливка.
@end deftypefn

@anchor{logo}
@deftypefn {Команда MGL} {} logo 'fname' [smooth=off]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Logo (@code{const char *}fname, @code{bool} smooth=@code{false}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Logo (@code{long} w, @code{long} h, @code{const unsigned char *}rgba, @code{bool} smooth=@code{false}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_logo (@code{HMGL} gr, @code{long} w, @code{long} h, @code{const unsigned char *}rgba, @code{bool} smooth, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_logo_file (@code{HMGL} gr, @code{const char *}fname, @code{bool} smooth, @code{const char *}opt)
@end ifclear
Draw bitmap (logo) along whole axis range, which can be changed by @ref{Command options}. Bitmap can be loaded from file or specified as RGBA values for pixels. Parameter @var{smooth} set to draw bitmap without or with color interpolation.
@end deftypefn



@anchor{symbol}
@deftypefn {Команда MGL} {} symbol @code{x y} 'id' ['fnt'='' @code{size=-1}]
@deftypefnx {Команда MGL} {} symbol @code{x y z} 'id' ['fnt'='' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Symbol (@code{mglPoint} p, @code{char} id, @code{const char *}fnt=@code{""}, @code{mreal} size=@code{-1})
@deftypefnx {Функция С} @code{void} mgl_symbol (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{char} id, @code{const char *}fnt, @code{mreal} size)
@end ifclear
Рисует определенный пользователем символ с именем @var{id} в точке @var{p} стилем @var{fnt}. Размер задается параметром @var{size} (по умолчанию @code{-1}). Строка @var{fnt}  может содержать цвет (до разделителя @samp{:}); стили @samp{a} или @samp{A} для вывода в абсолютной позиции (@{@var{x}, @var{y}@} полагаются в диапазоне [0,1]) относительно рисунка (для @samp{A}) или subplot/inplot (для @samp{a}); и стиль @samp{w} для рисования только контура символа.
@end deftypefn

@deftypefn {Команда MGL} {} symbol @code{x y dx dy} 'id' ['fnt'=':L' @code{size=-1}]
@deftypefnx {Команда MGL} {} symbol @code{x y z dx dy dz} 'id' ['fnt'=':L' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Symbol (@code{mglPoint} p, @code{mglPoint} d, @code{char} id, @code{const char *}fnt=@code{""}, @code{mreal} size=@code{-1})
@deftypefnx {Функция С} @code{void} mgl_symbol_dir (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{const char *}text, @code{const char *}fnt, @code{mreal} size)
@end ifclear
Аналогично предыдущему, но символ рисуется в повернутым в направлении @var{d}.
@end deftypefn

@anchor{addsymbol}
@deftypefn {Команда MGL} {} addsymbol 'id' xdat ydat
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} DefineSymbol (@code{char} id, @code{const mglDataA &}xdat, @code{const mglDataA &}ydat)
@deftypefnx {Функция С} @code{void} mgl_define_symbol (@code{HMGL} gr, @code{HCDT} xdat, @code{HCDT} ydat)
@end ifclear
Добавляет определенный пользователем символ с именем @var{id} и границей @{@var{xdat}, @var{ydat}@}. Значения @code{NAN} задают разрыв (скачок) граничной кривой.
@end deftypefn


@c ##################################################################
@external{}
@node Text printing, Axis and Colorbar, Primitives, MathGL core
@section Вывод текста
@nav{}
@ifclear UDAV
@cindex Puts
@cindex Putsw
@end ifclear
@cindex Text
@cindex fgets

Функции для вывода текста позволяют вывести строку текста в произвольном месте рисунка, в произвольном направлении и вдоль произвольной кривой. MathGL позволяет использовать произвольное начертание шрифта и многие ТеХ-ие команды (детальнее см. @ref{Font styles}). Все функции вывода текста имеют варианты для 8-bit строк (@code{char *}) и для Unicode строк (@code{wchar_t *}). В первом случае используется конверсия из текущей локали, т.е. иногда вам требуется явно указать локаль с помощью функции @code{setlocale()}. Аргумент @var{size} определяет размер текста: размер шрифта если положителен или относительный размер (=-@var{size}*@code{SetFontSize()}) если отрицателен. Начертание шрифта (STIX, arial, courier, times и др.) можно изменить с помощью функции LoadFont(). @xref{Font settings}.

Параметры шрифта задаются строкой, которая может содержать символы цвета @samp{wkrgbcymhRGBCYMHW} (см. @ref{Color styles}). Также после символа @samp{:} можно указать  символы стиля (@samp{rbiwou}) и/или выравнивания (@samp{LRCTV}). Стили шрифта: @samp{r} -- прямой, @samp{i} -- курсив, @samp{b} -- жирный, @samp{w} -- контурный, @samp{o} -- надчеркнутый, @samp{u} -- подчеркнутый. По умолчанию используется прямой шрифт. Типы выравнивания: @samp{L} -- по левому краю (по умолчанию), @samp{C} -- по центру, @samp{R} -- по правому краю, @samp{T} -- под текстом, @samp{V} -- по центру вертикально. Например, строка @samp{b:iC} соответствует курсиву синего цвета с выравниванием по центру. Начиная с MathGL версии 2.3, вы можете задать цветовой градиент для выводимой строки (см. @ref{Color scheme}).

Если строка содержит символы @samp{aA}, то текст выводится в абсолютных координатах (полагаются в диапазоне [0,1]). При этом используются координаты относительно рисунка (если указано @samp{A}) или относительно последнего subplot/inplot (если указано @samp{a}). Если строка содержит символ @samp{@@}, то вокруг текста рисуется прямоугольник.

@sref{Text features}

@anchor{text}
@deftypefn {Команда MGL} {} text @code{x y} 'text' ['fnt'='' @code{size=-1}]
@deftypefnx {Команда MGL} {} text @code{x y z} 'text' ['fnt'='' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Puts (@code{mglPoint} p, @code{const char *}text, @code{const char *}fnt=@code{":C"}, @code{mreal} size=@code{-1})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Putsw (@code{mglPoint} p, @code{const wchar_t *}text, @code{const char *}fnt=@code{":C"}, @code{mreal} size=@code{-1})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Puts (@code{mreal} x, @code{mreal} y, @code{const char *}text, @code{const char *}fnt=@code{":AC"}, @code{mreal} size=@code{-1})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Putsw (@code{mreal} x, @code{mreal} y, @code{const wchar_t *}text, @code{const char *}fnt=@code{":AC"}, @code{mreal} size=@code{-1})
@deftypefnx {Функция С} @code{void} mgl_puts (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{const char *}text, @code{const char *}fnt, @code{mreal} size)
@deftypefnx {Функция С} @code{void} mgl_putsw (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{const wchar_t *}text, @code{const char *}fnt, @code{mreal} size)
@end ifclear
Выводит строку @var{text} от точки @var{p} шрифтом определяемым строкой @var{fnt}. Размер шрифта задается параметром @var{size} (по умолчанию @code{-1}).
@end deftypefn

@deftypefn {Команда MGL} {} text @code{x y dx dy} 'text' ['fnt'=':L' @code{size=-1}]
@deftypefnx {Команда MGL} {} text @code{x y z dx dy dz} 'text' ['fnt'=':L' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Puts (@code{mglPoint} p, @code{mglPoint} d, @code{const char *}text, @code{const char *}fnt=@code{':L'}, @code{mreal} size=@code{-1})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Putsw (@code{mglPoint} p, @code{mglPoint} d, @code{const wchar_t *}text, @code{const char *}fnt=@code{':L'}, @code{mreal} size=@code{-1})
@deftypefnx {Функция С} @code{void} mgl_puts_dir (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{const char *}text, @code{const char *}fnt, @code{mreal} size)
@deftypefnx {Функция С} @code{void} mgl_putsw_dir (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{mreal} dx, @code{mreal} dy, @code{mreal} dz, @code{const wchar_t *}text, @code{const char *}fnt, @code{mreal} size)
@end ifclear
Выводит строку @var{text} от точки @var{p} вдоль направления @var{d}. Параметр @var{fnt} задает стиль текста и указывает выводить текст под линией (@samp{T}) или над ней (@samp{t}).
@end deftypefn

@anchor{fgets}
@deftypefn {Команда MGL} {} fgets @code{x y} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
@deftypefnx {Команда MGL} {} fgets @code{x y z} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
Выводит @var{n}-ую строку файла @var{fname} от точки @{@var{x},@var{y},@var{z}@} шрифтом @var{fnt} и размером @var{size}. По умолчанию используются параметры заданные командой @ref{font}.
@end deftypefn

@deftypefn {Команда MGL} {} text ydat 'text' ['fnt'='']
@deftypefnx {Команда MGL} {} text xdat ydat 'text' ['fnt'='' @code{size=-1 zval=nan}]
@deftypefnx {Команда MGL} {} text xdat ydat zdat 'text' ['fnt'='' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Text (@code{const mglDataA &}y, @code{const char *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Text (@code{const mglDataA &}y, @code{const wchar_t *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Text (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Text (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const wchar_t *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Text (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Text (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const wchar_t *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_text_y (@code{HMGL} gr, @code{HCDT} y, @code{const char *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_textw_y (@code{HMGL} gr, @code{HCDT} y, @code{const wchar_t *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_text_xy (@code{HCDT} x, @code{HCDT} y, @code{const char *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_textw_xy (@code{HCDT} x, @code{HCDT} y, @code{const wchar_t *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_text_xyz (@code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_textw_xyz (@code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const wchar_t *}text, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
Выводит строку @var{text} вдоль кривой @{@var{x}[i], @var{y}[i], @var{z}[i]@} шрифтом @var{fnt}. Строка @var{fnt} может содержать символы: @samp{t} для вывода текста под кривой (по умолчанию), или @samp{T} для вывода текста под кривой. Размеры по 1-ой размерности должны быть одинаковы для всех массивов @code{x.nx=y.nx=z.nx}. Если массив @var{x} не указан, то используется "автоматический" массив со значениями в диапазоне осей координат (см. @ref{Ranges (bounding box)}). Если массив @var{z} не указан, то используется минимальное значение оси z. Строка @var{opt} содержит опции команды (см. @ref{Command options}).
@end deftypefn

@c ##################################################################
@external{}
@node Axis and Colorbar, Legend, Text printing, MathGL core
@section Оси и Colorbar
@nav{}
@cindex Axis
@cindex Box
@cindex Grid
@cindex Colorbar
@cindex Label

Эти функции рисуют объекты для "измерения" типа осей координат, цветовой таблицы (colorbar), сетку по осям, обрамляющий параллелепипед и подписи по осям координат. См. также см. @ref{Axis settings}.

@anchor{axis}
@deftypefn {Команда MGL} {} axis ['dir'='xyz' 'stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Axis (@code{const char *}dir=@code{"xyz"}, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_axis (@code{HMGL} gr, @code{const char *}dir, @code{const char *}stl, @code{const char *}opt)
@end ifclear
Рисует оси координат и метки на них (см. @ref{Axis settings}) в направлениях @samp{xyz}, указанных строкой @var{dir}. Строка @var{dir} может содержать:
@itemize
@item @samp{xyz} для рисования соответствующих осей;
@item @samp{XYZ} для рисования соответствующих осей с метками с другой стороны;
@item @samp{~} или @samp{_} для осей без подписей;
@item @samp{U} для невращаемых подписей;
@item @samp{^} для инвертирования положения по умолчанию;
@item @samp{!} для отключения улучшения вида меток (см. @ref{tuneticks});
@item @samp{AKDTVISO} для вывода стрелки на конце оси;
@item @samp{a} для принудительной автоматической расстановки меток;
@item @samp{:} для рисования линий через точку (0,0,0);
@item @samp{f} для вывода чисел в фиксированном формате;
@item @samp{E} для вывода @samp{E} вместо @samp{e};
@item @samp{F} для вывода в формате LaTeX;
@item @samp{+} для вывода @samp{+} для положительных чисел;
@item @samp{-} для вывода обычного @samp{-};
@item @samp{0123456789} для задания точности при выводе чисел.
@end itemize
Стиль меток и оси(ей) задается строкой @var{stl}. Опция @code{value} задает угол вращения меток оси. @sref{Axis and ticks}
@end deftypefn

@anchor{colorbar}
@deftypefn {Команда MGL} {} colorbar ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Colorbar (@code{const char *}sch=@code{""})
@deftypefnx {Функция С} @code{void} mgl_colorbar (@code{HMGL} gr, @code{const char *}sch)
@end ifclear
Рисует полосу соответствия цвета и числовых значений (colorbar) для цветовой схемы @var{sch} (используется текущая для @code{sch=""}) с краю от графика. Строка @var{sch} также может содержать:
@itemize
@item @samp{<>^_} для расположения слева, справа, сверху или снизу соответственно;
@item @samp{I} для расположения около осей (по умолчанию, на краях subplot);
@item @samp{A} для использования абсолютных координат (относительно рисунка);
@item @samp{~} для colorbar без подписей;
@item @samp{!} для отключения улучшения вида меток (см. @ref{tuneticks});
@item @samp{a} для принудительной автоматической расстановки меток;
@item @samp{f} для вывода чисел в фиксированном формате;
@item @samp{E} для вывода @samp{E} вместо @samp{e};
@item @samp{F} для вывода в формате LaTeX;
@item @samp{+} для вывода @samp{+} для положительных чисел;
@item @samp{-} для вывода обычного @samp{-};
@item @samp{0123456789} для задания точности при выводе чисел.
@end itemize
@sref{Colorbars}
@end deftypefn

@deftypefn {Команда MGL} {} colorbar vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Colorbar (@code{const mglDataA &}v, @code{const char *}sch=@code{""})
@deftypefnx {Функция С} @code{void} mgl_colorbar_val (@code{HMGL} gr, @code{HCDT} v, @code{const char *}sch)
@end ifclear
Аналогично предыдущему, но для цветовой схемы без сглаживания с заданными значениями @var{v}. @sref{contd sample}
@end deftypefn

@deftypefn {Команда MGL} {} colorbar 'sch' @code{x y [w=1 h=1]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Colorbar (@code{const char *}sch, @code{mreal} x, @code{mreal} y, @code{mreal} w=@code{1}, @code{mreal} h=@code{1})
@deftypefnx {Функция С} @code{void} mgl_colorbar_ext (@code{HMGL} gr, @code{const char *}sch, @code{mreal} x, @code{mreal} y, @code{mreal} w, @code{mreal} h)
@end ifclear
Аналогично первому, но в произвольном месте графика @{@var{x}, @var{y}@} (полагаются в диапазоне [0,1]). Параметры @var{w}, @var{h} задают относительную ширину и высоту colorbar.
@end deftypefn

@deftypefn {Команда MGL} {} colorbar vdat 'sch' @code{x y [w=1 h=1]}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Colorbar (@code{const mglDataA &}v, @code{const char *}sch, @code{mreal} x, @code{mreal} y, @code{mreal} w=@code{1}, @code{mreal} h=@code{1})
@deftypefnx {Функция С} @code{void} mgl_colorbar_val_ext (@code{HMGL} gr, @code{HCDT} v, @code{const char *}sch, @code{mreal} x, @code{mreal} y, @code{mreal} w, @code{mreal} h)
@end ifclear
Аналогично предыдущему, но для цветовой схемы @var{sch} без сглаживания с заданными значениями @var{v}. @sref{contd sample}
@end deftypefn

@anchor{grid}
@deftypefn {Команда MGL} {} grid ['dir'='xyz' 'pen'='B']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Grid (@code{const char *}dir=@code{"xyz"}, @code{const char *}pen=@code{"B"}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_axis_grid (@code{HMGL} gr, @code{const char *}dir, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Рисует линии сетки в направлениях перпендикулярным @var{dir}. Если @var{dir} содержит @samp{!}, то линии рисуются также и для координат под-меток. Шаг сетки такой же как у меток осей координат. Стиль линий задается параметром @var{pen} (по умолчанию -- сплошная темно синяя линия @samp{B-}).
@end deftypefn

@anchor{box}
@deftypefn {Команда MGL} {} box ['stl'='k' @code{ticks=on}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Box (@code{const char *}col=@code{""}, @code{bool} ticks=@code{true})
@deftypefnx {Функция С} @code{void} mgl_box (@code{HMGL} gr)
@deftypefnx {Функция С} @code{void} mgl_box_str (@code{HMGL} gr, @code{const char *}col, @code{int} ticks)
@end ifclear
Рисует ограничивающий параллелепипед цветом @var{col}. Если @var{col} содержит @samp{@@}, то рисуются закрашенные задние грани. При этом первый цвет используется для граней (по умолчанию светло жёлтый), а последний для рёбер и меток.
@end deftypefn

@anchor{xlabel}
@anchor{ylabel}
@anchor{zlabel}
@anchor{tlabel}
@anchor{clabel}
@deftypefn {Команда MGL} {} xlabel 'text' [@code{pos=1}]
@deftypefnx {Команда MGL} {} ylabel 'text' [@code{pos=1}]
@deftypefnx {Команда MGL} {} zlabel 'text' [@code{pos=1}]
@deftypefnx {Команда MGL} {} tlabel 'text' [@code{pos=1}]
@deftypefnx {Команда MGL} {} clabel 'text' [@code{pos=1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Label (@code{char} dir, @code{const char *}text, @code{mreal} pos=@code{1}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Label (@code{char} dir, @code{const wchar_t *}text, @code{mreal} pos=@code{1}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_label (@code{HMGL} gr, @code{char} dir, @code{const char *}text, @code{mreal} pos, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_labelw (@code{HMGL} gr, @code{char} dir, @code{const wchar_t *}text, @code{mreal} pos, @code{const char *}opt)
@end ifclear
Выводит подпись @var{text} для оси @var{dir}=@samp{x},@samp{y},@samp{z},@samp{t},@samp{c}, где @samp{t} -- ``тернарная'' ось @math{t=1-x-y}; @samp{c} -- для цвета (следует вызывать после @ref{colorbar}). Параметр @var{pos} задает положение подписи: при @var{pos}=0 -- по центру оси, при @var{pos}>0 -- около максимальных значений, при @var{pos}<0 -- около минимальных значений. Опция @code{value} задает дополнительный сдвиг текста. @xref{Text printing}.
@end deftypefn

@c ##################################################################
@external{}
@node Legend, 1D plotting, Axis and Colorbar, MathGL core
@section Легенда
@nav{}
@cindex Legend
@cindex AddLegend
@cindex ClearLegend
@cindex SetLegendBox
@cindex SetLegendMarks

Эти функции обеспечивают рисование легенды графика (полезно для @ref{1D plotting}). Запись в легенде состоит из двух строк: одна для стиля линии и маркеров, другая с текстом описания (с включенным разбором TeX-их команд). Можно использовать непосредственно массивы строк, или накопление во внутренние массивы с помощью функции AddLegend() с последующим отображением. Положение легенды можно задать автоматически или вручную. Параметры @var{fnt} и @var{size} задают стиль и размер шрифта (см. @ref{Font settings}). Опция @code{value} задает зазор между примером линии и текстом (по умолчанию 0.1). Опция @code{size} задает размер текста. Если стиль линии пустой, то соответствующий текст печатается без отступа. Строка @var{fnt} может содержать:
@itemize @bullet
@item
стиль текста для записей;
@item
@samp{A} для расположения относительно всего рисунка, а не текущего subplot;
@item
@samp{^} для размещения снаружи от указанных координат;
@item
@samp{#} для вывода прямоугольника вокруг легенды;
@item
@samp{-} для горизонтального расположения записей;
@item
цвета для заливки (1-ый), для границы (2-ой) и для текста записей (3-ий). Если указано меньше трех цветов, то цвет границы черный (для 2 и менее цветов), и цвет заливки белый (для 1 и менее цвета).
@end itemize
@sref{Legend sample}

@anchor{legend}
@deftypefn {Команда MGL} {} legend [@code{pos=3} 'fnt'='#']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Legend (@code{int} pos=@code{0x3}, @code{const char *}fnt=@code{"#"}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_legend (@code{HMGL} gr, @code{int} pos, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
Рисует легенду из накопленных записей шрифтом @var{fnt}. Параметр @var{pos} задает положение легенды: @samp{0} -- в нижнем левом углу, @samp{1} -- нижнем правом углу, @samp{2} -- верхнем левом углу, @samp{3} -- верхнем правом углу (по умолчанию). Опция @code{value} задает зазор между примером линии и текстом (по умолчанию 0.1).
@end deftypefn

@deftypefn {Команда MGL} {} legend @code{x y} ['fnt'='#']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Legend (@code{mreal} x, @code{mreal} y, @code{const char *}fnt=@code{"#"}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_legend_pos (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
Рисует легенду из накопленных записей шрифтом @var{fnt}. Положение легенды задается параметрами @var{x}, @var{y}, которые полагаются нормированными в диапазоне [0,1]. Опция @code{value} задает зазор между примером линии и текстом (по умолчанию 0.1).
@end deftypefn

@anchor{addlegend}
@deftypefn {Команда MGL} {} addlegend 'text' 'stl'
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} AddLegend (@code{const char *}text, @code{const char *}style)
@deftypefnx {Метод класса @code{mglGraph}} @code{void} AddLegend (@code{const wchar_t *}text, @code{const char *}style)
@deftypefnx {Функция С} @code{void} mgl_add_legend (@code{HMGL} gr, @code{const char *}text, @code{const char *}style)
@deftypefnx {Функция С} @code{void} mgl_add_legendw (@code{HMGL} gr, @code{const wchar_t *}text, @code{const char *}style)
@end ifclear
Добавляет описание @var{text} кривой со стилем @var{style} (см. @ref{Line styles}) во внутренний массив записей легенды.
@end deftypefn

@anchor{clearlegend}
@deftypefn {Команда MGL} {} clearlegend
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ClearLegend ()
@deftypefnx {Функция С} @code{void} mgl_clear_legend (@code{HMGL} gr)
@end ifclear
Очищает внутренний массив записей легенды.
@end deftypefn

@anchor{legendmarks}
@deftypefn {Команда MGL} {} legendmarks @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetLegendMarks (@code{int} num)
@deftypefnx {Функция С} @code{void} mgl_set_legend_marks (@code{HMGL} gr, @code{int} num)
@end ifclear
Задает число маркеров в легенде. По умолчанию используется 1 маркер.
@end deftypefn

@c ##################################################################
@external{}
@node 1D plotting, 2D plotting, Legend, MathGL core
@section 1D графики
@nav{}
@cindex Plot
@cindex Radar
@cindex Tens
@cindex Area
@cindex Region
@cindex Stem
@cindex Bars
@cindex Barh
@cindex Chart
@cindex Step
@cindex Torus
@cindex Tube
@cindex Mark
@cindex TextMark
@cindex Error
@cindex BoxPlot
@cindex Candle
@cindex Tape
@cindex Label
@cindex Cones

Эти функции строят графики для одномерных (1D) массивов. Одномерными считаются массивы, зависящие только от одного параметра (индекса) подобно кривой в параметрической форме @{x(i),y(i),z(i)@}, i=1...n. По умолчанию (если отсутствуют) значения @var{x}[i] равно распределены в диапазоне оси х, и @var{z}[i] равно минимальному значению оси z. Графики рисуются для каждой строки массива данных если он двумерный. Размер по 1-ой координате @strong{должен быть одинаков} для всех массивов @code{x.nx=y.nx=z.nx}.

Строка @var{pen} задает цвет и стиль линии и маркеров (см. @ref{Line styles}). По умолчанию (@code{pen=""}) рисуется сплошная линия с текущим цветом из палитры (см. @ref{Palette and colors}). Символ @samp{!} в строке задает использование нового цвета из палитры для каждой точки данных (не для всей кривой, как по умолчанию). Строка @var{opt} задает опции графика (см. @ref{Command options}).

@anchor{plot}
@deftypefn {Команда MGL} {} plot ydat ['stl'='']
@deftypefnx {Команда MGL} {} plot xdat ydat ['stl'='']
@deftypefnx {Команда MGL} {} plot xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Plot (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Plot (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Plot (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_plot (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_plot_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_plot_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют ломанную линию по точкам @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Если @var{pen} содержит @samp{a}, то рисуются и сегменты между точками вне диапазона осей координат. Если @var{pen} содержит @samp{~}, то число сегментов уменьшается для квази-линейных участков. См. также @ref{area}, @ref{step}, @ref{stem}, @ref{tube}, @ref{mark}, @ref{error}, @ref{belt}, @ref{tens}, @ref{tape}, @ref{meshnum}. @sref{plot sample}
@end deftypefn

@anchor{radar}
@deftypefn {Команда MGL} {} radar adat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Radar (@code{const mglDataA &}a, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_radar (@code{HMGL} gr, @code{HCDT} a, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют radar chart, представляющий собой ломанную с вершинами на радиальных линиях (типа ломанной в полярных координатах). Параметр @code{value} в опциях @var{opt} задает дополнительный сдвиг данных (т.е. использование @var{a}+@code{value} вместо @var{a}). Если @var{pen} содержит @samp{#}, то рисуется "сетка" (радиальные линии). Если @var{pen} содержит @samp{a}, то рисуются и сегменты между точками вне диапазона осей координат. См. также @ref{plot}, @ref{meshnum}. @sref{radar sample}
@end deftypefn

@anchor{step}
@deftypefn {Команда MGL} {} step ydat ['stl'='']
@deftypefnx {Команда MGL} {} step xdat ydat ['stl'='']
@deftypefnx {Команда MGL} {} step xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Step (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Step (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Step (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_step (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_step_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_step_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют ступеньки для точек массива. Если @var{x}.nx>@var{y}.nx, то массив @var{x} задает границы ступенек, а не их конец. См. также @ref{plot}, @ref{stem}, @ref{tile}, @ref{boxs}, @ref{meshnum}. @sref{step sample}
@end deftypefn

@anchor{tens}
@deftypefn {Команда MGL} {} tens ydat cdat ['stl'='']
@deftypefnx {Команда MGL} {} tens xdat ydat cdat ['stl'='']
@deftypefnx {Команда MGL} {} tens xdat ydat zdat cdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tens (@code{const mglDataA &}y, @code{const mglDataA &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tens (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tens (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_tens (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tens_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tens_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют ломанную линию по точкам с цветом, определяемым массивом @var{c} (типа графика натяжений). Строка @var{pen} задает цветовую схему (см. @ref{Color scheme}) и стиль линий и/или маркеров (см. @ref{Line styles}). Если @var{pen} содержит @samp{a}, то рисуются и сегменты между точками вне диапазона осей координат. Если @var{pen} содержит @samp{~}, то число сегментов уменьшается для квази-линейных участков. См. также @ref{plot}, @ref{mesh}, @ref{fall}, @ref{meshnum}. @sref{tens sample}
@end deftypefn

@anchor{tape}
@deftypefn {Команда MGL} {} tape ydat ['stl'='']
@deftypefnx {Команда MGL} {} tape xdat ydat ['stl'='']
@deftypefnx {Команда MGL} {} tape xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tape (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tape (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tape (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_tape (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tape_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tape_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют ленты, которые вращаются вокруг кривой @{@var{x}[i], @var{y}[i], @var{z}[i]@} как её нормали. Начальная лента(ы) выбираются в плоскости x-y (для @samp{x} в @var{pen}) и/или y-z (для @samp{x} в @var{pen}). Ширина лент пропорциональна @ref{barwidth}, а также может быть изменена опцией @code{value}. См. также @ref{plot}, @ref{flow}, @ref{barwidth}. @sref{tape sample}
@end deftypefn

@anchor{area}
@deftypefn {Команда MGL} {} area ydat ['stl'='']
@deftypefnx {Команда MGL} {} area xdat ydat ['stl'='']
@deftypefnx {Команда MGL} {} area xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Area (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Area (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Area (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_area (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_area_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_area_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют ломанную линию между точками и закрашивает её вниз до плоскости осей координат. Градиентная заливка используется если число цветов равно удвоенному число кривых. Если @var{pen} содержит @samp{#}, то рисуется только каркас. Если @var{pen} содержит @samp{a}, то рисуются и сегменты между точками вне диапазона осей координат. См. также @ref{plot}, @ref{bars}, @ref{stem}, @ref{region}. @sref{area sample}
@end deftypefn

@anchor{region}
@deftypefn {Команда MGL} {} region ydat1 ydat2 ['stl'='']
@deftypefnx {Команда MGL} {} region xdat ydat1 ydat2 ['stl'='']
@deftypefnx {Команда MGL} {} region xdat1 ydat1 xdat2 ydat2 ['stl'='']
@deftypefnx {Команда MGL} {} region xdat1 ydat1 zdat1 xdat2 ydat2 zdat2 ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Region (@code{const mglDataA &}y1, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Region (@code{const mglDataA &}x, @code{const mglDataA &}y1, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Region (@code{const mglDataA &}x1, @code{const mglDataA &}y1, @code{const mglDataA &}x2, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Region (@code{const mglDataA &}x1, @code{const mglDataA &}y1, @code{const mglDataA &}z1, @code{const mglDataA &}x2, @code{const mglDataA &}y2, @code{const mglDataA &}z2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_region (@code{HMGL} gr, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_region_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_region_3d (@code{HMGL} gr, @code{HCDT} x1, @code{HCDT} y1, @code{HCDT} z1, @code{HCDT} x2, @code{HCDT} y2, @code{HCDT} z2, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции закрашивают область между 2 кривыми. Градиентная заливка используется если число цветов равно удвоенному число кривых. Если в 2d версии @var{pen} содержит @samp{i}, то закрашивается только область y1<y<y2, в противном случае будет закрашена и область y2<y<y1. Если @var{pen} содержит @samp{#}, то рисуется только каркас. Если @var{pen} содержит @samp{a}, то рисуются и сегменты между точками вне диапазона осей координат. См. также @ref{area}, @ref{bars}, @ref{stem}. @sref{region sample}
@end deftypefn

@anchor{stem}
@deftypefn {Команда MGL} {} stem ydat ['stl'='']
@deftypefnx {Команда MGL} {} stem xdat ydat ['stl'='']
@deftypefnx {Команда MGL} {} stem xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Stem (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Stem (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Stem (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_stem (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_stem_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_stem_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют вертикальные линии из точек до плоскости осей координат. См. также @ref{area}, @ref{bars}, @ref{plot}, @ref{mark}. @sref{stem sample}
@end deftypefn

@anchor{bars}
@deftypefn {Команда MGL} {} bars ydat ['stl'='']
@deftypefnx {Команда MGL} {} bars xdat ydat ['stl'='']
@deftypefnx {Команда MGL} {} bars xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Bars (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Bars (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Bars (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_bars (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_bars_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_bars_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют вертикальные полосы (прямоугольники) из точек до плоскости осей координат. Строка @var{pen} может содержать:
@itemize @bullet
@item
@samp{a} для вывода линий одной поверх другой (как при суммировании);
@item
@samp{f} для определения кумулятивного эффекта последовательности положительных и отрицательных значений (график типа waterfall);
@item
@samp{F} для использования одинаковой (минимальной) ширины полосок;
@item
@samp{<}, @samp{^} or @samp{>} для выравнивания полосок влево, вправо или центрирования относительно их координат.
@end itemize
Можно использовать разные цвета для положительных и отрицательных значений если число указанных цветов равно удвоенному числу кривых для построения. Если @var{x}.nx>@var{y}.nx, то массив @var{x} задает границы полос, а не их центр. См. также @ref{barh}, @ref{cones}, @ref{area}, @ref{stem}, @ref{chart}, @ref{barwidth}. @sref{bars sample}
@end deftypefn

@anchor{barh}
@deftypefn {Команда MGL} {} barh vdat ['stl'='']
@deftypefnx {Команда MGL} {} barh ydat vdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Barh (@code{const mglDataA &}v, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Barh (@code{const mglDataA &}y, @code{const mglDataA &}v, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_barh (@code{HMGL} gr, @code{HCDT} v, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_barh_xy (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} v, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют горизонтальные полосы (прямоугольники) из точек до плоскости осей координат. Строка @var{pen} может содержать:
@itemize @bullet
@item
@samp{a} для вывода линий одной поверх другой (как при суммировании);
@item
@samp{f} для определения кумулятивного эффекта последовательности положительных и отрицательных значений (график типа waterfall);
@item
@samp{F} для использования одинаковой (минимальной) ширины полосок;
@item
@samp{<}, @samp{^} or @samp{>} для выравнивания полосок влево, вправо или центрирования относительно их координат.
@end itemize
Можно использовать разные цвета для положительных и отрицательных значений если число указанных цветов равно удвоенному числу кривых для построения. Если @var{x}.nx>@var{y}.nx, то массив @var{x} задает границы полос, а не их центр. См. также @ref{bars}, @ref{barwidth}. @sref{barh sample}
@end deftypefn

@anchor{cones}
@deftypefn {Команда MGL} {} cones ydat ['stl'='']
@deftypefnx {Команда MGL} {} cones xdat ydat ['stl'='']
@deftypefnx {Команда MGL} {} cones xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cones (@code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cones (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cones (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_cones (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cones_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cones_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют конусы из точек до плоскости осей координат. Если строка @var{pen} содержит символ @samp{a}, то линии рисуются одна поверх другой. Можно использовать разные цвета для положительных и отрицательных значений если число указанных цветов равно удвоенному числу кривых для построения. Параметр @var{pen} может содержать:
@itemize @bullet
@item
@samp{@@} для рисования торцов;
@item
@samp{#} для сетчатой фигуры;
@item
@samp{t} для рисования цилиндра вместо конуса/призмы;
@item
@samp{4}, @samp{6}, @samp{8} для рисования квадратной, шестиугольной или восьмиугольной призмы вместо конуса;
@item
@samp{<}, @samp{^} или @samp{>} для выравнивания конусов влево, вправо или по центру относительно их координат.
@end itemize
См. также @ref{bars}, @ref{cone}, @ref{barwidth}. @sref{cones sample}
@end deftypefn



@anchor{chart}
@deftypefn {Команда MGL} {} chart adat ['col'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Chart (@code{const mglDataA &}a, @code{const char *}col=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_chart (@code{HMGL} gr, @code{HCDT} a, @code{const char *}col, @code{const char *}opt)
@end ifclear
Рисует цветные полосы (пояса) для массива данных @var{a}. Число полос равно числу строк @var{a} (равно @var{a.ny}). Цвет полос поочерёдно меняется из цветов указанных в @var{col} или в палитре (см. @ref{Palette and colors}). Пробел в цветах соответствует прозрачному "цвету", т.е. если @var{col} содержит пробел(ы), то соответствующая полоса не рисуется. Ширина полосы пропорциональна значению элемента в @var{a}. График строится только для массивов не содержащих отрицательных значений. Если строка @var{col} содержит @samp{#}, то рисуется также чёрная граница полос. График выглядит лучше в (после вращения системы координат) и/или в полярной системе координат (становится Pie chart). @sref{chart sample}
@end deftypefn

@anchor{boxplot}
@deftypefn {Команда MGL} {} boxplot adat ['stl'='']
@deftypefnx {Команда MGL} {} boxplot xdat adat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} BoxPlot (@code{const mglDataA &}a, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} BoxPlot (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_boxplot (@code{HMGL} gr, @code{HCDT} a, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_boxplot_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют boxplot (называемый также как box-and-whisker diagram или как "ящик с усами") в точках @var{x}[i] на плоскости @var{z} = @var{zVal} (по умолчанию @var{z} равно минимальному значению оси z). Это график, компактно изображающий распределение вероятностей @var{a}[i,j] (минимум, нижний квартиль (Q1), медиана (Q2), верхний квартиль (Q3) и максимум) вдоль второго (j-го) направления. Если @var{pen} содержит @samp{<}, @samp{^} или @samp{>}, то полоски будут выровнены влево, вправо или центрированы относительно их координат. См. также @ref{plot}, @ref{error}, @ref{bars}, @ref{barwidth}. @sref{boxplot sample}
@end deftypefn

@anchor{candle}
@deftypefn {Команда MGL} {} candle vdat1 ['stl'='']
@deftypefnx {Команда MGL} {} candle vdat1 vdat2 ['stl'='']
@deftypefnx {Команда MGL} {} candle vdat1 ydat1 ydat2 ['stl'='']
@deftypefnx {Команда MGL} {} candle vdat1 vdat2 ydat1 ydat2 ['stl'='']
@deftypefnx {Команда MGL} {} candle xdat vdat1 vdat2 ydat1 ydat2 ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Candle (@code{const mglDataA &}v1, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Candle (@code{const mglDataA &}v1, @code{const mglDataA &}v2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Candle (@code{const mglDataA &}v1, @code{const mglDataA &}y1, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Candle (@code{const mglDataA &}v1, @code{const mglDataA &}v2, @code{const mglDataA &}y1, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Candle (@code{const mglDataA &}x, @code{const mglDataA &}v1, @code{const mglDataA &}v2, @code{const mglDataA &}y1, @code{const mglDataA &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_candle (@code{HMGL} gr, @code{HCDT} v1, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_candle_yv (@code{HMGL} gr, @code{HCDT} v1, @code{HCDT} v2, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_candle_xyv (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} v1, @code{HCDT} v2, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют candlestick chart в точках @var{x}[i]. Этот график показывает прямоугольником ("свечой") диапазон изменения величины. Прозрачная (белая) свеча соответствует росту величины @var{v1}[i]<@var{v2}[i], чёрная -- уменьшению. "Тени" показывают минимальное @var{y1} и максимальное @var{y2} значения. Если @var{v2} отсутствует, то он определяется как @var{v2}[i]=@var{v1}[i+1]. Можно использовать разные цвета для растущих и падающих дней если число указанных цветов равно удвоенному числу кривых для построения. Если @var{pen} содержит @samp{#}, то прозрачная свеча будет использована и при 2-цветной схеме. См. также @ref{plot}, @ref{bars}, @ref{ohlc}, @ref{barwidth}. @sref{candle sample}
@end deftypefn

@anchor{ohlc}
@deftypefn {Команда MGL} {} ohlc odat hdat ldat cdat ['stl'='']
@deftypefnx {Команда MGL} {} ohlc xdat odat hdat ldat cdat ['stl'='']
@ifclear UDAV
@deftypefnx {MМетод класса @code{mglGraph}} @code{void} OHLC (@code{const mglDataA &}o, @code{const mglDataA &}h, @code{const mglDataA &}l, @code{const mglDataA &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} OHLC (@code{const mglDataA &}x, @code{const mglDataA &}o, @code{const mglDataA &}h, @code{const mglDataA &}l, @code{const mglDataA &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_ohlc (@code{HMGL} gr, @code{HCDT} o, @code{HCDT} h, @code{HCDT} l, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_ohlc_x (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} o, @code{HCDT} h, @code{HCDT} l, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют Open-High-Low-Close диаграмму. Этот график содержит вертикальные линии между максимальным @var{h} и минимальным @var{l} значениями, и горизонтальные линии перед/после вертикальной линии для начального @var{o} и конечного @var{c} значений процесса (обычно цены). Можно использовать разные цвета для растущих и падающих дней если число указанных цветов равно удвоенному числу кривых для построения. См. также @ref{candle}, @ref{plot}, @ref{barwidth}. @sref{ohlc sample}
@end deftypefn


@anchor{error}
@deftypefn {Команда MGL} {} error ydat yerr ['stl'='']
@deftypefnx {Команда MGL} {} error xdat ydat yerr ['stl'='']
@deftypefnx {Команда MGL} {} error xdat ydat xerr yerr ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Error (@code{const mglDataA &}y, @code{const mglDataA &}ey, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Error (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ey, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Error (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ex, @code{const mglDataA &}ey, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_error (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} ey, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_error_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ey, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_error_exy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ex, @code{HCDT} ey, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют размер ошибки @{@var{ex}[i], @var{ey}[i]@} в точках @{@var{x}[i], @var{y}[i]@} на плоскости @var{z} = @var{zVal} (по умолчанию @var{z} равно минимальному значению оси z). Такой график полезен для отображения ошибки эксперимента, вычислений и пр. Если @var{pen} содержит @samp{@@}, то будут использованы большие полупрозрачные маркеры. См. также @ref{plot}, @ref{mark}. @sref{error sample}
@end deftypefn

@anchor{mark}
@deftypefn {Команда MGL} {} mark ydat rdat ['stl'='']
@deftypefnx {Команда MGL} {} mark xdat ydat rdat ['stl'='']
@deftypefnx {Команда MGL} {} mark xdat ydat zdat rdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Mark (@code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Mark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Mark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_mark_y (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_mark_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_mark_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют маркеры размером @var{r}[i]*@ref{marksize} (см. @ref{Default sizes}) в точках @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Для рисования маркеров одинакового размера можно использовать функцию @ref{plot} с невидимой линией (со стилем содержащим @samp{ }). Для маркеров с размером как у координат можно использовать @ref{error} со стилем @samp{@@}. См. также @ref{plot}, @ref{textmark}, @ref{error}, @ref{stem}, @ref{meshnum}. @sref{mark sample}
@end deftypefn

@anchor{textmark}
@deftypefn {Команда MGL} {} textmark ydat 'txt' ['stl'='']
@deftypefnx {Команда MGL} {} textmark ydat rdat 'txt' ['stl'='']
@deftypefnx {Команда MGL} {} textmark xdat ydat rdat 'txt' ['stl'='']
@deftypefnx {Команда MGL} {} textmark xdat ydat zdat rdat 'txt' ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}y, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}y, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}y, @code{const mglDataA &}r, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}r, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TextMark (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_textmark (@code{HMGL} gr, @code{HCDT} y, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_textmarkw (@code{HMGL} gr, @code{HCDT} y, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_textmark_yr (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_textmarkw_yr (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_textmark_xyr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_textmarkw_xyr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_textmark_xyzr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_textmarkw_xyzr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
Функции рисуют текст @var{txt} как маркер с размером пропорциональным @var{r}[i]*@var{marksize} в точках @{@var{x}[i], @var{y}[i], @var{z}[i]@}. См. также @ref{plot}, @ref{mark}, @ref{stem}, @ref{meshnum}. @sref{textmark sample}
@end deftypefn

@anchor{label}
@deftypefn {Команда MGL} {} label ydat 'txt' ['stl'='']
@deftypefnx {Команда MGL} {} label xdat ydat 'txt' ['stl'='']
@deftypefnx {Команда MGL} {} label xdat ydat zdat 'txt' ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Label (@code{const mglDataA &}y, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Label (@code{const mglDataA &}y, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Label (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Label (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Label (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Label (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_label (@code{HMGL} gr, @code{HCDT} y, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_labelw (@code{HMGL} gr, @code{HCDT} y, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_label_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_labelw_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_label_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_labelw_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
Функции выводят текстовую строку @var{txt} в точках @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Если строка @var{txt} содержит @samp{%x}, @samp{%y}, @samp{%z} или @samp{%n}, то они будут заменены на значения соответствующих координат или на номер точки. Строка @var{fnt} может содержать:
@itemize
@item стиль текста @ref{Font styles};
@item @samp{f} для вывода чисел в фиксированном формате;
@item @samp{E} для вывода @samp{E} вместо @samp{e};
@item @samp{F} для вывода в формате LaTeX;
@item @samp{+} для вывода @samp{+} для положительных чисел;
@item @samp{-} для вывода обычного @samp{-};
@item @samp{0123456789} для задания точности при выводе чисел.
@end itemize
См. также @ref{plot}, @ref{mark}, @ref{textmark}, @ref{table}. @sref{label sample}
@end deftypefn

@anchor{table}
@deftypefn {Команда MGL} {} table vdat 'txt' ['stl'='#']
@deftypefnx {Команда MGL} {} table x y vdat 'txt' ['stl'='#']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Table (@code{const mglDataA &}val, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Table (@code{const mglDataA &}val, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Table (@code{mreal} x, @code{mreal} y, @code{const mglDataA &}val, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Table (@code{mreal} x, @code{mreal} y, @code{const mglDataA &}val, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_table (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{HCDT} val, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tablew (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{HCDT} val, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
Рисует таблицу значений массива @var{val} с заголовками @var{txt} (разделенными символом новой строки @samp{\n}) в точке @{@var{x}, @var{y}@} (по умолчанию @{0,0@}) относительно текущего subplot. Строка @var{fnt} может содержать:
@itemize
@item стиль текста @ref{Font styles};
@item @samp{#} для рисования границ ячеек;
@item @samp{=} для одинаковой ширины всех ячеек;
@item @samp{|} для ограничения ширины таблицы шириной subplot (эквивалентно опции @samp{value 1});
@item @samp{f} для вывода чисел в фиксированном формате;
@item @samp{E} для вывода @samp{E} вместо @samp{e};
@item @samp{F} для вывода в формате LaTeX;
@item @samp{+} для вывода @samp{+} для положительных чисел;
@item @samp{-} для вывода обычного @samp{-};
@item @samp{0123456789} для задания точности при выводе чисел.
@end itemize
Опция @code{value} задает ширину таблицы (по умолчанию 1). См. также @ref{plot}, @ref{label}. @sref{table sample}
@end deftypefn

@anchor{iris}
@deftypefn {Команда MGL} {} iris dats 'ids' ['stl'='']
@deftypefnx {Команда MGL} {} iris dats rngs 'ids' ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Iris (@code{const mglDataA &}dats, @code{const char *}ids, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Iris (@code{const mglDataA &}dats, @code{const wchar_t *}ids, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Iris (@code{const mglDataA &}dats, @code{const mglDataA &}rngs, @code{const char *}ids, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Iris (@code{const mglDataA &}dats, @code{const mglDataA &}rngs, @code{const wchar_t *}ids, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_iris_1 (@code{HMGL} gr, @code{HCDT} dats, @code{const char *}ids, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_irisw_1 (@code{HMGL} gr, @code{HCDT} dats, @code{const wchar_t *}ids, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_iris (@code{HMGL} gr, @code{HCDT} dats, @code{HCDT} rngs, @code{const char *}ids, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_irisw (@code{HMGL} gr, @code{HCDT} dats, @code{HCDT} rngs, @code{const wchar_t *}ids, @code{const char *}stl, @code{const char *}opt)
@end ifclear
Рисует Ирисы Фишера для определения зависимостей данных @var{dats} друг от друга (см. @uref{http://en.wikipedia.org/wiki/Iris_flower_data_set}). Массив @var{rngs} размером 2*@var{dats}.nx задает диапазон изменения осей для каждой из колонки. Строка @var{ids} содержит имена колонок данных, разделенных символом @samp{;}. Опция @code{value} задает размер текста для имен данных. На график можно добавить новый набор данных если указать тот же размер @var{rngs} и использовать пустую строку имен @var{ids}. См. также @ref{plot}. @sref{iris sample}
@end deftypefn

@anchor{tube}
@deftypefn {Команда MGL} {} tube ydat rdat ['stl'='']
@deftypefnx {Команда MGL} {} tube ydat @code{rval} ['stl'='']
@deftypefnx {Команда MGL} {} tube xdat ydat rdat ['stl'='']
@deftypefnx {Команда MGL} {} tube xdat ydat @code{rval} ['stl'='']
@deftypefnx {Команда MGL} {} tube xdat ydat zdat rdat ['stl'='']
@deftypefnx {Команда MGL} {} tube xdat ydat zdat @code{rval} ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}y, @code{mreal} r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{mreal} r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tube (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{mreal} r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_tube_r (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tube (@code{HMGL} gr, @code{HCDT} y, @code{mreal} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tube_xyr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tube_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{mreal} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tube_xyzr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tube_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{mreal} r, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют трубу радиуса @var{r}[i] вдоль кривой между точками @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Опция @code{value} число сегментов в поперечном сечении (по умолчанию 25). См. также @ref{plot}. @sref{tube sample}
@end deftypefn

@anchor{torus}
@deftypefn {Команда MGL} {} torus rdat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Torus (@code{const mglDataA &}r, @code{const mglDataA &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_torus (@code{HMGL} gr, @code{HCDT} r, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Функции рисуют поверхность вращения кривой @{@var{r}, @var{z}@} относительно оси. Если строка @var{pen} содержит @samp{x} или @samp{z}, то ось вращения будет выбрана в указанном направлении (по умолчанию вдоль оси y). Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. См. также @ref{plot}, @ref{axial}. @sref{torus sample}
@end deftypefn



@anchor{lamerey}
@deftypefn {Команда MGL} {} lamerey @code{x0} ydat ['stl'='']
@deftypefnx {Команда MGL} {} lamerey @code{x0} 'y(x)' ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Lamerey (@code{double} x0, @code{const mglDataA &}y, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Lamerey (@code{double} x0, @code{const char *}y, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_lamerey_dat (@code{HMGL} gr, @code{double} x0, @code{HCDT} y, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_lamerey_str (@code{HMGL} gr, @code{double} x0, @code{const char *}y, @code{const char *}stl, @code{const char *}opt)
@end ifclear
Функции рисуют диаграмму Ламерея для точечного отображения x_new = y(x_old) начиная с точки @var{x0}. Строка @var{stl} может содержать стиль линии, символ @samp{v} для стрелок, символ @samp{~} для исключения первого сегмента. Опция @code{value} задает число сегментов для рисования (по умолчанию 20). См. также @ref{plot}, @ref{fplot}, @ref{bifurcation}, @ref{pmap}. @sref{lamerey sample}
@end deftypefn

@anchor{bifurcation}
@deftypefn {Команда MGL} {} bifurcation @code{dx} ydat ['stl'='']
@deftypefnx {Команда MGL} {} bifurcation @code{dx} 'y(x)' ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Bifurcation (@code{double} dx, @code{const mglDataA &}y, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Bifurcation (@code{double} dx, @code{const char *}y, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_bifurcation_dat (@code{HMGL} gr, @code{double} dx, @code{HCDT} y, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_bifurcation_str (@code{HMGL} gr, @code{double} dx, @code{const char *}y, @code{const char *}stl, @code{const char *}opt)
@end ifclear
Функции рисуют бифуркационную диаграмму (диаграмму удвоения периода) для точечного отображения x_new = y(x_old). Параметр @var{dx} задает точность по оси x. Строка @var{stl} задает цвет. Опция @code{value} задает число учитываемых стационарных точек (по умолчанию 1024). См. также @ref{plot}, @ref{fplot}, @ref{lamerey}. @sref{bifurcation sample}
@end deftypefn

@anchor{pmap}
@deftypefn {Команда MGL} {} pmap ydat sdat ['stl'='']
@deftypefnx {Команда MGL} {} pmap xdat ydat sdat ['stl'='']
@deftypefnx {Команда MGL} {} pmap xdat ydat zdat sdat ['stl'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Pmap (@code{const mglDataA &}y, @code{const mglDataA &}s, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Pmap (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}s, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Pmap (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}s, @code{const char *}stl=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_pmap (@code{HMGL} gr, @code{HMDT} y, @code{HCDT} s, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_pmap_xy (@code{HMGL} gr, @code{HCDT} x, @code{HMDT} y, @code{HCDT} s, @code{const char *}stl, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_pmap_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HMDT} y, @code{HCDT} z, @code{HCDT} s, @code{const char *}stl, @code{const char *}opt)
@end ifclear
Функции рисуют отображение Пуанкаре для кривой @{@var{x}, @var{y}, @var{z}@} при условии @var{s}=0. Проще говоря, рисуются точки пересечения кривой и поверхности. Строка @var{stl} задает стиль маркеров. См. также @ref{plot}, @ref{mark}, @ref{lamerey}. @sref{pmap sample}
@end deftypefn


@c ##################################################################
@external{}
@node 2D plotting, 3D plotting, 1D plotting, MathGL core
@section 2D графики
@nav{}
@cindex Mesh
@cindex Fall
@cindex Belt
@cindex Surf
@cindex Boxs
@cindex Tile
@cindex Dens
@cindex Cont
@cindex ContF
@cindex ContD
@cindex Axial
@cindex Grad
@cindex Grid

Эти функции строят графики для двумерных (2D) массивов. Двумерными считаются массивы, зависящие только от двух параметров (индексов) подобно матрице @math{f(x_i,y_j), i=1...n, j=1...m}. По умолчанию (если отсутствуют) значения @var{x}, @var{y} равно распределены в диапазоне осей координат. Младшие размерности массивов @var{x}, @var{y}, @var{z} должны быть одинаковы @code{x.nx=z.nx && y.nx=z.ny} или @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Массивы @var{x} и @var{y} могут быть векторами (не матрицами как @var{z}). График строится для каждого z среза данных. Строка @var{sch} задает цветовую схему (см. @ref{Color scheme}). Строка @var{opt} задает опции графика (см. @ref{Command options}).

@anchor{surf}
@deftypefn {Команда MGL} {} surf zdat ['sch'='']
@deftypefnx {Команда MGL} {} surf xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surf (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surf_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует параметрически заданную поверхность @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Если @var{sch} содержит @samp{#}, то рисуется сетка на поверхности. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. См. также @ref{mesh}, @ref{dens}, @ref{belt}, @ref{tile}, @ref{boxs}, @ref{surfc}, @ref{surfa}. @sref{surf sample}
@end deftypefn

@anchor{mesh}
@deftypefn {Команда MGL} {} mesh zdat ['sch'='']
@deftypefnx {Команда MGL} {} mesh xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Mesh (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Mesh (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_mesh (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_mesh_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует сетчатую поверхность, заданную параметрически @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. См. также @ref{surf}, @ref{fall}, @ref{meshnum}, @ref{cont}, @ref{tens}. @sref{mesh sample}
@end deftypefn

@anchor{fall}
@deftypefn {Команда MGL} {} fall zdat ['sch'='']
@deftypefnx {Команда MGL} {} fall xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Fall (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Fall (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_fall (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_fall_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует водопад для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. График удобен для построения нескольких кривых, сдвинутых вглубь друг относительно друга. Если @var{sch} содержит @samp{x}, то линии рисуются вдоль оси x, иначе (по умолчанию) вдоль оси y. См. также @ref{belt}, @ref{mesh}, @ref{tens}, @ref{meshnum}. @sref{fall sample}
@end deftypefn

@anchor{belt}
@deftypefn {Команда MGL} {} belt zdat ['sch'='']
@deftypefnx {Команда MGL} {} belt xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Belt (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Belt (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_belt (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_belt_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует ленточки для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. График может использоваться как 3d обобщение графика @ref{plot}. Если @var{sch} содержит @samp{x}, то ленточки рисуются вдоль оси x, иначе (по умолчанию) вдоль оси y. См. также @ref{fall}, @ref{surf}, @ref{beltc}, @ref{plot}, @ref{meshnum}. @sref{belt sample}
@end deftypefn

@anchor{boxs}
@deftypefn {Команда MGL} {} boxs zdat ['sch'='']
@deftypefnx {Команда MGL} {} boxs xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Boxs (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Boxs (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_boxs (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_boxs_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует вертикальные ящики для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. См. также @ref{surf}, @ref{dens}, @ref{tile}, @ref{step}. @sref{boxs sample}
@end deftypefn

@anchor{tile}
@deftypefn {Команда MGL} {} tile zdat ['sch'='']
@deftypefnx {Команда MGL} {} tile xdat ydat zdat ['sch'='']
@deftypefnx {Команда MGL} {} tile xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tile (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tile (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Tile (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_tile (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tile_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tile_xyc (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует плитки для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} с цветом, заданным массивом @var{c}[i,j]. Если строка @var{sch} содержит стиль @samp{x} или @samp{y}, то плитки будут ориентированы перпендикулярно x- или y-оси. График может использоваться как 3d обобщение @ref{step}. См. также @ref{surf}, @ref{boxs}, @ref{step}, @ref{tiles}. @sref{tile sample}
@end deftypefn

@anchor{dens}
@deftypefn {Команда MGL} {} dens zdat ['sch'='']
@deftypefnx {Команда MGL} {} dens xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Dens (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{mreal} zVal=@code{NAN})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Dens (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{mreal} zVal=@code{NAN})
@deftypefnx {Функция С} @code{void} mgl_dens (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_dens_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует график плотности для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} при @var{z} равном минимальному значению оси z. Если @var{sch} содержит @samp{#}, то рисуется сетка. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. См. также @ref{surf}, @ref{cont}, @ref{contf}, @ref{boxs}, @ref{tile}, @code{dens[xyz]}. @sref{dens sample}
@end deftypefn

@anchor{cont}
@deftypefn {Команда MGL} {} cont vdat zdat ['sch'='']
@deftypefnx {Команда MGL} {} cont vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cont (@code{const mglDataA &}v, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cont (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_cont__val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cont_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует линии уровня для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} при @var{z=v}[k] или при @var{z}  равном минимальному значению оси z если @var{sch} содержит @samp{_}. Линии уровня рисуются для @var{z}[i,j]=@var{v}[k]. Если @var{sch} содержит @samp{t} или @samp{T}, то значения @var{v}[k] будут выведены вдоль контуров над (или под) кривой. См. также @ref{dens}, @ref{contf}, @ref{contd}, @ref{axial}, @code{cont[xyz]}. @sref{cont sample}
@end deftypefn

@deftypefn {Команда MGL} {} cont zdat ['sch'='']
@deftypefnx {Команда MGL} {} cont xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cont (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cont (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_cont (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cont_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в диапазоне изменения цвета. Здесь @var{num} равен значению параметра @code{value} в опциях @var{opt} (по умолчанию 7). Если @var{sch} содержит @samp{.}, то будут строится только контуры по уровням седловых точек.
@end deftypefn

@deftypefn  {Команда MGL} {} cont @code{val} adat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContGen (@code{mreal} val, @code{const mglDataA &}a, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_cont_gen (@code{HMGL} gr, @code{mreal} val, @code{HCDT} a, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует линии уровня для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} при @var{a}[i,j]=@var{val}. Если @var{sch} содержит @samp{t} или @samp{T}, то значения @var{v}[k] будут выведены вдоль контуров над (или под) кривой. 
@end deftypefn

@anchor{contf}
@deftypefn {Команда MGL} {} contf vdat zdat ['sch'='']
@deftypefnx {Команда MGL} {} contf vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContF (@code{const mglDataA &}v, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContF (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contf_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contf_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует закрашенные линии (контуры) уровня для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} при @var{z=v}[k] или при @var{z}  равном минимальному значению оси z если @var{sch} содержит @samp{_}. Линии уровня рисуются для @var{z}[i,j]=@var{v}[k]. См. также @ref{dens}, @ref{cont}, @ref{contd}, @code{contf[xyz]}. @sref{contf sample}
@end deftypefn

@deftypefn {Команда MGL} {} contf zdat ['sch'='']
@deftypefnx {Команда MGL} {} contf xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContF (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContF (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contf (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contf_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в диапазоне изменения цвета. Здесь @var{num} равен значению параметра @code{value} в опциях @var{opt} (по умолчанию 7).
@end deftypefn

@deftypefn  {Команда MGL} {} contf @code{v1 v2} adat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContFGen (@code{mreal} v1, @code{mreal} v2, @code{const mglDataA &}a, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contf_gen (@code{HMGL} gr, @code{mreal} v1, @code{mreal} v2, @code{HCDT} a, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует закрашенные линии (контуры) уровня для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} между @var{a}[i,j]=@var{v1} и @var{a}[i,j]=@var{v2}.
@end deftypefn

@anchor{contd}
@deftypefn {Команда MGL} {} contd vdat zdat ['sch'='']
@deftypefnx {Команда MGL} {} contd vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContD (@code{const mglDataA &}v, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContD (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contd_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contd_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует закрашенные линии (контуры) уровня для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} при @var{z=v}[k] или при @var{z}  равном минимальному значению оси z если @var{sch} содержит @samp{_}. Линии уровня рисуются для @var{z}[i,j]=@var{v}[k]. Строка @var{sch} задает цвета контуров: цвет k-го контура определяется как k-ый цвет строки. См. также @ref{dens}, @ref{cont}, @ref{contf}. @sref{contd sample}
@end deftypefn

@deftypefn {Команда MGL} {} contd zdat ['sch'='']
@deftypefnx {Команда MGL} {} contd xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContD (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContD (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contd (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contd_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в диапазоне изменения цвета. Здесь @var{num} равен значению параметра @code{value} в опциях @var{opt} (по умолчанию 7).
@end deftypefn


@anchor{contp}
@deftypefn {Команда MGL} {} contp vdat xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContP (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contp_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует линии уровня для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Линии уровня рисуются для @var{a}[i,j]=@var{v}[k]. Если @var{sch} содержит @samp{t} или @samp{T}, то значения @var{v}[k] будут выведены вдоль контуров над (или под) кривой. Если @var{sch} содержит @samp{f}, то контуры будут закрашены. См. также @ref{cont}, @ref{contf}, @ref{surfc}, @code{cont[xyz]}. @c TODO @sref{contp sample}
@end deftypefn

@deftypefn {Команда MGL} {} contp xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContP (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contp (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в диапазоне изменения цвета. Здесь @var{num} равен значению параметра @code{value} в опциях @var{opt} (по умолчанию 7).
@end deftypefn

@anchor{contv}
@deftypefn {Команда MGL} {} contv vdat zdat ['sch'='']
@deftypefnx {Команда MGL} {} contv vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContV (@code{const mglDataA &}v, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContV (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contv_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contv_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует вертикальные цилиндры от линий уровня для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} при @var{z}=@var{v}[k] или при @var{z}  равном минимальному значению оси z если @var{sch} содержит @samp{_}. Линии уровня рисуются для @var{z}[i,j]=@var{v}[k]. См. также @ref{cont}, @ref{contf}. @sref{contv sample}
@end deftypefn

@deftypefn {Команда MGL} {} contv zdat ['sch'='']
@deftypefnx {Команда MGL} {} contv xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContV (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContV (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contv (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contv_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в диапазоне изменения цвета. Здесь @var{num} равен значению параметра @code{value} в опциях @var{opt} (по умолчанию 7).
@end deftypefn

@anchor{axial}
@deftypefn {Команда MGL} {} axial vdat zdat ['sch'='']
@deftypefnx {Команда MGL} {} axial vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Axial (@code{const mglDataA &}v, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Axial (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_axial_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_axial_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует поверхность вращения линии уровня для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Линии уровня рисуются для @var{z}[i,j]=@var{v}[k]. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. Если строка содержит символы @samp{x} или @samp{z}, то ось вращения устанавливается в указанное направление (по умолчанию вдоль @samp{y}). См. также @ref{cont}, @ref{contf}, @ref{torus}, @ref{surf3}. @sref{axial sample}
@end deftypefn

@deftypefn {Команда MGL} {} axial zdat ['sch'='']
@deftypefnx {Команда MGL} {} axial xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Axial (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{int} num=@code{3})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Axial (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{int} num=@code{3})
@deftypefnx {Функция С} @code{void} mgl_axial (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_axial_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в диапазоне изменения цвета. Здесь @var{num} равен значению параметра @code{value} в опциях @var{opt} (по умолчанию 3).
@end deftypefn

@anchor{grid2}
@deftypefn {Команда MGL} {} grid2 zdat ['sch'='']
@deftypefnx {Команда MGL} {} grid2 xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Grid (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Grid (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_grid (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_grid_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует плоскую сету для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} при @var{z} равном минимальному значению оси z. См. также @ref{dens}, @ref{cont}, @ref{contf}, @ref{grid3}, @ref{meshnum}.
@end deftypefn


@c ##################################################################
@external{}
@node 3D plotting, Dual plotting, 2D plotting, MathGL core
@section 3D графики
@nav{}
@cindex Surf3
@cindex Dens3
@cindex Cont3
@cindex ContF3
@cindex Grid3
@cindex Cloud
@cindex Beam

Эти функции строят графики для трехмерных (3D) массивов. Трёхмерными считаются массивы, зависящие от трёх параметров (индексов) подобно матрице @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. По умолчанию (если отсутствуют) значения @var{x}, @var{y}, @var{z} равно распределены в диапазоне осей координат. Младшие размерности массивов @var{x}, @var{y}, @var{z} должны быть одинаковы @code{x.nx=a.nx && y.nx=a.ny && z.nz=a.nz} или @code{x.nx=y.nx=z.nx=a.nx && x.ny=y.ny=z.ny=a.ny && x.nz=y.nz=z.nz=a.nz}. Массивы @var{x}, @var{y} и @var{z} могут быть векторами (не матрицами как @var{a}). Строка @var{sch} задает цветовую схему (см. @ref{Color scheme}). Строка @var{opt} задает опции графика (см. @ref{Command options}).


@anchor{surf3}
@deftypefn {Команда MGL} {} surf3 adat @code{val} ['sch'='']
@deftypefnx {Команда MGL} {} surf3 xdat ydat zdat adat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3 (@code{mreal} val, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3 (@code{mreal} val, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surf3_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surf3_xyz_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует поверхность уровня для 3d массива, заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) при @var{a}(x,y,z)=@var{val}. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. Замечу, что возможно некорректная отрисовка граней вследствие неопределённости построения сечения если поверхность пересекает ячейку данных 2 и более раз. См. также @ref{cloud}, @ref{dens3}, @ref{surf3c}, @ref{surf3a}, @ref{axial}. @sref{surf3 sample}
@end deftypefn

@deftypefn {Команда MGL} {} surf3 adat ['sch'='']
@deftypefnx {Команда MGL} {} surf3 xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3 (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surf3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surf3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Аналогично предыдущему для @var{num} поверхностей уровня равномерно распределённых в диапазоне изменения цвета. Величина @var{num} равна значению параметра @code{value} в опциях @var{opt} (по умолчанию 3).
@end deftypefn

@anchor{cloud}
@deftypefn {Команда MGL} {} cloud adat ['sch'='']
@deftypefnx {Команда MGL} {} cloud xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cloud (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cloud (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_cloud (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cloud_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует облачный график для 3d массива, заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). График состоит из кубиков с цветом и прозрачностью пропорциональной значениям @var{a}. Результат похож на облако -- малые значения прозрачны, а большие нет. Число кубиков зависит от @ref{meshnum}. Если @var{sch} содержит @samp{.}, то будет построен график более низкого качества, но с заметно меньшим использованием памяти. Если @var{sch} содержит @samp{i}, то прозрачность будет инвертирована, т.е. области с более высокими значениями будут более прозрачны, а с более низким -- менее прозрачны. См. также @ref{surf3}, @ref{meshnum}. @sref{cloud sample}
@end deftypefn

@anchor{dens3}
@deftypefn {Команда MGL} {} dens3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {Команда MGL} {} dens3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Dens3 (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Dens3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_dens3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_dens3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
Рисует график плотности для 3d массива, заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). График рисуется на срезе @var{sVal} в направлении @{@samp{x}, @samp{y}, @samp{z}@}, указанном в строке @var{sch} (по умолчанию, в напралении @samp{y}). Если @var{sch} содержит @samp{#}, то на срезе рисуется сетка. См. также @ref{cont3}, @ref{contf3}, @ref{dens}, @ref{grid3}. @sref{dens3 sample}
@end deftypefn

@anchor{cont3}
@deftypefn {Команда MGL} {} cont3 vdat adat ['sch'='' @code{sval=-1}]
@deftypefnx {Команда MGL} {} cont3 vdat xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cont3 (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cont3 (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_cont3_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cont3_xyz_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
Рисует линии уровня для 3d массива, заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Линии рисуются для значений из массива @var{v} на срезе @var{sVal} в направлении @{@samp{x}, @samp{y}, @samp{z}@}, указанном в строке @var{sch} (по умолчанию, в напралении @samp{y}). Если @var{sch} содержит @samp{#}, то на срезе рисуется сетка. Если @var{sch} содержит @samp{t} или @samp{T}, то значения @var{v}[k] будут выведены вдоль контуров над (или под) кривой. См. также @ref{dens3}, @ref{contf3}, @ref{cont}, @ref{grid3}. @sref{cont3 sample}
@end deftypefn

@deftypefn {Команда MGL} {} cont3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {Команда MGL} {} cont3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cont3 (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Cont3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_cont3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cont3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
Аналогично предыдущему для @var{num} линий уровня равномерно распределённых в диапазоне изменения цвета. Величина @var{num} равна значению параметра @code{value} в опциях @var{opt} (по умолчанию 7).
@end deftypefn

@anchor{contf3}
@deftypefn {Команда MGL} {} contf3 vdat adat ['sch'='' @code{sval=-1}]
@deftypefnx {Команда MGL} {} contf3 vdat xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Contf3 (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Contf3 (@code{const mglDataA &}v, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contf3_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contf3_xyz_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
Рисует закрашенные линии (контуры) уровня для 3d массива, заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Линии рисуются для значений из массива @var{v} на срезе @var{sVal} в направлении @{@samp{x}, @samp{y}, @samp{z}@}, указанном в строке @var{sch} (по умолчанию, в напралении @samp{y}). Если @var{sch} содержит @samp{#}, то на срезе рисуется сетка. См. также @ref{dens3}, @ref{cont3}, @ref{contf}, @ref{grid3}. @sref{contf3 sample}
@end deftypefn

@deftypefn {Команда MGL} {} contf3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {Команда MGL} {} contf3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Contf3 (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Contf3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contf3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contf3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
Аналогично предыдущему для @var{num} закрашенных линий (контуров) уровня равномерно распределённых в диапазоне изменения цвета. Величина @var{num} равна значению параметра @code{value} в опциях @var{opt} (по умолчанию 7).
@end deftypefn

@anchor{grid3}
@deftypefn {Команда MGL} {} grid3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {Команда MGL} {} grid3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Grid3 (@code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Grid3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_grid3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_grid3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
Рисует сетку для 3d массива, заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). График рисуется на срезе @var{sVal} в направлении @{@samp{x}, @samp{y}, @samp{z}@}, указанном в строке @var{sch} (по умолчанию, в напралении @samp{y}). См. также @ref{cont3}, @ref{contf3}, @ref{dens3}, @ref{grid2}, @ref{meshnum}.
@end deftypefn

@anchor{beam}
@deftypefn {Команда MGL} {} beam tr g1 g2 adat @code{rval} ['sch'='' @code{flag=0 num=3}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Beam (@code{const mglDataA &}tr, @code{const mglDataA &}g1, @code{const mglDataA &}g2, @code{const mglDataA &}a, @code{mreal} r, @code{const char *}stl=@code{""}, @code{int} flag=@code{0}, @code{int} num=@code{3})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Beam (@code{mreal} val, @code{const mglDataA &}tr, @code{const mglDataA &}g1, @code{const mglDataA &}g2, @code{const mglDataA &}a, @code{mreal} r, @code{const char *}stl=@code{""}, @code{int} flag=@code{0})
@deftypefnx {Функция С} @code{void} mgl_beam (@code{HMGL} gr, @code{HCDT} tr, @code{HCDT} g1, @code{HCDT} g2, @code{HCDT} a, @code{mreal} r, @code{const char *}stl, @code{int} flag, @code{int} num)
@deftypefnx {Функция С} @code{void} mgl_beam_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} tr, @code{HCDT} g1, @code{HCDT} g2, @code{HCDT} a, @code{mreal} r, @code{const char *}stl, @code{int} flag)
@end ifclear
Рисует поверхность уровня для 3d массива @var{a} при постоянном значении @var{a}=@var{val}. Это специальный тип графика для @var{a} заданного в сопровождающей системе координат вдоль кривой @var{tr} с ортами @var{g1}, @var{g2} и с поперечным размером @var{r}. Переменная @var{flag} -- битовый флаг: @samp{0x1} - рисовать в сопровождающих (не лабораторных) координатах; @samp{0x2} - рисовать проекцию на плоскость @math{\rho-z}; @samp{0x4} - рисовать нормированное в каждом сечении поле. Размеры массивов по 1-му индексу @var{tr}, @var{g1}, @var{g2} должны быть nx>2. Размеры массивов по 2-му индексу @var{tr}, @var{g1}, @var{g2} и размер по 3-му индексу массива @var{a} должны быть одинаковы. См. также @ref{surf3}.
@end deftypefn


@c ##################################################################
@external{}
@node Dual plotting, Vector fields, 3D plotting, MathGL core
@section Парные графики
@nav{}
@cindex SurfC
@cindex SurfA
@cindex Surf3C
@cindex Surf3A
@cindex TileS
@cindex Map
@cindex STFA

Эти функции строят графики для двух связанных массивов. Есть несколько основных типов 3D графиков: поверхность и поверхность уровня с окраской по второму массиву (SurfC, Surf3C), поверхность и поверхность уровня с прозрачностью по второму массиву (SurfA, Surf3A), плитки переменного размера (TileS), диаграмма точечного отображения (Map), STFA диаграмма (STFA). По умолчанию (если отсутствуют) значения @var{x}, @var{y} (и @var{z} для @code{Surf3C, Surf3A}) равно распределены в диапазоне осей координат. Младшие размерности массивов @var{x}, @var{y}, @var{z}, @var{c} должны быть одинаковы @code{x.nx=a.nx && y.nx=a.ny && z.nz=a.nz} или @code{x.nx=y.nx=z.nx=a.nx && x.ny=y.ny=z.ny=a.ny && x.nz=y.nz=z.nz=a.nz}. Массивы @var{x}, @var{y} (и @var{z} для @code{Surf3C, Surf3A}) могут быть векторами (не матрицами как @var{c}). Строка @var{sch} задает цветовую схему (см. @ref{Color scheme}). Строка @var{opt} задает опции графика (см. @ref{Command options}).


@anchor{surfc}
@deftypefn {Команда MGL} {} surfc zdat cdat ['sch'='']
@deftypefnx {Команда MGL} {} surfc xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SurfC (@code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SurfC (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surfc (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surfc_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует параметрически заданную поверхность @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} с цветом, заданным массивом @var{c}[i,j]. Если @var{sch} содержит @samp{#}, то на поверхности рисуется сетка. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. Размерность массивов @var{z} и @var{c} должна быть одинакова. График строится для каждого z среза данных. См. также @ref{surf}, @ref{surfa}, @ref{beltc}, @ref{surf3c}. @sref{surfc sample}
@end deftypefn


@anchor{beltc}
@deftypefn {Команда MGL} {} beltc zdat cdat ['sch'='']
@deftypefnx {Команда MGL} {} beltc xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} BeltC (@code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} BeltC (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_beltc (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_beltc_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует ленточки для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} с цветом, заданным массивом @var{c}[i,j]. График может использоваться как 3d обобщение графика @ref{plot}. Если @var{sch} содержит @samp{x}, то ленточки рисуются вдоль оси x, иначе (по умолчанию) вдоль оси y. См. также @ref{belt}, @ref{surfc}, @ref{meshnum}. @c TODO @sref{beltc sample}
@end deftypefn


@anchor{surf3c}
@deftypefn {Команда MGL} {} surf3c adat cdat @code{val} ['sch'='']
@deftypefnx {Команда MGL} {} surf3c xdat ydat zdat adat cdat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3C (@code{mreal} val, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3C (@code{mreal} val, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surf3c_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surf3c_xyz_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует поверхность уровня для 3d массива, заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) при @var{a}(x,y,z)=@var{val}. Аналогично @ref{surf3}, но цвет задается массивом @var{c}. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. См. также @ref{surf3}, @ref{surfc}, @ref{surf3a}. @sref{surf3c sample}
@end deftypefn

@deftypefn {Команда MGL} {} surf3c adat cdat ['sch'='']
@deftypefnx {Команда MGL} {} surf3c xdat ydat zdat adat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3C (@code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3C (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surf3c (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surf3c_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Аналогично предыдущему для @var{num} поверхностей уровня равномерно распределённых в диапазоне изменения цвета. Величина @var{num} равна значению параметра @code{value} в опциях @var{opt} (по умолчанию 3).
@end deftypefn


@anchor{surfa}
@deftypefn {Команда MGL} {} surfa zdat cdat ['sch'='']
@deftypefnx {Команда MGL} {} surfa xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SurfA (@code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SurfA (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surfa (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surfa_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует параметрически заданную поверхность @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} с прозрачностью, заданной массивом @var{c}[i,j]. Если @var{sch} содержит @samp{#}, то на поверхности рисуется сетка. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. Размерность массивов @var{z} и @var{c} должна быть одинакова. График строится для каждого z среза данных. См. также @ref{surf}, @ref{surfc}, @ref{surf3a}. @sref{surfa sample}
@end deftypefn

@anchor{surf3a}
@deftypefn {Команда MGL} {} surf3a adat cdat @code{val} ['sch'='']
@deftypefnx {Команда MGL} {} surf3a xdat ydat zdat adat cdat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3A (@code{mreal} val, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3A (@code{mreal} val, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surf3a_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surf3a_xyz_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует поверхность уровня для 3d массива, заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) при @var{a}(x,y,z)=@var{val}. Аналогично @ref{surf3}, но прозрачность задается массивом @var{c}. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. См. также @ref{surf3}, @ref{surfc}, @ref{surf3a}. @sref{surf3a sample}
@end deftypefn

@deftypefn {Команда MGL} {} surf3a adat cdat ['sch'='']
@deftypefnx {Команда MGL} {} surf3a xdat ydat zdat adat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3A (@code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3A (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surf3a (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surf3a_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Аналогично предыдущему для @var{num} поверхностей уровня равномерно распределённых в диапазоне изменения цвета. При этом массив @var{c} может быть вектором со значениями прозрачности и @var{num}=@var{c}.nx. В противном случае величина @var{num} равна значению параметра @code{value} в опциях @var{opt} (по умолчанию 3).
@end deftypefn



@anchor{surfca}
@deftypefn {Команда MGL} {} surfca zdat cdat adat ['sch'='']
@deftypefnx {Команда MGL} {} surfca xdat ydat zdat cdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SurfCA (@code{const mglDataA &}z, @code{const mglDataA &}c, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SurfCA (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surfca (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surfca_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует параметрически заданную поверхность @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} с цветом и прозрачностью, заданными массивами @var{c}[i,j] и @var{a}[i,j] соответственно. Если @var{sch} содержит @samp{#}, то на поверхности рисуется сетка. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. Размерность массивов @var{z} и @var{c} должна быть одинакова. График строится для каждого z среза данных. См. также @ref{surf}, @ref{surfc}, @ref{surfa}, @ref{surf3ca}. @sref{surfca sample}
@end deftypefn

@anchor{surf3ca}
@deftypefn {Команда MGL} {} surf3ca adat cdat bdat @code{val} ['sch'='']
@deftypefnx {Команда MGL} {} surf3ca xdat ydat zdat adat cdat bdat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3CA (@code{mreal} val, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const mglDataA &}b, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3CA (@code{mreal} val, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const mglDataA &}b, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surf3ca_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} a, @code{HCDT} c, @code{HCDT} b, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surf3ca_xyz_val (@code{HMGL} gr, @code{mreal} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{HCDT} b, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует поверхность уровня для 3d массива, заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) при @var{a}(x,y,z)=@var{val}. Аналогично @ref{surf3}, но цвет и прозрачность задается массивами @var{c} и @var{b} соответственно. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. Если @var{sch} содержит @samp{.}, то рисуется поверхность из точек. См. также @ref{surf3}, @ref{surfc}, @ref{surf3a}. @sref{surf3a sample}
@end deftypefn

@deftypefn {Команда MGL} {} surf3ca adat cdat ['sch'='']
@deftypefnx {Команда MGL} {} surf3ca xdat ydat zdat adat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3CA (@code{const mglDataA &}a, @code{const mglDataA &}c, @code{const mglDataA &}b, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Surf3CA (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}c, @code{const mglDataA &}b, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_surf3ca (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} c, @code{HCDT} b, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_surf3ca_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{HCDT} b, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Аналогично предыдущему для @var{num} поверхностей уровня равномерно распределённых в диапазоне изменения цвета. Здесь величина @var{num} равна значению параметра @code{value} в опциях @var{opt} (по умолчанию 3).
@end deftypefn


@anchor{tiles}
@deftypefn {Команда MGL} {} tiles zdat rdat ['sch'='']
@deftypefnx {Команда MGL} {} tiles xdat ydat zdat rdat ['sch'='']
@deftypefnx {Команда MGL} {} tiles xdat ydat zdat rdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TileS (@code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TileS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TileS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}r, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_tiles (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tiles_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tiles_xyc (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует плитки для параметрически заданной поверхности @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} с цветом, заданным массивом @var{c}[i,j]. Аналогично Tile(), но размер плиток задается массивов @var{r}. Если строка @var{sch} содержит стиль @samp{x} или @samp{y}, то плитки будут ориентированы перпендикулярно x- или y-оси. Это создает эффект "прозрачности" при экспорте в файлы EPS. График строится для каждого z среза данных. См. также @ref{surfa}, @ref{tile}. @sref{tiles sample}
@end deftypefn

@anchor{map}
@deftypefn {Команда MGL} {} map udat vdat ['sch'='']
@deftypefnx {Команда MGL} {} map xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Map (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Map (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_map (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_map_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует точечное отображение для матриц @{@var{ax}, @var{ay} @} параметрически зависящих от координат @var{x}, @var{y}. Исходное положение ячейки задает ее цвет. Высота пропорциональна якобиану J(ax,ay). График является аналогом диаграммы Арнольда ??? Если @var{sch} содержит @samp{.}, то цветные точки рисуются в узлах матриц (полезно для "запутанного" отображения), иначе рисуются грани. @sref{Mapping visualization}
@end deftypefn

@anchor{stfa}
@deftypefn {Команда MGL} {} stfa re im @code{dn} ['sch'='']
@deftypefnx {Команда MGL} {} stfa xdat ydat re im @code{dn} ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} STFA (@code{const mglDataA &}re, @code{const mglDataA &}im, @code{int} dn, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} STFA (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}re, @code{const mglDataA &}im, @code{int} dn, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_stfa (@code{HMGL} gr, @code{HCDT} re, @code{HCDT} im, @code{int} dn, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_stfa_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} re, @code{HCDT} im, @code{int} dn, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует спектрограмму комплексного массива @var{re}+i*@var{im} для Фурье размером @var{dn} точек в плоскости @var{z} равно минимальному значению оси z. Параметр @var{dn} -- любое чётное число. Например в 1D случае, результатом будет график плотности от массива @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} размером @{int(nx/dn), dn, ny@}. Массивы @var{re}, @var{im} параметрически зависят от координат @var{x}, @var{y}. Все размеры массивов @var{re} и @var{im} должны быть одинаковы. Младшие размерности массивов @var{x}, @var{y}, @var{re} должны быть одинаковы. Массивы @var{x} и @var{y} могут быть векторами (не матрицами как @var{re}). @sref{stfa sample}
@end deftypefn


@c ##################################################################
@external{}
@node Vector fields, Other plotting, Dual plotting, MathGL core
@section Векторные поля
@nav{}
@cindex Traj
@cindex Vect
@cindex Dew
@cindex Flow
@cindex FlowP
@cindex Pipe

Эти функции рисуют графики для 2D и 3D векторных полей. Есть несколько типов графиков: просто векторное поле (Vect), вектора вдоль траектории (Traj), векторное поле каплями (Dew), нити тока (Flow, FlowP), трубки тока (Pipe). По умолчанию (если отсутствуют) значения @var{x}, @var{y} и @var{z} равно распределены в диапазоне осей координат. Младшие размерности массивов @var{x}, @var{y}, @var{z} и @var{ax} должны быть одинаковы. Размеры массивов @var{ax}, @var{ay} и @var{az} должны быть одинаковы. Массивы @var{x}, @var{y} и @var{z} могут быть векторами (не матрицами как @var{ax}). Строка @var{sch} задает цветовую схему (см. @ref{Color scheme}). Строка @var{opt} задает опции графика (см. @ref{Command options}).

@anchor{traj}
@deftypefn {Команда MGL} {} traj xdat ydat udat vdat ['sch'='']
@deftypefnx {Команда MGL} {} traj xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Traj (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Traj (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_traj_xyz (@code{HMGL} gr, @code{HCDT}x, @code{HCDT}y, @code{HCDT}z, @code{HCDT}ax, @code{HCDT}ay, @code{HCDT}az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_traj_xy (@code{HMGL} gr, @code{HCDT}x, @code{HCDT}y, @code{HCDT}ax, @code{HCDT}ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует вектора @{@var{ax}, @var{ay}, @var{az}@} вдоль кривой @{@var{x}, @var{y}, @var{z}@}. Длина векторов пропорциональна @math{\sqrt@{ax^2+ay^2+az^2@}}. Строка @var{pen} задает цвет (см. @ref{Line styles}). По умолчанию (@code{pen=""}) используется текущий цвет из палитры (см. @ref{Palette and colors}). Опция @code{value} задает фактор длины векторов (если не нуль) или выбирать длину пропорционально расстоянию между точками кривой (если @code{value=0}). Размер по 1-му индексу должен быть 2 или больше. График рисуется для каждой строки если один из массивов матрица. См. также @ref{vect}. @sref{traj sample}
@end deftypefn

@anchor{vect}
@deftypefn {Команда MGL} {} vect udat vdat ['sch'='']
@deftypefnx {Команда MGL} {} vect xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Vect (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Vect (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_vect_2d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_vect_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует векторное поле @{@var{ax}, @var{ay}@} параметрически зависящее от координат @var{x}, @var{y} на плоскости при @var{z} равном минимальному значению оси z. Длина и цвет векторов пропорциональна @math{\sqrt@{ax^2+ay^2@}}. Число рисуемых векторов зависит от @ref{meshnum}. Вид стрелок/штрихов может быть изменён символами:
@itemize @bullet
@item
@samp{f} для стрелок одинаковой длины,
@item
@samp{>}, @samp{<} для стрелок начинающихся или заканчивающихся в ячейке сетки (по умолчанию центрированы),
@item
@samp{.} для рисования штрихов с точкой в начале вместо стрелок,
@item
@samp{=} для использования градиента цвета вдоль стрелок.
@end itemize
См. также @ref{flow}, @ref{dew}. @sref{vect sample}
@end deftypefn

@deftypefn {Команда MGL} {} vect udat vdat wdat ['sch'='']
@deftypefnx {Команда MGL} {} vect xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Vect (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Vect (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_vect_3d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_vect_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Это 3d версия графика. Здесь массивы @var{ax}, @var{ay}, @var{az} должны трёхмерными тензорами и длина вектора пропорциональна @math{\sqrt@{ax^2+ay^2+az^2@}}.
@end deftypefn

@anchor{vect3}
@deftypefn {Команда MGL} {} vect3 udat vdat wdat ['sch'='' sval]
@deftypefnx {Команда MGL} {} vect3 xdat ydat zdat udat vdat wdat ['sch'='' sval]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Vect3 (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Vect3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{mreal} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_vect3 (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_vect3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
Рисует 3D векторное поле @{@var{ax}, @var{ay}, @var{az}@} параметрически зависящее от координат @var{x}, @var{y}, @var{z}. График рисуется на срезе @var{sVal} в направлении @{@samp{x}, @samp{y}, @samp{z}@}, указанном в строке @var{sch} (по умолчанию, в напралении @samp{y}). Длина и цвет векторов пропорциональна @math{\sqrt@{ax^2+ay^2+az^2@}}. Число рисуемых векторов зависит от @ref{meshnum}. Вид стрелок/штрихов может быть изменён символами:
@itemize @bullet
@item
@samp{f} для стрелок одинаковой длины,
@item
@samp{>}, @samp{<} для стрелок начинающихся или заканчивающихся в ячейке сетки (по умолчанию центрированы),
@item
@samp{.} для рисования штрихов с точкой в начале вместо стрелок,
@item
@samp{=} для использования градиента цвета вдоль стрелок.
@end itemize
См. также @ref{vect}, @ref{flow}, @ref{dew}. @sref{vect sample}
@end deftypefn

@anchor{dew}
@deftypefn {Команда MGL} {} dew udat vdat ['sch'='']
@deftypefnx {Команда MGL} {} dew xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Dew (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Dew (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_dew (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_dew_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует капли для векторного поля @{@var{ax}, @var{ay}@}, параметрически зависящего от координат @var{x}, @var{y} при @var{z} равном минимальному значению оси z. Замечу, что график требует много памяти и процессорного времени для своего создания! Цвет капель пропорционален @math{\sqrt@{ax^2+ay^2@}}. Число капель определяется @ref{meshnum}. См. также @ref{vect}. @sref{dew sample}
@end deftypefn

@anchor{flow}
@deftypefn {Команда MGL} {} flow udat vdat ['sch'='']
@deftypefnx {Команда MGL} {} flow xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Flow (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Flow (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_flow_2d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_flow_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует нити тока для векторного поля @{@var{ax}, @var{ay}@}, параметрически зависящего от координат @var{x}, @var{y} на плоскости при @var{z} равном минимальному значению оси z. Число нитей пропорционально значению опции @code{value} (по умолчанию 5). Цвет нитей пропорционален @math{\sqrt@{ax^2+ay^2@}}. Строка @var{sch} может содержать
@itemize @bullet
@item
цветовую схему -- тёплые цвета соответствуют нормальному току (типа стока), холодные цвета соответствуют обратному току (типа источника);
@item
@samp{#} для использования нитей, начинающихся только на границе;
@item
@samp{.} для рисования сепаратрис (нитей из/в стационарных точек).
@item
@samp{*} для использования нитей, начинающихся с двумерной сетки внутри данных;
@item
@samp{v} для рисования стрелок на нитях;
@item
@samp{x}, @samp{z} для рисования лент нормалей, начинающихся в плоскостях x-y и y-z соответственно.
@end itemize
См. также @ref{pipe}, @ref{vect}, @ref{tape}, @ref{flow3}, @ref{barwidth}. @sref{flow sample}
@end deftypefn

@deftypefn {Команда MGL} {} flow udat vdat wdat ['sch'='']
@deftypefnx {Команда MGL} {} flow xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Flow (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Flow (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_flow_3d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_flow_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Это 3d версия графика. Здесь массивы должны трёхмерными тензорами и цвет пропорционален @math{\sqrt@{ax^2+ay^2+az^2@}}.
@end deftypefn

@deftypefn {Команда MGL} {} flow @code{x0 y0} udat vdat ['sch'='']
@deftypefnx {Команда MGL} {} flow @code{x0 y0} xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_flowp_2d (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_flowp_xy (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Аналогично @ref{flow}, но рисует одну нить из точки @var{p0}=@{@var{x0},@var{y0},@var{z0}@}. Строка @var{sch} также может содержать: @samp{>} или @samp{<} для рисования линии тока только вперед или только назад от заданной точки (по умолчанию, рисует в обе стороны).
@end deftypefn

@deftypefn {Команда MGL} {} flow @code{x0 y0 z0} udat vdat wdat ['sch'='']
@deftypefnx {Команда MGL} {} flow @code{x0 y0 z0} xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_flowp_3d (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_flowp_xyz (@code{HMGL} gr, @code{mreal} x0, @code{mreal} y0, @code{mreal} z0, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Это 3d версия графика.
@end deftypefn

@anchor{flow3}
@deftypefn {Команда MGL} {} flow3 udat vdat wdat ['sch'='']
@deftypefnx {Команда MGL} {} flow3 xdat ydat zdat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Flow3 (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{double} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Flow3 (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{double} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_flow3 (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{double} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_flow3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{double} sVal, @code{const char *}opt)
@end ifclear
The function draws flow threads for the 3D vector field @{@var{ax}, @var{ay}, @var{az}@} parametrically depending on coordinates @var{x}, @var{y}, @var{z}. Flow threads starts from given plane. Option @code{value} set the approximate number of threads (default is 5). String @var{sch} may contain:
@itemize @bullet
@item
color scheme -- up-half (warm) corresponds to normal flow (like attractor), bottom-half (cold) corresponds to inverse flow (like source);
@item
@samp{x}, @samp{z} for normal of starting plane (default is y-direction);
@item
@samp{v} for drawing arrows on the threads;
@item
@samp{t} for drawing tapes of normals in x-y and y-z planes.
@end itemize
See also @ref{flow}, @ref{pipe}, @ref{vect}. @sref{flow3 sample}
@end deftypefn


@anchor{grad}
@deftypefn {Команда MGL} {} grad pdat ['sch'='']
@deftypefnx {Команда MGL} {} grad xdat ydat pdat ['sch'='']
@deftypefnx {Команда MGL} {} grad xdat ydat zdat pdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Grad (@code{const mglDataA &}phi, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Grad (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}phi, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Grad (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}phi, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_grad (@code{HMGL} gr, @code{HCDT} phi, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_grad_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} phi, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_grad_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} phi, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует линии градиента скалярного поля @var{phi}[i,j] (или @var{phi}[i,j,k] в 3d случае) заданного параметрически @{@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]@}. Число линий пропорционально значению опции @code{value} (по умолчанию 5). См. также @ref{dens}, @ref{cont}, @ref{flow}.
@end deftypefn

@anchor{pipe}
@deftypefn {Команда MGL} {} pipe udat vdat ['sch'='' @code{r0=0.05}]
@deftypefnx {Команда MGL} {} pipe xdat ydat udat vdat ['sch'='' @code{r0=0.05}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Pipe (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{mreal} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Pipe (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const char *}sch=@code{""}, @code{mreal} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_pipe_2d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{mreal} r0, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_pipe_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{mreal} r0, @code{const char *}opt)
@end ifclear
Рисует трубки тока для векторного поля @{@var{ax}, @var{ay}@}, параметрически зависящего от координат @var{x}, @var{y} на плоскости при @var{z} равном минимальному значению оси z. Число трубок пропорционально значению опции @code{value}. Цвет и радиус трубок пропорционален @math{\sqrt@{ax^2+ay^2@}}. Тёплые цвета соответствуют нормальному току (типа стока). Холодные цвета соответствуют обратному току (типа источника). Параметр @var{r0} задает радиус трубок. При @var{r0}<0 радиус трубок обратно пропорционален их амплитуде. См. также @ref{flow}, @ref{vect}. @sref{pipe sample}
@end deftypefn

@deftypefn {Команда MGL} {} pipe udat vdat wdat ['sch'='' @code{r0=0.05}]
@deftypefnx {Команда MGL} {} pipe xdat ydat zdat udat vdat wdat ['sch'='' @code{r0=0.05}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Pipe (@code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{mreal} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Pipe (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}ax, @code{const mglDataA &}ay, @code{const mglDataA &}az, @code{const char *}sch=@code{""}, @code{mreal} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_pipe_3d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{mreal} r0, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_pipe_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{mreal} r0, @code{const char *}opt)
@end ifclear
Это 3d версия графика. Здесь массивы @var{ax}, @var{ay}, @var{az} должны трёхмерными тензорами и цвет пропорционален @math{\sqrt@{ax^2+ay^2+az^2@}}.
@end deftypefn


@c ##################################################################
@external{}
@node Other plotting, Nonlinear fitting, Vector fields, MathGL core
@section Прочие графики
@nav{}
@cindex DensXYZ
@cindex ContXYZ
@cindex ContFXYZ
@cindex Dots
@cindex Crust
@cindex TriPlot
@cindex TriCont
@cindex QuadPlot
@cindex FPlot
@cindex FSurf

Это функции, не относящиеся к какой-то специальной категории. Сюда входят функции построения графиков по текстовым формулам (FPlot и FSurf), рисования поверхностей из треугольников и четырёхугольников (TriPlot, TriCont, QuadPlot), произвольных точек в пространстве (Dots) и реконструкции по ним поверхности (Crust), графики плотности и линии уровня на плоскостях, перпендикулярных осям x, y или z (Dens[XYZ], Cont[XYZ], ContF[XYZ]). Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданного массива. Параметры цветовой схемы задаются строкой. @xref{Color scheme}.

@anchor{densz} @anchor{densy} @anchor{densx} @anchor{DensXYZ}
@deftypefn {Команда MGL} {} densx dat ['sch'='' @code{sval=nan}]
@deftypefnx {Команда MGL} {} densy dat ['sch'='' @code{sval=nan}]
@deftypefnx {Команда MGL} {} densz dat ['sch'='' @code{sval=nan}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} DensX (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} DensY (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} DensZ (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_dens_x (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_dens_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_dens_z (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
Эти функции рисуют график плотности на x, y или z плоскостях. Если @var{a} -- 3d массив, то выполняется интерполяция к заданному срезу @var{sVal}. Функции полезны для создания проекций 3D массивов на оси координат. См. также @ref{ContXYZ}, @ref{ContFXYZ}, @ref{dens}, @ref{Data manipulation}. @sref{dens_xyz sample}
@end deftypefn

@anchor{contz} @anchor{conty} @anchor{contx} @anchor{ContXYZ}
@deftypefn {Команда MGL} {} contx dat ['sch'='' @code{sval=nan}]
@deftypefnx {Команда MGL} {} conty dat ['sch'='' @code{sval=nan}]
@deftypefnx {Команда MGL} {} contz dat ['sch'='' @code{sval=nan}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContX (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContY (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContZ (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_cont_x (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cont_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cont_z (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
Эти функции рисуют линии уровня на x, y или z плоскостях. Если @var{a} -- 3d массив, то выполняется интерполяция к заданному срезу @var{sVal}. Опция @code{value} задает число контуров. Функции полезны для создания проекций 3D массивов на оси координат. См. также @ref{ContFXYZ}, @ref{DensXYZ}, @ref{cont}, @ref{Data manipulation}. @sref{cont_xyz sample}
@end deftypefn

@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{void} ContX (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContY (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContZ (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_cont_x_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cont_y_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_cont_z_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
Аналогично предыдущему с ручным заданием значений для линий уровня.
@end deftypefn
@end ifclear

@anchor{contfz} @anchor{contfy} @anchor{contfx} @anchor{ContFXYZ}
@deftypefn {Команда MGL} {} contfx dat ['sch'='' @code{sval=nan}]
@deftypefnx {Команда MGL} {} contfy dat ['sch'='' @code{sval=nan}]
@deftypefnx {Команда MGL} {} contfz dat ['sch'='' @code{sval=nan}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContFX (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContFY (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContFZ (@code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contf_x (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contf_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contf_z (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@end ifclear
Эти функции рисуют закрашенные контуры уровня на x, y или z плоскостях. Если @var{a} -- 3d массив, то выполняется интерполяция к заданному срезу @var{sVal}. Опция @code{value} задает число контуров. Функции полезны для создания проекций 3D массивов на оси координат. См. также @ref{ContFXYZ}, @ref{DensXYZ}, @ref{cont}, @ref{Data manipulation}. @sref{contf_xyz sample}
@end deftypefn

@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{void} ContFX (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContFY (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} ContFZ (@code{const mglDataA &}v, @code{const mglDataA &}a, @code{const char *}stl=@code{""}, @code{mreal} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_contf_x_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contf_y_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_contf_z_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{mreal} sVal, @code{const char *}opt)
Аналогично предыдущему с ручным заданием значений для линий уровня.
@end deftypefn
@end ifclear

@anchor{fplot}
@deftypefn {Команда MGL} {} fplot 'y(x)' ['pen'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FPlot (@code{const char *}eqY, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_fplot (@code{HMGL} gr, @code{const char *}eqY, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Рисует функцию @samp{eqY(x)} в плоскости @var{z} равно минимальному значению оси z с координатой @samp{x} в диапазоне осей координат. Опция @code{value} задает начальное число точек. См. также @ref{plot}.
@end deftypefn

@deftypefn {Команда MGL} {} fplot 'x(t)' 'y(t)' 'z(t)' ['pen'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FPlot (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}pen, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_fplot_xyz (@code{HMGL} gr, @code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Рисует параметрическую кривую @{@samp{eqX(t)}, @samp{eqY(t)}, @samp{eqZ(t)}@}, где координата @samp{t} меняется в диапазоне [0, 1]. Опция @code{value} задает начальное число точек. См. также @ref{plot}.
@end deftypefn

@anchor{fsurf}
@deftypefn {Команда MGL} {} fsurf 'z(x,y)' ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FSurf (@code{const char *}eqZ, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""});
@deftypefnx {Функция С} @code{void} mgl_fsurf (@code{HMGL} gr, @code{const char *}eqZ, @code{const char *}sch, @code{const char *}opt);
@end ifclear
Рисует поверхность @samp{eqY(x,y)} с координатами @samp{x}, @samp{y} в диапазоне @code{xrange, yrange}. Опция @code{value} задает число точек. См. также @ref{surf}.
@end deftypefn

@deftypefn {Команда MGL} {} fsurf 'x(u,v)' 'y(u,v)' 'z(u,v)' ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} FSurf (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_fsurf_xyz (@code{HMGL} gr, @code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует параметрическую поверхность @{@samp{eqX(u,v)}, @samp{eqY(u,v)}, @samp{eqZ(u,v)}@}, где координаты @samp{u}, @samp{v} меняются в диапазоне [0, 1]. Опция @code{value} задает число точек. См. также @ref{surf}.
@end deftypefn

@anchor{triplot}
@deftypefn {Команда MGL} {} triplot idat xdat ydat ['sch'='']
@deftypefnx {Команда MGL} {} triplot idat xdat ydat zdat ['sch'='']
@deftypefnx {Команда MGL} {} triplot idat xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TriPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TriPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TriPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_triplot_xy (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_triplot_xyz (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_triplot_xyzc (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует поверхность из треугольников. Вершины треугольников задаются индексами @var{id} в массиве точек @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Строка @var{sch} задает цветовую схему. Если строка содержит @samp{#}, то рисуется сетчатая поверхность. Размер по 1-му индексу массива @var{id} должен быть 3 или больше. Массивы @var{x}, @var{y}, @var{z} должны иметь одинаковые размеры. Массив @var{c} задает цвет треугольников (если @var{id}.ny=@var{c}.nx) или цвет вершин (если @var{x}.nx=@var{c}.nx). См. также @ref{dots}, @ref{crust}, @ref{quadplot}, @ref{triangulation}. @sref{triplot sample}
@end deftypefn

@anchor{tricont}
@deftypefn {Команда MGL} {} tricont vdat idat xdat ydat zdat cdat ['sch'='']
@deftypefnx {Команда MGL} {} tricont vdat idat xdat ydat zdat ['sch'='']
@deftypefnx {Команда MGL} {} tricont idat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TriCont (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TriCont (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TriContV (@code{const mglDataA &}v, @code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} TriContV (@code{const mglDataA &}v, @code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_tricont_xyzc (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tricont_xyz (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tricont_xyzcv (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_tricont_xyzv (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует линии уровня поверхности из треугольников при @var{z}=@var{v}[k] (или при @var{z} равном минимальному значению оси z если @var{sch} содержит @samp{_}). Вершины треугольников задаются индексами @var{id} в массиве точек @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Если аргуент @var{v} не задан, то используется массив из @var{num} элементов равно распределенных в диапазоне изменения цвета. Здесь @var{num} равен значению параметра @code{value} в опциях @var{opt} (по умолчанию 7). Строка @var{sch} задает цветовую схему. Размер по 1-му индексу массива @var{id} должен быть 3 или больше. Массивы @var{x}, @var{y}, @var{z} должны иметь одинаковые размеры. Массив @var{c} задает цвет треугольников (если @var{id}.ny=@var{c}.nx) или цвет вершин (если @var{x}.nx=@var{c}.nx). См. также @ref{triplot}, @ref{cont}, @ref{triangulation}.
@end deftypefn

@anchor{quadplot}
@deftypefn {Команда MGL} {} quadplot idat xdat ydat ['sch'='']
@deftypefnx {Команда MGL} {} quadplot idat xdat ydat zdat ['sch'='']
@deftypefnx {Команда MGL} {} quadplot idat xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} QuadPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} QuadPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} QuadPlot (@code{const mglDataA &}id, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_quadplot_xy (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_quadplot_xyz (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_quadplot_xyzc (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует поверхность из четырёхугольников. Вершины четырёхугольников задаются индексами @var{id} в массиве точек @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Строка @var{sch} задает цветовую схему. Если строка содержит @samp{#}, то рисуется сетчатая поверхность. Размер по 1-му индексу массива @var{id} должен быть 4 или больше. Массивы @var{x}, @var{y}, @var{z} должны иметь одинаковые размеры. Массив @var{c} задает цвет четырёхугольников (если @var{id}.ny=@var{c}.nx) или цвет вершин (если @var{x}.nx=@var{c}.nx). См. также @ref{triplot}. @sref{triplot sample}
@end deftypefn

@anchor{dots}
@deftypefn {Команда MGL} {} dots xdat ydat zdat ['sch'='']
@deftypefnx {Команда MGL} {} dots xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Dots (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Dots (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Dots (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}c, @code{const mglDataA &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_dots (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_dots_a (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {Функция С} @code{void} mgl_dots_ca (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Рисует произвольно расположенные точки @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Строка @var{sch} задает цветовую схему и тип маркеров. Если определёны массивы @var{c}, @var{a} то они задают цвет и прозрачность точек соответственно. Непрозрачные точки с заданным цветом можно нарисовать с помощью @ref{tens}, используя стиль @samp{ .}. Массивы @var{x}, @var{y}, @var{z}, @var{a} должны иметь одинаковые размеры. См. также @ref{crust}, @ref{tens}, @ref{mark}, @ref{plot}. @sref{dots sample}
@end deftypefn

@anchor{crust}
@deftypefn {Команда MGL} {} crust xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Crust (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_crust (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Реконструирует и рисует поверхность по произвольно расположенным точкам @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Опция @var{value} задает радиус ошибки (увеличите для удаления дыр). Строка @var{sch} задает цветовую схему. Если строка содержит @samp{#}, то рисуется сетчатая поверхность. Массивы @var{x}, @var{y}, @var{z} должны иметь одинаковые размеры. См. также @ref{dots}, @ref{triplot}. @c @sref{crust sample}
@end deftypefn

@c ##################################################################
@external{}
@node Nonlinear fitting, Data manipulation, Other plotting, MathGL core
@section Nonlinear fitting
@nav{}
@cindex Fit
@cindex FitS
@cindex PutsFit
@cindex mglFitPnts
@cindex Fit2
@cindex Fit3

Эти функции подбирают параметры функции для наилучшей аппроксимации данных, т.е. минимизируют сумму @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. При этом аппроксимирующая функция @samp{f} может зависеть от одного аргумента @samp{x} (1D случай), от двух аргументов @samp{x,y} (2D случай) или от трех аргументов @samp{x,y,z} (3D случай). Функция @samp{f} также может зависеть от параметров. Список параметров задается строкой @var{var} (например, @samp{abcd}). Обычно пользователь должен предоставить начальные значения параметров в переменной @var{ini}. Однако, при его отсутствии используются нулевые значения. Параметр @var{print}=@code{true} включает вывод найденной формулы в @var{Message} (см. @ref{Error handling}).

Функции Fit() и FitS() не рисуют полученные массивы. Они заполняют массив @var{fit} по формуле @samp{f} с найденными коэффициентами и возвращают @math{\chi^2} ошибку аппроксимации. При этом, координаты @samp{x,y,z} равно распределены в диапазоне осей координат. Число точек в @var{fit} определяется опцией @code{value} (по умолчанию @var{mglFitPnts}=100). Функции используют библиотеку GSL. @sref{Nonlinear fitting hints}

@anchor{fits}
@deftypefn {Команда MGL} {} fits res adat sdat 'func' 'var' [ini=0]
@deftypefnx {Команда MGL} {} fits res xdat adat sdat 'func' 'var' [ini=0]
@deftypefnx {Команда MGL} {} fits res xdat ydat adat sdat 'func' 'var' [ini=0]
@deftypefnx {Команда MGL} {} fits res xdat ydat zdat adat sdat 'func' 'var' [ini=0]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} FitS (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const mglDataA &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{HMDT} mgl_fit_ys (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {Функция С} @code{HMDT} mgl_fit_xys (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {Функция С} @code{HMDT} mgl_fit_xyzs (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {Функция С} @code{HMDT} mgl_fit_xyzas (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@end ifclear
"Подгоняют" формулу вдоль x-, y- и z-направлений для 3d массива заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) с весовым множителем @var{s}[i,j,k].
@end deftypefn

@anchor{fit}
@deftypefn {Команда MGL} {} fit res adat 'func' 'var' [ini=0]
@deftypefnx {Команда MGL} {} fit res xdat adat 'func' 'var' [ini=0]
@deftypefnx {Команда MGL} {} fit res xdat ydat adat 'func' 'var' [ini=0]
@deftypefnx {Команда MGL} {} fit res xdat ydat zdat adat 'func' 'var' [ini=0]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{HMDT} mgl_fit_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {Функция С} @code{HMDT} mgl_fit_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {Функция С} @code{HMDT} mgl_fit_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {Функция С} @code{HMDT} mgl_fit_xyza (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@end ifclear
"Подгоняют" формулу вдоль x-, y- и z-направлений для 3d массива заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) с весовым множителем 1.
@end deftypefn


@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{mglData} Fit2 (@code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit2 (@code{mglData &}fit, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit3 (@code{mglData &}fit, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Fit3 (@code{mglData &}fit, @code{const mglDataA &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{HMDT} mgl_fit_2 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {Функция С} @code{HMDT} mgl_fit_3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
"Подгоняют" формулу вдоль всех направлений для 2d или 3d массива @var{a} с @var{s}=1 и @var{x}, @var{y}, @var{z} равно распределёнными в диапазоне осей координат.
@end deftypefn
@end ifclear

@anchor{putsfit}
@deftypefn {Команда MGL} {} putsfit @code{x y} ['pre'='' 'fnt'='' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} PutsFit (@code{mglPoint} p, @code{const char *}prefix=@code{""}, @code{const char *}font=@code{""}, @code{mreal} size=@code{-1})
@deftypefnx {Функция С} @code{void} mgl_puts_fit (@code{HMGL} gr, @code{mreal} x, @code{mreal} y, @code{mreal} z, @code{const char *}prefix, @code{const char *}font, @code{mreal} size)
@end ifclear
Печатает последнюю подобранную формулу с найденными коэффициентами в точке @var{p0}. Строка @var{prefix} будет напечатана перед формулой. Все другие параметры такие же как в @ref{Text printing}.
@end deftypefn

@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{const char *}GetFit ()
@deftypefnx {Функция С} @code{const char *} mgl_get_fit (@code{HMGL} gr)
@deftypefnx {Fortran процедура} @code{} mgl_get_fit (@code{long} gr, @code{char *}out, @code{int} len)
Возвращает последнюю подобранную формулу с найденными коэффициентами.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{mreal} GetFitChi ()
@deftypefnx {Функция С} @code{mreal} mgl_get_fit_chi ()
Возвращает величину \chi для последней подобранной формулы.
@end deftypefn

@deftypefn {Метод класса @code{mglGraph}} @code{mreal} GetFitCovar ()
@deftypefnx {Функция С} @code{mreal} mgl_get_fit_covar ()
Возвращает ковариационную матрицу для последней подобранной формулы.
@end deftypefn

@end ifclear


@c ##################################################################
@external{}
@node Data manipulation, , Nonlinear fitting, MathGL core
@section Распределение данных
@nav{}
@cindex Hist
@cindex Fill
@cindex DataGrid

@deftypefn {Команда MGL} {} hist @sc{res} xdat adat
@deftypefnx {Команда MGL} {} hist @sc{res} xdat ydat adat
@deftypefnx {Команда MGL} {} hist @sc{res} xdat ydat zdat adat
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Hist (@code{const mglDataA &}x, @code{const mglDataA &}a, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Hist (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}a, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} Hist (@code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}a, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{HMDT} mgl_hist_x (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{const char *}opt)
@deftypefnx {Функция С} @code{HMDT} mgl_hist_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} a, @code{const char *}opt)
@deftypefnx {Функция С} @code{HMDT} mgl_hist_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}opt)
@end ifclear
Создают распределения данных. Они не рисуют данные. Функции могут быть полезны в случае когда данные пользователя определены на случайно расположенных точка (например, после PIC расчетов) и он хочет построить график, требующий регулярных данных (данных на сетках). Диапазон сеток равен диапазону осей координат. Массивы @var{x}, @var{y}, @var{z} определяют положение (координаты) точек. Массив @var{a} задает значения данных. Число точек в результате @var{res} определяется опцией @code{value} (по умолчанию @var{mglFitPnts}=100).
@end deftypefn


@deftypefn {Команда MGL} {} fill dat 'eq'
@deftypefnx {Команда MGL} {} fill dat 'eq' vdat
@deftypefnx {Команда MGL} {} fill dat 'eq' vdat wdat
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Fill (@code{mglData &}u, @code{const char *}eq, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Fill (@code{mglData &}u, @code{const char *}eq, @code{const mglDataA &}v, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglGraph}} @code{void} Fill (@code{mglData &}u, @code{const char *}eq, @code{const mglDataA &}v, @code{const mglDataA &}w, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_data_fill_eq (@code{HMGL} gr, @code{HMDT} u, @code{const char *}eq, @code{HCDT}v, @code{HCDT}w, @code{const char *}opt)
@end ifclear
Заполняют значения массива @samp{u} в соответствии с формулой в строке @var{eq}. Формула -- произвольное выражение, зависящее от переменных @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Координаты @samp{x}, @samp{y}, @samp{z} полагаются в диапазоне изменения осей координат. Переменная @samp{u} -- значение исходного массива. Переменные @samp{v} и @samp{w} -- значения массивов @var{v}, @var{w}, которые могут быть @code{NULL} (т.е. могут быть опущены).
@end deftypefn

@deftypefn {Команда MGL} {} datagrid dat xdat ydat zdat
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} DataGrid (@code{mglData &}u, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_data_grid (@code{HMGL} gr, @code{HMDT} u, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}opt)
@end ifclear
Заполняет значения массива @samp{u} результатом линейной интерполяции по триангулированной поверхности, найденной по произвольно расположенным точкам @samp{x}, @samp{y}, @samp{z}. NAN значение используется для точек сетки вне триангулированной поверхности. @sref{Making regular data}
@end deftypefn

@deftypefn {Команда MGL} {} refill dat xdat vdat [sl=-1]
@deftypefnx {Команда MGL} {} refill dat xdat ydat vdat [sl=-1]
@deftypefnx {Команда MGL} {} refill dat xdat ydat zdat vdat
@ifclear UDAV
@deftypefnx {Метод класса @code{mglData}} @code{void} Refill (@code{mglDataA &}dat, @code{const mglDataA &}x, @code{const mglDataA &}v, @code{long} sl=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglData}} @code{void} Refill (@code{mglDataA &}dat, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}v, @code{long} sl=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Метод класса @code{mglData}} @code{void} Refill (@code{mglDataA &}dat, @code{const mglDataA &}x, @code{const mglDataA &}y, @code{const mglDataA &}z, @code{const mglDataA &}v, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{void} mgl_data_refill_gr (@code{HMGL} gr, @code{HMDT} a, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} v, @code{long} sl, @code{const char *}opt)
@end ifclear
Заполняет значениями интерполяции массива @var{v} в точках @{@var{x}, @var{y}, @var{z}@}=@{@code{X[i], Y[j], Z[k]}@} (или @{@var{x}, @var{y}, @var{z}@}=@{@code{X[i,j,k], Y[i,j,k], Z[i,j,k]}@} если @var{x}, @var{y}, @var{z} не 1d массивы), где @code{X,Y,Z} равномерно распределены в диапазоне осей координат и имеют такой же размер как и массив @var{dat}. Если параметр @var{sl} равен 0 или положительный, то изменятся будет только @var{sl}-ый срез.
@end deftypefn



@deftypefn {Команда MGL} {} pde @sc{res} 'ham' ini_re ini_im [@code{dz=0.1 k0=100}]
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{mglData} PDE (@code{const char *}ham, @code{const mglDataA &}ini_re, @code{const mglDataA &}ini_im, @code{mreal} dz=@code{0.1}, @code{mreal} k0=@code{100}, @code{const char *}opt=@code{""})
@deftypefnx {Функция С} @code{HMDT} mgl_pde_solve (@code{HMGL} gr, @code{const char *}ham, @code{HCDT} ini_re, @code{HCDT} ini_im, @code{mreal} dz, @code{mreal} k0, @code{const char *}opt)
@end ifclear
Решает уравнение в частных производных du/dz = i*k0*@var{ham}(p,q,x,y,z,|u|)[u], где p=-i/k0*d/dx, q=-i/k0*d/dy -- псевдо-дифференциальные оперторы. Параметры @var{ini_re}, @var{ini_im} задают действительную и мнимую часть начального распределения поля. Координаты @samp{x}, @samp{y}, @samp{z} полагаются в диапазоне изменения осей координат. Отмечу, ято в действительности этот диапазон увеличен на 3/2 для уменьшения отражения от границ сетки. Параметр @var{dz} задает шаг по эволюционной координате z. Сейчас используется упрощенный вид функции @var{ham} -- исключены все ``смешанные'' члены (типа @samp{x*p}->x*d/dx). Например, в 2D случае это функция вида @math{ham = f(p,z) + g(x,z,u)}. Однако, коммутирующие члены (типа @samp{x*q}->x*d/dy) разрешены. Переменная @samp{u} используется для амплитуды поля |u|, что позволяет решать нелинейные задачи -- например уравнение Шредингера @code{ham="p^2 + q^2 - u^2"}. Вы можете задавать мнимую часть для поглощения волн, например @code{ham = "p^2 + i*x*(x>0)"}, но только для линейной зависимости от переменной @samp{i} (т.е. @math{ham = hre+i*him}). @sref{PDE solving hints}
@end deftypefn

@c ##################################################################
@c @external{}
@c @node IDTF functions, , Data distributions, MathGL core
@c @section IDTF функции
@c @nav{}

@c Эти функции обеспечивают поддержку особых возможностей при создании IDTF. Во всех прочих случаях они не делают ничего.

@c @deftypefn {Метод класса @code{mglGraph}} @code{void} VertexColor (@code{bool} enable)
@c Разрешает плавное изменение цвета.
@c @end deftypefn

@c @deftypefn {Метод класса @code{mglGraph}} @code{void} Compression (@code{bool} enable)
@c Дает меньший объем файла, но с худшим качеством.
@c @end deftypefn

@c inline void DoubleSided(bool){}	// NOTE: Add later -- IDTF
@c inline void TextureColor(bool){}	// NOTE: Add later -- IDTF

@c @end ifclear

@external{}
