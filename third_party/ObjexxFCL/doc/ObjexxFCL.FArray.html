<!DOCTYPE html>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<title>ObjexxFCL Users Guide: FArray</title>
	<meta name="description" content="Objexx Fortran Compatibility Library">
	<meta name="keywords" content="ObjexxFCL, Fortran-to-C++, F2C++, F2Cpp, F2Cxx, F2C, Fortran, C++, array library">
	<meta name="copyright" content="Copyright 2000-2014 Objexx Engineering, Inc. All rights reserved.">
	<link rel="icon" href="favicon.ico" type="image/x-icon">
	<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
	<link rel="stylesheet" href="styles/Objexx.css" type="text/css">
	<style type="text/css">
	<!--
	.style1 {font-weight: bold}
	-->
	</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#CC3366" vlink="#990033" alink="#FF3366">
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tbody>
	<tr>
		<td></td>
		<td height="80"><a href="ObjexxFCL.html"><img src="images/Objexx.logo.gif" alt="Home" border="0" align="left" /></a></td>
		<td></td>
		<td colspan="3" valign="middle"><div id="Title">ObjexxFCL 4.0</div></td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td colspan="5" height="16" valign="top" bgcolor="#CFD8B4"></td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td height="24" colspan="5"></td>
		<td></td>
	</tr>
	<tr>
		<td height="300">&nbsp;</td>
		<td valign="top">
			<div id="sectionLinksTop">
				<a href="ObjexxFCL.html">Home</a>
			</div>
			<div id="sectionLinks">
				<a href="ObjexxFCL.Release.html">Release</a>
				<a href="ObjexxFCL.Users.html">Users Guide</a>
				<a href="ObjexxFCL.Developers.html">Developers</a>
				<a href="ObjexxFCL.Support.html">Support</a>
				<a href="http://objexx.com">Web</a>
			</div>
		</td>
		<td></td>
		<td width="500" valign="top">
			<h1>FArray</h1>
			<p class="body">The FArray class template hierarchy provides Fortran-compatible arrays with these attributes of Fortran 77 arrays:</p>
			<ul class="body">
				<li>Column-major, contiguous element storage.</li>
				<li>Arbitrary index ranges for each dimension.</li>
				<li>Arrays and array elements can be passed to array arguments of any <b>rank</b> (number of dimensions) and/or dimensions.</li>
				<li>Array arguments can be dimensioned with an assumed size for the last dimension.</li>
            </ul>
			<p class="body">and these capabilities <em>not</em> provided by Fortran 77 arrays:</p>
			<ul class="body">
				<li>Default and copy construction</li>
				<li>Constant arrays and optionally const-correct array proxies</li>
				<li>Initializer values/functions (more powerful than DATA statements)</li>
				<li>Whole-array value and array assignment</li>
				<li>Index range and size accessors</li>
				<li>Linear index subscripting for fast inner loop operations</li>
				<li>Dynamic (run-time) sizing</li>
				<li>Automatic dynamic sizing using <a href="ObjexxFCL.Dimension.html">Dimensions</a></li>
			</ul>
			<p class="body">The FArrays are not intended to be a complete numerical matrix class library. A number of general purpose matrix libraries are available for C++ and Objexx Engineering can provide interfacing to those libraries. Objexx Engineering can also provide linear algebra functions and solvers for the FArray classes to meet project requirements.</p>
			<p class="body">There are five types of FArrays:</p>
			<ul class="body">
				<li><a href="#Base_FArrays">Base FArrays</a> are the abstract base class for the three concrete FArray types.</li>
				<li><a href="#Real_FArrays">Real FArrays</a> are regular arrays that own their data.</li>
				<li><a href="#Proxy_FArrays">Proxy FArrays</a> arrays that use the data of another array. Proxy arrays automatically redimension themselves when any Dimension objects that they depend on are set/changed and can reattach themselves to the reallocated data of their source arrays in some cases. Proxy arrays provide &quot;EQUIVALENCE&quot; support between arrays.</li>
				<li><a href="#Argument_FArrays">Argument FArrays</a> that use the data of other arrays. Argument arrays are a type of proxy but unlike proxy FArrays they do not automatically redimension or reattach themselves. Argument arrays are used as function arguments to support passing arrays of a different rank or array &quot;slices&quot; to functions as is common in Fortran 77 usage.</li>
<!--				<li><a href="#Key_FArrays">Key FArrays</a> are real FArrays that use key index types for element lookup.<-->
				<li><a href="#Slice_FArrays">Slice FArrays</a> are proxy arrays that select a sub-array of the same or lesser rank defined by index slices or sections.</li>
			</ul>
			<p class="body">The FArrays are class templates. Shorthand (typedef) names are provided for the common value types in the FArray forward declaration headers so, for example, we use <span class="source">FArray2D_int</span> instead of <span class="source">FArray2D&lt; int &gt;</span> on this page.</p>

			<h2 class="h4"><a href="ObjexxFCL.Dimension.html" class="h3">Dimensions</a></h2>
			<p class="body">The ObjexxFCL supports automated dynamic array dimensioning based around Dimension  parameter objects, as described in the <a href="ObjexxFCL.Dimension.html">Dimensions</a> section. </p>

			<h2 class="h4"><a href="ObjexxFCL.IndexRange.html" class="h3">Index Ranges</a></h2>
			<p class="body">As in Fortran arrays, the dimensions of FArrays can be an arbitrary index range. These ranges are described in the <a href="ObjexxFCL.IndexRange.html">Index Ranges</a> section. Each FArray class contains a typedef named IR that is the correct IndexRange type for that FArray type: DynamicIndexRange for real and proxy FArrays and StaticIndexRange for argument FArrays, and IndexRange for abstract FArray base classes.</p>

			<h2 class="h3">Subscripting</h2>
			<p class="body">FArray elements can be accessed, as in Fortran, by passing a list of indices:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7">
					<pre>FArray2D_double A( 5, 10 );
...
double x = A( 3, 7 );</pre></td>
				</tr>
			</table>
			<p class="body">This type of subscripting can add significant overhead in inner loop computations, especially for higher rank arrays. For <b>faster</b> access to array elements when the elements are contiguous or the stride is known the FArrays provide an <span class="source">index</span> member function that returns a zero-based linear index for subscripting via a C-style [] operator, as in:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7">
					<pre>FArray2D_int A( 5, 10 );
for ( int j = 1, k = A.index( 1, 1 ); j &lt;= 10; ++j ) {
   // A.index( 1, 1 ) is 0
   for ( int i = 1; i &lt;= 5; ++i, ++k ) {
	  A[ k ] = i * j; // [ k ] == ( i, j )
   }
}</pre></td>
				</tr>
			</table>
			<p class="body">The <span class="source">index</span> calls return an unsigned value of type FArray<i>N</i>D::size_type but they can be assigned to a signed or smaller integer type if there are no concerns about exceeding the range of that type. To support index math, <span class="source">index</span> doesn't check that the subscript is in bounds for the FArray but linear subscripting accesses to an FArray's elements are bounds-checked via assertions in a debug build: these checks can only determine if the index is within the linear extent of the data array, so the index range checking of each dimension is sacrificed for speed. </p>

			<h2 class="h3">Assignment</h2>
			<p class="body">FArrays support the whole-array assignment of any FArray of the same rank and dimensions with the operators {=, +=, -=}:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			<tr>
				<td bgcolor="#F7F4F7"><pre>FArray2D_int A( 3, 3 );
FArray2D_double B( 3, 3 );
...
B = A;
...
A += B;</pre></td>
			</tr>
			</table>
			<p class="body">and the whole-array  assignment of any value that is assignment-compatible with the FArray's value type with the operators {=, +=, -=, *=, /=}:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			<tr>
				<td bgcolor="#F7F4F7"><pre>FArray2D_int A( 3, 3 );

...
A = 123; // All elements set to 123
A += 4.2; // Now elements are 127</pre></td>
			</tr>
			</table>
			<p class="body">The FArray whole-array assignment operators are supported for value types that support those operators.</p>
			<p>FArrays also support assignment of different dimensioned arrays of the same rank with the operator = functions:</p>
			<table border="1" cellspacing="0" cellpadding="12">
              <tr>
                <td bgcolor="#F7F4F7"><pre>FArray2D_int A( 3, 3 );
FArray2D_double B( 5, 5 );
...
B = A; // Now B is 3 x 3</pre></td>
              </tr>
            </table>
			<p>This will redimension the array if necessary before assigning the values of the other array. For an argument or proxy FArray this redimensioning only changes the view into the data array to which it is attached.</p>
			<p class="body">Individual FArray elements can be assigned in the usual fashion using multidimensional or linear subscripting:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			<tr>
				<td bgcolor="#F7F4F7"><pre>FArray2D_double A( 5, 10 );
...
A( 3, 7 ) = 1.23;
A[ 28 ] = 4.56;</pre></td>
			  </tr>
			</table>
			<p><b>Warning!:</b> Assignment between real FArrays and (argument or proxy FArray) proxies of them or between proxies of the same real FArray can lead to unexpected results and should be avoided.</p>

			<h2 class="h3"><a name="Base_FArrays" id="Base_FArrays"></a>Base FArrays</h2>
			<p class="body">Base FArrays are the abstract base class for the three concrete types of FArrays of the same rank and value type. Base FArrays classes have names of the form
			FArray<em>N</em>&lt;<em>type</em>&gt;	with shorthand names of the form FArray<em>N</em>_<em>type</em> where <em>N</em> is the rank of the array and <em>type</em> is the value type the array hold. Functions written with pass by reference or const reference base FArray arguments can be passed any FArrays of its rank and value type.</p>

			<h2 class="h3"><a name="Real_FArrays" id="Real_FArrays"></a>Real FArrays</h2>
			<p class="body">Real FArrays are normal arrays that own their data. Real FArrays have names of the form FArray<em>N</em>D&lt;<em>type</em>&gt; with shorthand names of the form FArray<em>N</em>D_<em>type</em> where <em>N</em> is the rank of the array and <em>type</em> is the value type the array hold.</p>
			<h3 class="h4">Construction</h3>
			<p class="body">Real FArrays can be constructed in a number of ways. Default construction is not possible with Fortran 77 arrays but is for FArrays: </p>
			<table border="1" cellspacing="0" cellpadding="12">
			  <tr>
				<td bgcolor="#F7F4F7"><pre>FArray2D_int A; // Default constructed: Nothing allocated</pre></td>
			  </tr>
			</table>
			<p class="body">Default constructed real FArrays can be later dimensioned and allocated with a <span class="source">dimension</span> call as described below.</p>
			<p class="body">Index range construction is analogous to Fortran 77 array declaration: </p>
			<table border="1" cellspacing="0" cellpadding="12">
			<tr>
				<td bgcolor="#F7F4F7"><pre>
FArray2D_int A( 10, 10 ); // 10 x 10 array


// Same as F77 array: INTEGER A(1:5,-10:10)
FArray2D_int A( 5, DRange(-10,10) );
FArray2D_int A( 5, FArray2D_int::IR(-10,10) ); // Same thing
</pre></td>
			  </tr>
			</table>
			<p class="body">To specify an index range with a lower index other than 1 an explicit index range must be specified, as in Fortran. DRange is a shorthand name for DynamicIndexRange, which is the type of index range that a real FArray uses.</p>
			<p class="body">Copy constructors accept any FArray of the same rank that has an data type that is assignable to the FArray being constructed:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			<tr>
				<td bgcolor="#F7F4F7"><pre>FArray2D_int A( 3, 3 );
FArray2D_float B( A );</pre></td>
			  </tr>
			</table>
			<h3 class="h4">Initialization</h3>
			<p class="body">As in Fortran, for run-time efficiency arrays are uninitialized by default. An optional final <b>initializer</b> constructor argument can be used to specify a uniform initializer value:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7">
						<pre>FArray3D_float B( 2, 7, 3, 4.56 );</pre></td>
				</tr>
			</table>
			<p class="body">Or an initializer function for non-uniform initialization:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>void
A_initializer( FArray1D_int &amp; A )
{
   A( 1 ) = 1;
   A( 2 ) = 2;
}

FArray1D_int A( 2, A_initializer );</pre></td>
				</tr>
			</table>
			<p class="body">Initializer functions are any void functions that take a non-const reference to the FArray type.</p>
			<p class="body">Initializer values should be of the exact value type of the FArray to avoid any potential C++ ambiguity when the value is zero of a different type that could be equally well converted to the value type or to a function pointer.</p>
			<p class="body">Initializers are automatically reapplied when a real FArray is automatically resized because a Dimension that it depends on is modified. Initializer functions for FArrays that may go through such automatic resizing should therefore be written to initialize within the FArray's current dimensional bounds, using the <span class="source">l<em>N</em></span> and <span class="source">u<em>N</em></span> functions to access the lower and upper index ranges of dimension <em>N</em>. Explicit resizing with a <span class="source">dimension</span> call (see below) will remove the initializer but a variant <span class="source">dimension</span> call with an extra initializer argument can be used. Data-preserving <span class="source">redimension</span> calls (see below) also remove the initializer. The intializer value or function can be explicitly set with <span class="source">initializer</span> calls and cleared with <span class="source">initializer_clear</span>:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>
A.initializer( 123 );
B.initializer( B_initializer );
C.initializer_clear();</pre></td>
				</tr>
			</table>
			<p class="body">FArrays without initializer values or functions can be <b>default initialized</b> to the default-constructed value of the data type (zero for numeric types) by defining the OBJEXXFCL_FARRAY_INIT macro when compiling (this is done with a -DOBJEXXFCL_FARRAY_INIT switch to GCC and some other compilers). All source files must be compiled with this definition if any are or undefined behavior may result. There could be a significant performance cost to initializing all arrays this way and it can mask initialization errors so this is recommended primarily for transitional use while migrating and debugging code that depended on a Fortran compiler (such as g77) that did  (non-standard) zero-initialization of arrays.</p>
			<h3 class="h4">Explicit Dimensioning</h3>
			<p class="body">Although Fortran 77 does not provide array resizing real FArrays can be dynamically (re)sized via the <span class="source">dimension</span> member function using a syntax similar to their constructors:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>FArray2D_int A( 3, 3 );
...
A.dimension( 4, 4 ); // Uninitialized
...
A.dimension( 5, 5, 123 ); // Initialize values to 123</pre></td>
				</tr>
			</table>
			<p class="body">The basic <span class="source">dimension</span> call discards the data that was in the real FArray, removes any initializer associated with it, and does not initialize the redimensioned array (unless the code was compiled with OBJEXXFCL_FARRAY_INIT defined). Real FArrays have a variant of <span class="source">dimension</span> that is analogous to the constructors with an extra initializer argument.</p>
			<p class="body">The <span class="source">redimension</span> call preserves the data in the real FArray that overlaps with the new dimensions. The elements in any added portions are not initialized unless the <span class="source">redimension</span> variant with a fill value is used:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>FArray2D_int A( 3, 3 );
...
A.redimension( 4, 4 ); // Row &amp; col 4 are uninitialized
...
A.redimension( 5, 5, 123 ); // Sets new elements to 123</pre></td>
				</tr>
			</table>
			<p> The <span class="source">redimension</span> calls removes any initializer associated with the real FArray (a fill value is not treated as a new initializer). A new initializer can be assigned to the FArray by an explicit <span class="source">initializer</span> call (see above). </p>
			<p class="body">Real FArrays can also be dimensioned and redimensioned to match the dimensions of another array:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>FArray2D_float A( 3, 3 );
FArray2D_float B( 5, 5 );
FArray2D_float C; // Default constructed
...
C.dimension( A ); // C is now 3 x 3
...
C.redimension( B ); // C is now 5 x 5 with 3 x 3 portion preserved</pre></td>
				</tr>
			</table>
			<p class="body"><b>Warning!:</b> Resizing a real FArray invalidates any argument FArrays attached to it and any proxy FArrays attached to its elements or sections.</p>

			<h2 class="h3"><a name="Proxy_FArrays" id="Proxy_FArrays"></a>Proxy FArrays</h2>
			<p class="body">Proxy FArrays behave in most ways like a real FArray but they attach to the data of another FArray and do not allocate or own their array data. Proxy FArrays can attach to all or part of FArrays of any rank and dimensions. Typically, they may provide a smaller, lower rank &quot;view&quot; of a slice of a larger array or simply a lower rank &quot;view&quot; of a whole array. This provides the ability to mimic Fortran array passing &ldquo;tricks&rdquo; and the memory sharing of a Fortran <b>EQUIVALENCE</b> between two arrays or array sections.</p>
			<p class="body">Proxy FArrays will automatically redimension themselves if a <a href="ObjexxFCL.Dimension.html">Dimension</a> they depend on is changed. Proxy FArrays attached to whole FArrays will automatically reattach themselves to the array data if the source array is reallocated. </p>
			<p class="body">Proxy FArrays have names of the form FArray<em>N</em>P&lt;<em>type</em>&gt; with shorthand names of the form FArray<em>N</em>P_<em>type</em> where <em>N</em> is the rank of the array and <em>type</em> is the value type the array hold. </p>
			<h3 class="h4">Construction</h3>
			<p class="body">Proxy FArrays can be constructed in a number of ways. Default construction creates an undimensioned proxy FArray that is not attached to another FArray:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			  <tr>
				<td bgcolor="#F7F4F7"><pre>FArray2P_int P; // Default constructed: Detached</pre></td>
			  </tr>
			</table>
			<p class="body">Default-constructed proxy FArrays can be later attached and dimensioned  with <span class="source">attach</span> and <span class="source">dimension</span> calls as described below.</p>
			<p class="body">Whole array construction attaches the proxy FArray to the whole source FArray: </p>
			<table border="1" cellspacing="0" cellpadding="12">
			  <tr>
				<td bgcolor="#F7F4F7"><pre>FArray2D_int A( 7, 7 );
FArray1P_int P( A ); // 1-D view of A</pre></td>
			  </tr>
			</table>
			<p class="body">You can also construct a whole-array proxy FArray and specify its dimensions with multi-argument constructors:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			<tr>
				<td bgcolor="#F7F4F7"><pre>FArray3D_int A( 5, 5, 10 );
FArray2P_int P( A, 25, 10 ); // 2-D view of A</pre></td>
			  </tr>
			</table>
			<p class="body">Proxy FArrays can be constructed from elements of another FArray to create a view of a portion of the array:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			<tr>
				<td bgcolor="#F7F4F7"><pre>FArray3D_int A( 5, 5, 10 );
FArray2P_int P( A( 1, 1, 3 ), 5, 5 ); // 2-D slice
FArray2P_int S( A.a( 1, 1, 3 ), 5, 5 ); // 2-D section</pre></td>
			  </tr>
			</table>
			<p class="body"> The S array is passed an element using the <span class="source">a</span> subscripting function, which  creates an FArrayTail object that knows its size, which allows bounds error detection in debug builds but at some cost in construction time.</p>
			<p class="body">When single-argument constructors are used, as when creating a proxy FArray via pass-by-value, default proxy FArray dimensions are used: </p>
			<ul class="body">
				<li>If the argument is an FArray of the same rank as the argument FArray then its dimensions are used.</li>
				<li>If the argument is an FArray of different rank or an array element or section then an index range of [1,1] is used for all dimensions except the last which gets the range [1,<em>size</em>] where <em>size</em> is the array or section size and is unbounded for construction from an element. The <span class="source">dimension</span> function (see below) can be used to set the desired dimensions before the array is used.</li>
			</ul>
			<p class="body">Index ranges are specified the same as for real FArrays: DynamicIndexRange is also the index range type used by proxy FArrays.</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>FArray3D_int const A( 5, 5, 10, A_initializer );
FArray2P_int const P( A( 1, 1, 3 ), 5, 5 ); // 2-D slice
</pre></td>
				</tr>
			</table>
			<h3 class="h4">Attach/Detach</h3>
			<p class="body">Proxy FArrays can be dynamically attached and detached from source arrays:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			<tr>
				<td bgcolor="#F7F4F7"><pre>FArray2P_int P; // Default constructed: Detached
...
FArray3D_int A( 3, 3, 5 );
P.attach( A ).dimension( 9, 5 ); // All of A
...
P.attach( A( 3, 3, 2 ) ).dimension( 3, 3 ); // Slice of A</pre></td>
			  </tr>
			</table>
			<p class="body">A call to <span class="source">detach</span> detaches a proxy FArray from its source array. It isn't necessary to explicitly detach before attaching to a new source array. The <span class="source">dimension</span> calls (see below) are chained after the <span class="source">attach</span> calls to set the dimensions.</p>
			<p class="body">The <span class="source">active</span> member function will tell you whether a proxy FArray is currently attached to a source array. </p>
			<h3 class="h4">Explicit Dimensioning</h3>
			<p class="body">Proxy FArrays can be dynamically (re)sized via the <span class="source">dimension</span> member function using a syntax similar to their constructors:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			  <tr>
				<td bgcolor="#F7F4F7"><pre>FArray3D_int A( 3, 3, 5 );
FArray2P_int P( A( 1, 1, 2 ) );
P.dimension( 3, 3 );
</pre></td>
			  </tr>
			</table>
			<p class="body">Dimensioning proxy FArrays only changes the perceived size of the proxys' view and doesn't cause reallocation of a data array, so no initializing variants of <span class="source">dimension</span> are provided. From the proxys' perspective the elements are reflowed in column-major order to fill the new dimensions, unlike a data-preserving <span class="source">redimension</span> call on a real FArray, which keeps elements in their original index positions as the dimensions change. Attempting to dimension a proxy FArray to a size that exceeds the actual size of the associated data array, if known, will trigger an assertion failure in debug builds.</p>
			<p class="body">Proxy FArrays can also be dimensioned to match the dimensions of another array:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			  <tr>
				<td bgcolor="#F7F4F7"><pre>FArray2D_float B( 3, 3 );

FArray3D_int A( 3, 3, 5 );
FArray2P_int P( A( 1, 1, 2 ) );
P.dimension( B );
</pre></td>
			  </tr>
			</table>
			<p class="body">An assumed-size (upper-unbounded) dimension can be specified for the last dimension by using the <span class="source">ObjexxFCL::star</span> object: </p>
			<table border="1" cellspacing="0" cellpadding="12">
			  <tr>
				<td bgcolor="#F7F4F7"><pre>void f( FArray2P_int I )
{
   I.dim( 100, star ); // Assumed-size
}</pre></td>
			  </tr>
			</table>
			<p><span class="body">The use of <span class="source">ObjexxFCL::star</span> for the last dimension is analogous to Fortran's assumed-size array dimensioning. If the actual array size is known then the last dimension will be set appropriately so that bounds errors can be caught by assertion failures in debug builds, but if an array element is passed by the fast method the last dimension will have an unbounded upper extent and the array size will be unbounded.</span></p>
			<p><span class="body">The <span class="source">dim</span> function can be used to dimension a const proxy FArray, such as one created <i>via</i> a pass-by-value argument:</span></p>
			<table border="1" cellspacing="0" cellpadding="12">
			  <tr>
				<td bgcolor="#F7F4F7"><pre>void f( FArray2P_double const R )
{
   R.dim( 3, 3 );
   ...
}</pre></td>
			  </tr>
			</table>
			<p><b>Warning!:</b> Resizing a real FArray invalidates any proxy FArrays that are attached to its its elements or sections.</p>
			<h3 class="h4">Const-Correctness</h3>
			<p class="body">Proxy and argument FArrays have proxy semantics and share the const-correctness semantics of pointers. The constness of the proxy and the data it is a proxy for are distinct and both are needed to get full constness:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>FArray2D_int const A( 3, 3 );
...
FArray2P_int B( A ); // Can alter A's data and proxy's state
FArray2P_int const C( A ); // Can alter A's data but not proxy's state</pre>
				</tr>
			</table>
			<p class="body">One approach sometimes used to address this issue is to provide always-const versions of the proxy classes. This has the benefit of compile-time const correctness checks but forces a lot of code changes and limits the legal attach operations.</p>
			<p class="body">The approach used in the ObjexxFCL is different. If the macro <b>OBJEXXFCL_PROXY_CONST_CHECKS</b> is defined when compiling the ObjexxFCL and application code in debug mode (either via a <b>#define</b> in the code or on the compile command line, typically with <b>-DOBJEXXFCL_PROXY_CONST_CHECKS</b>) the proxy FArrays remember if they were attached to const data and, if so, any operations that would alter the array data will trigger assertion failures. This gives the user the choice as to whether strict proxy const-correctness is enforced but only detects violations at runtime <i>via</i> assertion tests. When using GCC on Linux you can set <b>OBJEXXFCL_PROXY_CONST_CHECKS</b> to a value of 2 to turn on a report-only mode that sends backtraces for each violation to stderr but does not abort.</p>
			<p class="body">Argument FArrays (see below) are typically created <i>via</i> pass-by-value function arguments. If the functions do not need to alter the array values then qualify them with const in the function declaration so that the const array subscript operators will be used, avoiding const-correctness violations. Alternatively, a const reference to the argument FArrays can be used for subscripting operations.</p>

			<h2 class="h3"><a name="Argument_FArrays" id="Argument_FArrays"></a>Argument FArrays</h2>
			<p class="body">Argument FArrays are very similar to proxy FArrays but are designed for very fast construction as pass-by-value function arguments and, for efficiency, do <em>not</em> automatically redimension when <a href="ObjexxFCL.Dimension.html">Dimensions</a> used in their index ranges change or automatically reattach to reallocated source arrays.</p>
			<p class="body">Argument FArrays have names of the form FArray<em>N</em>A&lt;<em>type</em>&gt; with shorthand names of the form FArray<em>N</em>A_<em>type</em> where <em>N</em> is the rank of the array and <em>type</em> is the value type the array hold.</p>
			<p class="body">Construction, assignment, attach/detach, explicit dimensioning and other functions are analogous to those of proxy FArrays. Index ranges are specified the same as for real and proxy FArrays except that StaticIndexRange is the index range type used by argument FArrays.</p>
			<p class="body">Here is an example of a real FArray of three dimensions being passed to an argument FArray of two dimensions:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			  <tr>
				<td bgcolor="#F7F4F7"><pre>void f( FArray2A_int A ) // Pass by value
{
   A.dim( 10, 77 );
   A( 2, 33 ) = 3.14159;
}

void g()
{
   FArray3D_int G( 5, 22, 7 );
   f( G );
}</pre></td>
			  </tr>
			</table>
			<p class="body">When an argument FArray is declared as a pass-by-value argument of a function the actual argument passed becomes the constructor argument to the argument FArray. Argument FArrays must be passed by value to create a proxy of the passed array, but they can also be passed by reference when proxy creation isn't needed (no change to rank or dimensions is required). Although there is no copying of the array data when argument FArrays are constructed there is a small construction cost.</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>void f( FArray2A_int <b>const</b> A ) // Pass by value: A is const
{
   A.dim( 10, 77 ); // dim allowed on const A
   // Don't need/want to modify A here
}

void g()
{
   FArray3D_int G( 5, 22, 7 );
   f( G );
}</pre></td>
				</tr>
			</table>
			<p class="body">The <span class="source">dim</span> function is like <span class="source">dimension</span> but can be used to set up the argument FArray dimensions even if it is const: this is needed since we can't set the desired dimensions in the argument declaration.</p>
			<p class="body"><b>Warning!:</b> Resizing a real FArray invalidates any argument FArrays that are attached to its data.</p>

<!--			<h2 class="h3"><a name="Key_FArrays" id="Key_FArrays"></a>Key FArrays</h2>																																																																																																																																																																-->
<!--			<p class="body">Key FArrays are real FArrays that are accessed by key index objects rather than integer indices. Any key type that the Key FArray is able to convert to an integer will work: if the integer index for a key is a protected or private conversion then the Key FArray will have to be a friend of the key type. -->

			<h2 class="h3"><a name="Slice_FArrays" id="Slice_FArrays"></a>Slice FArrays</h2>
			<p class="body">Slice FArrays are array proxies that present a slice of another array as an array of the same or lesser rank. A slice FArray is normally created by an indexing operation on an array where some or all of the indexes are index slices rather than scalar indexes. An index slice has a start index, an end index, and a stride, or step, value. Index slices are denoted with a <span class="source">{start,end,stride}</span> syntax:</p>
			<table border="1" cellspacing="0" cellpadding="12">
			  <tr>
				<td bgcolor="#F7F4F7"><pre>FArray2D_int A( 3, 3 ); // 2D array
...
A( {1,3,2}, {1,3,2} ); // 2D 2x2 slice of A selecting indexes 1 and 3 in each dimension
A( 2, {1,2} ); // 1D slice of A with elements 1 and 2 of A's 2nd row
</pre></td>
			  </tr>
			</table>
			<p class="body">Details about slice arrays:</p>
				<ul>
					<li>The start and end indexes must be valid array indexes for the dimension.</li>
					<li>Start indexes default to the lower index of the dimension.</li>
					<li>End indexes default to the upper index of the dimension.</li>
					<li>Stride values default to 1 and can be positive or negative but not zero.</li>
					<li>The <span class="source">{start,end,stride}</span> syntax uses the C++11 initializer_list type. An underscore can be used for the start or end index to indicate the default value. An index slice with a single value is taken as specifying the start index as in <span class="source">{start}</span>. (The underscore is actually a predefined object of the Omit type provided for convenience.)</li>
					<li>Slice arrays themselves are indexed contiguously like regular arrays with a lower index of 1 in each dimension.</li>
					<li>Index slices are instances of the IndexSlice class internally and that type can be used instead of the initializer_list syntax but this is not recommended.</li>
					<li>Slice arrays are types within the FArrayS class template hierarchy.</li>
					<li>Slice arrays are used for the analog of Fortran's assumed shape array arguments as pass-by-value proxy arguments.</li>
					<li>While slices are proxies, so creating them does not copy arrays, there are performance considerations when using them. There is some modest overhead in constructing a slice, either from an explicit slicing operation or as a pass-by-value argument. Slices do not support the fast linear indexing of the other FArrys, limiting performance tuning opportunities. Sparse slices are not cache efficient and thus can degrade performance. It is sometimes beneficial to copy the slice of interest into a contiguous FArray before using it in a performance-critical section.</li>
				</ul>

			<h2 class="h3">FArray Passing</h2>
			<p class="body">Real FArrays can be used as function arguments that are declared as passed by value (expensive), reference, or const reference. Within the functions those FArrays have the same rank and dimensions as the passed FArray.</p>
			<p class="body">To pass FArrays of different rank or dimensions or size or to pass FArray elements as the starting point of an FArray section or slice the function argument must be a proxy or argument FArray declared as pass-by-value. These arrays are constructed at the time of the function call but the underlying data is not copied: since they are proxies for the passed arrays data so the construction cost is modest. Argument FArrays do not automatically redimension themselves when Dimensions used in their index ranges change and do not automatically reattach to source arrays that are reallocated so they are less expensive to construct than proxy FArrays.</p>
			<p class="body">Arrays and array elements of any rank and size FArray can be passed to a proxy or argument FArray. Although the array data is not copied, the construction of proxy or argument FArrays at each function call can add significant overhead for heavily called functions compared with passing FArrays by reference. If a function will always be passed arrays of the rank and dimensions used by the function it is more efficient for the array arguments to be passed by reference. To support passing all types of FArray of a given rank and value type to a function the arguments should be declared references to the base FArray class of that rank and value type:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>void f( FArray2_int &amp; A );</pre></td>
				</tr>
			</table>
			<p class="body">Base FArrays support all FArray operations except those with semantics that are specific to the concrete FArray type, such as <span class="source">dimension</span> or <span class="source">attach</span>.</p>

			<h2 class="h3">FArray Element Passing</h2>
			<p class="body">There are two ways to pass an array element to an argument array, <b>faster</b> or <b>safer</b>:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>void f( FArray2A_int A );

void g()
{
   FArray3D_int G( 3, 3, 5 );
   f( G( 2, 3, 4 ) ); // Faster
   f( G.a( 2, 3, 4 ) ); // Safer
}</pre></td>
				</tr>
			</table>
				<p class="body">The faster method is transparent in the call statement but does not provide the function information about the actual size of the underlying array. The safer method uses the argument member function, <span class="source">a</span>, to provide a proxy for the array tail section starting at the specified element that allows the function to check for array bounds errors in debug builds.</p>

				<h2 class="h3">FArray Size</h2>
				<p class="body">FArray sizes are limited to  2<sup>N</sup>-2 where N is the bit size of std::size_t, so very large arrays are supported on 64-bit platforms where std::size_t is 64 bits. The index range for each dimension is indexed by int, which is still 32 bits on 64-bit platforms, so the size along each dimension is more limited than the total array size on 64-bit platforms. Attempting to create an array with a dimension or total size exceeding these limits is caught by assertion-enabled  debug builds. The operating system on a given platform may further limit the allocatable size.</p>
				<p class="body">The size of an FArray can be obtained via the <span class="source">size</span> member function. For real FArrays this is the actual array data size and for argument and proxy FArrays this is the size of the active array part that it is using, which may be unknown/unbounded. The <span class="source">size_bounded</span> and <span class="source">size_unbounded</span> member functions can be used to test whether the active array has unbounded/unknown extent. The size of the actual array data can be obtained via the <span class="source">array_size</span> member function, and the <span class="source">array_size_bounded</span> and <span class="source">array_size_unbounded</span> member functions can be used to test whether the actual array data has unknown/unbounded extent.</p>
				<h3 class="h4">FArray Size Reports</h3>
				<p class="body">FArrays with size greater than or equal to <em>S</em> bytes can be reported to <span class="style1"><b>std::cout</b></span> at the time of construction or re-dimensioning by compiling with a macro defined using one of these methods:</p>
				<ul>
					<li>In source: <span class="style1"><b>#define OBJEXXFCL_FARRAY_SIZE_REPORT <em>S</em></b></span></li>
					<li>Compile switch:<br />
						<span class="style1"><b>-D'OBJEXXFCL_FARRAY_SIZE_REPORT=<em>S</em>'</b></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*nix<br />
						<span class="style1"><b>-D'OBJEXXFCL_FARRAY_SIZE_REPORT=<em>S</em>'</b></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Windows<sup>&reg;</sup><br>
						(quoting methods vary by platform and shell)</li>
				</ul>
				<p> The array name or location of creation isn't known at the point of reporting but the report includes the value type, element count, and index ranges to aid in the identification of the associated array. The value type held by the FArray is the typeid's name() string for that type, which varies by compiler. The codes used by GCC are:</p>
			<table width="176" border="1">
				<tr>
					<td width="137">bool</td>
					<td width="23">b</td>
				</tr>
				<tr>
					<td>short</td>
					<td>s</td>
				</tr>
				<tr>
					<td>int</td>
					<td>i</td>
				</tr>
				<tr>
					<td>long</td>
					<td>l</td>
				</tr>
				<tr>
					<td>unsigned short</td>
					<td>t</td>
				</tr>
				<tr>
					<td>unsigned int</td>
					<td>j</td>
				</tr>
				<tr>
					<td>unsigned long</td>
					<td>m</td>
				</tr>
				<tr>
					<td>std::size_t</td>
					<td>j</td>
				</tr>
				<tr>
					<td>char</td>
					<td>c</td>
				</tr>
				<tr>
					<td>signed char</td>
					<td>a</td>
				</tr>
				<tr>
					<td>unsigned char</td>
					<td>h</td>
				</tr>
				<tr>
					<td>std::string</td>
					<td><p>Ss</p>
				</td>
				</tr>
				<tr>
					<td>float</td>
					<td>f</td>
				</tr>
				<tr>
					<td>double</td>
					<td>d</td>
				</tr>
				<tr>
					<td>long double</td>
					<td>e</td>
				</tr>
			</table>
			<p> The size is computed as the number of elements times the sizeof the FArray's value type, so FArrays holding value types that have associated heap memory do not show the full memory they use. </p>

			<h2 class="h3">FArray Activity State</h2>
			<p class="body">The <span class="source">active</span> member function can be called to determine whether a real FArray is allocated or whether a proxy or argument FArray is attached to another FArray.</p>

			<h2 class="h3">Generator Functions</h2>
			<p class="body">Operator functions that generate FArrays include the unary minus function and sums and differences of FArrays of the same rank and dimensions and of FArrays and scalar values:</p>
			<table border="1" cellspacing="0" cellpadding="12">
				<tr>
					<td bgcolor="#F7F4F7"><pre>FArray2D_int A, B, C;
...
C = -A;

C = A + B;
C = A - B;
C = A + 3; // Adds 3 to each element</pre>
					</td>
				</tr>
			</table>
			<p>These operators accept all types of FArrays but always produce real FArrays. </p>

			<h2 class="h3">Special Functions</h2>
			<p class="body"><b>FArray1D</b> arrays have the <span class="source">length</span> and <span class="source">length_squared</span> member functions to compute their L<sub>2</sub> norm length and squared length and the <span class="source">normalize</span> function to normalize the array to unit length. The <span class="source">dot_product</span> function computes the dot (inner) product of two FArray1Ds. The <span class="source">cross_product</span> function computes the cross product of two FArray1Ds of size 3. </p>
			<p class="body"><b>FArray2D</b> arrays have the boolean <span class="source">square</span> function to test whether the array is square, the <span class="source"><b>to_identity</b></span> function to make a square array into the identity matrix and the <span class="source">to_diag</span> function to make a square array into a diagonal matrix with a uniform value. The <span class="source">transpose</span> function  transposes a square array and the <span class="source">transposed</span> function returns a transposed copy of the array. The <span class="source">identity</span> and <span class="source">diag</span> static functions are named constructors to create identity and diagonal matrices, respectively.</p>
			<p class="body">The <span class="source">swap</span> functions allow two real FArrays of the same rank to efficiently swap their contents. There is a single-argument <span class="source">swap</span> member function and a two-argument <span class="source">swap</span> non-member function. Use <span class="source">A.swap( B )</span> or <span class="source">swap( A, B )</span> (using <span class="source">std::swap( A, B )</span> wil be slower on compilers that don't support the provided overloaded function templates).</p>

			<h2 class="h3">FArray Debugging</h2>
			<p class="body">For Fortran-like performance, the FArray classes don't check for array bounds errors in release builds (when NDEBUG is defined). It is therefore important to test assertion-enabled debug builds of code using the FArray classes. To get all proxy/argument FArrays bounds checked it would be necessary to use the safer array element passing method described above, but at some cost to the performance of release builds.</p>

			<h2 class="h3">FArray Output</h2>
			<p class="body">Stream output operators are provided in separate FArray<i>N</i>.io.hh header files for FArrays of rank <em>N</em> and, for convenience, a master FArray.io.hh header file that includes the headers for every rank FArray.</p>

			<h2 class="h3">FArray Headers</h2>
			<p class="body">Headers are provided for each FArray rank and type:</p>
			<table border="1" cellspacing="0" cellpadding="6" bordercolor="#CABEDC" width="100%">
				<tr class="table_text">
					<td><b>FArray Header</b></td>
					<td><b>Description</b></td>
				</tr>
				<tr class="table_text">
					<td><font color="#16694A"><b>FArray<em>N</em>D.hh</b></font></td>
					<td><em>N</em>D real FArray class template</td>
				</tr>
				<tr class="table_text">
					<td><font color="#16694A"><b>FArray<em>N</em>P.hh</b></font></td>
					<td><em>N</em>D proxy FArray class template</td>
				</tr>
				<tr class="table_text">
					<td><font color="#16694A"><b>FArray<em>N</em>A.hh</b></font></td>
					<td><em>N</em>D argument FArray class template</td>
				</tr>
<!--			<tr class="table_text">                                                          -->
<!--				<td><font color="#16694A"><b>KeyFArray<em>N</em>D.hh</b></font></td>            -->
<!--				<td><em>N</em>D  key-indexed FArray class template</td>                         -->
<!--			</tr>                                                                            -->
				<tr class="table_text">
					<td><font color="#16694A"><b>FArray<em>N</em>.all.hh</b></font></td>
					<td><em>N</em>D FArray class template master header</td>
				</tr>
				<tr class="table_text">
					<td><font color="#16694A"><b>FArray<em>N</em>S.hh</b></font></td>
					<td><em>N</em>D slice FArray class template</td>
				</tr>
			</table>
			<p class="body">Headers for each rank and type of FArray that are used more than &quot;in name&quot; must be included. Because of the inclusion dependencies between the FArray headers you can just include the first header in this sequence that has all the FArray types used to its left:<br />
				&nbsp;&nbsp;&nbsp;&nbsp;FArray<em>N</em>D.hh &nbsp;&raquo; &nbsp;FArray<em>N</em>P.hh &nbsp;&raquo; &nbsp;FArray<em>N</em>A.hh<br />
				or simply include the FArray<em>N</em>.all.hh to	get	them all. Using only the FArray headers needed will reduce compilation time.</p>
		</td>
		<td></td>
		<td width="100%" valign="top">
		</td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td></td>
		<td colspan="3" height="30" valign="bottom" class="footer_text">
			<a href="ObjexxFCL.html"><span class="footer_link">Home</span></a> |
			<a href="ObjexxFCL.Release.html"><span class="footer_link">Release Notes</span></a> |
			<a href="ObjexxFCL.Users.html"><span class="footer_link">Users Guide</span></a> |
			<a href="ObjexxFCL.Developers.html"><span class="footer_link">Developers Guide</span></a> |
			<a href="ObjexxFCL.Support.html"><span class="footer_link">Support</span></a> |
			<a href="ObjexxFCL.License.txt"><span class="footer_link">License</span></a> |
			<a href="http://objexx.com"><span class="footer_link">Web</span></a>
		</td>
		<td></td>
	</tr>
	<tr>
		<td height="21"></td>
		<td></td>
		<td></td>
		<td colspan="3" valign="bottom" class="footer_text">Copyright &copy; 2000-2014 Objexx Engineering, Inc. All Rights Reserved.</td>
		<td></td>
	</tr>
	<tr>
		<td><img src="images/spacer.gif" alt="" style="width:25px; height:9px"></td>
		<td><img src="images/spacer.gif" alt="" style="width:100px; height:1px"></td>
		<td><img src="images/spacer.gif" alt="" style="width:40px; height:1px"></td>
		<td><img src="images/spacer.gif" alt="" style="width:500px; height:1px"></td>
		<td><img src="images/spacer.gif" alt="" style="width:40px; height:1px"></td>
		<td><img src="images/spacer.gif" alt="" style="width:100%; height:1px"></td>
		<td><img src="images/spacer.gif" alt="" style="width:25px; height:1px"></td>
	</tr>
</tbody>
</table>
</body>
</html>
